/**
 * @license
 * Video.js 8.9.0 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/main/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>
 */
(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.videojs = factory());
})(this, function() {
  "use strict";
  var version$5 = "8.9.0";
  const hooks_ = {};
  const hooks = function(type, fn) {
    hooks_[type] = hooks_[type] || [];
    if (fn) {
      hooks_[type] = hooks_[type].concat(fn);
    }
    return hooks_[type];
  };
  const hook = function(type, fn) {
    hooks(type, fn);
  };
  const removeHook = function(type, fn) {
    const index = hooks(type).indexOf(fn);
    if (index <= -1) {
      return false;
    }
    hooks_[type] = hooks_[type].slice();
    hooks_[type].splice(index, 1);
    return true;
  };
  const hookOnce = function(type, fn) {
    hooks(type, [].concat(fn).map((original) => {
      const wrapper = (...args) => {
        removeHook(type, wrapper);
        return original(...args);
      };
      return wrapper;
    }));
  };
  const FullscreenApi = {
    prefixed: true
  };
  const apiMap = [
    ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror", "fullscreen"],
    // WebKit
    ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen"]
  ];
  const specApi = apiMap[0];
  let browserApi;
  for (let i = 0; i < apiMap.length; i++) {
    if (apiMap[i][1] in document) {
      browserApi = apiMap[i];
      break;
    }
  }
  if (browserApi) {
    for (let i = 0; i < browserApi.length; i++) {
      FullscreenApi[specApi[i]] = browserApi[i];
    }
    FullscreenApi.prefixed = browserApi[0] !== specApi[0];
  }
  let history = [];
  const LogByTypeFactory = (name, log2, styles) => (type, level, args) => {
    const lvl = log2.levels[level];
    const lvlRegExp = new RegExp(`^(${lvl})$`);
    let resultName = name;
    if (type !== "log") {
      args.unshift(type.toUpperCase() + ":");
    }
    if (styles) {
      resultName = `%c${name}`;
      args.unshift(styles);
    }
    args.unshift(resultName + ":");
    if (history) {
      history.push([].concat(args));
      const splice = history.length - 1e3;
      history.splice(0, splice > 0 ? splice : 0);
    }
    if (!window.console) {
      return;
    }
    let fn = window.console[type];
    if (!fn && type === "debug") {
      fn = window.console.info || window.console.log;
    }
    if (!fn || !lvl || !lvlRegExp.test(type)) {
      return;
    }
    fn[Array.isArray(args) ? "apply" : "call"](window.console, args);
  };
  function createLogger$1(name, delimiter = ":", styles = "") {
    let level = "info";
    let logByType;
    const log2 = function(...args) {
      logByType("log", level, args);
    };
    logByType = LogByTypeFactory(name, log2, styles);
    log2.createLogger = (subName, subDelimiter, subStyles) => {
      const resultDelimiter = subDelimiter !== void 0 ? subDelimiter : delimiter;
      const resultStyles = subStyles !== void 0 ? subStyles : styles;
      const resultName = `${name} ${resultDelimiter} ${subName}`;
      return createLogger$1(resultName, resultDelimiter, resultStyles);
    };
    log2.createNewLogger = (newName, newDelimiter, newStyles) => {
      return createLogger$1(newName, newDelimiter, newStyles);
    };
    log2.levels = {
      all: "debug|log|warn|error",
      off: "",
      debug: "debug|log|warn|error",
      info: "log|warn|error",
      warn: "warn|error",
      error: "error",
      DEFAULT: level
    };
    log2.level = (lvl) => {
      if (typeof lvl === "string") {
        if (!log2.levels.hasOwnProperty(lvl)) {
          throw new Error(`"${lvl}" in not a valid log level`);
        }
        level = lvl;
      }
      return level;
    };
    log2.history = () => history ? [].concat(history) : [];
    log2.history.filter = (fname) => {
      return (history || []).filter((historyItem) => {
        return new RegExp(`.*${fname}.*`).test(historyItem[0]);
      });
    };
    log2.history.clear = () => {
      if (history) {
        history.length = 0;
      }
    };
    log2.history.disable = () => {
      if (history !== null) {
        history.length = 0;
        history = null;
      }
    };
    log2.history.enable = () => {
      if (history === null) {
        history = [];
      }
    };
    log2.error = (...args) => logByType("error", level, args);
    log2.warn = (...args) => logByType("warn", level, args);
    log2.debug = (...args) => logByType("debug", level, args);
    return log2;
  }
  const log$1 = createLogger$1("VIDEOJS");
  const createLogger = log$1.createLogger;
  const toString$1 = Object.prototype.toString;
  const keys = function(object) {
    return isObject$1(object) ? Object.keys(object) : [];
  };
  function each(object, fn) {
    keys(object).forEach((key) => fn(object[key], key));
  }
  function reduce(object, fn, initial = 0) {
    return keys(object).reduce((accum, key) => fn(accum, object[key], key), initial);
  }
  function isObject$1(value) {
    return !!value && typeof value === "object";
  }
  function isPlain(value) {
    return isObject$1(value) && toString$1.call(value) === "[object Object]" && value.constructor === Object;
  }
  function merge$2(...sources) {
    const result = {};
    sources.forEach((source) => {
      if (!source) {
        return;
      }
      each(source, (value, key) => {
        if (!isPlain(value)) {
          result[key] = value;
          return;
        }
        if (!isPlain(result[key])) {
          result[key] = {};
        }
        result[key] = merge$2(result[key], value);
      });
    });
    return result;
  }
  function values$1(source = {}) {
    const result = [];
    for (const key in source) {
      if (source.hasOwnProperty(key)) {
        const value = source[key];
        result.push(value);
      }
    }
    return result;
  }
  function defineLazyProperty(obj, key, getValue, setter = true) {
    const set2 = (value) => Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      writable: true
    });
    const options = {
      configurable: true,
      enumerable: true,
      get() {
        const value = getValue();
        set2(value);
        return value;
      }
    };
    if (setter) {
      options.set = set2;
    }
    return Object.defineProperty(obj, key, options);
  }
  var Obj = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    each,
    reduce,
    isObject: isObject$1,
    isPlain,
    merge: merge$2,
    values: values$1,
    defineLazyProperty
  });
  let IS_IPOD = false;
  let IOS_VERSION = null;
  let IS_ANDROID = false;
  let ANDROID_VERSION;
  let IS_FIREFOX = false;
  let IS_EDGE = false;
  let IS_CHROMIUM = false;
  let IS_CHROME = false;
  let CHROMIUM_VERSION = null;
  let CHROME_VERSION = null;
  let IE_VERSION = null;
  let IS_SAFARI = false;
  let IS_WINDOWS = false;
  let IS_IPAD = false;
  let IS_IPHONE = false;
  const TOUCH_ENABLED = Boolean(isReal() && ("ontouchstart" in window || window.navigator.maxTouchPoints || window.DocumentTouch && window.document instanceof window.DocumentTouch));
  const UAD = window.navigator && window.navigator.userAgentData;
  if (UAD && UAD.platform && UAD.brands) {
    IS_ANDROID = UAD.platform === "Android";
    IS_EDGE = Boolean(UAD.brands.find((b) => b.brand === "Microsoft Edge"));
    IS_CHROMIUM = Boolean(UAD.brands.find((b) => b.brand === "Chromium"));
    IS_CHROME = !IS_EDGE && IS_CHROMIUM;
    CHROMIUM_VERSION = CHROME_VERSION = (UAD.brands.find((b) => b.brand === "Chromium") || {}).version || null;
    IS_WINDOWS = UAD.platform === "Windows";
  }
  if (!IS_CHROMIUM) {
    const USER_AGENT = window.navigator && window.navigator.userAgent || "";
    IS_IPOD = /iPod/i.test(USER_AGENT);
    IOS_VERSION = function() {
      const match = USER_AGENT.match(/OS (\d+)_/i);
      if (match && match[1]) {
        return match[1];
      }
      return null;
    }();
    IS_ANDROID = /Android/i.test(USER_AGENT);
    ANDROID_VERSION = function() {
      const match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
      if (!match) {
        return null;
      }
      const major = match[1] && parseFloat(match[1]);
      const minor = match[2] && parseFloat(match[2]);
      if (major && minor) {
        return parseFloat(match[1] + "." + match[2]);
      } else if (major) {
        return major;
      }
      return null;
    }();
    IS_FIREFOX = /Firefox/i.test(USER_AGENT);
    IS_EDGE = /Edg/i.test(USER_AGENT);
    IS_CHROMIUM = /Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT);
    IS_CHROME = !IS_EDGE && IS_CHROMIUM;
    CHROMIUM_VERSION = CHROME_VERSION = function() {
      const match = USER_AGENT.match(/(Chrome|CriOS)\/(\d+)/);
      if (match && match[2]) {
        return parseFloat(match[2]);
      }
      return null;
    }();
    IE_VERSION = function() {
      const result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
      let version2 = result && parseFloat(result[1]);
      if (!version2 && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
        version2 = 11;
      }
      return version2;
    }();
    IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
    IS_WINDOWS = /Windows/i.test(USER_AGENT);
    IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);
    IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
  }
  const IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;
  const IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;
  var browser = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    get IS_IPOD() {
      return IS_IPOD;
    },
    get IOS_VERSION() {
      return IOS_VERSION;
    },
    get IS_ANDROID() {
      return IS_ANDROID;
    },
    get ANDROID_VERSION() {
      return ANDROID_VERSION;
    },
    get IS_FIREFOX() {
      return IS_FIREFOX;
    },
    get IS_EDGE() {
      return IS_EDGE;
    },
    get IS_CHROMIUM() {
      return IS_CHROMIUM;
    },
    get IS_CHROME() {
      return IS_CHROME;
    },
    get CHROMIUM_VERSION() {
      return CHROMIUM_VERSION;
    },
    get CHROME_VERSION() {
      return CHROME_VERSION;
    },
    get IE_VERSION() {
      return IE_VERSION;
    },
    get IS_SAFARI() {
      return IS_SAFARI;
    },
    get IS_WINDOWS() {
      return IS_WINDOWS;
    },
    get IS_IPAD() {
      return IS_IPAD;
    },
    get IS_IPHONE() {
      return IS_IPHONE;
    },
    TOUCH_ENABLED,
    IS_IOS,
    IS_ANY_SAFARI
  });
  function isNonBlankString(str) {
    return typeof str === "string" && Boolean(str.trim());
  }
  function throwIfWhitespace(str) {
    if (str.indexOf(" ") >= 0) {
      throw new Error("class has illegal whitespace characters");
    }
  }
  function isReal() {
    return document === window.document;
  }
  function isEl(value) {
    return isObject$1(value) && value.nodeType === 1;
  }
  function isInFrame() {
    try {
      return window.parent !== window.self;
    } catch (x) {
      return true;
    }
  }
  function createQuerier(method) {
    return function(selector, context) {
      if (!isNonBlankString(selector)) {
        return document[method](null);
      }
      if (isNonBlankString(context)) {
        context = document.querySelector(context);
      }
      const ctx = isEl(context) ? context : document;
      return ctx[method] && ctx[method](selector);
    };
  }
  function createEl(tagName = "div", properties = {}, attributes = {}, content) {
    const el = document.createElement(tagName);
    Object.getOwnPropertyNames(properties).forEach(function(propName) {
      const val = properties[propName];
      if (propName === "textContent") {
        textContent(el, val);
      } else if (el[propName] !== val || propName === "tabIndex") {
        el[propName] = val;
      }
    });
    Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
      el.setAttribute(attrName, attributes[attrName]);
    });
    if (content) {
      appendContent(el, content);
    }
    return el;
  }
  function textContent(el, text) {
    if (typeof el.textContent === "undefined") {
      el.innerText = text;
    } else {
      el.textContent = text;
    }
    return el;
  }
  function prependTo(child, parent) {
    if (parent.firstChild) {
      parent.insertBefore(child, parent.firstChild);
    } else {
      parent.appendChild(child);
    }
  }
  function hasClass(element, classToCheck) {
    throwIfWhitespace(classToCheck);
    return element.classList.contains(classToCheck);
  }
  function addClass(element, ...classesToAdd) {
    element.classList.add(...classesToAdd.reduce((prev, current) => prev.concat(current.split(/\s+/)), []));
    return element;
  }
  function removeClass(element, ...classesToRemove) {
    if (!element) {
      log$1.warn("removeClass was called with an element that doesn't exist");
      return null;
    }
    element.classList.remove(...classesToRemove.reduce((prev, current) => prev.concat(current.split(/\s+/)), []));
    return element;
  }
  function toggleClass(element, classToToggle, predicate) {
    if (typeof predicate === "function") {
      predicate = predicate(element, classToToggle);
    }
    if (typeof predicate !== "boolean") {
      predicate = void 0;
    }
    classToToggle.split(/\s+/).forEach((className) => element.classList.toggle(className, predicate));
    return element;
  }
  function setAttributes(el, attributes) {
    Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
      const attrValue = attributes[attrName];
      if (attrValue === null || typeof attrValue === "undefined" || attrValue === false) {
        el.removeAttribute(attrName);
      } else {
        el.setAttribute(attrName, attrValue === true ? "" : attrValue);
      }
    });
  }
  function getAttributes(tag) {
    const obj = {};
    const knownBooleans = ["autoplay", "controls", "playsinline", "loop", "muted", "default", "defaultMuted"];
    if (tag && tag.attributes && tag.attributes.length > 0) {
      const attrs = tag.attributes;
      for (let i = attrs.length - 1; i >= 0; i--) {
        const attrName = attrs[i].name;
        let attrVal = attrs[i].value;
        if (knownBooleans.includes(attrName)) {
          attrVal = attrVal !== null ? true : false;
        }
        obj[attrName] = attrVal;
      }
    }
    return obj;
  }
  function getAttribute(el, attribute) {
    return el.getAttribute(attribute);
  }
  function setAttribute(el, attribute, value) {
    el.setAttribute(attribute, value);
  }
  function removeAttribute(el, attribute) {
    el.removeAttribute(attribute);
  }
  function blockTextSelection() {
    document.body.focus();
    document.onselectstart = function() {
      return false;
    };
  }
  function unblockTextSelection() {
    document.onselectstart = function() {
      return true;
    };
  }
  function getBoundingClientRect(el) {
    if (el && el.getBoundingClientRect && el.parentNode) {
      const rect = el.getBoundingClientRect();
      const result = {};
      ["bottom", "height", "left", "right", "top", "width"].forEach((k) => {
        if (rect[k] !== void 0) {
          result[k] = rect[k];
        }
      });
      if (!result.height) {
        result.height = parseFloat(computedStyle(el, "height"));
      }
      if (!result.width) {
        result.width = parseFloat(computedStyle(el, "width"));
      }
      return result;
    }
  }
  function findPosition(el) {
    if (!el || el && !el.offsetParent) {
      return {
        left: 0,
        top: 0,
        width: 0,
        height: 0
      };
    }
    const width = el.offsetWidth;
    const height = el.offsetHeight;
    let left = 0;
    let top = 0;
    while (el.offsetParent && el !== document[FullscreenApi.fullscreenElement]) {
      left += el.offsetLeft;
      top += el.offsetTop;
      el = el.offsetParent;
    }
    return {
      left,
      top,
      width,
      height
    };
  }
  function getPointerPosition(el, event) {
    const translated = {
      x: 0,
      y: 0
    };
    if (IS_IOS) {
      let item = el;
      while (item && item.nodeName.toLowerCase() !== "html") {
        const transform2 = computedStyle(item, "transform");
        if (/^matrix/.test(transform2)) {
          const values2 = transform2.slice(7, -1).split(/,\s/).map(Number);
          translated.x += values2[4];
          translated.y += values2[5];
        } else if (/^matrix3d/.test(transform2)) {
          const values2 = transform2.slice(9, -1).split(/,\s/).map(Number);
          translated.x += values2[12];
          translated.y += values2[13];
        }
        item = item.parentNode;
      }
    }
    const position2 = {};
    const boxTarget = findPosition(event.target);
    const box = findPosition(el);
    const boxW = box.width;
    const boxH = box.height;
    let offsetY = event.offsetY - (box.top - boxTarget.top);
    let offsetX = event.offsetX - (box.left - boxTarget.left);
    if (event.changedTouches) {
      offsetX = event.changedTouches[0].pageX - box.left;
      offsetY = event.changedTouches[0].pageY + box.top;
      if (IS_IOS) {
        offsetX -= translated.x;
        offsetY -= translated.y;
      }
    }
    position2.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));
    position2.x = Math.max(0, Math.min(1, offsetX / boxW));
    return position2;
  }
  function isTextNode$1(value) {
    return isObject$1(value) && value.nodeType === 3;
  }
  function emptyEl(el) {
    while (el.firstChild) {
      el.removeChild(el.firstChild);
    }
    return el;
  }
  function normalizeContent(content) {
    if (typeof content === "function") {
      content = content();
    }
    return (Array.isArray(content) ? content : [content]).map((value) => {
      if (typeof value === "function") {
        value = value();
      }
      if (isEl(value) || isTextNode$1(value)) {
        return value;
      }
      if (typeof value === "string" && /\S/.test(value)) {
        return document.createTextNode(value);
      }
    }).filter((value) => value);
  }
  function appendContent(el, content) {
    normalizeContent(content).forEach((node) => el.appendChild(node));
    return el;
  }
  function insertContent(el, content) {
    return appendContent(emptyEl(el), content);
  }
  function isSingleLeftClick(event) {
    if (event.button === void 0 && event.buttons === void 0) {
      return true;
    }
    if (event.button === 0 && event.buttons === void 0) {
      return true;
    }
    if (event.type === "mouseup" && event.button === 0 && event.buttons === 0) {
      return true;
    }
    if (event.button !== 0 || event.buttons !== 1) {
      return false;
    }
    return true;
  }
  const $ = createQuerier("querySelector");
  const $$ = createQuerier("querySelectorAll");
  function computedStyle(el, prop) {
    if (!el || !prop) {
      return "";
    }
    if (typeof window.getComputedStyle === "function") {
      let computedStyleValue;
      try {
        computedStyleValue = window.getComputedStyle(el);
      } catch (e) {
        return "";
      }
      return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : "";
    }
    return "";
  }
  function copyStyleSheetsToWindow(win2) {
    [...document.styleSheets].forEach((styleSheet) => {
      try {
        const cssRules = [...styleSheet.cssRules].map((rule) => rule.cssText).join("");
        const style = document.createElement("style");
        style.textContent = cssRules;
        win2.document.head.appendChild(style);
      } catch (e) {
        const link = document.createElement("link");
        link.rel = "stylesheet";
        link.type = styleSheet.type;
        link.media = styleSheet.media.mediaText;
        link.href = styleSheet.href;
        win2.document.head.appendChild(link);
      }
    });
  }
  var Dom = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    isReal,
    isEl,
    isInFrame,
    createEl,
    textContent,
    prependTo,
    hasClass,
    addClass,
    removeClass,
    toggleClass,
    setAttributes,
    getAttributes,
    getAttribute,
    setAttribute,
    removeAttribute,
    blockTextSelection,
    unblockTextSelection,
    getBoundingClientRect,
    findPosition,
    getPointerPosition,
    isTextNode: isTextNode$1,
    emptyEl,
    normalizeContent,
    appendContent,
    insertContent,
    isSingleLeftClick,
    $,
    $$,
    computedStyle,
    copyStyleSheetsToWindow
  });
  let _windowLoaded = false;
  let videojs$1;
  const autoSetup = function() {
    if (videojs$1.options.autoSetup === false) {
      return;
    }
    const vids = Array.prototype.slice.call(document.getElementsByTagName("video"));
    const audios = Array.prototype.slice.call(document.getElementsByTagName("audio"));
    const divs = Array.prototype.slice.call(document.getElementsByTagName("video-js"));
    const mediaEls = vids.concat(audios, divs);
    if (mediaEls && mediaEls.length > 0) {
      for (let i = 0, e = mediaEls.length; i < e; i++) {
        const mediaEl = mediaEls[i];
        if (mediaEl && mediaEl.getAttribute) {
          if (mediaEl.player === void 0) {
            const options = mediaEl.getAttribute("data-setup");
            if (options !== null) {
              videojs$1(mediaEl);
            }
          }
        } else {
          autoSetupTimeout(1);
          break;
        }
      }
    } else if (!_windowLoaded) {
      autoSetupTimeout(1);
    }
  };
  function autoSetupTimeout(wait, vjs) {
    if (!isReal()) {
      return;
    }
    if (vjs) {
      videojs$1 = vjs;
    }
    window.setTimeout(autoSetup, wait);
  }
  function setWindowLoaded() {
    _windowLoaded = true;
    window.removeEventListener("load", setWindowLoaded);
  }
  if (isReal()) {
    if (document.readyState === "complete") {
      setWindowLoaded();
    } else {
      window.addEventListener("load", setWindowLoaded);
    }
  }
  const createStyleElement = function(className) {
    const style = document.createElement("style");
    style.className = className;
    return style;
  };
  const setTextContent = function(el, content) {
    if (el.styleSheet) {
      el.styleSheet.cssText = content;
    } else {
      el.textContent = content;
    }
  };
  var DomData = /* @__PURE__ */ new WeakMap();
  const _initialGuid = 3;
  let _guid = _initialGuid;
  function newGUID() {
    return _guid++;
  }
  function _cleanUpEvents(elem, type) {
    if (!DomData.has(elem)) {
      return;
    }
    const data = DomData.get(elem);
    if (data.handlers[type].length === 0) {
      delete data.handlers[type];
      if (elem.removeEventListener) {
        elem.removeEventListener(type, data.dispatcher, false);
      } else if (elem.detachEvent) {
        elem.detachEvent("on" + type, data.dispatcher);
      }
    }
    if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
      delete data.handlers;
      delete data.dispatcher;
      delete data.disabled;
    }
    if (Object.getOwnPropertyNames(data).length === 0) {
      DomData.delete(elem);
    }
  }
  function _handleMultipleEvents(fn, elem, types, callback) {
    types.forEach(function(type) {
      fn(elem, type, callback);
    });
  }
  function fixEvent(event) {
    if (event.fixed_) {
      return event;
    }
    function returnTrue() {
      return true;
    }
    function returnFalse() {
      return false;
    }
    if (!event || !event.isPropagationStopped || !event.isImmediatePropagationStopped) {
      const old = event || window.event;
      event = {};
      for (const key in old) {
        if (key !== "layerX" && key !== "layerY" && key !== "keyLocation" && key !== "webkitMovementX" && key !== "webkitMovementY" && key !== "path") {
          if (!(key === "returnValue" && old.preventDefault)) {
            event[key] = old[key];
          }
        }
      }
      if (!event.target) {
        event.target = event.srcElement || document;
      }
      if (!event.relatedTarget) {
        event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
      }
      event.preventDefault = function() {
        if (old.preventDefault) {
          old.preventDefault();
        }
        event.returnValue = false;
        old.returnValue = false;
        event.defaultPrevented = true;
      };
      event.defaultPrevented = false;
      event.stopPropagation = function() {
        if (old.stopPropagation) {
          old.stopPropagation();
        }
        event.cancelBubble = true;
        old.cancelBubble = true;
        event.isPropagationStopped = returnTrue;
      };
      event.isPropagationStopped = returnFalse;
      event.stopImmediatePropagation = function() {
        if (old.stopImmediatePropagation) {
          old.stopImmediatePropagation();
        }
        event.isImmediatePropagationStopped = returnTrue;
        event.stopPropagation();
      };
      event.isImmediatePropagationStopped = returnFalse;
      if (event.clientX !== null && event.clientX !== void 0) {
        const doc = document.documentElement;
        const body = document.body;
        event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
        event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
      }
      event.which = event.charCode || event.keyCode;
      if (event.button !== null && event.button !== void 0) {
        event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
      }
    }
    event.fixed_ = true;
    return event;
  }
  let _supportsPassive;
  const supportsPassive = function() {
    if (typeof _supportsPassive !== "boolean") {
      _supportsPassive = false;
      try {
        const opts = Object.defineProperty({}, "passive", {
          get() {
            _supportsPassive = true;
          }
        });
        window.addEventListener("test", null, opts);
        window.removeEventListener("test", null, opts);
      } catch (e) {
      }
    }
    return _supportsPassive;
  };
  const passiveEvents = ["touchstart", "touchmove"];
  function on(elem, type, fn) {
    if (Array.isArray(type)) {
      return _handleMultipleEvents(on, elem, type, fn);
    }
    if (!DomData.has(elem)) {
      DomData.set(elem, {});
    }
    const data = DomData.get(elem);
    if (!data.handlers) {
      data.handlers = {};
    }
    if (!data.handlers[type]) {
      data.handlers[type] = [];
    }
    if (!fn.guid) {
      fn.guid = newGUID();
    }
    data.handlers[type].push(fn);
    if (!data.dispatcher) {
      data.disabled = false;
      data.dispatcher = function(event, hash) {
        if (data.disabled) {
          return;
        }
        event = fixEvent(event);
        const handlers = data.handlers[event.type];
        if (handlers) {
          const handlersCopy = handlers.slice(0);
          for (let m = 0, n = handlersCopy.length; m < n; m++) {
            if (event.isImmediatePropagationStopped()) {
              break;
            } else {
              try {
                handlersCopy[m].call(elem, event, hash);
              } catch (e) {
                log$1.error(e);
              }
            }
          }
        }
      };
    }
    if (data.handlers[type].length === 1) {
      if (elem.addEventListener) {
        let options = false;
        if (supportsPassive() && passiveEvents.indexOf(type) > -1) {
          options = {
            passive: true
          };
        }
        elem.addEventListener(type, data.dispatcher, options);
      } else if (elem.attachEvent) {
        elem.attachEvent("on" + type, data.dispatcher);
      }
    }
  }
  function off(elem, type, fn) {
    if (!DomData.has(elem)) {
      return;
    }
    const data = DomData.get(elem);
    if (!data.handlers) {
      return;
    }
    if (Array.isArray(type)) {
      return _handleMultipleEvents(off, elem, type, fn);
    }
    const removeType = function(el, t) {
      data.handlers[t] = [];
      _cleanUpEvents(el, t);
    };
    if (type === void 0) {
      for (const t in data.handlers) {
        if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {
          removeType(elem, t);
        }
      }
      return;
    }
    const handlers = data.handlers[type];
    if (!handlers) {
      return;
    }
    if (!fn) {
      removeType(elem, type);
      return;
    }
    if (fn.guid) {
      for (let n = 0; n < handlers.length; n++) {
        if (handlers[n].guid === fn.guid) {
          handlers.splice(n--, 1);
        }
      }
    }
    _cleanUpEvents(elem, type);
  }
  function trigger(elem, event, hash) {
    const elemData = DomData.has(elem) ? DomData.get(elem) : {};
    const parent = elem.parentNode || elem.ownerDocument;
    if (typeof event === "string") {
      event = {
        type: event,
        target: elem
      };
    } else if (!event.target) {
      event.target = elem;
    }
    event = fixEvent(event);
    if (elemData.dispatcher) {
      elemData.dispatcher.call(elem, event, hash);
    }
    if (parent && !event.isPropagationStopped() && event.bubbles === true) {
      trigger.call(null, parent, event, hash);
    } else if (!parent && !event.defaultPrevented && event.target && event.target[event.type]) {
      if (!DomData.has(event.target)) {
        DomData.set(event.target, {});
      }
      const targetData = DomData.get(event.target);
      if (event.target[event.type]) {
        targetData.disabled = true;
        if (typeof event.target[event.type] === "function") {
          event.target[event.type]();
        }
        targetData.disabled = false;
      }
    }
    return !event.defaultPrevented;
  }
  function one(elem, type, fn) {
    if (Array.isArray(type)) {
      return _handleMultipleEvents(one, elem, type, fn);
    }
    const func = function() {
      off(elem, type, func);
      fn.apply(this, arguments);
    };
    func.guid = fn.guid = fn.guid || newGUID();
    on(elem, type, func);
  }
  function any(elem, type, fn) {
    const func = function() {
      off(elem, type, func);
      fn.apply(this, arguments);
    };
    func.guid = fn.guid = fn.guid || newGUID();
    on(elem, type, func);
  }
  var Events = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fixEvent,
    on,
    off,
    trigger,
    one,
    any
  });
  const UPDATE_REFRESH_INTERVAL = 30;
  const bind_ = function(context, fn, uid) {
    if (!fn.guid) {
      fn.guid = newGUID();
    }
    const bound = fn.bind(context);
    bound.guid = uid ? uid + "_" + fn.guid : fn.guid;
    return bound;
  };
  const throttle = function(fn, wait) {
    let last = window.performance.now();
    const throttled = function(...args) {
      const now = window.performance.now();
      if (now - last >= wait) {
        fn(...args);
        last = now;
      }
    };
    return throttled;
  };
  const debounce = function(func, wait, immediate, context = window) {
    let timeout;
    const cancel = () => {
      context.clearTimeout(timeout);
      timeout = null;
    };
    const debounced = function() {
      const self2 = this;
      const args = arguments;
      let later = function() {
        timeout = null;
        later = null;
        if (!immediate) {
          func.apply(self2, args);
        }
      };
      if (!timeout && immediate) {
        func.apply(self2, args);
      }
      context.clearTimeout(timeout);
      timeout = context.setTimeout(later, wait);
    };
    debounced.cancel = cancel;
    return debounced;
  };
  var Fn = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    UPDATE_REFRESH_INTERVAL,
    bind_,
    throttle,
    debounce
  });
  let EVENT_MAP;
  class EventTarget$2 {
    /**
     * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a
     * function that will get called when an event with a certain name gets triggered.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} fn
     *        The function to call with `EventTarget`s
     */
    on(type, fn) {
      const ael = this.addEventListener;
      this.addEventListener = () => {
      };
      on(this, type, fn);
      this.addEventListener = ael;
    }
    /**
     * Removes an `event listener` for a specific event from an instance of `EventTarget`.
     * This makes it so that the `event listener` will no longer get called when the
     * named event happens.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} fn
     *        The function to remove.
     */
    off(type, fn) {
      off(this, type, fn);
    }
    /**
     * This function will add an `event listener` that gets triggered only once. After the
     * first trigger it will get removed. This is like adding an `event listener`
     * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} fn
     *        The function to be called once for each event name.
     */
    one(type, fn) {
      const ael = this.addEventListener;
      this.addEventListener = () => {
      };
      one(this, type, fn);
      this.addEventListener = ael;
    }
    /**
     * This function will add an `event listener` that gets triggered only once and is
     * removed from all events. This is like adding an array of `event listener`s
     * with {@link EventTarget#on} that calls {@link EventTarget#off} on all events the
     * first time it is triggered.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} fn
     *        The function to be called once for each event name.
     */
    any(type, fn) {
      const ael = this.addEventListener;
      this.addEventListener = () => {
      };
      any(this, type, fn);
      this.addEventListener = ael;
    }
    /**
     * This function causes an event to happen. This will then cause any `event listeners`
     * that are waiting for that event, to get called. If there are no `event listeners`
     * for an event then nothing will happen.
     *
     * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.
     * Trigger will also call the `on` + `uppercaseEventName` function.
     *
     * Example:
     * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call
     * `onClick` if it exists.
     *
     * @param {string|EventTarget~Event|Object} event
     *        The name of the event, an `Event`, or an object with a key of type set to
     *        an event name.
     */
    trigger(event) {
      const type = event.type || event;
      if (typeof event === "string") {
        event = {
          type
        };
      }
      event = fixEvent(event);
      if (this.allowedEvents_[type] && this["on" + type]) {
        this["on" + type](event);
      }
      trigger(this, event);
    }
    queueTrigger(event) {
      if (!EVENT_MAP) {
        EVENT_MAP = /* @__PURE__ */ new Map();
      }
      const type = event.type || event;
      let map = EVENT_MAP.get(this);
      if (!map) {
        map = /* @__PURE__ */ new Map();
        EVENT_MAP.set(this, map);
      }
      const oldTimeout = map.get(type);
      map.delete(type);
      window.clearTimeout(oldTimeout);
      const timeout = window.setTimeout(() => {
        map.delete(type);
        if (map.size === 0) {
          map = null;
          EVENT_MAP.delete(this);
        }
        this.trigger(event);
      }, 0);
      map.set(type, timeout);
    }
  }
  EventTarget$2.prototype.allowedEvents_ = {};
  EventTarget$2.prototype.addEventListener = EventTarget$2.prototype.on;
  EventTarget$2.prototype.removeEventListener = EventTarget$2.prototype.off;
  EventTarget$2.prototype.dispatchEvent = EventTarget$2.prototype.trigger;
  const objName = (obj) => {
    if (typeof obj.name === "function") {
      return obj.name();
    }
    if (typeof obj.name === "string") {
      return obj.name;
    }
    if (obj.name_) {
      return obj.name_;
    }
    if (obj.constructor && obj.constructor.name) {
      return obj.constructor.name;
    }
    return typeof obj;
  };
  const isEvented = (object) => object instanceof EventTarget$2 || !!object.eventBusEl_ && ["on", "one", "off", "trigger"].every((k) => typeof object[k] === "function");
  const addEventedCallback = (target, callback) => {
    if (isEvented(target)) {
      callback();
    } else {
      if (!target.eventedCallbacks) {
        target.eventedCallbacks = [];
      }
      target.eventedCallbacks.push(callback);
    }
  };
  const isValidEventType = (type) => (
    // The regex here verifies that the `type` contains at least one non-
    // whitespace character.
    typeof type === "string" && /\S/.test(type) || Array.isArray(type) && !!type.length
  );
  const validateTarget = (target, obj, fnName) => {
    if (!target || !target.nodeName && !isEvented(target)) {
      throw new Error(`Invalid target for ${objName(obj)}#${fnName}; must be a DOM node or evented object.`);
    }
  };
  const validateEventType = (type, obj, fnName) => {
    if (!isValidEventType(type)) {
      throw new Error(`Invalid event type for ${objName(obj)}#${fnName}; must be a non-empty string or array.`);
    }
  };
  const validateListener = (listener, obj, fnName) => {
    if (typeof listener !== "function") {
      throw new Error(`Invalid listener for ${objName(obj)}#${fnName}; must be a function.`);
    }
  };
  const normalizeListenArgs = (self2, args, fnName) => {
    const isTargetingSelf = args.length < 3 || args[0] === self2 || args[0] === self2.eventBusEl_;
    let target;
    let type;
    let listener;
    if (isTargetingSelf) {
      target = self2.eventBusEl_;
      if (args.length >= 3) {
        args.shift();
      }
      [type, listener] = args;
    } else {
      [target, type, listener] = args;
    }
    validateTarget(target, self2, fnName);
    validateEventType(type, self2, fnName);
    validateListener(listener, self2, fnName);
    listener = bind_(self2, listener);
    return {
      isTargetingSelf,
      target,
      type,
      listener
    };
  };
  const listen = (target, method, type, listener) => {
    validateTarget(target, target, method);
    if (target.nodeName) {
      Events[method](target, type, listener);
    } else {
      target[method](type, listener);
    }
  };
  const EventedMixin = {
    /**
     * Add a listener to an event (or events) on this object or another evented
     * object.
     *
     * @param  {string|Array|Element|Object} targetOrType
     *         If this is a string or array, it represents the event type(s)
     *         that will trigger the listener.
     *
     *         Another evented object can be passed here instead, which will
     *         cause the listener to listen for events on _that_ object.
     *
     *         In either case, the listener's `this` value will be bound to
     *         this object.
     *
     * @param  {string|Array|Function} typeOrListener
     *         If the first argument was a string or array, this should be the
     *         listener function. Otherwise, this is a string or array of event
     *         type(s).
     *
     * @param  {Function} [listener]
     *         If the first argument was another evented object, this will be
     *         the listener function.
     */
    on(...args) {
      const {
        isTargetingSelf,
        target,
        type,
        listener
      } = normalizeListenArgs(this, args, "on");
      listen(target, "on", type, listener);
      if (!isTargetingSelf) {
        const removeListenerOnDispose = () => this.off(target, type, listener);
        removeListenerOnDispose.guid = listener.guid;
        const removeRemoverOnTargetDispose = () => this.off("dispose", removeListenerOnDispose);
        removeRemoverOnTargetDispose.guid = listener.guid;
        listen(this, "on", "dispose", removeListenerOnDispose);
        listen(target, "on", "dispose", removeRemoverOnTargetDispose);
      }
    },
    /**
     * Add a listener to an event (or events) on this object or another evented
     * object. The listener will be called once per event and then removed.
     *
     * @param  {string|Array|Element|Object} targetOrType
     *         If this is a string or array, it represents the event type(s)
     *         that will trigger the listener.
     *
     *         Another evented object can be passed here instead, which will
     *         cause the listener to listen for events on _that_ object.
     *
     *         In either case, the listener's `this` value will be bound to
     *         this object.
     *
     * @param  {string|Array|Function} typeOrListener
     *         If the first argument was a string or array, this should be the
     *         listener function. Otherwise, this is a string or array of event
     *         type(s).
     *
     * @param  {Function} [listener]
     *         If the first argument was another evented object, this will be
     *         the listener function.
     */
    one(...args) {
      const {
        isTargetingSelf,
        target,
        type,
        listener
      } = normalizeListenArgs(this, args, "one");
      if (isTargetingSelf) {
        listen(target, "one", type, listener);
      } else {
        const wrapper = (...largs) => {
          this.off(target, type, wrapper);
          listener.apply(null, largs);
        };
        wrapper.guid = listener.guid;
        listen(target, "one", type, wrapper);
      }
    },
    /**
     * Add a listener to an event (or events) on this object or another evented
     * object. The listener will only be called once for the first event that is triggered
     * then removed.
     *
     * @param  {string|Array|Element|Object} targetOrType
     *         If this is a string or array, it represents the event type(s)
     *         that will trigger the listener.
     *
     *         Another evented object can be passed here instead, which will
     *         cause the listener to listen for events on _that_ object.
     *
     *         In either case, the listener's `this` value will be bound to
     *         this object.
     *
     * @param  {string|Array|Function} typeOrListener
     *         If the first argument was a string or array, this should be the
     *         listener function. Otherwise, this is a string or array of event
     *         type(s).
     *
     * @param  {Function} [listener]
     *         If the first argument was another evented object, this will be
     *         the listener function.
     */
    any(...args) {
      const {
        isTargetingSelf,
        target,
        type,
        listener
      } = normalizeListenArgs(this, args, "any");
      if (isTargetingSelf) {
        listen(target, "any", type, listener);
      } else {
        const wrapper = (...largs) => {
          this.off(target, type, wrapper);
          listener.apply(null, largs);
        };
        wrapper.guid = listener.guid;
        listen(target, "any", type, wrapper);
      }
    },
    /**
     * Removes listener(s) from event(s) on an evented object.
     *
     * @param  {string|Array|Element|Object} [targetOrType]
     *         If this is a string or array, it represents the event type(s).
     *
     *         Another evented object can be passed here instead, in which case
     *         ALL 3 arguments are _required_.
     *
     * @param  {string|Array|Function} [typeOrListener]
     *         If the first argument was a string or array, this may be the
     *         listener function. Otherwise, this is a string or array of event
     *         type(s).
     *
     * @param  {Function} [listener]
     *         If the first argument was another evented object, this will be
     *         the listener function; otherwise, _all_ listeners bound to the
     *         event type(s) will be removed.
     */
    off(targetOrType, typeOrListener, listener) {
      if (!targetOrType || isValidEventType(targetOrType)) {
        off(this.eventBusEl_, targetOrType, typeOrListener);
      } else {
        const target = targetOrType;
        const type = typeOrListener;
        validateTarget(target, this, "off");
        validateEventType(type, this, "off");
        validateListener(listener, this, "off");
        listener = bind_(this, listener);
        this.off("dispose", listener);
        if (target.nodeName) {
          off(target, type, listener);
          off(target, "dispose", listener);
        } else if (isEvented(target)) {
          target.off(type, listener);
          target.off("dispose", listener);
        }
      }
    },
    /**
     * Fire an event on this evented object, causing its listeners to be called.
     *
     * @param   {string|Object} event
     *          An event type or an object with a type property.
     *
     * @param   {Object} [hash]
     *          An additional object to pass along to listeners.
     *
     * @return {boolean}
     *          Whether or not the default behavior was prevented.
     */
    trigger(event, hash) {
      validateTarget(this.eventBusEl_, this, "trigger");
      const type = event && typeof event !== "string" ? event.type : event;
      if (!isValidEventType(type)) {
        throw new Error(`Invalid event type for ${objName(this)}#trigger; must be a non-empty string or object with a type key that has a non-empty value.`);
      }
      return trigger(this.eventBusEl_, event, hash);
    }
  };
  function evented(target, options = {}) {
    const {
      eventBusKey
    } = options;
    if (eventBusKey) {
      if (!target[eventBusKey].nodeName) {
        throw new Error(`The eventBusKey "${eventBusKey}" does not refer to an element.`);
      }
      target.eventBusEl_ = target[eventBusKey];
    } else {
      target.eventBusEl_ = createEl("span", {
        className: "vjs-event-bus"
      });
    }
    Object.assign(target, EventedMixin);
    if (target.eventedCallbacks) {
      target.eventedCallbacks.forEach((callback) => {
        callback();
      });
    }
    target.on("dispose", () => {
      target.off();
      [target, target.el_, target.eventBusEl_].forEach(function(val) {
        if (val && DomData.has(val)) {
          DomData.delete(val);
        }
      });
      window.setTimeout(() => {
        target.eventBusEl_ = null;
      }, 0);
    });
    return target;
  }
  const StatefulMixin = {
    /**
     * A hash containing arbitrary keys and values representing the state of
     * the object.
     *
     * @type {Object}
     */
    state: {},
    /**
     * Set the state of an object by mutating its
     * {@link module:stateful~StatefulMixin.state|state} object in place.
     *
     * @fires   module:stateful~StatefulMixin#statechanged
     * @param   {Object|Function} stateUpdates
     *          A new set of properties to shallow-merge into the plugin state.
     *          Can be a plain object or a function returning a plain object.
     *
     * @return {Object|undefined}
     *          An object containing changes that occurred. If no changes
     *          occurred, returns `undefined`.
     */
    setState(stateUpdates) {
      if (typeof stateUpdates === "function") {
        stateUpdates = stateUpdates();
      }
      let changes;
      each(stateUpdates, (value, key) => {
        if (this.state[key] !== value) {
          changes = changes || {};
          changes[key] = {
            from: this.state[key],
            to: value
          };
        }
        this.state[key] = value;
      });
      if (changes && isEvented(this)) {
        this.trigger({
          changes,
          type: "statechanged"
        });
      }
      return changes;
    }
  };
  function stateful(target, defaultState) {
    Object.assign(target, StatefulMixin);
    target.state = Object.assign({}, target.state, defaultState);
    if (typeof target.handleStateChanged === "function" && isEvented(target)) {
      target.on("statechanged", target.handleStateChanged);
    }
    return target;
  }
  const toLowerCase = function(string) {
    if (typeof string !== "string") {
      return string;
    }
    return string.replace(/./, (w) => w.toLowerCase());
  };
  const toTitleCase$1 = function(string) {
    if (typeof string !== "string") {
      return string;
    }
    return string.replace(/./, (w) => w.toUpperCase());
  };
  const titleCaseEquals = function(str1, str2) {
    return toTitleCase$1(str1) === toTitleCase$1(str2);
  };
  var Str = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    toLowerCase,
    toTitleCase: toTitleCase$1,
    titleCaseEquals
  });
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function unwrapExports(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function createCommonjsModule(fn, module2) {
    return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
  }
  var keycode = createCommonjsModule(function(module2, exports2) {
    function keyCode(searchInput) {
      if (searchInput && "object" === typeof searchInput) {
        var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;
        if (hasKeyCode)
          searchInput = hasKeyCode;
      }
      if ("number" === typeof searchInput)
        return names[searchInput];
      var search = String(searchInput);
      var foundNamedKey = codes[search.toLowerCase()];
      if (foundNamedKey)
        return foundNamedKey;
      var foundNamedKey = aliases[search.toLowerCase()];
      if (foundNamedKey)
        return foundNamedKey;
      if (search.length === 1)
        return search.charCodeAt(0);
      return void 0;
    }
    keyCode.isEventKey = function isEventKey(event, nameOrCode) {
      if (event && "object" === typeof event) {
        var keyCode2 = event.which || event.keyCode || event.charCode;
        if (keyCode2 === null || keyCode2 === void 0) {
          return false;
        }
        if (typeof nameOrCode === "string") {
          var foundNamedKey = codes[nameOrCode.toLowerCase()];
          if (foundNamedKey) {
            return foundNamedKey === keyCode2;
          }
          var foundNamedKey = aliases[nameOrCode.toLowerCase()];
          if (foundNamedKey) {
            return foundNamedKey === keyCode2;
          }
        } else if (typeof nameOrCode === "number") {
          return nameOrCode === keyCode2;
        }
        return false;
      }
    };
    exports2 = module2.exports = keyCode;
    var codes = exports2.code = exports2.codes = {
      "backspace": 8,
      "tab": 9,
      "enter": 13,
      "shift": 16,
      "ctrl": 17,
      "alt": 18,
      "pause/break": 19,
      "caps lock": 20,
      "esc": 27,
      "space": 32,
      "page up": 33,
      "page down": 34,
      "end": 35,
      "home": 36,
      "left": 37,
      "up": 38,
      "right": 39,
      "down": 40,
      "insert": 45,
      "delete": 46,
      "command": 91,
      "left command": 91,
      "right command": 93,
      "numpad *": 106,
      "numpad +": 107,
      "numpad -": 109,
      "numpad .": 110,
      "numpad /": 111,
      "num lock": 144,
      "scroll lock": 145,
      "my computer": 182,
      "my calculator": 183,
      ";": 186,
      "=": 187,
      ",": 188,
      "-": 189,
      ".": 190,
      "/": 191,
      "`": 192,
      "[": 219,
      "\\": 220,
      "]": 221,
      "'": 222
    };
    var aliases = exports2.aliases = {
      "windows": 91,
      "\u21E7": 16,
      "\u2325": 18,
      "\u2303": 17,
      "\u2318": 91,
      "ctl": 17,
      "control": 17,
      "option": 18,
      "pause": 19,
      "break": 19,
      "caps": 20,
      "return": 13,
      "escape": 27,
      "spc": 32,
      "spacebar": 32,
      "pgup": 33,
      "pgdn": 34,
      "ins": 45,
      "del": 46,
      "cmd": 91
    };
    /*!
     * Programatically add the following
     */
    for (i = 97; i < 123; i++)
      codes[String.fromCharCode(i)] = i - 32;
    for (var i = 48; i < 58; i++)
      codes[i - 48] = i;
    for (i = 1; i < 13; i++)
      codes["f" + i] = i + 111;
    for (i = 0; i < 10; i++)
      codes["numpad " + i] = i + 96;
    var names = exports2.names = exports2.title = {};
    for (i in codes)
      names[codes[i]] = i;
    for (var alias in aliases) {
      codes[alias] = aliases[alias];
    }
  });
  keycode.code;
  keycode.codes;
  keycode.aliases;
  keycode.names;
  keycode.title;
  class Component$1 {
    /**
     * A callback that is called when a component is ready. Does not have any
     * parameters and any callback value will be ignored.
     *
     * @callback ReadyCallback
     * @this Component
     */
    /**
     * Creates an instance of this class.
     *
     * @param { import('./player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of component options.
     *
     * @param {Object[]} [options.children]
     *        An array of children objects to initialize this component with. Children objects have
     *        a name property that will be used if more than one component of the same type needs to be
     *        added.
     *
     * @param  {string} [options.className]
     *         A class or space separated list of classes to add the component
     *
     * @param {ReadyCallback} [ready]
     *        Function that gets called when the `Component` is ready.
     */
    constructor(player, options, ready) {
      if (!player && this.play) {
        this.player_ = player = this;
      } else {
        this.player_ = player;
      }
      this.isDisposed_ = false;
      this.parentComponent_ = null;
      this.options_ = merge$2({}, this.options_);
      options = this.options_ = merge$2(this.options_, options);
      this.id_ = options.id || options.el && options.el.id;
      if (!this.id_) {
        const id = player && player.id && player.id() || "no_player";
        this.id_ = `${id}_component_${newGUID()}`;
      }
      this.name_ = options.name || null;
      if (options.el) {
        this.el_ = options.el;
      } else if (options.createEl !== false) {
        this.el_ = this.createEl();
      }
      if (options.className && this.el_) {
        options.className.split(" ").forEach((c) => this.addClass(c));
      }
      ["on", "off", "one", "any", "trigger"].forEach((fn) => {
        this[fn] = void 0;
      });
      if (options.evented !== false) {
        evented(this, {
          eventBusKey: this.el_ ? "el_" : null
        });
        this.handleLanguagechange = this.handleLanguagechange.bind(this);
        this.on(this.player_, "languagechange", this.handleLanguagechange);
      }
      stateful(this, this.constructor.defaultState);
      this.children_ = [];
      this.childIndex_ = {};
      this.childNameIndex_ = {};
      this.setTimeoutIds_ = /* @__PURE__ */ new Set();
      this.setIntervalIds_ = /* @__PURE__ */ new Set();
      this.rafIds_ = /* @__PURE__ */ new Set();
      this.namedRafs_ = /* @__PURE__ */ new Map();
      this.clearingTimersOnDispose_ = false;
      if (options.initChildren !== false) {
        this.initChildren();
      }
      this.ready(ready);
      if (options.reportTouchActivity !== false) {
        this.enableTouchActivity();
      }
    }
    // `on`, `off`, `one`, `any` and `trigger` are here so tsc includes them in definitions.
    // They are replaced or removed in the constructor
    /**
     * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a
     * function that will get called when an event with a certain name gets triggered.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} fn
     *        The function to call with `EventTarget`s
     */
    on(type, fn) {
    }
    /**
     * Removes an `event listener` for a specific event from an instance of `EventTarget`.
     * This makes it so that the `event listener` will no longer get called when the
     * named event happens.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} [fn]
     *        The function to remove. If not specified, all listeners managed by Video.js will be removed.
     */
    off(type, fn) {
    }
    /**
     * This function will add an `event listener` that gets triggered only once. After the
     * first trigger it will get removed. This is like adding an `event listener`
     * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} fn
     *        The function to be called once for each event name.
     */
    one(type, fn) {
    }
    /**
     * This function will add an `event listener` that gets triggered only once and is
     * removed from all events. This is like adding an array of `event listener`s
     * with {@link EventTarget#on} that calls {@link EventTarget#off} on all events the
     * first time it is triggered.
     *
     * @param {string|string[]} type
     *        An event name or an array of event names.
     *
     * @param {Function} fn
     *        The function to be called once for each event name.
     */
    any(type, fn) {
    }
    /**
     * This function causes an event to happen. This will then cause any `event listeners`
     * that are waiting for that event, to get called. If there are no `event listeners`
     * for an event then nothing will happen.
     *
     * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.
     * Trigger will also call the `on` + `uppercaseEventName` function.
     *
     * Example:
     * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call
     * `onClick` if it exists.
     *
     * @param {string|Event|Object} event
     *        The name of the event, an `Event`, or an object with a key of type set to
     *        an event name.
     *
     * @param {Object} [hash]
     *        Optionally extra argument to pass through to an event listener
     */
    trigger(event, hash) {
    }
    /**
     * Dispose of the `Component` and all child components.
     *
     * @fires Component#dispose
     *
     * @param {Object} options
     * @param {Element} options.originalEl element with which to replace player element
     */
    dispose(options = {}) {
      if (this.isDisposed_) {
        return;
      }
      if (this.readyQueue_) {
        this.readyQueue_.length = 0;
      }
      this.trigger({
        type: "dispose",
        bubbles: false
      });
      this.isDisposed_ = true;
      if (this.children_) {
        for (let i = this.children_.length - 1; i >= 0; i--) {
          if (this.children_[i].dispose) {
            this.children_[i].dispose();
          }
        }
      }
      this.children_ = null;
      this.childIndex_ = null;
      this.childNameIndex_ = null;
      this.parentComponent_ = null;
      if (this.el_) {
        if (this.el_.parentNode) {
          if (options.restoreEl) {
            this.el_.parentNode.replaceChild(options.restoreEl, this.el_);
          } else {
            this.el_.parentNode.removeChild(this.el_);
          }
        }
        this.el_ = null;
      }
      this.player_ = null;
    }
    /**
     * Determine whether or not this component has been disposed.
     *
     * @return {boolean}
     *         If the component has been disposed, will be `true`. Otherwise, `false`.
     */
    isDisposed() {
      return Boolean(this.isDisposed_);
    }
    /**
     * Return the {@link Player} that the `Component` has attached to.
     *
     * @return { import('./player').default }
     *         The player that this `Component` has attached to.
     */
    player() {
      return this.player_;
    }
    /**
     * Deep merge of options objects with new options.
     * > Note: When both `obj` and `options` contain properties whose values are objects.
     *         The two properties get merged using {@link module:obj.merge}
     *
     * @param {Object} obj
     *        The object that contains new options.
     *
     * @return {Object}
     *         A new object of `this.options_` and `obj` merged together.
     */
    options(obj) {
      if (!obj) {
        return this.options_;
      }
      this.options_ = merge$2(this.options_, obj);
      return this.options_;
    }
    /**
     * Get the `Component`s DOM element
     *
     * @return {Element}
     *         The DOM element for this `Component`.
     */
    el() {
      return this.el_;
    }
    /**
     * Create the `Component`s DOM element.
     *
     * @param {string} [tagName]
     *        Element's DOM node type. e.g. 'div'
     *
     * @param {Object} [properties]
     *        An object of properties that should be set.
     *
     * @param {Object} [attributes]
     *        An object of attributes that should be set.
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl(tagName, properties, attributes) {
      return createEl(tagName, properties, attributes);
    }
    /**
     * Localize a string given the string in english.
     *
     * If tokens are provided, it'll try and run a simple token replacement on the provided string.
     * The tokens it looks for look like `{1}` with the index being 1-indexed into the tokens array.
     *
     * If a `defaultValue` is provided, it'll use that over `string`,
     * if a value isn't found in provided language files.
     * This is useful if you want to have a descriptive key for token replacement
     * but have a succinct localized string and not require `en.json` to be included.
     *
     * Currently, it is used for the progress bar timing.
     * ```js
     * {
     *   "progress bar timing: currentTime={1} duration={2}": "{1} of {2}"
     * }
     * ```
     * It is then used like so:
     * ```js
     * this.localize('progress bar timing: currentTime={1} duration{2}',
     *               [this.player_.currentTime(), this.player_.duration()],
     *               '{1} of {2}');
     * ```
     *
     * Which outputs something like: `01:23 of 24:56`.
     *
     *
     * @param {string} string
     *        The string to localize and the key to lookup in the language files.
     * @param {string[]} [tokens]
     *        If the current item has token replacements, provide the tokens here.
     * @param {string} [defaultValue]
     *        Defaults to `string`. Can be a default value to use for token replacement
     *        if the lookup key is needed to be separate.
     *
     * @return {string}
     *         The localized string or if no localization exists the english string.
     */
    localize(string, tokens, defaultValue = string) {
      const code = this.player_.language && this.player_.language();
      const languages = this.player_.languages && this.player_.languages();
      const language = languages && languages[code];
      const primaryCode = code && code.split("-")[0];
      const primaryLang = languages && languages[primaryCode];
      let localizedString = defaultValue;
      if (language && language[string]) {
        localizedString = language[string];
      } else if (primaryLang && primaryLang[string]) {
        localizedString = primaryLang[string];
      }
      if (tokens) {
        localizedString = localizedString.replace(/\{(\d+)\}/g, function(match, index) {
          const value = tokens[index - 1];
          let ret = value;
          if (typeof value === "undefined") {
            ret = match;
          }
          return ret;
        });
      }
      return localizedString;
    }
    /**
     * Handles language change for the player in components. Should be overridden by sub-components.
     *
     * @abstract
     */
    handleLanguagechange() {
    }
    /**
     * Return the `Component`s DOM element. This is where children get inserted.
     * This will usually be the the same as the element returned in {@link Component#el}.
     *
     * @return {Element}
     *         The content element for this `Component`.
     */
    contentEl() {
      return this.contentEl_ || this.el_;
    }
    /**
     * Get this `Component`s ID
     *
     * @return {string}
     *         The id of this `Component`
     */
    id() {
      return this.id_;
    }
    /**
     * Get the `Component`s name. The name gets used to reference the `Component`
     * and is set during registration.
     *
     * @return {string}
     *         The name of this `Component`.
     */
    name() {
      return this.name_;
    }
    /**
     * Get an array of all child components
     *
     * @return {Array}
     *         The children
     */
    children() {
      return this.children_;
    }
    /**
     * Returns the child `Component` with the given `id`.
     *
     * @param {string} id
     *        The id of the child `Component` to get.
     *
     * @return {Component|undefined}
     *         The child `Component` with the given `id` or undefined.
     */
    getChildById(id) {
      return this.childIndex_[id];
    }
    /**
     * Returns the child `Component` with the given `name`.
     *
     * @param {string} name
     *        The name of the child `Component` to get.
     *
     * @return {Component|undefined}
     *         The child `Component` with the given `name` or undefined.
     */
    getChild(name) {
      if (!name) {
        return;
      }
      return this.childNameIndex_[name];
    }
    /**
     * Returns the descendant `Component` following the givent
     * descendant `names`. For instance ['foo', 'bar', 'baz'] would
     * try to get 'foo' on the current component, 'bar' on the 'foo'
     * component and 'baz' on the 'bar' component and return undefined
     * if any of those don't exist.
     *
     * @param {...string[]|...string} names
     *        The name of the child `Component` to get.
     *
     * @return {Component|undefined}
     *         The descendant `Component` following the given descendant
     *         `names` or undefined.
     */
    getDescendant(...names) {
      names = names.reduce((acc, n) => acc.concat(n), []);
      let currentChild = this;
      for (let i = 0; i < names.length; i++) {
        currentChild = currentChild.getChild(names[i]);
        if (!currentChild || !currentChild.getChild) {
          return;
        }
      }
      return currentChild;
    }
    /**
     * Adds an SVG icon element to another element or component.
     *
     * @param {string} iconName
     *        The name of icon. A list of all the icon names can be found at 'sandbox/svg-icons.html'
     *
     * @param {Element} [el=this.el()]
     *        Element to set the title on. Defaults to the current Component's element.
     *
     * @return {Element}
     *        The newly created icon element.
     */
    setIcon(iconName, el = this.el()) {
      if (!this.player_.options_.experimentalSvgIcons) {
        return;
      }
      const xmlnsURL = "http://www.w3.org/2000/svg";
      const iconContainer = createEl("span", {
        className: "vjs-icon-placeholder vjs-svg-icon"
      }, {
        "aria-hidden": "true"
      });
      const svgEl = document.createElementNS(xmlnsURL, "svg");
      svgEl.setAttributeNS(null, "viewBox", "0 0 512 512");
      const useEl = document.createElementNS(xmlnsURL, "use");
      svgEl.appendChild(useEl);
      useEl.setAttributeNS(null, "href", `#vjs-icon-${iconName}`);
      iconContainer.appendChild(svgEl);
      if (this.iconIsSet_) {
        el.replaceChild(iconContainer, el.querySelector(".vjs-icon-placeholder"));
      } else {
        el.appendChild(iconContainer);
      }
      this.iconIsSet_ = true;
      return iconContainer;
    }
    /**
     * Add a child `Component` inside the current `Component`.
     *
     * @param {string|Component} child
     *        The name or instance of a child to add.
     *
     * @param {Object} [options={}]
     *        The key/value store of options that will get passed to children of
     *        the child.
     *
     * @param {number} [index=this.children_.length]
     *        The index to attempt to add a child into.
     *
     *
     * @return {Component}
     *         The `Component` that gets added as a child. When using a string the
     *         `Component` will get created by this process.
     */
    addChild(child, options = {}, index = this.children_.length) {
      let component;
      let componentName;
      if (typeof child === "string") {
        componentName = toTitleCase$1(child);
        const componentClassName = options.componentClass || componentName;
        options.name = componentName;
        const ComponentClass = Component$1.getComponent(componentClassName);
        if (!ComponentClass) {
          throw new Error(`Component ${componentClassName} does not exist`);
        }
        if (typeof ComponentClass !== "function") {
          return null;
        }
        component = new ComponentClass(this.player_ || this, options);
      } else {
        component = child;
      }
      if (component.parentComponent_) {
        component.parentComponent_.removeChild(component);
      }
      this.children_.splice(index, 0, component);
      component.parentComponent_ = this;
      if (typeof component.id === "function") {
        this.childIndex_[component.id()] = component;
      }
      componentName = componentName || component.name && toTitleCase$1(component.name());
      if (componentName) {
        this.childNameIndex_[componentName] = component;
        this.childNameIndex_[toLowerCase(componentName)] = component;
      }
      if (typeof component.el === "function" && component.el()) {
        let refNode = null;
        if (this.children_[index + 1]) {
          if (this.children_[index + 1].el_) {
            refNode = this.children_[index + 1].el_;
          } else if (isEl(this.children_[index + 1])) {
            refNode = this.children_[index + 1];
          }
        }
        this.contentEl().insertBefore(component.el(), refNode);
      }
      return component;
    }
    /**
     * Remove a child `Component` from this `Component`s list of children. Also removes
     * the child `Component`s element from this `Component`s element.
     *
     * @param {Component} component
     *        The child `Component` to remove.
     */
    removeChild(component) {
      if (typeof component === "string") {
        component = this.getChild(component);
      }
      if (!component || !this.children_) {
        return;
      }
      let childFound = false;
      for (let i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i] === component) {
          childFound = true;
          this.children_.splice(i, 1);
          break;
        }
      }
      if (!childFound) {
        return;
      }
      component.parentComponent_ = null;
      this.childIndex_[component.id()] = null;
      this.childNameIndex_[toTitleCase$1(component.name())] = null;
      this.childNameIndex_[toLowerCase(component.name())] = null;
      const compEl = component.el();
      if (compEl && compEl.parentNode === this.contentEl()) {
        this.contentEl().removeChild(component.el());
      }
    }
    /**
     * Add and initialize default child `Component`s based upon options.
     */
    initChildren() {
      const children = this.options_.children;
      if (children) {
        const parentOptions = this.options_;
        const handleAdd = (child) => {
          const name = child.name;
          let opts = child.opts;
          if (parentOptions[name] !== void 0) {
            opts = parentOptions[name];
          }
          if (opts === false) {
            return;
          }
          if (opts === true) {
            opts = {};
          }
          opts.playerOptions = this.options_.playerOptions;
          const newChild = this.addChild(name, opts);
          if (newChild) {
            this[name] = newChild;
          }
        };
        let workingChildren;
        const Tech2 = Component$1.getComponent("Tech");
        if (Array.isArray(children)) {
          workingChildren = children;
        } else {
          workingChildren = Object.keys(children);
        }
        workingChildren.concat(Object.keys(this.options_).filter(function(child) {
          return !workingChildren.some(function(wchild) {
            if (typeof wchild === "string") {
              return child === wchild;
            }
            return child === wchild.name;
          });
        })).map((child) => {
          let name;
          let opts;
          if (typeof child === "string") {
            name = child;
            opts = children[name] || this.options_[name] || {};
          } else {
            name = child.name;
            opts = child;
          }
          return {
            name,
            opts
          };
        }).filter((child) => {
          const c = Component$1.getComponent(child.opts.componentClass || toTitleCase$1(child.name));
          return c && !Tech2.isTech(c);
        }).forEach(handleAdd);
      }
    }
    /**
     * Builds the default DOM class name. Should be overridden by sub-components.
     *
     * @return {string}
     *         The DOM class name for this object.
     *
     * @abstract
     */
    buildCSSClass() {
      return "";
    }
    /**
     * Bind a listener to the component's ready state.
     * Different from event listeners in that if the ready event has already happened
     * it will trigger the function immediately.
     *
     * @param {ReadyCallback} fn
     *        Function that gets called when the `Component` is ready.
     *
     * @return {Component}
     *         Returns itself; method can be chained.
     */
    ready(fn, sync = false) {
      if (!fn) {
        return;
      }
      if (!this.isReady_) {
        this.readyQueue_ = this.readyQueue_ || [];
        this.readyQueue_.push(fn);
        return;
      }
      if (sync) {
        fn.call(this);
      } else {
        this.setTimeout(fn, 1);
      }
    }
    /**
     * Trigger all the ready listeners for this `Component`.
     *
     * @fires Component#ready
     */
    triggerReady() {
      this.isReady_ = true;
      this.setTimeout(function() {
        const readyQueue = this.readyQueue_;
        this.readyQueue_ = [];
        if (readyQueue && readyQueue.length > 0) {
          readyQueue.forEach(function(fn) {
            fn.call(this);
          }, this);
        }
        this.trigger("ready");
      }, 1);
    }
    /**
     * Find a single DOM element matching a `selector`. This can be within the `Component`s
     * `contentEl()` or another custom context.
     *
     * @param {string} selector
     *        A valid CSS selector, which will be passed to `querySelector`.
     *
     * @param {Element|string} [context=this.contentEl()]
     *        A DOM element within which to query. Can also be a selector string in
     *        which case the first matching element will get used as context. If
     *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
     *        nothing it falls back to `document`.
     *
     * @return {Element|null}
     *         the dom element that was found, or null
     *
     * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
     */
    $(selector, context) {
      return $(selector, context || this.contentEl());
    }
    /**
     * Finds all DOM element matching a `selector`. This can be within the `Component`s
     * `contentEl()` or another custom context.
     *
     * @param {string} selector
     *        A valid CSS selector, which will be passed to `querySelectorAll`.
     *
     * @param {Element|string} [context=this.contentEl()]
     *        A DOM element within which to query. Can also be a selector string in
     *        which case the first matching element will get used as context. If
     *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
     *        nothing it falls back to `document`.
     *
     * @return {NodeList}
     *         a list of dom elements that were found
     *
     * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
     */
    $$(selector, context) {
      return $$(selector, context || this.contentEl());
    }
    /**
     * Check if a component's element has a CSS class name.
     *
     * @param {string} classToCheck
     *        CSS class name to check.
     *
     * @return {boolean}
     *         - True if the `Component` has the class.
     *         - False if the `Component` does not have the class`
     */
    hasClass(classToCheck) {
      return hasClass(this.el_, classToCheck);
    }
    /**
     * Add a CSS class name to the `Component`s element.
     *
     * @param {...string} classesToAdd
     *        One or more CSS class name to add.
     */
    addClass(...classesToAdd) {
      addClass(this.el_, ...classesToAdd);
    }
    /**
     * Remove a CSS class name from the `Component`s element.
     *
     * @param {...string} classesToRemove
     *        One or more CSS class name to remove.
     */
    removeClass(...classesToRemove) {
      removeClass(this.el_, ...classesToRemove);
    }
    /**
     * Add or remove a CSS class name from the component's element.
     * - `classToToggle` gets added when {@link Component#hasClass} would return false.
     * - `classToToggle` gets removed when {@link Component#hasClass} would return true.
     *
     * @param  {string} classToToggle
     *         The class to add or remove based on (@link Component#hasClass}
     *
     * @param  {boolean|Dom~predicate} [predicate]
     *         An {@link Dom~predicate} function or a boolean
     */
    toggleClass(classToToggle, predicate) {
      toggleClass(this.el_, classToToggle, predicate);
    }
    /**
     * Show the `Component`s element if it is hidden by removing the
     * 'vjs-hidden' class name from it.
     */
    show() {
      this.removeClass("vjs-hidden");
    }
    /**
     * Hide the `Component`s element if it is currently showing by adding the
     * 'vjs-hidden` class name to it.
     */
    hide() {
      this.addClass("vjs-hidden");
    }
    /**
     * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'
     * class name to it. Used during fadeIn/fadeOut.
     *
     * @private
     */
    lockShowing() {
      this.addClass("vjs-lock-showing");
    }
    /**
     * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'
     * class name from it. Used during fadeIn/fadeOut.
     *
     * @private
     */
    unlockShowing() {
      this.removeClass("vjs-lock-showing");
    }
    /**
     * Get the value of an attribute on the `Component`s element.
     *
     * @param {string} attribute
     *        Name of the attribute to get the value from.
     *
     * @return {string|null}
     *         - The value of the attribute that was asked for.
     *         - Can be an empty string on some browsers if the attribute does not exist
     *           or has no value
     *         - Most browsers will return null if the attribute does not exist or has
     *           no value.
     *
     * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}
     */
    getAttribute(attribute) {
      return getAttribute(this.el_, attribute);
    }
    /**
     * Set the value of an attribute on the `Component`'s element
     *
     * @param {string} attribute
     *        Name of the attribute to set.
     *
     * @param {string} value
     *        Value to set the attribute to.
     *
     * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}
     */
    setAttribute(attribute, value) {
      setAttribute(this.el_, attribute, value);
    }
    /**
     * Remove an attribute from the `Component`s element.
     *
     * @param {string} attribute
     *        Name of the attribute to remove.
     *
     * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}
     */
    removeAttribute(attribute) {
      removeAttribute(this.el_, attribute);
    }
    /**
     * Get or set the width of the component based upon the CSS styles.
     * See {@link Component#dimension} for more detailed information.
     *
     * @param {number|string} [num]
     *        The width that you want to set postfixed with '%', 'px' or nothing.
     *
     * @param {boolean} [skipListeners]
     *        Skip the componentresize event trigger
     *
     * @return {number|undefined}
     *         The width when getting, zero if there is no width
     */
    width(num, skipListeners) {
      return this.dimension("width", num, skipListeners);
    }
    /**
     * Get or set the height of the component based upon the CSS styles.
     * See {@link Component#dimension} for more detailed information.
     *
     * @param {number|string} [num]
     *        The height that you want to set postfixed with '%', 'px' or nothing.
     *
     * @param {boolean} [skipListeners]
     *        Skip the componentresize event trigger
     *
     * @return {number|undefined}
     *         The height when getting, zero if there is no height
     */
    height(num, skipListeners) {
      return this.dimension("height", num, skipListeners);
    }
    /**
     * Set both the width and height of the `Component` element at the same time.
     *
     * @param  {number|string} width
     *         Width to set the `Component`s element to.
     *
     * @param  {number|string} height
     *         Height to set the `Component`s element to.
     */
    dimensions(width, height) {
      this.width(width, true);
      this.height(height);
    }
    /**
     * Get or set width or height of the `Component` element. This is the shared code
     * for the {@link Component#width} and {@link Component#height}.
     *
     * Things to know:
     * - If the width or height in an number this will return the number postfixed with 'px'.
     * - If the width/height is a percent this will return the percent postfixed with '%'
     * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function
     *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.
     *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}
     *   for more information
     * - If you want the computed style of the component, use {@link Component#currentWidth}
     *   and {@link {Component#currentHeight}
     *
     * @fires Component#componentresize
     *
     * @param {string} widthOrHeight
     8        'width' or 'height'
     *
     * @param  {number|string} [num]
     8         New dimension
     *
     * @param  {boolean} [skipListeners]
     *         Skip componentresize event trigger
     *
     * @return {number|undefined}
     *         The dimension when getting or 0 if unset
     */
    dimension(widthOrHeight, num, skipListeners) {
      if (num !== void 0) {
        if (num === null || num !== num) {
          num = 0;
        }
        if (("" + num).indexOf("%") !== -1 || ("" + num).indexOf("px") !== -1) {
          this.el_.style[widthOrHeight] = num;
        } else if (num === "auto") {
          this.el_.style[widthOrHeight] = "";
        } else {
          this.el_.style[widthOrHeight] = num + "px";
        }
        if (!skipListeners) {
          this.trigger("componentresize");
        }
        return;
      }
      if (!this.el_) {
        return 0;
      }
      const val = this.el_.style[widthOrHeight];
      const pxIndex = val.indexOf("px");
      if (pxIndex !== -1) {
        return parseInt(val.slice(0, pxIndex), 10);
      }
      return parseInt(this.el_["offset" + toTitleCase$1(widthOrHeight)], 10);
    }
    /**
     * Get the computed width or the height of the component's element.
     *
     * Uses `window.getComputedStyle`.
     *
     * @param {string} widthOrHeight
     *        A string containing 'width' or 'height'. Whichever one you want to get.
     *
     * @return {number}
     *         The dimension that gets asked for or 0 if nothing was set
     *         for that dimension.
     */
    currentDimension(widthOrHeight) {
      let computedWidthOrHeight = 0;
      if (widthOrHeight !== "width" && widthOrHeight !== "height") {
        throw new Error("currentDimension only accepts width or height value");
      }
      computedWidthOrHeight = computedStyle(this.el_, widthOrHeight);
      computedWidthOrHeight = parseFloat(computedWidthOrHeight);
      if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {
        const rule = `offset${toTitleCase$1(widthOrHeight)}`;
        computedWidthOrHeight = this.el_[rule];
      }
      return computedWidthOrHeight;
    }
    /**
     * An object that contains width and height values of the `Component`s
     * computed style. Uses `window.getComputedStyle`.
     *
     * @typedef {Object} Component~DimensionObject
     *
     * @property {number} width
     *           The width of the `Component`s computed style.
     *
     * @property {number} height
     *           The height of the `Component`s computed style.
     */
    /**
     * Get an object that contains computed width and height values of the
     * component's element.
     *
     * Uses `window.getComputedStyle`.
     *
     * @return {Component~DimensionObject}
     *         The computed dimensions of the component's element.
     */
    currentDimensions() {
      return {
        width: this.currentDimension("width"),
        height: this.currentDimension("height")
      };
    }
    /**
     * Get the computed width of the component's element.
     *
     * Uses `window.getComputedStyle`.
     *
     * @return {number}
     *         The computed width of the component's element.
     */
    currentWidth() {
      return this.currentDimension("width");
    }
    /**
     * Get the computed height of the component's element.
     *
     * Uses `window.getComputedStyle`.
     *
     * @return {number}
     *         The computed height of the component's element.
     */
    currentHeight() {
      return this.currentDimension("height");
    }
    /**
     * Set the focus to this component
     */
    focus() {
      this.el_.focus();
    }
    /**
     * Remove the focus from this component
     */
    blur() {
      this.el_.blur();
    }
    /**
     * When this Component receives a `keydown` event which it does not process,
     *  it passes the event to the Player for handling.
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called.
     */
    handleKeyDown(event) {
      if (this.player_) {
        if (!keycode.isEventKey(event, "Tab")) {
          event.stopPropagation();
        }
        this.player_.handleKeyDown(event);
      }
    }
    /**
     * Many components used to have a `handleKeyPress` method, which was poorly
     * named because it listened to a `keydown` event. This method name now
     * delegates to `handleKeyDown`. This means anyone calling `handleKeyPress`
     * will not see their method calls stop working.
     *
     * @param {KeyboardEvent} event
     *        The event that caused this function to be called.
     */
    handleKeyPress(event) {
      this.handleKeyDown(event);
    }
    /**
     * Emit a 'tap' events when touch event support gets detected. This gets used to
     * support toggling the controls through a tap on the video. They get enabled
     * because every sub-component would have extra overhead otherwise.
     *
     * @protected
     * @fires Component#tap
     * @listens Component#touchstart
     * @listens Component#touchmove
     * @listens Component#touchleave
     * @listens Component#touchcancel
     * @listens Component#touchend
      */
    emitTapEvents() {
      let touchStart = 0;
      let firstTouch = null;
      const tapMovementThreshold = 10;
      const touchTimeThreshold = 200;
      let couldBeTap;
      this.on("touchstart", function(event) {
        if (event.touches.length === 1) {
          firstTouch = {
            pageX: event.touches[0].pageX,
            pageY: event.touches[0].pageY
          };
          touchStart = window.performance.now();
          couldBeTap = true;
        }
      });
      this.on("touchmove", function(event) {
        if (event.touches.length > 1) {
          couldBeTap = false;
        } else if (firstTouch) {
          const xdiff = event.touches[0].pageX - firstTouch.pageX;
          const ydiff = event.touches[0].pageY - firstTouch.pageY;
          const touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
          if (touchDistance > tapMovementThreshold) {
            couldBeTap = false;
          }
        }
      });
      const noTap = function() {
        couldBeTap = false;
      };
      this.on("touchleave", noTap);
      this.on("touchcancel", noTap);
      this.on("touchend", function(event) {
        firstTouch = null;
        if (couldBeTap === true) {
          const touchTime = window.performance.now() - touchStart;
          if (touchTime < touchTimeThreshold) {
            event.preventDefault();
            this.trigger("tap");
          }
        }
      });
    }
    /**
     * This function reports user activity whenever touch events happen. This can get
     * turned off by any sub-components that wants touch events to act another way.
     *
     * Report user touch activity when touch events occur. User activity gets used to
     * determine when controls should show/hide. It is simple when it comes to mouse
     * events, because any mouse event should show the controls. So we capture mouse
     * events that bubble up to the player and report activity when that happens.
     * With touch events it isn't as easy as `touchstart` and `touchend` toggle player
     * controls. So touch events can't help us at the player level either.
     *
     * User activity gets checked asynchronously. So what could happen is a tap event
     * on the video turns the controls off. Then the `touchend` event bubbles up to
     * the player. Which, if it reported user activity, would turn the controls right
     * back on. We also don't want to completely block touch events from bubbling up.
     * Furthermore a `touchmove` event and anything other than a tap, should not turn
     * controls back on.
     *
     * @listens Component#touchstart
     * @listens Component#touchmove
     * @listens Component#touchend
     * @listens Component#touchcancel
     */
    enableTouchActivity() {
      if (!this.player() || !this.player().reportUserActivity) {
        return;
      }
      const report = bind_(this.player(), this.player().reportUserActivity);
      let touchHolding;
      this.on("touchstart", function() {
        report();
        this.clearInterval(touchHolding);
        touchHolding = this.setInterval(report, 250);
      });
      const touchEnd = function(event) {
        report();
        this.clearInterval(touchHolding);
      };
      this.on("touchmove", report);
      this.on("touchend", touchEnd);
      this.on("touchcancel", touchEnd);
    }
    /**
     * A callback that has no parameters and is bound into `Component`s context.
     *
     * @callback Component~GenericCallback
     * @this Component
     */
    /**
     * Creates a function that runs after an `x` millisecond timeout. This function is a
     * wrapper around `window.setTimeout`. There are a few reasons to use this one
     * instead though:
     * 1. It gets cleared via  {@link Component#clearTimeout} when
     *    {@link Component#dispose} gets called.
     * 2. The function callback will gets turned into a {@link Component~GenericCallback}
     *
     * > Note: You can't use `window.clearTimeout` on the id returned by this function. This
     *         will cause its dispose listener not to get cleaned up! Please use
     *         {@link Component#clearTimeout} or {@link Component#dispose} instead.
     *
     * @param {Component~GenericCallback} fn
     *        The function that will be run after `timeout`.
     *
     * @param {number} timeout
     *        Timeout in milliseconds to delay before executing the specified function.
     *
     * @return {number}
     *         Returns a timeout ID that gets used to identify the timeout. It can also
     *         get used in {@link Component#clearTimeout} to clear the timeout that
     *         was set.
     *
     * @listens Component#dispose
     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}
     */
    setTimeout(fn, timeout) {
      var timeoutId;
      fn = bind_(this, fn);
      this.clearTimersOnDispose_();
      timeoutId = window.setTimeout(() => {
        if (this.setTimeoutIds_.has(timeoutId)) {
          this.setTimeoutIds_.delete(timeoutId);
        }
        fn();
      }, timeout);
      this.setTimeoutIds_.add(timeoutId);
      return timeoutId;
    }
    /**
     * Clears a timeout that gets created via `window.setTimeout` or
     * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}
     * use this function instead of `window.clearTimout`. If you don't your dispose
     * listener will not get cleaned up until {@link Component#dispose}!
     *
     * @param {number} timeoutId
     *        The id of the timeout to clear. The return value of
     *        {@link Component#setTimeout} or `window.setTimeout`.
     *
     * @return {number}
     *         Returns the timeout id that was cleared.
     *
     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}
     */
    clearTimeout(timeoutId) {
      if (this.setTimeoutIds_.has(timeoutId)) {
        this.setTimeoutIds_.delete(timeoutId);
        window.clearTimeout(timeoutId);
      }
      return timeoutId;
    }
    /**
     * Creates a function that gets run every `x` milliseconds. This function is a wrapper
     * around `window.setInterval`. There are a few reasons to use this one instead though.
     * 1. It gets cleared via  {@link Component#clearInterval} when
     *    {@link Component#dispose} gets called.
     * 2. The function callback will be a {@link Component~GenericCallback}
     *
     * @param {Component~GenericCallback} fn
     *        The function to run every `x` seconds.
     *
     * @param {number} interval
     *        Execute the specified function every `x` milliseconds.
     *
     * @return {number}
     *         Returns an id that can be used to identify the interval. It can also be be used in
     *         {@link Component#clearInterval} to clear the interval.
     *
     * @listens Component#dispose
     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}
     */
    setInterval(fn, interval) {
      fn = bind_(this, fn);
      this.clearTimersOnDispose_();
      const intervalId = window.setInterval(fn, interval);
      this.setIntervalIds_.add(intervalId);
      return intervalId;
    }
    /**
     * Clears an interval that gets created via `window.setInterval` or
     * {@link Component#setInterval}. If you set an interval via {@link Component#setInterval}
     * use this function instead of `window.clearInterval`. If you don't your dispose
     * listener will not get cleaned up until {@link Component#dispose}!
     *
     * @param {number} intervalId
     *        The id of the interval to clear. The return value of
     *        {@link Component#setInterval} or `window.setInterval`.
     *
     * @return {number}
     *         Returns the interval id that was cleared.
     *
     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}
     */
    clearInterval(intervalId) {
      if (this.setIntervalIds_.has(intervalId)) {
        this.setIntervalIds_.delete(intervalId);
        window.clearInterval(intervalId);
      }
      return intervalId;
    }
    /**
     * Queues up a callback to be passed to requestAnimationFrame (rAF), but
     * with a few extra bonuses:
     *
     * - Supports browsers that do not support rAF by falling back to
     *   {@link Component#setTimeout}.
     *
     * - The callback is turned into a {@link Component~GenericCallback} (i.e.
     *   bound to the component).
     *
     * - Automatic cancellation of the rAF callback is handled if the component
     *   is disposed before it is called.
     *
     * @param  {Component~GenericCallback} fn
     *         A function that will be bound to this component and executed just
     *         before the browser's next repaint.
     *
     * @return {number}
     *         Returns an rAF ID that gets used to identify the timeout. It can
     *         also be used in {@link Component#cancelAnimationFrame} to cancel
     *         the animation frame callback.
     *
     * @listens Component#dispose
     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}
     */
    requestAnimationFrame(fn) {
      this.clearTimersOnDispose_();
      var id;
      fn = bind_(this, fn);
      id = window.requestAnimationFrame(() => {
        if (this.rafIds_.has(id)) {
          this.rafIds_.delete(id);
        }
        fn();
      });
      this.rafIds_.add(id);
      return id;
    }
    /**
     * Request an animation frame, but only one named animation
     * frame will be queued. Another will never be added until
     * the previous one finishes.
     *
     * @param {string} name
     *        The name to give this requestAnimationFrame
     *
     * @param  {Component~GenericCallback} fn
     *         A function that will be bound to this component and executed just
     *         before the browser's next repaint.
     */
    requestNamedAnimationFrame(name, fn) {
      if (this.namedRafs_.has(name)) {
        return;
      }
      this.clearTimersOnDispose_();
      fn = bind_(this, fn);
      const id = this.requestAnimationFrame(() => {
        fn();
        if (this.namedRafs_.has(name)) {
          this.namedRafs_.delete(name);
        }
      });
      this.namedRafs_.set(name, id);
      return name;
    }
    /**
     * Cancels a current named animation frame if it exists.
     *
     * @param {string} name
     *        The name of the requestAnimationFrame to cancel.
     */
    cancelNamedAnimationFrame(name) {
      if (!this.namedRafs_.has(name)) {
        return;
      }
      this.cancelAnimationFrame(this.namedRafs_.get(name));
      this.namedRafs_.delete(name);
    }
    /**
     * Cancels a queued callback passed to {@link Component#requestAnimationFrame}
     * (rAF).
     *
     * If you queue an rAF callback via {@link Component#requestAnimationFrame},
     * use this function instead of `window.cancelAnimationFrame`. If you don't,
     * your dispose listener will not get cleaned up until {@link Component#dispose}!
     *
     * @param {number} id
     *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.
     *
     * @return {number}
     *         Returns the rAF ID that was cleared.
     *
     * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}
     */
    cancelAnimationFrame(id) {
      if (this.rafIds_.has(id)) {
        this.rafIds_.delete(id);
        window.cancelAnimationFrame(id);
      }
      return id;
    }
    /**
     * A function to setup `requestAnimationFrame`, `setTimeout`,
     * and `setInterval`, clearing on dispose.
     *
     * > Previously each timer added and removed dispose listeners on it's own.
     * For better performance it was decided to batch them all, and use `Set`s
     * to track outstanding timer ids.
     *
     * @private
     */
    clearTimersOnDispose_() {
      if (this.clearingTimersOnDispose_) {
        return;
      }
      this.clearingTimersOnDispose_ = true;
      this.one("dispose", () => {
        [["namedRafs_", "cancelNamedAnimationFrame"], ["rafIds_", "cancelAnimationFrame"], ["setTimeoutIds_", "clearTimeout"], ["setIntervalIds_", "clearInterval"]].forEach(([idName, cancelName]) => {
          this[idName].forEach((val, key) => this[cancelName](key));
        });
        this.clearingTimersOnDispose_ = false;
      });
    }
    /**
     * Register a `Component` with `videojs` given the name and the component.
     *
     * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s
     *         should be registered using {@link Tech.registerTech} or
     *         {@link videojs:videojs.registerTech}.
     *
     * > NOTE: This function can also be seen on videojs as
     *         {@link videojs:videojs.registerComponent}.
     *
     * @param {string} name
     *        The name of the `Component` to register.
     *
     * @param {Component} ComponentToRegister
     *        The `Component` class to register.
     *
     * @return {Component}
     *         The `Component` that was registered.
     */
    static registerComponent(name, ComponentToRegister) {
      if (typeof name !== "string" || !name) {
        throw new Error(`Illegal component name, "${name}"; must be a non-empty string.`);
      }
      const Tech2 = Component$1.getComponent("Tech");
      const isTech = Tech2 && Tech2.isTech(ComponentToRegister);
      const isComp = Component$1 === ComponentToRegister || Component$1.prototype.isPrototypeOf(ComponentToRegister.prototype);
      if (isTech || !isComp) {
        let reason;
        if (isTech) {
          reason = "techs must be registered using Tech.registerTech()";
        } else {
          reason = "must be a Component subclass";
        }
        throw new Error(`Illegal component, "${name}"; ${reason}.`);
      }
      name = toTitleCase$1(name);
      if (!Component$1.components_) {
        Component$1.components_ = {};
      }
      const Player2 = Component$1.getComponent("Player");
      if (name === "Player" && Player2 && Player2.players) {
        const players = Player2.players;
        const playerNames = Object.keys(players);
        if (players && playerNames.length > 0 && playerNames.map((pname) => players[pname]).every(Boolean)) {
          throw new Error("Can not register Player component after player has been created.");
        }
      }
      Component$1.components_[name] = ComponentToRegister;
      Component$1.components_[toLowerCase(name)] = ComponentToRegister;
      return ComponentToRegister;
    }
    /**
     * Get a `Component` based on the name it was registered with.
     *
     * @param {string} name
     *        The Name of the component to get.
     *
     * @return {typeof Component}
     *         The `Component` that got registered under the given name.
     */
    static getComponent(name) {
      if (!name || !Component$1.components_) {
        return;
      }
      return Component$1.components_[name];
    }
  }
  Component$1.registerComponent("Component", Component$1);
  function rangeCheck(fnName, index, maxIndex) {
    if (typeof index !== "number" || index < 0 || index > maxIndex) {
      throw new Error(`Failed to execute '${fnName}' on 'TimeRanges': The index provided (${index}) is non-numeric or out of bounds (0-${maxIndex}).`);
    }
  }
  function getRange(fnName, valueIndex, ranges, rangeIndex) {
    rangeCheck(fnName, rangeIndex, ranges.length - 1);
    return ranges[rangeIndex][valueIndex];
  }
  function createTimeRangesObj(ranges) {
    let timeRangesObj;
    if (ranges === void 0 || ranges.length === 0) {
      timeRangesObj = {
        length: 0,
        start() {
          throw new Error("This TimeRanges object is empty");
        },
        end() {
          throw new Error("This TimeRanges object is empty");
        }
      };
    } else {
      timeRangesObj = {
        length: ranges.length,
        start: getRange.bind(null, "start", 0, ranges),
        end: getRange.bind(null, "end", 1, ranges)
      };
    }
    if (window.Symbol && window.Symbol.iterator) {
      timeRangesObj[window.Symbol.iterator] = () => (ranges || []).values();
    }
    return timeRangesObj;
  }
  function createTimeRanges$1(start, end) {
    if (Array.isArray(start)) {
      return createTimeRangesObj(start);
    } else if (start === void 0 || end === void 0) {
      return createTimeRangesObj();
    }
    return createTimeRangesObj([[start, end]]);
  }
  const defaultImplementation = function(seconds, guide) {
    seconds = seconds < 0 ? 0 : seconds;
    let s = Math.floor(seconds % 60);
    let m = Math.floor(seconds / 60 % 60);
    let h = Math.floor(seconds / 3600);
    const gm = Math.floor(guide / 60 % 60);
    const gh = Math.floor(guide / 3600);
    if (isNaN(seconds) || seconds === Infinity) {
      h = m = s = "-";
    }
    h = h > 0 || gh > 0 ? h + ":" : "";
    m = ((h || gm >= 10) && m < 10 ? "0" + m : m) + ":";
    s = s < 10 ? "0" + s : s;
    return h + m + s;
  };
  let implementation = defaultImplementation;
  function setFormatTime(customImplementation) {
    implementation = customImplementation;
  }
  function resetFormatTime() {
    implementation = defaultImplementation;
  }
  function formatTime(seconds, guide = seconds) {
    return implementation(seconds, guide);
  }
  var Time = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    createTimeRanges: createTimeRanges$1,
    createTimeRange: createTimeRanges$1,
    setFormatTime,
    resetFormatTime,
    formatTime
  });
  function bufferedPercent(buffered, duration2) {
    let bufferedDuration = 0;
    let start;
    let end;
    if (!duration2) {
      return 0;
    }
    if (!buffered || !buffered.length) {
      buffered = createTimeRanges$1(0, 0);
    }
    for (let i = 0; i < buffered.length; i++) {
      start = buffered.start(i);
      end = buffered.end(i);
      if (end > duration2) {
        end = duration2;
      }
      bufferedDuration += end - start;
    }
    return bufferedDuration / duration2;
  }
  function MediaError(value) {
    if (value instanceof MediaError) {
      return value;
    }
    if (typeof value === "number") {
      this.code = value;
    } else if (typeof value === "string") {
      this.message = value;
    } else if (isObject$1(value)) {
      if (typeof value.code === "number") {
        this.code = value.code;
      }
      Object.assign(this, value);
    }
    if (!this.message) {
      this.message = MediaError.defaultMessages[this.code] || "";
    }
  }
  MediaError.prototype.code = 0;
  MediaError.prototype.message = "";
  MediaError.prototype.status = null;
  MediaError.errorTypes = ["MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED"];
  MediaError.defaultMessages = {
    1: "You aborted the media playback",
    2: "A network error caused the media download to fail part-way.",
    3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
    4: "The media could not be loaded, either because the server or network failed or because the format is not supported.",
    5: "The media is encrypted and we do not have the keys to decrypt it."
  };
  for (let errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
    MediaError[MediaError.errorTypes[errNum]] = errNum;
    MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
  }
  var tuple = SafeParseTuple;
  function SafeParseTuple(obj, reviver) {
    var json;
    var error = null;
    try {
      json = JSON.parse(obj, reviver);
    } catch (err) {
      error = err;
    }
    return [error, json];
  }
  function isPromise(value) {
    return value !== void 0 && value !== null && typeof value.then === "function";
  }
  function silencePromise(value) {
    if (isPromise(value)) {
      value.then(null, (e) => {
      });
    }
  }
  const trackToJson_ = function(track) {
    const ret = ["kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src"].reduce((acc, prop, i) => {
      if (track[prop]) {
        acc[prop] = track[prop];
      }
      return acc;
    }, {
      cues: track.cues && Array.prototype.map.call(track.cues, function(cue) {
        return {
          startTime: cue.startTime,
          endTime: cue.endTime,
          text: cue.text,
          id: cue.id
        };
      })
    });
    return ret;
  };
  const textTracksToJson = function(tech) {
    const trackEls = tech.$$("track");
    const trackObjs = Array.prototype.map.call(trackEls, (t) => t.track);
    const tracks = Array.prototype.map.call(trackEls, function(trackEl) {
      const json = trackToJson_(trackEl.track);
      if (trackEl.src) {
        json.src = trackEl.src;
      }
      return json;
    });
    return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function(track) {
      return trackObjs.indexOf(track) === -1;
    }).map(trackToJson_));
  };
  const jsonToTextTracks = function(json, tech) {
    json.forEach(function(track) {
      const addedTrack = tech.addRemoteTextTrack(track).track;
      if (!track.src && track.cues) {
        track.cues.forEach((cue) => addedTrack.addCue(cue));
      }
    });
    return tech.textTracks();
  };
  var textTrackConverter = {
    textTracksToJson,
    jsonToTextTracks,
    trackToJson_
  };
  const MODAL_CLASS_NAME = "vjs-modal-dialog";
  class ModalDialog extends Component$1 {
    /**
     * Create an instance of this class.
     *
     * @param { import('./player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param { import('./utils/dom').ContentDescriptor} [options.content=undefined]
     *        Provide customized content for this modal.
     *
     * @param {string} [options.description]
     *        A text description for the modal, primarily for accessibility.
     *
     * @param {boolean} [options.fillAlways=false]
     *        Normally, modals are automatically filled only the first time
     *        they open. This tells the modal to refresh its content
     *        every time it opens.
     *
     * @param {string} [options.label]
     *        A text label for the modal, primarily for accessibility.
     *
     * @param {boolean} [options.pauseOnOpen=true]
     *        If `true`, playback will will be paused if playing when
     *        the modal opens, and resumed when it closes.
     *
     * @param {boolean} [options.temporary=true]
     *        If `true`, the modal can only be opened once; it will be
     *        disposed as soon as it's closed.
     *
     * @param {boolean} [options.uncloseable=false]
     *        If `true`, the user will not be able to close the modal
     *        through the UI in the normal ways. Programmatic closing is
     *        still possible.
     */
    constructor(player, options) {
      super(player, options);
      this.handleKeyDown_ = (e) => this.handleKeyDown(e);
      this.close_ = (e) => this.close(e);
      this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = false;
      this.closeable(!this.options_.uncloseable);
      this.content(this.options_.content);
      this.contentEl_ = createEl("div", {
        className: `${MODAL_CLASS_NAME}-content`
      }, {
        role: "document"
      });
      this.descEl_ = createEl("p", {
        className: `${MODAL_CLASS_NAME}-description vjs-control-text`,
        id: this.el().getAttribute("aria-describedby")
      });
      textContent(this.descEl_, this.description());
      this.el_.appendChild(this.descEl_);
      this.el_.appendChild(this.contentEl_);
    }
    /**
     * Create the `ModalDialog`'s DOM element
     *
     * @return {Element}
     *         The DOM element that gets created.
     */
    createEl() {
      return super.createEl("div", {
        className: this.buildCSSClass(),
        tabIndex: -1
      }, {
        "aria-describedby": `${this.id()}_description`,
        "aria-hidden": "true",
        "aria-label": this.label(),
        "role": "dialog"
      });
    }
    dispose() {
      this.contentEl_ = null;
      this.descEl_ = null;
      this.previouslyActiveEl_ = null;
      super.dispose();
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `${MODAL_CLASS_NAME} vjs-hidden ${super.buildCSSClass()}`;
    }
    /**
     * Returns the label string for this modal. Primarily used for accessibility.
     *
     * @return {string}
     *         the localized or raw label of this modal.
     */
    label() {
      return this.localize(this.options_.label || "Modal Window");
    }
    /**
     * Returns the description string for this modal. Primarily used for
     * accessibility.
     *
     * @return {string}
     *         The localized or raw description of this modal.
     */
    description() {
      let desc = this.options_.description || this.localize("This is a modal window.");
      if (this.closeable()) {
        desc += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.");
      }
      return desc;
    }
    /**
     * Opens the modal.
     *
     * @fires ModalDialog#beforemodalopen
     * @fires ModalDialog#modalopen
     */
    open() {
      if (!this.opened_) {
        const player = this.player();
        this.trigger("beforemodalopen");
        this.opened_ = true;
        if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
          this.fill();
        }
        this.wasPlaying_ = !player.paused();
        if (this.options_.pauseOnOpen && this.wasPlaying_) {
          player.pause();
        }
        this.on("keydown", this.handleKeyDown_);
        this.hadControls_ = player.controls();
        player.controls(false);
        this.show();
        this.conditionalFocus_();
        this.el().setAttribute("aria-hidden", "false");
        this.trigger("modalopen");
        this.hasBeenOpened_ = true;
      }
    }
    /**
     * If the `ModalDialog` is currently open or closed.
     *
     * @param  {boolean} [value]
     *         If given, it will open (`true`) or close (`false`) the modal.
     *
     * @return {boolean}
     *         the current open state of the modaldialog
     */
    opened(value) {
      if (typeof value === "boolean") {
        this[value ? "open" : "close"]();
      }
      return this.opened_;
    }
    /**
     * Closes the modal, does nothing if the `ModalDialog` is
     * not open.
     *
     * @fires ModalDialog#beforemodalclose
     * @fires ModalDialog#modalclose
     */
    close() {
      if (!this.opened_) {
        return;
      }
      const player = this.player();
      this.trigger("beforemodalclose");
      this.opened_ = false;
      if (this.wasPlaying_ && this.options_.pauseOnOpen) {
        player.play();
      }
      this.off("keydown", this.handleKeyDown_);
      if (this.hadControls_) {
        player.controls(true);
      }
      this.hide();
      this.el().setAttribute("aria-hidden", "true");
      this.trigger("modalclose");
      this.conditionalBlur_();
      if (this.options_.temporary) {
        this.dispose();
      }
    }
    /**
     * Check to see if the `ModalDialog` is closeable via the UI.
     *
     * @param  {boolean} [value]
     *         If given as a boolean, it will set the `closeable` option.
     *
     * @return {boolean}
     *         Returns the final value of the closable option.
     */
    closeable(value) {
      if (typeof value === "boolean") {
        const closeable = this.closeable_ = !!value;
        let close = this.getChild("closeButton");
        if (closeable && !close) {
          const temp = this.contentEl_;
          this.contentEl_ = this.el_;
          close = this.addChild("closeButton", {
            controlText: "Close Modal Dialog"
          });
          this.contentEl_ = temp;
          this.on(close, "close", this.close_);
        }
        if (!closeable && close) {
          this.off(close, "close", this.close_);
          this.removeChild(close);
          close.dispose();
        }
      }
      return this.closeable_;
    }
    /**
     * Fill the modal's content element with the modal's "content" option.
     * The content element will be emptied before this change takes place.
     */
    fill() {
      this.fillWith(this.content());
    }
    /**
     * Fill the modal's content element with arbitrary content.
     * The content element will be emptied before this change takes place.
     *
     * @fires ModalDialog#beforemodalfill
     * @fires ModalDialog#modalfill
     *
     * @param { import('./utils/dom').ContentDescriptor} [content]
     *        The same rules apply to this as apply to the `content` option.
     */
    fillWith(content) {
      const contentEl = this.contentEl();
      const parentEl = contentEl.parentNode;
      const nextSiblingEl = contentEl.nextSibling;
      this.trigger("beforemodalfill");
      this.hasBeenFilled_ = true;
      parentEl.removeChild(contentEl);
      this.empty();
      insertContent(contentEl, content);
      this.trigger("modalfill");
      if (nextSiblingEl) {
        parentEl.insertBefore(contentEl, nextSiblingEl);
      } else {
        parentEl.appendChild(contentEl);
      }
      const closeButton = this.getChild("closeButton");
      if (closeButton) {
        parentEl.appendChild(closeButton.el_);
      }
    }
    /**
     * Empties the content element. This happens anytime the modal is filled.
     *
     * @fires ModalDialog#beforemodalempty
     * @fires ModalDialog#modalempty
     */
    empty() {
      this.trigger("beforemodalempty");
      emptyEl(this.contentEl());
      this.trigger("modalempty");
    }
    /**
     * Gets or sets the modal content, which gets normalized before being
     * rendered into the DOM.
     *
     * This does not update the DOM or fill the modal, but it is called during
     * that process.
     *
     * @param  { import('./utils/dom').ContentDescriptor} [value]
     *         If defined, sets the internal content value to be used on the
     *         next call(s) to `fill`. This value is normalized before being
     *         inserted. To "clear" the internal content value, pass `null`.
     *
     * @return { import('./utils/dom').ContentDescriptor}
     *         The current content of the modal dialog
     */
    content(value) {
      if (typeof value !== "undefined") {
        this.content_ = value;
      }
      return this.content_;
    }
    /**
     * conditionally focus the modal dialog if focus was previously on the player.
     *
     * @private
     */
    conditionalFocus_() {
      const activeEl = document.activeElement;
      const playerEl = this.player_.el_;
      this.previouslyActiveEl_ = null;
      if (playerEl.contains(activeEl) || playerEl === activeEl) {
        this.previouslyActiveEl_ = activeEl;
        this.focus();
      }
    }
    /**
     * conditionally blur the element and refocus the last focused element
     *
     * @private
     */
    conditionalBlur_() {
      if (this.previouslyActiveEl_) {
        this.previouslyActiveEl_.focus();
        this.previouslyActiveEl_ = null;
      }
    }
    /**
     * Keydown handler. Attached when modal is focused.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      event.stopPropagation();
      if (keycode.isEventKey(event, "Escape") && this.closeable()) {
        event.preventDefault();
        this.close();
        return;
      }
      if (!keycode.isEventKey(event, "Tab")) {
        return;
      }
      const focusableEls = this.focusableEls_();
      const activeEl = this.el_.querySelector(":focus");
      let focusIndex;
      for (let i = 0; i < focusableEls.length; i++) {
        if (activeEl === focusableEls[i]) {
          focusIndex = i;
          break;
        }
      }
      if (document.activeElement === this.el_) {
        focusIndex = 0;
      }
      if (event.shiftKey && focusIndex === 0) {
        focusableEls[focusableEls.length - 1].focus();
        event.preventDefault();
      } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {
        focusableEls[0].focus();
        event.preventDefault();
      }
    }
    /**
     * get all focusable elements
     *
     * @private
     */
    focusableEls_() {
      const allChildren = this.el_.querySelectorAll("*");
      return Array.prototype.filter.call(allChildren, (child) => {
        return (child instanceof window.HTMLAnchorElement || child instanceof window.HTMLAreaElement) && child.hasAttribute("href") || (child instanceof window.HTMLInputElement || child instanceof window.HTMLSelectElement || child instanceof window.HTMLTextAreaElement || child instanceof window.HTMLButtonElement) && !child.hasAttribute("disabled") || child instanceof window.HTMLIFrameElement || child instanceof window.HTMLObjectElement || child instanceof window.HTMLEmbedElement || child.hasAttribute("tabindex") && child.getAttribute("tabindex") !== -1 || child.hasAttribute("contenteditable");
      });
    }
  }
  ModalDialog.prototype.options_ = {
    pauseOnOpen: true,
    temporary: true
  };
  Component$1.registerComponent("ModalDialog", ModalDialog);
  class TrackList extends EventTarget$2 {
    /**
     * Create an instance of this class
     *
     * @param { import('./track').default[] } tracks
     *        A list of tracks to initialize the list with.
     *
     * @abstract
     */
    constructor(tracks = []) {
      super();
      this.tracks_ = [];
      Object.defineProperty(this, "length", {
        get() {
          return this.tracks_.length;
        }
      });
      for (let i = 0; i < tracks.length; i++) {
        this.addTrack(tracks[i]);
      }
    }
    /**
     * Add a {@link Track} to the `TrackList`
     *
     * @param { import('./track').default } track
     *        The audio, video, or text track to add to the list.
     *
     * @fires TrackList#addtrack
     */
    addTrack(track) {
      const index = this.tracks_.length;
      if (!("" + index in this)) {
        Object.defineProperty(this, index, {
          get() {
            return this.tracks_[index];
          }
        });
      }
      if (this.tracks_.indexOf(track) === -1) {
        this.tracks_.push(track);
        this.trigger({
          track,
          type: "addtrack",
          target: this
        });
      }
      track.labelchange_ = () => {
        this.trigger({
          track,
          type: "labelchange",
          target: this
        });
      };
      if (isEvented(track)) {
        track.addEventListener("labelchange", track.labelchange_);
      }
    }
    /**
     * Remove a {@link Track} from the `TrackList`
     *
     * @param { import('./track').default } rtrack
     *        The audio, video, or text track to remove from the list.
     *
     * @fires TrackList#removetrack
     */
    removeTrack(rtrack) {
      let track;
      for (let i = 0, l = this.length; i < l; i++) {
        if (this[i] === rtrack) {
          track = this[i];
          if (track.off) {
            track.off();
          }
          this.tracks_.splice(i, 1);
          break;
        }
      }
      if (!track) {
        return;
      }
      this.trigger({
        track,
        type: "removetrack",
        target: this
      });
    }
    /**
     * Get a Track from the TrackList by a tracks id
     *
     * @param {string} id - the id of the track to get
     * @method getTrackById
     * @return { import('./track').default }
     * @private
     */
    getTrackById(id) {
      let result = null;
      for (let i = 0, l = this.length; i < l; i++) {
        const track = this[i];
        if (track.id === id) {
          result = track;
          break;
        }
      }
      return result;
    }
  }
  TrackList.prototype.allowedEvents_ = {
    change: "change",
    addtrack: "addtrack",
    removetrack: "removetrack",
    labelchange: "labelchange"
  };
  for (const event in TrackList.prototype.allowedEvents_) {
    TrackList.prototype["on" + event] = null;
  }
  const disableOthers$1 = function(list, track) {
    for (let i = 0; i < list.length; i++) {
      if (!Object.keys(list[i]).length || track.id === list[i].id) {
        continue;
      }
      list[i].enabled = false;
    }
  };
  class AudioTrackList extends TrackList {
    /**
     * Create an instance of this class.
     *
     * @param { import('./audio-track').default[] } [tracks=[]]
     *        A list of `AudioTrack` to instantiate the list with.
     */
    constructor(tracks = []) {
      for (let i = tracks.length - 1; i >= 0; i--) {
        if (tracks[i].enabled) {
          disableOthers$1(tracks, tracks[i]);
          break;
        }
      }
      super(tracks);
      this.changing_ = false;
    }
    /**
     * Add an {@link AudioTrack} to the `AudioTrackList`.
     *
     * @param { import('./audio-track').default } track
     *        The AudioTrack to add to the list
     *
     * @fires TrackList#addtrack
     */
    addTrack(track) {
      if (track.enabled) {
        disableOthers$1(this, track);
      }
      super.addTrack(track);
      if (!track.addEventListener) {
        return;
      }
      track.enabledChange_ = () => {
        if (this.changing_) {
          return;
        }
        this.changing_ = true;
        disableOthers$1(this, track);
        this.changing_ = false;
        this.trigger("change");
      };
      track.addEventListener("enabledchange", track.enabledChange_);
    }
    removeTrack(rtrack) {
      super.removeTrack(rtrack);
      if (rtrack.removeEventListener && rtrack.enabledChange_) {
        rtrack.removeEventListener("enabledchange", rtrack.enabledChange_);
        rtrack.enabledChange_ = null;
      }
    }
  }
  const disableOthers = function(list, track) {
    for (let i = 0; i < list.length; i++) {
      if (!Object.keys(list[i]).length || track.id === list[i].id) {
        continue;
      }
      list[i].selected = false;
    }
  };
  class VideoTrackList extends TrackList {
    /**
     * Create an instance of this class.
     *
     * @param {VideoTrack[]} [tracks=[]]
     *        A list of `VideoTrack` to instantiate the list with.
     */
    constructor(tracks = []) {
      for (let i = tracks.length - 1; i >= 0; i--) {
        if (tracks[i].selected) {
          disableOthers(tracks, tracks[i]);
          break;
        }
      }
      super(tracks);
      this.changing_ = false;
      Object.defineProperty(this, "selectedIndex", {
        get() {
          for (let i = 0; i < this.length; i++) {
            if (this[i].selected) {
              return i;
            }
          }
          return -1;
        },
        set() {
        }
      });
    }
    /**
     * Add a {@link VideoTrack} to the `VideoTrackList`.
     *
     * @param { import('./video-track').default } track
     *        The VideoTrack to add to the list
     *
     * @fires TrackList#addtrack
     */
    addTrack(track) {
      if (track.selected) {
        disableOthers(this, track);
      }
      super.addTrack(track);
      if (!track.addEventListener) {
        return;
      }
      track.selectedChange_ = () => {
        if (this.changing_) {
          return;
        }
        this.changing_ = true;
        disableOthers(this, track);
        this.changing_ = false;
        this.trigger("change");
      };
      track.addEventListener("selectedchange", track.selectedChange_);
    }
    removeTrack(rtrack) {
      super.removeTrack(rtrack);
      if (rtrack.removeEventListener && rtrack.selectedChange_) {
        rtrack.removeEventListener("selectedchange", rtrack.selectedChange_);
        rtrack.selectedChange_ = null;
      }
    }
  }
  class TextTrackList extends TrackList {
    /**
     * Add a {@link TextTrack} to the `TextTrackList`
     *
     * @param { import('./text-track').default } track
     *        The text track to add to the list.
     *
     * @fires TrackList#addtrack
     */
    addTrack(track) {
      super.addTrack(track);
      if (!this.queueChange_) {
        this.queueChange_ = () => this.queueTrigger("change");
      }
      if (!this.triggerSelectedlanguagechange) {
        this.triggerSelectedlanguagechange_ = () => this.trigger("selectedlanguagechange");
      }
      track.addEventListener("modechange", this.queueChange_);
      const nonLanguageTextTrackKind = ["metadata", "chapters"];
      if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {
        track.addEventListener("modechange", this.triggerSelectedlanguagechange_);
      }
    }
    removeTrack(rtrack) {
      super.removeTrack(rtrack);
      if (rtrack.removeEventListener) {
        if (this.queueChange_) {
          rtrack.removeEventListener("modechange", this.queueChange_);
        }
        if (this.selectedlanguagechange_) {
          rtrack.removeEventListener("modechange", this.triggerSelectedlanguagechange_);
        }
      }
    }
  }
  class HtmlTrackElementList {
    /**
     * Create an instance of this class.
     *
     * @param {HtmlTrackElement[]} [tracks=[]]
     *        A list of `HtmlTrackElement` to instantiate the list with.
     */
    constructor(trackElements = []) {
      this.trackElements_ = [];
      Object.defineProperty(this, "length", {
        get() {
          return this.trackElements_.length;
        }
      });
      for (let i = 0, length = trackElements.length; i < length; i++) {
        this.addTrackElement_(trackElements[i]);
      }
    }
    /**
     * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`
     *
     * @param {HtmlTrackElement} trackElement
     *        The track element to add to the list.
     *
     * @private
     */
    addTrackElement_(trackElement) {
      const index = this.trackElements_.length;
      if (!("" + index in this)) {
        Object.defineProperty(this, index, {
          get() {
            return this.trackElements_[index];
          }
        });
      }
      if (this.trackElements_.indexOf(trackElement) === -1) {
        this.trackElements_.push(trackElement);
      }
    }
    /**
     * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an
     * {@link TextTrack}.
     *
     * @param {TextTrack} track
     *        The track associated with a track element.
     *
     * @return {HtmlTrackElement|undefined}
     *         The track element that was found or undefined.
     *
     * @private
     */
    getTrackElementByTrack_(track) {
      let trackElement_;
      for (let i = 0, length = this.trackElements_.length; i < length; i++) {
        if (track === this.trackElements_[i].track) {
          trackElement_ = this.trackElements_[i];
          break;
        }
      }
      return trackElement_;
    }
    /**
     * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`
     *
     * @param {HtmlTrackElement} trackElement
     *        The track element to remove from the list.
     *
     * @private
     */
    removeTrackElement_(trackElement) {
      for (let i = 0, length = this.trackElements_.length; i < length; i++) {
        if (trackElement === this.trackElements_[i]) {
          if (this.trackElements_[i].track && typeof this.trackElements_[i].track.off === "function") {
            this.trackElements_[i].track.off();
          }
          if (typeof this.trackElements_[i].off === "function") {
            this.trackElements_[i].off();
          }
          this.trackElements_.splice(i, 1);
          break;
        }
      }
    }
  }
  class TextTrackCueList {
    /**
     * Create an instance of this class..
     *
     * @param {Array} cues
     *        A list of cues to be initialized with
     */
    constructor(cues) {
      TextTrackCueList.prototype.setCues_.call(this, cues);
      Object.defineProperty(this, "length", {
        get() {
          return this.length_;
        }
      });
    }
    /**
     * A setter for cues in this list. Creates getters
     * an an index for the cues.
     *
     * @param {Array} cues
     *        An array of cues to set
     *
     * @private
     */
    setCues_(cues) {
      const oldLength = this.length || 0;
      let i = 0;
      const l = cues.length;
      this.cues_ = cues;
      this.length_ = cues.length;
      const defineProp = function(index) {
        if (!("" + index in this)) {
          Object.defineProperty(this, "" + index, {
            get() {
              return this.cues_[index];
            }
          });
        }
      };
      if (oldLength < l) {
        i = oldLength;
        for (; i < l; i++) {
          defineProp.call(this, i);
        }
      }
    }
    /**
     * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.
     *
     * @param {string} id
     *        The id of the cue that should be searched for.
     *
     * @return {TextTrackCueList~TextTrackCue|null}
     *         A single cue or null if none was found.
     */
    getCueById(id) {
      let result = null;
      for (let i = 0, l = this.length; i < l; i++) {
        const cue = this[i];
        if (cue.id === id) {
          result = cue;
          break;
        }
      }
      return result;
    }
  }
  const VideoTrackKind = {
    alternative: "alternative",
    captions: "captions",
    main: "main",
    sign: "sign",
    subtitles: "subtitles",
    commentary: "commentary"
  };
  const AudioTrackKind = {
    "alternative": "alternative",
    "descriptions": "descriptions",
    "main": "main",
    "main-desc": "main-desc",
    "translation": "translation",
    "commentary": "commentary"
  };
  const TextTrackKind = {
    subtitles: "subtitles",
    captions: "captions",
    descriptions: "descriptions",
    chapters: "chapters",
    metadata: "metadata"
  };
  const TextTrackMode = {
    disabled: "disabled",
    hidden: "hidden",
    showing: "showing"
  };
  class Track extends EventTarget$2 {
    /**
     * Create an instance of this class.
     *
     * @param {Object} [options={}]
     *        Object of option names and values
     *
     * @param {string} [options.kind='']
     *        A valid kind for the track type you are creating.
     *
     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
     *        A unique id for this AudioTrack.
     *
     * @param {string} [options.label='']
     *        The menu label for this track.
     *
     * @param {string} [options.language='']
     *        A valid two character language code.
     *
     * @abstract
     */
    constructor(options = {}) {
      super();
      const trackProps = {
        id: options.id || "vjs_track_" + newGUID(),
        kind: options.kind || "",
        language: options.language || ""
      };
      let label = options.label || "";
      for (const key in trackProps) {
        Object.defineProperty(this, key, {
          get() {
            return trackProps[key];
          },
          set() {
          }
        });
      }
      Object.defineProperty(this, "label", {
        get() {
          return label;
        },
        set(newLabel) {
          if (newLabel !== label) {
            label = newLabel;
            this.trigger("labelchange");
          }
        }
      });
    }
  }
  const parseUrl = function(url) {
    const props = ["protocol", "hostname", "port", "pathname", "search", "hash", "host"];
    const a = document.createElement("a");
    a.href = url;
    const details = {};
    for (let i = 0; i < props.length; i++) {
      details[props[i]] = a[props[i]];
    }
    if (details.protocol === "http:") {
      details.host = details.host.replace(/:80$/, "");
    }
    if (details.protocol === "https:") {
      details.host = details.host.replace(/:443$/, "");
    }
    if (!details.protocol) {
      details.protocol = window.location.protocol;
    }
    if (!details.host) {
      details.host = window.location.host;
    }
    return details;
  };
  const getAbsoluteURL = function(url) {
    if (!url.match(/^https?:\/\//)) {
      const a = document.createElement("a");
      a.href = url;
      url = a.href;
    }
    return url;
  };
  const getFileExtension = function(path) {
    if (typeof path === "string") {
      const splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/;
      const pathParts = splitPathRe.exec(path);
      if (pathParts) {
        return pathParts.pop().toLowerCase();
      }
    }
    return "";
  };
  const isCrossOrigin = function(url, winLoc = window.location) {
    const urlInfo = parseUrl(url);
    const srcProtocol = urlInfo.protocol === ":" ? winLoc.protocol : urlInfo.protocol;
    const crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;
    return crossOrigin;
  };
  var Url = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    parseUrl,
    getAbsoluteURL,
    getFileExtension,
    isCrossOrigin
  });
  var win;
  if (typeof window !== "undefined") {
    win = window;
  } else if (typeof commonjsGlobal !== "undefined") {
    win = commonjsGlobal;
  } else if (typeof self !== "undefined") {
    win = self;
  } else {
    win = {};
  }
  var window_1 = win;
  var _extends_1 = createCommonjsModule(function(module2) {
    function _extends2() {
      module2.exports = _extends2 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      return _extends2.apply(this, arguments);
    }
    module2.exports = _extends2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  });
  var _extends$1 = unwrapExports(_extends_1);
  var isFunction_1 = isFunction;
  var toString = Object.prototype.toString;
  function isFunction(fn) {
    if (!fn) {
      return false;
    }
    var string = toString.call(fn);
    return string === "[object Function]" || typeof fn === "function" && string !== "[object RegExp]" || typeof window !== "undefined" && // IE8 and below
    (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
  }
  var httpResponseHandler = function httpResponseHandler2(callback, decodeResponseBody) {
    if (decodeResponseBody === void 0) {
      decodeResponseBody = false;
    }
    return function(err, response, responseBody) {
      if (err) {
        callback(err);
        return;
      }
      if (response.statusCode >= 400 && response.statusCode <= 599) {
        var cause = responseBody;
        if (decodeResponseBody) {
          if (window_1.TextDecoder) {
            var charset = getCharset(response.headers && response.headers["content-type"]);
            try {
              cause = new TextDecoder(charset).decode(responseBody);
            } catch (e) {
            }
          } else {
            cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));
          }
        }
        callback({
          cause
        });
        return;
      }
      callback(null, responseBody);
    };
  };
  function getCharset(contentTypeHeader) {
    if (contentTypeHeader === void 0) {
      contentTypeHeader = "";
    }
    return contentTypeHeader.toLowerCase().split(";").reduce(function(charset, contentType) {
      var _contentType$split = contentType.split("="), type = _contentType$split[0], value = _contentType$split[1];
      if (type.trim() === "charset") {
        return value.trim();
      }
      return charset;
    }, "utf-8");
  }
  var httpHandler = httpResponseHandler;
  createXHR.httpHandler = httpHandler;
  /**
   * @license
   * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>
   * Copyright (c) 2014 David Björklund
   * Available under the MIT license
   * <https://github.com/kesla/parse-headers/blob/master/LICENCE>
   */
  var parseHeaders = function parseHeaders2(headers) {
    var result = {};
    if (!headers) {
      return result;
    }
    headers.trim().split("\n").forEach(function(row) {
      var index = row.indexOf(":");
      var key = row.slice(0, index).trim().toLowerCase();
      var value = row.slice(index + 1).trim();
      if (typeof result[key] === "undefined") {
        result[key] = value;
      } else if (Array.isArray(result[key])) {
        result[key].push(value);
      } else {
        result[key] = [result[key], value];
      }
    });
    return result;
  };
  var lib = createXHR;
  var default_1 = createXHR;
  createXHR.XMLHttpRequest = window_1.XMLHttpRequest || noop$1;
  createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window_1.XDomainRequest;
  forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
      options = initParams(uri, options, callback);
      options.method = method.toUpperCase();
      return _createXHR(options);
    };
  });
  function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
      iterator(array[i]);
    }
  }
  function isEmpty(obj) {
    for (var i in obj) {
      if (obj.hasOwnProperty(i))
        return false;
    }
    return true;
  }
  function initParams(uri, options, callback) {
    var params = uri;
    if (isFunction_1(options)) {
      callback = options;
      if (typeof uri === "string") {
        params = {
          uri
        };
      }
    } else {
      params = _extends_1({}, options, {
        uri
      });
    }
    params.callback = callback;
    return params;
  }
  function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback);
    return _createXHR(options);
  }
  function _createXHR(options) {
    if (typeof options.callback === "undefined") {
      throw new Error("callback argument missing");
    }
    var called = false;
    var callback = function cbOnce(err, response, body2) {
      if (!called) {
        called = true;
        options.callback(err, response, body2);
      }
    };
    function readystatechange() {
      if (xhr.readyState === 4) {
        setTimeout(loadFunc, 0);
      }
    }
    function getBody() {
      var body2 = void 0;
      if (xhr.response) {
        body2 = xhr.response;
      } else {
        body2 = xhr.responseText || getXml(xhr);
      }
      if (isJson) {
        try {
          body2 = JSON.parse(body2);
        } catch (e) {
        }
      }
      return body2;
    }
    function errorFunc(evt) {
      clearTimeout(timeoutTimer);
      if (!(evt instanceof Error)) {
        evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
      }
      evt.statusCode = 0;
      return callback(evt, failureResponse);
    }
    function loadFunc() {
      if (aborted)
        return;
      var status2;
      clearTimeout(timeoutTimer);
      if (options.useXDR && xhr.status === void 0) {
        status2 = 200;
      } else {
        status2 = xhr.status === 1223 ? 204 : xhr.status;
      }
      var response = failureResponse;
      var err = null;
      if (status2 !== 0) {
        response = {
          body: getBody(),
          statusCode: status2,
          method,
          headers: {},
          url: uri,
          rawRequest: xhr
        };
        if (xhr.getAllResponseHeaders) {
          response.headers = parseHeaders(xhr.getAllResponseHeaders());
        }
      } else {
        err = new Error("Internal XMLHttpRequest Error");
      }
      return callback(err, response, response.body);
    }
    var xhr = options.xhr || null;
    if (!xhr) {
      if (options.cors || options.useXDR) {
        xhr = new createXHR.XDomainRequest();
      } else {
        xhr = new createXHR.XMLHttpRequest();
      }
    }
    var key;
    var aborted;
    var uri = xhr.url = options.uri || options.url;
    var method = xhr.method = options.method || "GET";
    var body = options.body || options.data;
    var headers = xhr.headers = options.headers || {};
    var sync = !!options.sync;
    var isJson = false;
    var timeoutTimer;
    var failureResponse = {
      body: void 0,
      headers: {},
      statusCode: 0,
      method,
      url: uri,
      rawRequest: xhr
    };
    if ("json" in options && options.json !== false) {
      isJson = true;
      headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json");
      if (method !== "GET" && method !== "HEAD") {
        headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json");
        body = JSON.stringify(options.json === true ? body : options.json);
      }
    }
    xhr.onreadystatechange = readystatechange;
    xhr.onload = loadFunc;
    xhr.onerror = errorFunc;
    xhr.onprogress = function() {
    };
    xhr.onabort = function() {
      aborted = true;
    };
    xhr.ontimeout = errorFunc;
    xhr.open(method, uri, !sync, options.username, options.password);
    if (!sync) {
      xhr.withCredentials = !!options.withCredentials;
    }
    if (!sync && options.timeout > 0) {
      timeoutTimer = setTimeout(function() {
        if (aborted)
          return;
        aborted = true;
        xhr.abort("timeout");
        var e = new Error("XMLHttpRequest timeout");
        e.code = "ETIMEDOUT";
        errorFunc(e);
      }, options.timeout);
    }
    if (xhr.setRequestHeader) {
      for (key in headers) {
        if (headers.hasOwnProperty(key)) {
          xhr.setRequestHeader(key, headers[key]);
        }
      }
    } else if (options.headers && !isEmpty(options.headers)) {
      throw new Error("Headers cannot be set on an XDomainRequest object");
    }
    if ("responseType" in options) {
      xhr.responseType = options.responseType;
    }
    if ("beforeSend" in options && typeof options.beforeSend === "function") {
      options.beforeSend(xhr);
    }
    xhr.send(body || null);
    return xhr;
  }
  function getXml(xhr) {
    try {
      if (xhr.responseType === "document") {
        return xhr.responseXML;
      }
      var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
      if (xhr.responseType === "" && !firefoxBugTakenEffect) {
        return xhr.responseXML;
      }
    } catch (e) {
    }
    return null;
  }
  function noop$1() {
  }
  lib.default = default_1;
  const parseCues = function(srcContent, track) {
    const parser = new window.WebVTT.Parser(window, window.vttjs, window.WebVTT.StringDecoder());
    const errors2 = [];
    parser.oncue = function(cue) {
      track.addCue(cue);
    };
    parser.onparsingerror = function(error) {
      errors2.push(error);
    };
    parser.onflush = function() {
      track.trigger({
        type: "loadeddata",
        target: track
      });
    };
    parser.parse(srcContent);
    if (errors2.length > 0) {
      if (window.console && window.console.groupCollapsed) {
        window.console.groupCollapsed(`Text Track parsing errors for ${track.src}`);
      }
      errors2.forEach((error) => log$1.error(error));
      if (window.console && window.console.groupEnd) {
        window.console.groupEnd();
      }
    }
    parser.flush();
  };
  const loadTrack = function(src, track) {
    const opts = {
      uri: src
    };
    const crossOrigin = isCrossOrigin(src);
    if (crossOrigin) {
      opts.cors = crossOrigin;
    }
    const withCredentials = track.tech_.crossOrigin() === "use-credentials";
    if (withCredentials) {
      opts.withCredentials = withCredentials;
    }
    lib(opts, bind_(this, function(err, response, responseBody) {
      if (err) {
        return log$1.error(err, response);
      }
      track.loaded_ = true;
      if (typeof window.WebVTT !== "function") {
        if (track.tech_) {
          track.tech_.any(["vttjsloaded", "vttjserror"], (event) => {
            if (event.type === "vttjserror") {
              log$1.error(`vttjs failed to load, stopping trying to process ${track.src}`);
              return;
            }
            return parseCues(responseBody, track);
          });
        }
      } else {
        parseCues(responseBody, track);
      }
    }));
  };
  class TextTrack extends Track {
    /**
     * Create an instance of this class.
     *
     * @param {Object} options={}
     *        Object of option names and values
     *
     * @param { import('../tech/tech').default } options.tech
     *        A reference to the tech that owns this TextTrack.
     *
     * @param {TextTrack~Kind} [options.kind='subtitles']
     *        A valid text track kind.
     *
     * @param {TextTrack~Mode} [options.mode='disabled']
     *        A valid text track mode.
     *
     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
     *        A unique id for this TextTrack.
     *
     * @param {string} [options.label='']
     *        The menu label for this track.
     *
     * @param {string} [options.language='']
     *        A valid two character language code.
     *
     * @param {string} [options.srclang='']
     *        A valid two character language code. An alternative, but deprioritized
     *        version of `options.language`
     *
     * @param {string} [options.src]
     *        A url to TextTrack cues.
     *
     * @param {boolean} [options.default]
     *        If this track should default to on or off.
     */
    constructor(options = {}) {
      if (!options.tech) {
        throw new Error("A tech was not provided.");
      }
      const settings = merge$2(options, {
        kind: TextTrackKind[options.kind] || "subtitles",
        language: options.language || options.srclang || ""
      });
      let mode = TextTrackMode[settings.mode] || "disabled";
      const default_ = settings.default;
      if (settings.kind === "metadata" || settings.kind === "chapters") {
        mode = "hidden";
      }
      super(settings);
      this.tech_ = settings.tech;
      this.cues_ = [];
      this.activeCues_ = [];
      this.preload_ = this.tech_.preloadTextTracks !== false;
      const cues = new TextTrackCueList(this.cues_);
      const activeCues = new TextTrackCueList(this.activeCues_);
      let changed = false;
      this.timeupdateHandler = bind_(this, function(event = {}) {
        if (this.tech_.isDisposed()) {
          return;
        }
        if (!this.tech_.isReady_) {
          if (event.type !== "timeupdate") {
            this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
          }
          return;
        }
        this.activeCues = this.activeCues;
        if (changed) {
          this.trigger("cuechange");
          changed = false;
        }
        if (event.type !== "timeupdate") {
          this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
        }
      });
      const disposeHandler = () => {
        this.stopTracking();
      };
      this.tech_.one("dispose", disposeHandler);
      if (mode !== "disabled") {
        this.startTracking();
      }
      Object.defineProperties(this, {
        /**
         * @memberof TextTrack
         * @member {boolean} default
         *         If this track was set to be on or off by default. Cannot be changed after
         *         creation.
         * @instance
         *
         * @readonly
         */
        default: {
          get() {
            return default_;
          },
          set() {
          }
        },
        /**
         * @memberof TextTrack
         * @member {string} mode
         *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will
         *         not be set if setting to an invalid mode.
         * @instance
         *
         * @fires TextTrack#modechange
         */
        mode: {
          get() {
            return mode;
          },
          set(newMode) {
            if (!TextTrackMode[newMode]) {
              return;
            }
            if (mode === newMode) {
              return;
            }
            mode = newMode;
            if (!this.preload_ && mode !== "disabled" && this.cues.length === 0) {
              loadTrack(this.src, this);
            }
            this.stopTracking();
            if (mode !== "disabled") {
              this.startTracking();
            }
            this.trigger("modechange");
          }
        },
        /**
         * @memberof TextTrack
         * @member {TextTrackCueList} cues
         *         The text track cue list for this TextTrack.
         * @instance
         */
        cues: {
          get() {
            if (!this.loaded_) {
              return null;
            }
            return cues;
          },
          set() {
          }
        },
        /**
         * @memberof TextTrack
         * @member {TextTrackCueList} activeCues
         *         The list text track cues that are currently active for this TextTrack.
         * @instance
         */
        activeCues: {
          get() {
            if (!this.loaded_) {
              return null;
            }
            if (this.cues.length === 0) {
              return activeCues;
            }
            const ct = this.tech_.currentTime();
            const active = [];
            for (let i = 0, l = this.cues.length; i < l; i++) {
              const cue = this.cues[i];
              if (cue.startTime <= ct && cue.endTime >= ct) {
                active.push(cue);
              }
            }
            changed = false;
            if (active.length !== this.activeCues_.length) {
              changed = true;
            } else {
              for (let i = 0; i < active.length; i++) {
                if (this.activeCues_.indexOf(active[i]) === -1) {
                  changed = true;
                }
              }
            }
            this.activeCues_ = active;
            activeCues.setCues_(this.activeCues_);
            return activeCues;
          },
          // /!\ Keep this setter empty (see the timeupdate handler above)
          set() {
          }
        }
      });
      if (settings.src) {
        this.src = settings.src;
        if (!this.preload_) {
          this.loaded_ = true;
        }
        if (this.preload_ || settings.kind !== "subtitles" && settings.kind !== "captions") {
          loadTrack(this.src, this);
        }
      } else {
        this.loaded_ = true;
      }
    }
    startTracking() {
      this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
      this.tech_.on("timeupdate", this.timeupdateHandler);
    }
    stopTracking() {
      if (this.rvf_) {
        this.tech_.cancelVideoFrameCallback(this.rvf_);
        this.rvf_ = void 0;
      }
      this.tech_.off("timeupdate", this.timeupdateHandler);
    }
    /**
     * Add a cue to the internal list of cues.
     *
     * @param {TextTrack~Cue} cue
     *        The cue to add to our internal list
     */
    addCue(originalCue) {
      let cue = originalCue;
      if (!("getCueAsHTML" in cue)) {
        cue = new window.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);
        for (const prop in originalCue) {
          if (!(prop in cue)) {
            cue[prop] = originalCue[prop];
          }
        }
        cue.id = originalCue.id;
        cue.originalCue_ = originalCue;
      }
      const tracks = this.tech_.textTracks();
      for (let i = 0; i < tracks.length; i++) {
        if (tracks[i] !== this) {
          tracks[i].removeCue(cue);
        }
      }
      this.cues_.push(cue);
      this.cues.setCues_(this.cues_);
    }
    /**
     * Remove a cue from our internal list
     *
     * @param {TextTrack~Cue} removeCue
     *        The cue to remove from our internal list
     */
    removeCue(removeCue) {
      let i = this.cues_.length;
      while (i--) {
        const cue = this.cues_[i];
        if (cue === removeCue || cue.originalCue_ && cue.originalCue_ === removeCue) {
          this.cues_.splice(i, 1);
          this.cues.setCues_(this.cues_);
          break;
        }
      }
    }
  }
  TextTrack.prototype.allowedEvents_ = {
    cuechange: "cuechange"
  };
  class AudioTrack extends Track {
    /**
     * Create an instance of this class.
     *
     * @param {Object} [options={}]
     *        Object of option names and values
     *
     * @param {AudioTrack~Kind} [options.kind='']
     *        A valid audio track kind
     *
     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
     *        A unique id for this AudioTrack.
     *
     * @param {string} [options.label='']
     *        The menu label for this track.
     *
     * @param {string} [options.language='']
     *        A valid two character language code.
     *
     * @param {boolean} [options.enabled]
     *        If this track is the one that is currently playing. If this track is part of
     *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.
     */
    constructor(options = {}) {
      const settings = merge$2(options, {
        kind: AudioTrackKind[options.kind] || ""
      });
      super(settings);
      let enabled = false;
      Object.defineProperty(this, "enabled", {
        get() {
          return enabled;
        },
        set(newEnabled) {
          if (typeof newEnabled !== "boolean" || newEnabled === enabled) {
            return;
          }
          enabled = newEnabled;
          this.trigger("enabledchange");
        }
      });
      if (settings.enabled) {
        this.enabled = settings.enabled;
      }
      this.loaded_ = true;
    }
  }
  class VideoTrack extends Track {
    /**
     * Create an instance of this class.
     *
     * @param {Object} [options={}]
     *        Object of option names and values
     *
     * @param {string} [options.kind='']
     *        A valid {@link VideoTrack~Kind}
     *
     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
     *        A unique id for this AudioTrack.
     *
     * @param {string} [options.label='']
     *        The menu label for this track.
     *
     * @param {string} [options.language='']
     *        A valid two character language code.
     *
     * @param {boolean} [options.selected]
     *        If this track is the one that is currently playing.
     */
    constructor(options = {}) {
      const settings = merge$2(options, {
        kind: VideoTrackKind[options.kind] || ""
      });
      super(settings);
      let selected = false;
      Object.defineProperty(this, "selected", {
        get() {
          return selected;
        },
        set(newSelected) {
          if (typeof newSelected !== "boolean" || newSelected === selected) {
            return;
          }
          selected = newSelected;
          this.trigger("selectedchange");
        }
      });
      if (settings.selected) {
        this.selected = settings.selected;
      }
    }
  }
  class HTMLTrackElement extends EventTarget$2 {
    /**
     * Create an instance of this class.
     *
     * @param {Object} options={}
     *        Object of option names and values
     *
     * @param { import('../tech/tech').default } options.tech
     *        A reference to the tech that owns this HTMLTrackElement.
     *
     * @param {TextTrack~Kind} [options.kind='subtitles']
     *        A valid text track kind.
     *
     * @param {TextTrack~Mode} [options.mode='disabled']
     *        A valid text track mode.
     *
     * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
     *        A unique id for this TextTrack.
     *
     * @param {string} [options.label='']
     *        The menu label for this track.
     *
     * @param {string} [options.language='']
     *        A valid two character language code.
     *
     * @param {string} [options.srclang='']
     *        A valid two character language code. An alternative, but deprioritized
     *        version of `options.language`
     *
     * @param {string} [options.src]
     *        A url to TextTrack cues.
     *
     * @param {boolean} [options.default]
     *        If this track should default to on or off.
     */
    constructor(options = {}) {
      super();
      let readyState;
      const track = new TextTrack(options);
      this.kind = track.kind;
      this.src = track.src;
      this.srclang = track.language;
      this.label = track.label;
      this.default = track.default;
      Object.defineProperties(this, {
        /**
         * @memberof HTMLTrackElement
         * @member {HTMLTrackElement~ReadyState} readyState
         *         The current ready state of the track element.
         * @instance
         */
        readyState: {
          get() {
            return readyState;
          }
        },
        /**
         * @memberof HTMLTrackElement
         * @member {TextTrack} track
         *         The underlying TextTrack object.
         * @instance
         *
         */
        track: {
          get() {
            return track;
          }
        }
      });
      readyState = HTMLTrackElement.NONE;
      track.addEventListener("loadeddata", () => {
        readyState = HTMLTrackElement.LOADED;
        this.trigger({
          type: "load",
          target: this
        });
      });
    }
  }
  HTMLTrackElement.prototype.allowedEvents_ = {
    load: "load"
  };
  HTMLTrackElement.NONE = 0;
  HTMLTrackElement.LOADING = 1;
  HTMLTrackElement.LOADED = 2;
  HTMLTrackElement.ERROR = 3;
  const NORMAL = {
    audio: {
      ListClass: AudioTrackList,
      TrackClass: AudioTrack,
      capitalName: "Audio"
    },
    video: {
      ListClass: VideoTrackList,
      TrackClass: VideoTrack,
      capitalName: "Video"
    },
    text: {
      ListClass: TextTrackList,
      TrackClass: TextTrack,
      capitalName: "Text"
    }
  };
  Object.keys(NORMAL).forEach(function(type) {
    NORMAL[type].getterName = `${type}Tracks`;
    NORMAL[type].privateName = `${type}Tracks_`;
  });
  const REMOTE = {
    remoteText: {
      ListClass: TextTrackList,
      TrackClass: TextTrack,
      capitalName: "RemoteText",
      getterName: "remoteTextTracks",
      privateName: "remoteTextTracks_"
    },
    remoteTextEl: {
      ListClass: HtmlTrackElementList,
      TrackClass: HTMLTrackElement,
      capitalName: "RemoteTextTrackEls",
      getterName: "remoteTextTrackEls",
      privateName: "remoteTextTrackEls_"
    }
  };
  const ALL = Object.assign({}, NORMAL, REMOTE);
  REMOTE.names = Object.keys(REMOTE);
  NORMAL.names = Object.keys(NORMAL);
  ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);
  var minDoc = {};
  var topLevel = typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : {};
  var doccy;
  if (typeof document !== "undefined") {
    doccy = document;
  } else {
    doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
    if (!doccy) {
      doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
    }
  }
  var document_1 = doccy;
  var _objCreate = Object.create || function() {
    function F() {
    }
    return function(o) {
      if (arguments.length !== 1) {
        throw new Error("Object.create shim only accepts one parameter.");
      }
      F.prototype = o;
      return new F();
    };
  }();
  function ParsingError(errorData, message) {
    this.name = "ParsingError";
    this.code = errorData.code;
    this.message = message || errorData.message;
  }
  ParsingError.prototype = _objCreate(Error.prototype);
  ParsingError.prototype.constructor = ParsingError;
  ParsingError.Errors = {
    BadSignature: {
      code: 0,
      message: "Malformed WebVTT signature."
    },
    BadTimeStamp: {
      code: 1,
      message: "Malformed time stamp."
    }
  };
  function parseTimeStamp(input) {
    function computeSeconds(h, m2, s, f) {
      return (h | 0) * 3600 + (m2 | 0) * 60 + (s | 0) + (f | 0) / 1e3;
    }
    var m = input.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
    if (!m) {
      return null;
    }
    if (m[3]) {
      return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
    } else if (m[1] > 59) {
      return computeSeconds(m[1], m[2], 0, m[4]);
    } else {
      return computeSeconds(0, m[1], m[2], m[4]);
    }
  }
  function Settings() {
    this.values = _objCreate(null);
  }
  Settings.prototype = {
    // Only accept the first assignment to any key.
    set: function(k, v) {
      if (!this.get(k) && v !== "") {
        this.values[k] = v;
      }
    },
    // Return the value for a key, or a default value.
    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
    // a number of possible default values as properties where 'defaultKey' is
    // the key of the property that will be chosen; otherwise it's assumed to be
    // a single value.
    get: function(k, dflt, defaultKey) {
      if (defaultKey) {
        return this.has(k) ? this.values[k] : dflt[defaultKey];
      }
      return this.has(k) ? this.values[k] : dflt;
    },
    // Check whether we have a value for a key.
    has: function(k) {
      return k in this.values;
    },
    // Accept a setting if its one of the given alternatives.
    alt: function(k, v, a) {
      for (var n = 0; n < a.length; ++n) {
        if (v === a[n]) {
          this.set(k, v);
          break;
        }
      }
    },
    // Accept a setting if its a valid (signed) integer.
    integer: function(k, v) {
      if (/^-?\d+$/.test(v)) {
        this.set(k, parseInt(v, 10));
      }
    },
    // Accept a setting if its a valid percentage.
    percent: function(k, v) {
      if (v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
        v = parseFloat(v);
        if (v >= 0 && v <= 100) {
          this.set(k, v);
          return true;
        }
      }
      return false;
    }
  };
  function parseOptions(input, callback, keyValueDelim, groupDelim) {
    var groups = groupDelim ? input.split(groupDelim) : [input];
    for (var i in groups) {
      if (typeof groups[i] !== "string") {
        continue;
      }
      var kv = groups[i].split(keyValueDelim);
      if (kv.length !== 2) {
        continue;
      }
      var k = kv[0].trim();
      var v = kv[1].trim();
      callback(k, v);
    }
  }
  function parseCue(input, cue, regionList) {
    var oInput = input;
    function consumeTimeStamp() {
      var ts = parseTimeStamp(input);
      if (ts === null) {
        throw new ParsingError(ParsingError.Errors.BadTimeStamp, "Malformed timestamp: " + oInput);
      }
      input = input.replace(/^[^\sa-zA-Z-]+/, "");
      return ts;
    }
    function consumeCueSettings(input2, cue2) {
      var settings = new Settings();
      parseOptions(input2, function(k, v) {
        switch (k) {
          case "region":
            for (var i = regionList.length - 1; i >= 0; i--) {
              if (regionList[i].id === v) {
                settings.set(k, regionList[i].region);
                break;
              }
            }
            break;
          case "vertical":
            settings.alt(k, v, ["rl", "lr"]);
            break;
          case "line":
            var vals = v.split(","), vals0 = vals[0];
            settings.integer(k, vals0);
            settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
            settings.alt(k, vals0, ["auto"]);
            if (vals.length === 2) {
              settings.alt("lineAlign", vals[1], ["start", "center", "end"]);
            }
            break;
          case "position":
            vals = v.split(",");
            settings.percent(k, vals[0]);
            if (vals.length === 2) {
              settings.alt("positionAlign", vals[1], ["start", "center", "end"]);
            }
            break;
          case "size":
            settings.percent(k, v);
            break;
          case "align":
            settings.alt(k, v, ["start", "center", "end", "left", "right"]);
            break;
        }
      }, /:/, /\s/);
      cue2.region = settings.get("region", null);
      cue2.vertical = settings.get("vertical", "");
      try {
        cue2.line = settings.get("line", "auto");
      } catch (e) {
      }
      cue2.lineAlign = settings.get("lineAlign", "start");
      cue2.snapToLines = settings.get("snapToLines", true);
      cue2.size = settings.get("size", 100);
      try {
        cue2.align = settings.get("align", "center");
      } catch (e) {
        cue2.align = settings.get("align", "middle");
      }
      try {
        cue2.position = settings.get("position", "auto");
      } catch (e) {
        cue2.position = settings.get("position", {
          start: 0,
          left: 0,
          center: 50,
          middle: 50,
          end: 100,
          right: 100
        }, cue2.align);
      }
      cue2.positionAlign = settings.get("positionAlign", {
        start: "start",
        left: "start",
        center: "center",
        middle: "center",
        end: "end",
        right: "end"
      }, cue2.align);
    }
    function skipWhitespace() {
      input = input.replace(/^\s+/, "");
    }
    skipWhitespace();
    cue.startTime = consumeTimeStamp();
    skipWhitespace();
    if (input.substr(0, 3) !== "-->") {
      throw new ParsingError(ParsingError.Errors.BadTimeStamp, "Malformed time stamp (time stamps must be separated by '-->'): " + oInput);
    }
    input = input.substr(3);
    skipWhitespace();
    cue.endTime = consumeTimeStamp();
    skipWhitespace();
    consumeCueSettings(input, cue);
  }
  var TEXTAREA_ELEMENT = document_1.createElement && document_1.createElement("textarea");
  var TAG_NAME = {
    c: "span",
    i: "i",
    b: "b",
    u: "u",
    ruby: "ruby",
    rt: "rt",
    v: "span",
    lang: "span"
  };
  var DEFAULT_COLOR_CLASS = {
    white: "rgba(255,255,255,1)",
    lime: "rgba(0,255,0,1)",
    cyan: "rgba(0,255,255,1)",
    red: "rgba(255,0,0,1)",
    yellow: "rgba(255,255,0,1)",
    magenta: "rgba(255,0,255,1)",
    blue: "rgba(0,0,255,1)",
    black: "rgba(0,0,0,1)"
  };
  var TAG_ANNOTATION = {
    v: "title",
    lang: "lang"
  };
  var NEEDS_PARENT = {
    rt: "ruby"
  };
  function parseContent(window2, input) {
    function nextToken() {
      if (!input) {
        return null;
      }
      function consume(result) {
        input = input.substr(result.length);
        return result;
      }
      var m2 = input.match(/^([^<]*)(<[^>]*>?)?/);
      return consume(m2[1] ? m2[1] : m2[2]);
    }
    function unescape2(s) {
      TEXTAREA_ELEMENT.innerHTML = s;
      s = TEXTAREA_ELEMENT.textContent;
      TEXTAREA_ELEMENT.textContent = "";
      return s;
    }
    function shouldAdd(current2, element) {
      return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current2.localName;
    }
    function createElement(type, annotation) {
      var tagName = TAG_NAME[type];
      if (!tagName) {
        return null;
      }
      var element = window2.document.createElement(tagName);
      var name = TAG_ANNOTATION[type];
      if (name && annotation) {
        element[name] = annotation.trim();
      }
      return element;
    }
    var rootDiv = window2.document.createElement("div"), current = rootDiv, t, tagStack = [];
    while ((t = nextToken()) !== null) {
      if (t[0] === "<") {
        if (t[1] === "/") {
          if (tagStack.length && tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
            tagStack.pop();
            current = current.parentNode;
          }
          continue;
        }
        var ts = parseTimeStamp(t.substr(1, t.length - 2));
        var node;
        if (ts) {
          node = window2.document.createProcessingInstruction("timestamp", ts);
          current.appendChild(node);
          continue;
        }
        var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
        if (!m) {
          continue;
        }
        node = createElement(m[1], m[3]);
        if (!node) {
          continue;
        }
        if (!shouldAdd(current, node)) {
          continue;
        }
        if (m[2]) {
          var classes = m[2].split(".");
          classes.forEach(function(cl) {
            var bgColor = /^bg_/.test(cl);
            var colorName = bgColor ? cl.slice(3) : cl;
            if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {
              var propName = bgColor ? "background-color" : "color";
              var propValue = DEFAULT_COLOR_CLASS[colorName];
              node.style[propName] = propValue;
            }
          });
          node.className = classes.join(" ");
        }
        tagStack.push(m[1]);
        current.appendChild(node);
        current = node;
        continue;
      }
      current.appendChild(window2.document.createTextNode(unescape2(t)));
    }
    return rootDiv;
  }
  var strongRTLRanges = [[1470, 1470], [1472, 1472], [1475, 1475], [1478, 1478], [1488, 1514], [1520, 1524], [1544, 1544], [1547, 1547], [1549, 1549], [1563, 1563], [1566, 1610], [1645, 1647], [1649, 1749], [1765, 1766], [1774, 1775], [1786, 1805], [1807, 1808], [1810, 1839], [1869, 1957], [1969, 1969], [1984, 2026], [2036, 2037], [2042, 2042], [2048, 2069], [2074, 2074], [2084, 2084], [2088, 2088], [2096, 2110], [2112, 2136], [2142, 2142], [2208, 2208], [2210, 2220], [8207, 8207], [64285, 64285], [64287, 64296], [64298, 64310], [64312, 64316], [64318, 64318], [64320, 64321], [64323, 64324], [64326, 64449], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65020], [65136, 65140], [65142, 65276], [67584, 67589], [67592, 67592], [67594, 67637], [67639, 67640], [67644, 67644], [67647, 67669], [67671, 67679], [67840, 67867], [67872, 67897], [67903, 67903], [67968, 68023], [68030, 68031], [68096, 68096], [68112, 68115], [68117, 68119], [68121, 68147], [68160, 68167], [68176, 68184], [68192, 68223], [68352, 68405], [68416, 68437], [68440, 68466], [68472, 68479], [68608, 68680], [126464, 126467], [126469, 126495], [126497, 126498], [126500, 126500], [126503, 126503], [126505, 126514], [126516, 126519], [126521, 126521], [126523, 126523], [126530, 126530], [126535, 126535], [126537, 126537], [126539, 126539], [126541, 126543], [126545, 126546], [126548, 126548], [126551, 126551], [126553, 126553], [126555, 126555], [126557, 126557], [126559, 126559], [126561, 126562], [126564, 126564], [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], [126590, 126590], [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [1114109, 1114109]];
  function isStrongRTLChar(charCode) {
    for (var i = 0; i < strongRTLRanges.length; i++) {
      var currentRange = strongRTLRanges[i];
      if (charCode >= currentRange[0] && charCode <= currentRange[1]) {
        return true;
      }
    }
    return false;
  }
  function determineBidi(cueDiv) {
    var nodeStack = [], text = "", charCode;
    if (!cueDiv || !cueDiv.childNodes) {
      return "ltr";
    }
    function pushNodes(nodeStack2, node) {
      for (var i2 = node.childNodes.length - 1; i2 >= 0; i2--) {
        nodeStack2.push(node.childNodes[i2]);
      }
    }
    function nextTextNode(nodeStack2) {
      if (!nodeStack2 || !nodeStack2.length) {
        return null;
      }
      var node = nodeStack2.pop(), text2 = node.textContent || node.innerText;
      if (text2) {
        var m = text2.match(/^.*(\n|\r)/);
        if (m) {
          nodeStack2.length = 0;
          return m[0];
        }
        return text2;
      }
      if (node.tagName === "ruby") {
        return nextTextNode(nodeStack2);
      }
      if (node.childNodes) {
        pushNodes(nodeStack2, node);
        return nextTextNode(nodeStack2);
      }
    }
    pushNodes(nodeStack, cueDiv);
    while (text = nextTextNode(nodeStack)) {
      for (var i = 0; i < text.length; i++) {
        charCode = text.charCodeAt(i);
        if (isStrongRTLChar(charCode)) {
          return "rtl";
        }
      }
    }
    return "ltr";
  }
  function computeLinePos(cue) {
    if (typeof cue.line === "number" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) {
      return cue.line;
    }
    if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) {
      return -1;
    }
    var track = cue.track, trackList = track.textTrackList, count = 0;
    for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
      if (trackList[i].mode === "showing") {
        count++;
      }
    }
    return ++count * -1;
  }
  function StyleBox() {
  }
  StyleBox.prototype.applyStyles = function(styles, div) {
    div = div || this.div;
    for (var prop in styles) {
      if (styles.hasOwnProperty(prop)) {
        div.style[prop] = styles[prop];
      }
    }
  };
  StyleBox.prototype.formatStyle = function(val, unit) {
    return val === 0 ? 0 : val + unit;
  };
  function CueStyleBox(window2, cue, styleOptions) {
    StyleBox.call(this);
    this.cue = cue;
    this.cueDiv = parseContent(window2, cue.text);
    var styles = {
      color: "rgba(255, 255, 255, 1)",
      backgroundColor: "rgba(0, 0, 0, 0.8)",
      position: "relative",
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      display: "inline",
      writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
      unicodeBidi: "plaintext"
    };
    this.applyStyles(styles, this.cueDiv);
    this.div = window2.document.createElement("div");
    styles = {
      direction: determineBidi(this.cueDiv),
      writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
      unicodeBidi: "plaintext",
      textAlign: cue.align === "middle" ? "center" : cue.align,
      font: styleOptions.font,
      whiteSpace: "pre-line",
      position: "absolute"
    };
    this.applyStyles(styles);
    this.div.appendChild(this.cueDiv);
    var textPos = 0;
    switch (cue.positionAlign) {
      case "start":
      case "line-left":
        textPos = cue.position;
        break;
      case "center":
        textPos = cue.position - cue.size / 2;
        break;
      case "end":
      case "line-right":
        textPos = cue.position - cue.size;
        break;
    }
    if (cue.vertical === "") {
      this.applyStyles({
        left: this.formatStyle(textPos, "%"),
        width: this.formatStyle(cue.size, "%")
      });
    } else {
      this.applyStyles({
        top: this.formatStyle(textPos, "%"),
        height: this.formatStyle(cue.size, "%")
      });
    }
    this.move = function(box) {
      this.applyStyles({
        top: this.formatStyle(box.top, "px"),
        bottom: this.formatStyle(box.bottom, "px"),
        left: this.formatStyle(box.left, "px"),
        right: this.formatStyle(box.right, "px"),
        height: this.formatStyle(box.height, "px"),
        width: this.formatStyle(box.width, "px")
      });
    };
  }
  CueStyleBox.prototype = _objCreate(StyleBox.prototype);
  CueStyleBox.prototype.constructor = CueStyleBox;
  function BoxPosition(obj) {
    var lh, height, width, top;
    if (obj.div) {
      height = obj.div.offsetHeight;
      width = obj.div.offsetWidth;
      top = obj.div.offsetTop;
      var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();
      obj = obj.div.getBoundingClientRect();
      lh = rects ? Math.max(rects[0] && rects[0].height || 0, obj.height / rects.length) : 0;
    }
    this.left = obj.left;
    this.right = obj.right;
    this.top = obj.top || top;
    this.height = obj.height || height;
    this.bottom = obj.bottom || top + (obj.height || height);
    this.width = obj.width || width;
    this.lineHeight = lh !== void 0 ? lh : obj.lineHeight;
  }
  BoxPosition.prototype.move = function(axis, toMove) {
    toMove = toMove !== void 0 ? toMove : this.lineHeight;
    switch (axis) {
      case "+x":
        this.left += toMove;
        this.right += toMove;
        break;
      case "-x":
        this.left -= toMove;
        this.right -= toMove;
        break;
      case "+y":
        this.top += toMove;
        this.bottom += toMove;
        break;
      case "-y":
        this.top -= toMove;
        this.bottom -= toMove;
        break;
    }
  };
  BoxPosition.prototype.overlaps = function(b2) {
    return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;
  };
  BoxPosition.prototype.overlapsAny = function(boxes) {
    for (var i = 0; i < boxes.length; i++) {
      if (this.overlaps(boxes[i])) {
        return true;
      }
    }
    return false;
  };
  BoxPosition.prototype.within = function(container) {
    return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;
  };
  BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
    switch (axis) {
      case "+x":
        return this.left < container.left;
      case "-x":
        return this.right > container.right;
      case "+y":
        return this.top < container.top;
      case "-y":
        return this.bottom > container.bottom;
    }
  };
  BoxPosition.prototype.intersectPercentage = function(b2) {
    var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)), y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)), intersectArea = x * y;
    return intersectArea / (this.height * this.width);
  };
  BoxPosition.prototype.toCSSCompatValues = function(reference) {
    return {
      top: this.top - reference.top,
      bottom: reference.bottom - this.bottom,
      left: this.left - reference.left,
      right: reference.right - this.right,
      height: this.height,
      width: this.width
    };
  };
  BoxPosition.getSimpleBoxPosition = function(obj) {
    var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
    var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
    var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;
    obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;
    var ret = {
      left: obj.left,
      right: obj.right,
      top: obj.top || top,
      height: obj.height || height,
      bottom: obj.bottom || top + (obj.height || height),
      width: obj.width || width
    };
    return ret;
  };
  function moveBoxToLinePosition(window2, styleBox, containerBox, boxPositions) {
    function findBestPosition(b, axis2) {
      var bestPosition2, specifiedPosition = new BoxPosition(b), percentage = 1;
      for (var i = 0; i < axis2.length; i++) {
        while (b.overlapsOppositeAxis(containerBox, axis2[i]) || b.within(containerBox) && b.overlapsAny(boxPositions)) {
          b.move(axis2[i]);
        }
        if (b.within(containerBox)) {
          return b;
        }
        var p = b.intersectPercentage(containerBox);
        if (percentage > p) {
          bestPosition2 = new BoxPosition(b);
          percentage = p;
        }
        b = new BoxPosition(specifiedPosition);
      }
      return bestPosition2 || specifiedPosition;
    }
    var boxPosition = new BoxPosition(styleBox), cue = styleBox.cue, linePos = computeLinePos(cue), axis = [];
    if (cue.snapToLines) {
      var size;
      switch (cue.vertical) {
        case "":
          axis = ["+y", "-y"];
          size = "height";
          break;
        case "rl":
          axis = ["+x", "-x"];
          size = "width";
          break;
        case "lr":
          axis = ["-x", "+x"];
          size = "width";
          break;
      }
      var step = boxPosition.lineHeight, position2 = step * Math.round(linePos), maxPosition = containerBox[size] + step, initialAxis = axis[0];
      if (Math.abs(position2) > maxPosition) {
        position2 = position2 < 0 ? -1 : 1;
        position2 *= Math.ceil(maxPosition / step) * step;
      }
      if (linePos < 0) {
        position2 += cue.vertical === "" ? containerBox.height : containerBox.width;
        axis = axis.reverse();
      }
      boxPosition.move(initialAxis, position2);
    } else {
      var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;
      switch (cue.lineAlign) {
        case "center":
          linePos -= calculatedPercentage / 2;
          break;
        case "end":
          linePos -= calculatedPercentage;
          break;
      }
      switch (cue.vertical) {
        case "":
          styleBox.applyStyles({
            top: styleBox.formatStyle(linePos, "%")
          });
          break;
        case "rl":
          styleBox.applyStyles({
            left: styleBox.formatStyle(linePos, "%")
          });
          break;
        case "lr":
          styleBox.applyStyles({
            right: styleBox.formatStyle(linePos, "%")
          });
          break;
      }
      axis = ["+y", "-x", "+x", "-y"];
      boxPosition = new BoxPosition(styleBox);
    }
    var bestPosition = findBestPosition(boxPosition, axis);
    styleBox.move(bestPosition.toCSSCompatValues(containerBox));
  }
  function WebVTT$1() {
  }
  WebVTT$1.StringDecoder = function() {
    return {
      decode: function(data) {
        if (!data) {
          return "";
        }
        if (typeof data !== "string") {
          throw new Error("Error - expected string data.");
        }
        return decodeURIComponent(encodeURIComponent(data));
      }
    };
  };
  WebVTT$1.convertCueToDOMTree = function(window2, cuetext) {
    if (!window2 || !cuetext) {
      return null;
    }
    return parseContent(window2, cuetext);
  };
  var FONT_SIZE_PERCENT = 0.05;
  var FONT_STYLE = "sans-serif";
  var CUE_BACKGROUND_PADDING = "1.5%";
  WebVTT$1.processCues = function(window2, cues, overlay) {
    if (!window2 || !cues || !overlay) {
      return null;
    }
    while (overlay.firstChild) {
      overlay.removeChild(overlay.firstChild);
    }
    var paddedOverlay = window2.document.createElement("div");
    paddedOverlay.style.position = "absolute";
    paddedOverlay.style.left = "0";
    paddedOverlay.style.right = "0";
    paddedOverlay.style.top = "0";
    paddedOverlay.style.bottom = "0";
    paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
    overlay.appendChild(paddedOverlay);
    function shouldCompute(cues2) {
      for (var i2 = 0; i2 < cues2.length; i2++) {
        if (cues2[i2].hasBeenReset || !cues2[i2].displayState) {
          return true;
        }
      }
      return false;
    }
    if (!shouldCompute(cues)) {
      for (var i = 0; i < cues.length; i++) {
        paddedOverlay.appendChild(cues[i].displayState);
      }
      return;
    }
    var boxPositions = [], containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay), fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
    var styleOptions = {
      font: fontSize + "px " + FONT_STYLE
    };
    (function() {
      var styleBox, cue;
      for (var i2 = 0; i2 < cues.length; i2++) {
        cue = cues[i2];
        styleBox = new CueStyleBox(window2, cue, styleOptions);
        paddedOverlay.appendChild(styleBox.div);
        moveBoxToLinePosition(window2, styleBox, containerBox, boxPositions);
        cue.displayState = styleBox.div;
        boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
      }
    })();
  };
  WebVTT$1.Parser = function(window2, vttjs, decoder) {
    if (!decoder) {
      decoder = vttjs;
      vttjs = {};
    }
    if (!vttjs) {
      vttjs = {};
    }
    this.window = window2;
    this.vttjs = vttjs;
    this.state = "INITIAL";
    this.buffer = "";
    this.decoder = decoder || new TextDecoder("utf8");
    this.regionList = [];
  };
  WebVTT$1.Parser.prototype = {
    // If the error is a ParsingError then report it to the consumer if
    // possible. If it's not a ParsingError then throw it like normal.
    reportOrThrowError: function(e) {
      if (e instanceof ParsingError) {
        this.onparsingerror && this.onparsingerror(e);
      } else {
        throw e;
      }
    },
    parse: function(data) {
      var self2 = this;
      if (data) {
        self2.buffer += self2.decoder.decode(data, {
          stream: true
        });
      }
      function collectNextLine() {
        var buffer = self2.buffer;
        var pos = 0;
        while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") {
          ++pos;
        }
        var line2 = buffer.substr(0, pos);
        if (buffer[pos] === "\r") {
          ++pos;
        }
        if (buffer[pos] === "\n") {
          ++pos;
        }
        self2.buffer = buffer.substr(pos);
        return line2;
      }
      function parseRegion(input) {
        var settings = new Settings();
        parseOptions(input, function(k, v) {
          switch (k) {
            case "id":
              settings.set(k, v);
              break;
            case "width":
              settings.percent(k, v);
              break;
            case "lines":
              settings.integer(k, v);
              break;
            case "regionanchor":
            case "viewportanchor":
              var xy = v.split(",");
              if (xy.length !== 2) {
                break;
              }
              var anchor = new Settings();
              anchor.percent("x", xy[0]);
              anchor.percent("y", xy[1]);
              if (!anchor.has("x") || !anchor.has("y")) {
                break;
              }
              settings.set(k + "X", anchor.get("x"));
              settings.set(k + "Y", anchor.get("y"));
              break;
            case "scroll":
              settings.alt(k, v, ["up"]);
              break;
          }
        }, /=/, /\s/);
        if (settings.has("id")) {
          var region = new (self2.vttjs.VTTRegion || self2.window.VTTRegion)();
          region.width = settings.get("width", 100);
          region.lines = settings.get("lines", 3);
          region.regionAnchorX = settings.get("regionanchorX", 0);
          region.regionAnchorY = settings.get("regionanchorY", 100);
          region.viewportAnchorX = settings.get("viewportanchorX", 0);
          region.viewportAnchorY = settings.get("viewportanchorY", 100);
          region.scroll = settings.get("scroll", "");
          self2.onregion && self2.onregion(region);
          self2.regionList.push({
            id: settings.get("id"),
            region
          });
        }
      }
      function parseTimestampMap(input) {
        var settings = new Settings();
        parseOptions(input, function(k, v) {
          switch (k) {
            case "MPEGT":
              settings.integer(k + "S", v);
              break;
            case "LOCA":
              settings.set(k + "L", parseTimeStamp(v));
              break;
          }
        }, /[^\d]:/, /,/);
        self2.ontimestampmap && self2.ontimestampmap({
          "MPEGTS": settings.get("MPEGTS"),
          "LOCAL": settings.get("LOCAL")
        });
      }
      function parseHeader(input) {
        if (input.match(/X-TIMESTAMP-MAP/)) {
          parseOptions(input, function(k, v) {
            switch (k) {
              case "X-TIMESTAMP-MAP":
                parseTimestampMap(v);
                break;
            }
          }, /=/);
        } else {
          parseOptions(input, function(k, v) {
            switch (k) {
              case "Region":
                parseRegion(v);
                break;
            }
          }, /:/);
        }
      }
      try {
        var line;
        if (self2.state === "INITIAL") {
          if (!/\r\n|\n/.test(self2.buffer)) {
            return this;
          }
          line = collectNextLine();
          var m = line.match(/^WEBVTT([ \t].*)?$/);
          if (!m || !m[0]) {
            throw new ParsingError(ParsingError.Errors.BadSignature);
          }
          self2.state = "HEADER";
        }
        var alreadyCollectedLine = false;
        while (self2.buffer) {
          if (!/\r\n|\n/.test(self2.buffer)) {
            return this;
          }
          if (!alreadyCollectedLine) {
            line = collectNextLine();
          } else {
            alreadyCollectedLine = false;
          }
          switch (self2.state) {
            case "HEADER":
              if (/:/.test(line)) {
                parseHeader(line);
              } else if (!line) {
                self2.state = "ID";
              }
              continue;
            case "NOTE":
              if (!line) {
                self2.state = "ID";
              }
              continue;
            case "ID":
              if (/^NOTE($|[ \t])/.test(line)) {
                self2.state = "NOTE";
                break;
              }
              if (!line) {
                continue;
              }
              self2.cue = new (self2.vttjs.VTTCue || self2.window.VTTCue)(0, 0, "");
              try {
                self2.cue.align = "center";
              } catch (e) {
                self2.cue.align = "middle";
              }
              self2.state = "CUE";
              if (line.indexOf("-->") === -1) {
                self2.cue.id = line;
                continue;
              }
            case "CUE":
              try {
                parseCue(line, self2.cue, self2.regionList);
              } catch (e) {
                self2.reportOrThrowError(e);
                self2.cue = null;
                self2.state = "BADCUE";
                continue;
              }
              self2.state = "CUETEXT";
              continue;
            case "CUETEXT":
              var hasSubstring = line.indexOf("-->") !== -1;
              if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                self2.oncue && self2.oncue(self2.cue);
                self2.cue = null;
                self2.state = "ID";
                continue;
              }
              if (self2.cue.text) {
                self2.cue.text += "\n";
              }
              self2.cue.text += line.replace(/\u2028/g, "\n").replace(/u2029/g, "\n");
              continue;
            case "BADCUE":
              if (!line) {
                self2.state = "ID";
              }
              continue;
          }
        }
      } catch (e) {
        self2.reportOrThrowError(e);
        if (self2.state === "CUETEXT" && self2.cue && self2.oncue) {
          self2.oncue(self2.cue);
        }
        self2.cue = null;
        self2.state = self2.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
      }
      return this;
    },
    flush: function() {
      var self2 = this;
      try {
        self2.buffer += self2.decoder.decode();
        if (self2.cue || self2.state === "HEADER") {
          self2.buffer += "\n\n";
          self2.parse();
        }
        if (self2.state === "INITIAL") {
          throw new ParsingError(ParsingError.Errors.BadSignature);
        }
      } catch (e) {
        self2.reportOrThrowError(e);
      }
      self2.onflush && self2.onflush();
      return this;
    }
  };
  var vtt = WebVTT$1;
  var autoKeyword = "auto";
  var directionSetting = {
    "": 1,
    "lr": 1,
    "rl": 1
  };
  var alignSetting = {
    "start": 1,
    "center": 1,
    "end": 1,
    "left": 1,
    "right": 1,
    "auto": 1,
    "line-left": 1,
    "line-right": 1
  };
  function findDirectionSetting(value) {
    if (typeof value !== "string") {
      return false;
    }
    var dir = directionSetting[value.toLowerCase()];
    return dir ? value.toLowerCase() : false;
  }
  function findAlignSetting(value) {
    if (typeof value !== "string") {
      return false;
    }
    var align = alignSetting[value.toLowerCase()];
    return align ? value.toLowerCase() : false;
  }
  function VTTCue(startTime, endTime, text) {
    this.hasBeenReset = false;
    var _id = "";
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = "";
    var _snapToLines = true;
    var _line = "auto";
    var _lineAlign = "start";
    var _position = "auto";
    var _positionAlign = "auto";
    var _size = 100;
    var _align = "center";
    Object.defineProperties(this, {
      "id": {
        enumerable: true,
        get: function() {
          return _id;
        },
        set: function(value) {
          _id = "" + value;
        }
      },
      "pauseOnExit": {
        enumerable: true,
        get: function() {
          return _pauseOnExit;
        },
        set: function(value) {
          _pauseOnExit = !!value;
        }
      },
      "startTime": {
        enumerable: true,
        get: function() {
          return _startTime;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("Start time must be set to a number.");
          }
          _startTime = value;
          this.hasBeenReset = true;
        }
      },
      "endTime": {
        enumerable: true,
        get: function() {
          return _endTime;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("End time must be set to a number.");
          }
          _endTime = value;
          this.hasBeenReset = true;
        }
      },
      "text": {
        enumerable: true,
        get: function() {
          return _text;
        },
        set: function(value) {
          _text = "" + value;
          this.hasBeenReset = true;
        }
      },
      "region": {
        enumerable: true,
        get: function() {
          return _region;
        },
        set: function(value) {
          _region = value;
          this.hasBeenReset = true;
        }
      },
      "vertical": {
        enumerable: true,
        get: function() {
          return _vertical;
        },
        set: function(value) {
          var setting = findDirectionSetting(value);
          if (setting === false) {
            throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
          }
          _vertical = setting;
          this.hasBeenReset = true;
        }
      },
      "snapToLines": {
        enumerable: true,
        get: function() {
          return _snapToLines;
        },
        set: function(value) {
          _snapToLines = !!value;
          this.hasBeenReset = true;
        }
      },
      "line": {
        enumerable: true,
        get: function() {
          return _line;
        },
        set: function(value) {
          if (typeof value !== "number" && value !== autoKeyword) {
            throw new SyntaxError("Line: an invalid number or illegal string was specified.");
          }
          _line = value;
          this.hasBeenReset = true;
        }
      },
      "lineAlign": {
        enumerable: true,
        get: function() {
          return _lineAlign;
        },
        set: function(value) {
          var setting = findAlignSetting(value);
          if (!setting) {
            console.warn("lineAlign: an invalid or illegal string was specified.");
          } else {
            _lineAlign = setting;
            this.hasBeenReset = true;
          }
        }
      },
      "position": {
        enumerable: true,
        get: function() {
          return _position;
        },
        set: function(value) {
          if (value < 0 || value > 100) {
            throw new Error("Position must be between 0 and 100.");
          }
          _position = value;
          this.hasBeenReset = true;
        }
      },
      "positionAlign": {
        enumerable: true,
        get: function() {
          return _positionAlign;
        },
        set: function(value) {
          var setting = findAlignSetting(value);
          if (!setting) {
            console.warn("positionAlign: an invalid or illegal string was specified.");
          } else {
            _positionAlign = setting;
            this.hasBeenReset = true;
          }
        }
      },
      "size": {
        enumerable: true,
        get: function() {
          return _size;
        },
        set: function(value) {
          if (value < 0 || value > 100) {
            throw new Error("Size must be between 0 and 100.");
          }
          _size = value;
          this.hasBeenReset = true;
        }
      },
      "align": {
        enumerable: true,
        get: function() {
          return _align;
        },
        set: function(value) {
          var setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
          }
          _align = setting;
          this.hasBeenReset = true;
        }
      }
    });
    this.displayState = void 0;
  }
  VTTCue.prototype.getCueAsHTML = function() {
    return WebVTT.convertCueToDOMTree(window, this.text);
  };
  var vttcue = VTTCue;
  var scrollSetting = {
    "": true,
    "up": true
  };
  function findScrollSetting(value) {
    if (typeof value !== "string") {
      return false;
    }
    var scroll = scrollSetting[value.toLowerCase()];
    return scroll ? value.toLowerCase() : false;
  }
  function isValidPercentValue(value) {
    return typeof value === "number" && value >= 0 && value <= 100;
  }
  function VTTRegion() {
    var _width = 100;
    var _lines = 3;
    var _regionAnchorX = 0;
    var _regionAnchorY = 100;
    var _viewportAnchorX = 0;
    var _viewportAnchorY = 100;
    var _scroll = "";
    Object.defineProperties(this, {
      "width": {
        enumerable: true,
        get: function() {
          return _width;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("Width must be between 0 and 100.");
          }
          _width = value;
        }
      },
      "lines": {
        enumerable: true,
        get: function() {
          return _lines;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("Lines must be set to a number.");
          }
          _lines = value;
        }
      },
      "regionAnchorY": {
        enumerable: true,
        get: function() {
          return _regionAnchorY;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("RegionAnchorX must be between 0 and 100.");
          }
          _regionAnchorY = value;
        }
      },
      "regionAnchorX": {
        enumerable: true,
        get: function() {
          return _regionAnchorX;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("RegionAnchorY must be between 0 and 100.");
          }
          _regionAnchorX = value;
        }
      },
      "viewportAnchorY": {
        enumerable: true,
        get: function() {
          return _viewportAnchorY;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("ViewportAnchorY must be between 0 and 100.");
          }
          _viewportAnchorY = value;
        }
      },
      "viewportAnchorX": {
        enumerable: true,
        get: function() {
          return _viewportAnchorX;
        },
        set: function(value) {
          if (!isValidPercentValue(value)) {
            throw new Error("ViewportAnchorX must be between 0 and 100.");
          }
          _viewportAnchorX = value;
        }
      },
      "scroll": {
        enumerable: true,
        get: function() {
          return _scroll;
        },
        set: function(value) {
          var setting = findScrollSetting(value);
          if (setting === false) {
            console.warn("Scroll: an invalid or illegal string was specified.");
          } else {
            _scroll = setting;
          }
        }
      }
    });
  }
  var vttregion = VTTRegion;
  var browserIndex = createCommonjsModule(function(module2) {
    var vttjs = module2.exports = {
      WebVTT: vtt,
      VTTCue: vttcue,
      VTTRegion: vttregion
    };
    window_1.vttjs = vttjs;
    window_1.WebVTT = vttjs.WebVTT;
    var cueShim = vttjs.VTTCue;
    var regionShim = vttjs.VTTRegion;
    var nativeVTTCue = window_1.VTTCue;
    var nativeVTTRegion = window_1.VTTRegion;
    vttjs.shim = function() {
      window_1.VTTCue = cueShim;
      window_1.VTTRegion = regionShim;
    };
    vttjs.restore = function() {
      window_1.VTTCue = nativeVTTCue;
      window_1.VTTRegion = nativeVTTRegion;
    };
    if (!window_1.VTTCue) {
      vttjs.shim();
    }
  });
  browserIndex.WebVTT;
  browserIndex.VTTCue;
  browserIndex.VTTRegion;
  function createTrackHelper(self2, kind, label, language, options = {}) {
    const tracks = self2.textTracks();
    options.kind = kind;
    if (label) {
      options.label = label;
    }
    if (language) {
      options.language = language;
    }
    options.tech = self2;
    const track = new ALL.text.TrackClass(options);
    tracks.addTrack(track);
    return track;
  }
  class Tech extends Component$1 {
    /**
    * Create an instance of this Tech.
    *
    * @param {Object} [options]
    *        The key/value store of player options.
    *
    * @param {Function} [ready]
    *        Callback function to call when the `HTML5` Tech is ready.
    */
    constructor(options = {}, ready = function() {
    }) {
      options.reportTouchActivity = false;
      super(null, options, ready);
      this.onDurationChange_ = (e) => this.onDurationChange(e);
      this.trackProgress_ = (e) => this.trackProgress(e);
      this.trackCurrentTime_ = (e) => this.trackCurrentTime(e);
      this.stopTrackingCurrentTime_ = (e) => this.stopTrackingCurrentTime(e);
      this.disposeSourceHandler_ = (e) => this.disposeSourceHandler(e);
      this.queuedHanders_ = /* @__PURE__ */ new Set();
      this.hasStarted_ = false;
      this.on("playing", function() {
        this.hasStarted_ = true;
      });
      this.on("loadstart", function() {
        this.hasStarted_ = false;
      });
      ALL.names.forEach((name) => {
        const props = ALL[name];
        if (options && options[props.getterName]) {
          this[props.privateName] = options[props.getterName];
        }
      });
      if (!this.featuresProgressEvents) {
        this.manualProgressOn();
      }
      if (!this.featuresTimeupdateEvents) {
        this.manualTimeUpdatesOn();
      }
      ["Text", "Audio", "Video"].forEach((track) => {
        if (options[`native${track}Tracks`] === false) {
          this[`featuresNative${track}Tracks`] = false;
        }
      });
      if (options.nativeCaptions === false || options.nativeTextTracks === false) {
        this.featuresNativeTextTracks = false;
      } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {
        this.featuresNativeTextTracks = true;
      }
      if (!this.featuresNativeTextTracks) {
        this.emulateTextTracks();
      }
      this.preloadTextTracks = options.preloadTextTracks !== false;
      this.autoRemoteTextTracks_ = new ALL.text.ListClass();
      this.initTrackListeners();
      if (!options.nativeControlsForTouch) {
        this.emitTapEvents();
      }
      if (this.constructor) {
        this.name_ = this.constructor.name || "Unknown Tech";
      }
    }
    /**
     * A special function to trigger source set in a way that will allow player
     * to re-trigger if the player or tech are not ready yet.
     *
     * @fires Tech#sourceset
     * @param {string} src The source string at the time of the source changing.
     */
    triggerSourceset(src) {
      if (!this.isReady_) {
        this.one("ready", () => this.setTimeout(() => this.triggerSourceset(src), 1));
      }
      this.trigger({
        src,
        type: "sourceset"
      });
    }
    /* Fallbacks for unsupported event types
    ================================================================================ */
    /**
     * Polyfill the `progress` event for browsers that don't support it natively.
     *
     * @see {@link Tech#trackProgress}
     */
    manualProgressOn() {
      this.on("durationchange", this.onDurationChange_);
      this.manualProgress = true;
      this.one("ready", this.trackProgress_);
    }
    /**
     * Turn off the polyfill for `progress` events that was created in
     * {@link Tech#manualProgressOn}
     */
    manualProgressOff() {
      this.manualProgress = false;
      this.stopTrackingProgress();
      this.off("durationchange", this.onDurationChange_);
    }
    /**
     * This is used to trigger a `progress` event when the buffered percent changes. It
     * sets an interval function that will be called every 500 milliseconds to check if the
     * buffer end percent has changed.
     *
     * > This function is called by {@link Tech#manualProgressOn}
     *
     * @param {Event} event
     *        The `ready` event that caused this to run.
     *
     * @listens Tech#ready
     * @fires Tech#progress
     */
    trackProgress(event) {
      this.stopTrackingProgress();
      this.progressInterval = this.setInterval(bind_(this, function() {
        const numBufferedPercent = this.bufferedPercent();
        if (this.bufferedPercent_ !== numBufferedPercent) {
          this.trigger("progress");
        }
        this.bufferedPercent_ = numBufferedPercent;
        if (numBufferedPercent === 1) {
          this.stopTrackingProgress();
        }
      }), 500);
    }
    /**
     * Update our internal duration on a `durationchange` event by calling
     * {@link Tech#duration}.
     *
     * @param {Event} event
     *        The `durationchange` event that caused this to run.
     *
     * @listens Tech#durationchange
     */
    onDurationChange(event) {
      this.duration_ = this.duration();
    }
    /**
     * Get and create a `TimeRange` object for buffering.
     *
     * @return { import('../utils/time').TimeRange }
     *         The time range object that was created.
     */
    buffered() {
      return createTimeRanges$1(0, 0);
    }
    /**
     * Get the percentage of the current video that is currently buffered.
     *
     * @return {number}
     *         A number from 0 to 1 that represents the decimal percentage of the
     *         video that is buffered.
     *
     */
    bufferedPercent() {
      return bufferedPercent(this.buffered(), this.duration_);
    }
    /**
     * Turn off the polyfill for `progress` events that was created in
     * {@link Tech#manualProgressOn}
     * Stop manually tracking progress events by clearing the interval that was set in
     * {@link Tech#trackProgress}.
     */
    stopTrackingProgress() {
      this.clearInterval(this.progressInterval);
    }
    /**
     * Polyfill the `timeupdate` event for browsers that don't support it.
     *
     * @see {@link Tech#trackCurrentTime}
     */
    manualTimeUpdatesOn() {
      this.manualTimeUpdates = true;
      this.on("play", this.trackCurrentTime_);
      this.on("pause", this.stopTrackingCurrentTime_);
    }
    /**
     * Turn off the polyfill for `timeupdate` events that was created in
     * {@link Tech#manualTimeUpdatesOn}
     */
    manualTimeUpdatesOff() {
      this.manualTimeUpdates = false;
      this.stopTrackingCurrentTime();
      this.off("play", this.trackCurrentTime_);
      this.off("pause", this.stopTrackingCurrentTime_);
    }
    /**
     * Sets up an interval function to track current time and trigger `timeupdate` every
     * 250 milliseconds.
     *
     * @listens Tech#play
     * @triggers Tech#timeupdate
     */
    trackCurrentTime() {
      if (this.currentTimeInterval) {
        this.stopTrackingCurrentTime();
      }
      this.currentTimeInterval = this.setInterval(function() {
        this.trigger({
          type: "timeupdate",
          target: this,
          manuallyTriggered: true
        });
      }, 250);
    }
    /**
     * Stop the interval function created in {@link Tech#trackCurrentTime} so that the
     * `timeupdate` event is no longer triggered.
     *
     * @listens {Tech#pause}
     */
    stopTrackingCurrentTime() {
      this.clearInterval(this.currentTimeInterval);
      this.trigger({
        type: "timeupdate",
        target: this,
        manuallyTriggered: true
      });
    }
    /**
     * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},
     * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.
     *
     * @fires Component#dispose
     */
    dispose() {
      this.clearTracks(NORMAL.names);
      if (this.manualProgress) {
        this.manualProgressOff();
      }
      if (this.manualTimeUpdates) {
        this.manualTimeUpdatesOff();
      }
      super.dispose();
    }
    /**
     * Clear out a single `TrackList` or an array of `TrackLists` given their names.
     *
     * > Note: Techs without source handlers should call this between sources for `video`
     *         & `audio` tracks. You don't want to use them between tracks!
     *
     * @param {string[]|string} types
     *        TrackList names to clear, valid names are `video`, `audio`, and
     *        `text`.
     */
    clearTracks(types) {
      types = [].concat(types);
      types.forEach((type) => {
        const list = this[`${type}Tracks`]() || [];
        let i = list.length;
        while (i--) {
          const track = list[i];
          if (type === "text") {
            this.removeRemoteTextTrack(track);
          }
          list.removeTrack(track);
        }
      });
    }
    /**
     * Remove any TextTracks added via addRemoteTextTrack that are
     * flagged for automatic garbage collection
     */
    cleanupAutoTextTracks() {
      const list = this.autoRemoteTextTracks_ || [];
      let i = list.length;
      while (i--) {
        const track = list[i];
        this.removeRemoteTextTrack(track);
      }
    }
    /**
     * Reset the tech, which will removes all sources and reset the internal readyState.
     *
     * @abstract
     */
    reset() {
    }
    /**
     * Get the value of `crossOrigin` from the tech.
     *
     * @abstract
     *
     * @see {Html5#crossOrigin}
     */
    crossOrigin() {
    }
    /**
     * Set the value of `crossOrigin` on the tech.
     *
     * @abstract
     *
     * @param {string} crossOrigin the crossOrigin value
     * @see {Html5#setCrossOrigin}
     */
    setCrossOrigin() {
    }
    /**
     * Get or set an error on the Tech.
     *
     * @param {MediaError} [err]
     *        Error to set on the Tech
     *
     * @return {MediaError|null}
     *         The current error object on the tech, or null if there isn't one.
     */
    error(err) {
      if (err !== void 0) {
        this.error_ = new MediaError(err);
        this.trigger("error");
      }
      return this.error_;
    }
    /**
     * Returns the `TimeRange`s that have been played through for the current source.
     *
     * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.
     *         It only checks whether the source has played at all or not.
     *
     * @return { import('../utils/time').TimeRange }
     *         - A single time range if this video has played
     *         - An empty set of ranges if not.
     */
    played() {
      if (this.hasStarted_) {
        return createTimeRanges$1(0, 0);
      }
      return createTimeRanges$1();
    }
    /**
     * Start playback
     *
     * @abstract
     *
     * @see {Html5#play}
     */
    play() {
    }
    /**
     * Set whether we are scrubbing or not
     *
     * @abstract
     * @param {boolean} _isScrubbing
     *                  - true for we are currently scrubbing
     *                  - false for we are no longer scrubbing
     *
     * @see {Html5#setScrubbing}
     */
    setScrubbing(_isScrubbing) {
    }
    /**
     * Get whether we are scrubbing or not
     *
     * @abstract
     *
     * @see {Html5#scrubbing}
     */
    scrubbing() {
    }
    /**
     * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was
     * previously called.
     *
     * @param {number} _seconds
     *        Set the current time of the media to this.
     * @fires Tech#timeupdate
     */
    setCurrentTime(_seconds) {
      if (this.manualTimeUpdates) {
        this.trigger({
          type: "timeupdate",
          target: this,
          manuallyTriggered: true
        });
      }
    }
    /**
     * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and
     * {@link TextTrackList} events.
     *
     * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.
     *
     * @fires Tech#audiotrackchange
     * @fires Tech#videotrackchange
     * @fires Tech#texttrackchange
     */
    initTrackListeners() {
      NORMAL.names.forEach((name) => {
        const props = NORMAL[name];
        const trackListChanges = () => {
          this.trigger(`${name}trackchange`);
        };
        const tracks = this[props.getterName]();
        tracks.addEventListener("removetrack", trackListChanges);
        tracks.addEventListener("addtrack", trackListChanges);
        this.on("dispose", () => {
          tracks.removeEventListener("removetrack", trackListChanges);
          tracks.removeEventListener("addtrack", trackListChanges);
        });
      });
    }
    /**
     * Emulate TextTracks using vtt.js if necessary
     *
     * @fires Tech#vttjsloaded
     * @fires Tech#vttjserror
     */
    addWebVttScript_() {
      if (window.WebVTT) {
        return;
      }
      if (document.body.contains(this.el())) {
        if (!this.options_["vtt.js"] && isPlain(browserIndex) && Object.keys(browserIndex).length > 0) {
          this.trigger("vttjsloaded");
          return;
        }
        const script = document.createElement("script");
        script.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js";
        script.onload = () => {
          this.trigger("vttjsloaded");
        };
        script.onerror = () => {
          this.trigger("vttjserror");
        };
        this.on("dispose", () => {
          script.onload = null;
          script.onerror = null;
        });
        window.WebVTT = true;
        this.el().parentNode.appendChild(script);
      } else {
        this.ready(this.addWebVttScript_);
      }
    }
    /**
     * Emulate texttracks
     *
     */
    emulateTextTracks() {
      const tracks = this.textTracks();
      const remoteTracks = this.remoteTextTracks();
      const handleAddTrack = (e) => tracks.addTrack(e.track);
      const handleRemoveTrack = (e) => tracks.removeTrack(e.track);
      remoteTracks.on("addtrack", handleAddTrack);
      remoteTracks.on("removetrack", handleRemoveTrack);
      this.addWebVttScript_();
      const updateDisplay = () => this.trigger("texttrackchange");
      const textTracksChanges = () => {
        updateDisplay();
        for (let i = 0; i < tracks.length; i++) {
          const track = tracks[i];
          track.removeEventListener("cuechange", updateDisplay);
          if (track.mode === "showing") {
            track.addEventListener("cuechange", updateDisplay);
          }
        }
      };
      textTracksChanges();
      tracks.addEventListener("change", textTracksChanges);
      tracks.addEventListener("addtrack", textTracksChanges);
      tracks.addEventListener("removetrack", textTracksChanges);
      this.on("dispose", function() {
        remoteTracks.off("addtrack", handleAddTrack);
        remoteTracks.off("removetrack", handleRemoveTrack);
        tracks.removeEventListener("change", textTracksChanges);
        tracks.removeEventListener("addtrack", textTracksChanges);
        tracks.removeEventListener("removetrack", textTracksChanges);
        for (let i = 0; i < tracks.length; i++) {
          const track = tracks[i];
          track.removeEventListener("cuechange", updateDisplay);
        }
      });
    }
    /**
     * Create and returns a remote {@link TextTrack} object.
     *
     * @param {string} kind
     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
     *
     * @param {string} [label]
     *        Label to identify the text track
     *
     * @param {string} [language]
     *        Two letter language abbreviation
     *
     * @return {TextTrack}
     *         The TextTrack that gets created.
     */
    addTextTrack(kind, label, language) {
      if (!kind) {
        throw new Error("TextTrack kind is required but was not provided");
      }
      return createTrackHelper(this, kind, label, language);
    }
    /**
     * Create an emulated TextTrack for use by addRemoteTextTrack
     *
     * This is intended to be overridden by classes that inherit from
     * Tech in order to create native or custom TextTracks.
     *
     * @param {Object} options
     *        The object should contain the options to initialize the TextTrack with.
     *
     * @param {string} [options.kind]
     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
     *
     * @param {string} [options.label].
     *        Label to identify the text track
     *
     * @param {string} [options.language]
     *        Two letter language abbreviation.
     *
     * @return {HTMLTrackElement}
     *         The track element that gets created.
     */
    createRemoteTextTrack(options) {
      const track = merge$2(options, {
        tech: this
      });
      return new REMOTE.remoteTextEl.TrackClass(track);
    }
    /**
     * Creates a remote text track object and returns an html track element.
     *
     * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.
     *
     * @param {Object} options
     *        See {@link Tech#createRemoteTextTrack} for more detailed properties.
     *
     * @param {boolean} [manualCleanup=false]
     *        - When false: the TextTrack will be automatically removed from the video
     *          element whenever the source changes
     *        - When True: The TextTrack will have to be cleaned up manually
     *
     * @return {HTMLTrackElement}
     *         An Html Track Element.
     *
     */
    addRemoteTextTrack(options = {}, manualCleanup) {
      const htmlTrackElement = this.createRemoteTextTrack(options);
      if (typeof manualCleanup !== "boolean") {
        manualCleanup = false;
      }
      this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
      this.remoteTextTracks().addTrack(htmlTrackElement.track);
      if (manualCleanup === false) {
        this.ready(() => this.autoRemoteTextTracks_.addTrack(htmlTrackElement.track));
      }
      return htmlTrackElement;
    }
    /**
     * Remove a remote text track from the remote `TextTrackList`.
     *
     * @param {TextTrack} track
     *        `TextTrack` to remove from the `TextTrackList`
     */
    removeRemoteTextTrack(track) {
      const trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);
      this.remoteTextTrackEls().removeTrackElement_(trackElement);
      this.remoteTextTracks().removeTrack(track);
      this.autoRemoteTextTracks_.removeTrack(track);
    }
    /**
     * Gets available media playback quality metrics as specified by the W3C's Media
     * Playback Quality API.
     *
     * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
     *
     * @return {Object}
     *         An object with supported media playback quality metrics
     *
     * @abstract
     */
    getVideoPlaybackQuality() {
      return {};
    }
    /**
     * Attempt to create a floating video window always on top of other windows
     * so that users may continue consuming media while they interact with other
     * content sites, or applications on their device.
     *
     * @see [Spec]{@link https://wicg.github.io/picture-in-picture}
     *
     * @return {Promise|undefined}
     *         A promise with a Picture-in-Picture window if the browser supports
     *         Promises (or one was passed in as an option). It returns undefined
     *         otherwise.
     *
     * @abstract
     */
    requestPictureInPicture() {
      return Promise.reject();
    }
    /**
     * A method to check for the value of the 'disablePictureInPicture' <video> property.
     * Defaults to true, as it should be considered disabled if the tech does not support pip
     *
     * @abstract
     */
    disablePictureInPicture() {
      return true;
    }
    /**
     * A method to set or unset the 'disablePictureInPicture' <video> property.
     *
     * @abstract
     */
    setDisablePictureInPicture() {
    }
    /**
     * A fallback implementation of requestVideoFrameCallback using requestAnimationFrame
     *
     * @param {function} cb
     * @return {number} request id
     */
    requestVideoFrameCallback(cb) {
      const id = newGUID();
      if (!this.isReady_ || this.paused()) {
        this.queuedHanders_.add(id);
        this.one("playing", () => {
          if (this.queuedHanders_.has(id)) {
            this.queuedHanders_.delete(id);
            cb();
          }
        });
      } else {
        this.requestNamedAnimationFrame(id, cb);
      }
      return id;
    }
    /**
     * A fallback implementation of cancelVideoFrameCallback
     *
     * @param {number} id id of callback to be cancelled
     */
    cancelVideoFrameCallback(id) {
      if (this.queuedHanders_.has(id)) {
        this.queuedHanders_.delete(id);
      } else {
        this.cancelNamedAnimationFrame(id);
      }
    }
    /**
     * A method to set a poster from a `Tech`.
     *
     * @abstract
     */
    setPoster() {
    }
    /**
     * A method to check for the presence of the 'playsinline' <video> attribute.
     *
     * @abstract
     */
    playsinline() {
    }
    /**
     * A method to set or unset the 'playsinline' <video> attribute.
     *
     * @abstract
     */
    setPlaysinline() {
    }
    /**
     * Attempt to force override of native audio tracks.
     *
     * @param {boolean} override - If set to true native audio will be overridden,
     * otherwise native audio will potentially be used.
     *
     * @abstract
     */
    overrideNativeAudioTracks(override) {
    }
    /**
     * Attempt to force override of native video tracks.
     *
     * @param {boolean} override - If set to true native video will be overridden,
     * otherwise native video will potentially be used.
     *
     * @abstract
     */
    overrideNativeVideoTracks(override) {
    }
    /**
     * Check if the tech can support the given mime-type.
     *
     * The base tech does not support any type, but source handlers might
     * overwrite this.
     *
     * @param  {string} _type
     *         The mimetype to check for support
     *
     * @return {string}
     *         'probably', 'maybe', or empty string
     *
     * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}
     *
     * @abstract
     */
    canPlayType(_type) {
      return "";
    }
    /**
     * Check if the type is supported by this tech.
     *
     * The base tech does not support any type, but source handlers might
     * overwrite this.
     *
     * @param {string} _type
     *        The media type to check
     * @return {string} Returns the native video element's response
     */
    static canPlayType(_type) {
      return "";
    }
    /**
     * Check if the tech can support the given source
     *
     * @param {Object} srcObj
     *        The source object
     * @param {Object} options
     *        The options passed to the tech
     * @return {string} 'probably', 'maybe', or '' (empty string)
     */
    static canPlaySource(srcObj, options) {
      return Tech.canPlayType(srcObj.type);
    }
    /*
     * Return whether the argument is a Tech or not.
     * Can be passed either a Class like `Html5` or a instance like `player.tech_`
     *
     * @param {Object} component
     *        The item to check
     *
     * @return {boolean}
     *         Whether it is a tech or not
     *         - True if it is a tech
     *         - False if it is not
     */
    static isTech(component) {
      return component.prototype instanceof Tech || component instanceof Tech || component === Tech;
    }
    /**
     * Registers a `Tech` into a shared list for videojs.
     *
     * @param {string} name
     *        Name of the `Tech` to register.
     *
     * @param {Object} tech
     *        The `Tech` class to register.
     */
    static registerTech(name, tech) {
      if (!Tech.techs_) {
        Tech.techs_ = {};
      }
      if (!Tech.isTech(tech)) {
        throw new Error(`Tech ${name} must be a Tech`);
      }
      if (!Tech.canPlayType) {
        throw new Error("Techs must have a static canPlayType method on them");
      }
      if (!Tech.canPlaySource) {
        throw new Error("Techs must have a static canPlaySource method on them");
      }
      name = toTitleCase$1(name);
      Tech.techs_[name] = tech;
      Tech.techs_[toLowerCase(name)] = tech;
      if (name !== "Tech") {
        Tech.defaultTechOrder_.push(name);
      }
      return tech;
    }
    /**
     * Get a `Tech` from the shared list by name.
     *
     * @param {string} name
     *        `camelCase` or `TitleCase` name of the Tech to get
     *
     * @return {Tech|undefined}
     *         The `Tech` or undefined if there was no tech with the name requested.
     */
    static getTech(name) {
      if (!name) {
        return;
      }
      if (Tech.techs_ && Tech.techs_[name]) {
        return Tech.techs_[name];
      }
      name = toTitleCase$1(name);
      if (window && window.videojs && window.videojs[name]) {
        log$1.warn(`The ${name} tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)`);
        return window.videojs[name];
      }
    }
  }
  ALL.names.forEach(function(name) {
    const props = ALL[name];
    Tech.prototype[props.getterName] = function() {
      this[props.privateName] = this[props.privateName] || new props.ListClass();
      return this[props.privateName];
    };
  });
  Tech.prototype.featuresVolumeControl = true;
  Tech.prototype.featuresMuteControl = true;
  Tech.prototype.featuresFullscreenResize = false;
  Tech.prototype.featuresPlaybackRate = false;
  Tech.prototype.featuresProgressEvents = false;
  Tech.prototype.featuresSourceset = false;
  Tech.prototype.featuresTimeupdateEvents = false;
  Tech.prototype.featuresNativeTextTracks = false;
  Tech.prototype.featuresVideoFrameCallback = false;
  Tech.withSourceHandlers = function(_Tech) {
    _Tech.registerSourceHandler = function(handler, index) {
      let handlers = _Tech.sourceHandlers;
      if (!handlers) {
        handlers = _Tech.sourceHandlers = [];
      }
      if (index === void 0) {
        index = handlers.length;
      }
      handlers.splice(index, 0, handler);
    };
    _Tech.canPlayType = function(type) {
      const handlers = _Tech.sourceHandlers || [];
      let can;
      for (let i = 0; i < handlers.length; i++) {
        can = handlers[i].canPlayType(type);
        if (can) {
          return can;
        }
      }
      return "";
    };
    _Tech.selectSourceHandler = function(source, options) {
      const handlers = _Tech.sourceHandlers || [];
      let can;
      for (let i = 0; i < handlers.length; i++) {
        can = handlers[i].canHandleSource(source, options);
        if (can) {
          return handlers[i];
        }
      }
      return null;
    };
    _Tech.canPlaySource = function(srcObj, options) {
      const sh = _Tech.selectSourceHandler(srcObj, options);
      if (sh) {
        return sh.canHandleSource(srcObj, options);
      }
      return "";
    };
    const deferrable = ["seekable", "seeking", "duration"];
    deferrable.forEach(function(fnName) {
      const originalFn = this[fnName];
      if (typeof originalFn !== "function") {
        return;
      }
      this[fnName] = function() {
        if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
          return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
        }
        return originalFn.apply(this, arguments);
      };
    }, _Tech.prototype);
    _Tech.prototype.setSource = function(source) {
      let sh = _Tech.selectSourceHandler(source, this.options_);
      if (!sh) {
        if (_Tech.nativeSourceHandler) {
          sh = _Tech.nativeSourceHandler;
        } else {
          log$1.error("No source handler found for the current source.");
        }
      }
      this.disposeSourceHandler();
      this.off("dispose", this.disposeSourceHandler_);
      if (sh !== _Tech.nativeSourceHandler) {
        this.currentSource_ = source;
      }
      this.sourceHandler_ = sh.handleSource(source, this, this.options_);
      this.one("dispose", this.disposeSourceHandler_);
    };
    _Tech.prototype.disposeSourceHandler = function() {
      if (this.currentSource_) {
        this.clearTracks(["audio", "video"]);
        this.currentSource_ = null;
      }
      this.cleanupAutoTextTracks();
      if (this.sourceHandler_) {
        if (this.sourceHandler_.dispose) {
          this.sourceHandler_.dispose();
        }
        this.sourceHandler_ = null;
      }
    };
  };
  Component$1.registerComponent("Tech", Tech);
  Tech.registerTech("Tech", Tech);
  Tech.defaultTechOrder_ = [];
  const middlewares = {};
  const middlewareInstances = {};
  const TERMINATOR = {};
  function use(type, middleware) {
    middlewares[type] = middlewares[type] || [];
    middlewares[type].push(middleware);
  }
  function setSource(player, src, next) {
    player.setTimeout(() => setSourceHelper(src, middlewares[src.type], next, player), 1);
  }
  function setTech(middleware, tech) {
    middleware.forEach((mw) => mw.setTech && mw.setTech(tech));
  }
  function get(middleware, tech, method) {
    return middleware.reduceRight(middlewareIterator(method), tech[method]());
  }
  function set(middleware, tech, method, arg) {
    return tech[method](middleware.reduce(middlewareIterator(method), arg));
  }
  function mediate(middleware, tech, method, arg = null) {
    const callMethod = "call" + toTitleCase$1(method);
    const middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);
    const terminated = middlewareValue === TERMINATOR;
    const returnValue = terminated ? null : tech[method](middlewareValue);
    executeRight(middleware, method, returnValue, terminated);
    return returnValue;
  }
  const allowedGetters = {
    buffered: 1,
    currentTime: 1,
    duration: 1,
    muted: 1,
    played: 1,
    paused: 1,
    seekable: 1,
    volume: 1,
    ended: 1
  };
  const allowedSetters = {
    setCurrentTime: 1,
    setMuted: 1,
    setVolume: 1
  };
  const allowedMediators = {
    play: 1,
    pause: 1
  };
  function middlewareIterator(method) {
    return (value, mw) => {
      if (value === TERMINATOR) {
        return TERMINATOR;
      }
      if (mw[method]) {
        return mw[method](value);
      }
      return value;
    };
  }
  function executeRight(mws, method, value, terminated) {
    for (let i = mws.length - 1; i >= 0; i--) {
      const mw = mws[i];
      if (mw[method]) {
        mw[method](terminated, value);
      }
    }
  }
  function clearCacheForPlayer(player) {
    middlewareInstances[player.id()] = null;
  }
  function getOrCreateFactory(player, mwFactory) {
    const mws = middlewareInstances[player.id()];
    let mw = null;
    if (mws === void 0 || mws === null) {
      mw = mwFactory(player);
      middlewareInstances[player.id()] = [[mwFactory, mw]];
      return mw;
    }
    for (let i = 0; i < mws.length; i++) {
      const [mwf, mwi] = mws[i];
      if (mwf !== mwFactory) {
        continue;
      }
      mw = mwi;
    }
    if (mw === null) {
      mw = mwFactory(player);
      mws.push([mwFactory, mw]);
    }
    return mw;
  }
  function setSourceHelper(src = {}, middleware = [], next, player, acc = [], lastRun = false) {
    const [mwFactory, ...mwrest] = middleware;
    if (typeof mwFactory === "string") {
      setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);
    } else if (mwFactory) {
      const mw = getOrCreateFactory(player, mwFactory);
      if (!mw.setSource) {
        acc.push(mw);
        return setSourceHelper(src, mwrest, next, player, acc, lastRun);
      }
      mw.setSource(Object.assign({}, src), function(err, _src) {
        if (err) {
          return setSourceHelper(src, mwrest, next, player, acc, lastRun);
        }
        acc.push(mw);
        setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
      });
    } else if (mwrest.length) {
      setSourceHelper(src, mwrest, next, player, acc, lastRun);
    } else if (lastRun) {
      next(src, acc);
    } else {
      setSourceHelper(src, middlewares["*"], next, player, acc, true);
    }
  }
  const MimetypesKind = {
    opus: "video/ogg",
    ogv: "video/ogg",
    mp4: "video/mp4",
    mov: "video/mp4",
    m4v: "video/mp4",
    mkv: "video/x-matroska",
    m4a: "audio/mp4",
    mp3: "audio/mpeg",
    aac: "audio/aac",
    caf: "audio/x-caf",
    flac: "audio/flac",
    oga: "audio/ogg",
    wav: "audio/wav",
    m3u8: "application/x-mpegURL",
    mpd: "application/dash+xml",
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    gif: "image/gif",
    png: "image/png",
    svg: "image/svg+xml",
    webp: "image/webp"
  };
  const getMimetype = function(src = "") {
    const ext = getFileExtension(src);
    const mimetype = MimetypesKind[ext.toLowerCase()];
    return mimetype || "";
  };
  const findMimetype = (player, src) => {
    if (!src) {
      return "";
    }
    if (player.cache_.source.src === src && player.cache_.source.type) {
      return player.cache_.source.type;
    }
    const matchingSources = player.cache_.sources.filter((s) => s.src === src);
    if (matchingSources.length) {
      return matchingSources[0].type;
    }
    const sources = player.$$("source");
    for (let i = 0; i < sources.length; i++) {
      const s = sources[i];
      if (s.type && s.src && s.src === src) {
        return s.type;
      }
    }
    return getMimetype(src);
  };
  const filterSource = function(src) {
    if (Array.isArray(src)) {
      let newsrc = [];
      src.forEach(function(srcobj) {
        srcobj = filterSource(srcobj);
        if (Array.isArray(srcobj)) {
          newsrc = newsrc.concat(srcobj);
        } else if (isObject$1(srcobj)) {
          newsrc.push(srcobj);
        }
      });
      src = newsrc;
    } else if (typeof src === "string" && src.trim()) {
      src = [fixSource({
        src
      })];
    } else if (isObject$1(src) && typeof src.src === "string" && src.src && src.src.trim()) {
      src = [fixSource(src)];
    } else {
      src = [];
    }
    return src;
  };
  function fixSource(src) {
    if (!src.type) {
      const mimetype = getMimetype(src.src);
      if (mimetype) {
        src.type = mimetype;
      }
    }
    return src;
  }
  var icons = '<svg xmlns="http://www.w3.org/2000/svg">\n  <defs>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-play">\n      <path d="M16 10v28l22-14z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-pause">\n      <path d="M12 38h8V10h-8v28zm16-28v28h8V10h-8z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-audio">\n      <path d="M24 2C14.06 2 6 10.06 6 20v14c0 3.31 2.69 6 6 6h6V24h-8v-4c0-7.73 6.27-14 14-14s14 6.27 14 14v4h-8v16h6c3.31 0 6-2.69 6-6V20c0-9.94-8.06-18-18-18z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-captions">\n      <path d="M38 8H10c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h28c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM22 22h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2zm14 0h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-subtitles">\n      <path d="M40 8H8c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h32c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM8 24h8v4H8v-4zm20 12H8v-4h20v4zm12 0h-8v-4h8v4zm0-8H20v-4h20v4z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-fullscreen-enter">\n      <path d="M14 28h-4v10h10v-4h-6v-6zm-4-8h4v-6h6v-4H10v10zm24 14h-6v4h10V28h-4v6zm-6-24v4h6v6h4V10H28z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-fullscreen-exit">\n      <path d="M10 32h6v6h4V28H10v4zm6-16h-6v4h10V10h-4v6zm12 22h4v-6h6v-4H28v10zm4-22v-6h-4v10h10v-4h-6z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-play-circle">\n      <path d="M20 33l12-9-12-9v18zm4-29C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-mute">\n      <path d="M33 24c0-3.53-2.04-6.58-5-8.05v4.42l4.91 4.91c.06-.42.09-.85.09-1.28zm5 0c0 1.88-.41 3.65-1.08 5.28l3.03 3.03C41.25 29.82 42 27 42 24c0-8.56-5.99-15.72-14-17.54v4.13c5.78 1.72 10 7.07 10 13.41zM8.55 6L6 8.55 15.45 18H6v12h8l10 10V26.55l8.51 8.51c-1.34 1.03-2.85 1.86-4.51 2.36v4.13a17.94 17.94 0 0 0 7.37-3.62L39.45 42 42 39.45l-18-18L8.55 6zM24 8l-4.18 4.18L24 16.36V8z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-low">\n      <path d="M14 18v12h8l10 10V8L22 18h-8z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-medium">\n      <path d="M37 24c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zm-27-6v12h8l10 10V8L18 18h-8z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-high">\n      <path d="M6 18v12h8l10 10V8L14 18H6zm27 6c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zM28 6.46v4.13c5.78 1.72 10 7.07 10 13.41s-4.22 11.69-10 13.41v4.13c8.01-1.82 14-8.97 14-17.54S36.01 8.28 28 6.46z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-spinner">\n      <path d="M18.8 21l9.53-16.51C26.94 4.18 25.49 4 24 4c-4.8 0-9.19 1.69-12.64 4.51l7.33 12.69.11-.2zm24.28-3c-1.84-5.85-6.3-10.52-11.99-12.68L23.77 18h19.31zm.52 2H28.62l.58 1 9.53 16.5C41.99 33.94 44 29.21 44 24c0-1.37-.14-2.71-.4-4zm-26.53 4l-7.8-13.5C6.01 14.06 4 18.79 4 24c0 1.37.14 2.71.4 4h14.98l-2.31-4zM4.92 30c1.84 5.85 6.3 10.52 11.99 12.68L24.23 30H4.92zm22.54 0l-7.8 13.51c1.4.31 2.85.49 4.34.49 4.8 0 9.19-1.69 12.64-4.51L29.31 26.8 27.46 30z"></path>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-hd">\n      <path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-8 12H9.5v-2h-2v2H6V9h1.5v2.5h2V9H11v6zm2-6h4c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1h-4V9zm1.5 4.5h2v-3h-2v3z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-chapters">\n      <path d="M6 26h4v-4H6v4zm0 8h4v-4H6v4zm0-16h4v-4H6v4zm8 8h28v-4H14v4zm0 8h28v-4H14v4zm0-20v4h28v-4H14z"></path>\n    </symbol>\n    <symbol viewBox="0 0 40 40" id="vjs-icon-downloading">\n      <path d="M18.208 36.875q-3.208-.292-5.979-1.729-2.771-1.438-4.812-3.729-2.042-2.292-3.188-5.229-1.146-2.938-1.146-6.23 0-6.583 4.334-11.416 4.333-4.834 10.833-5.5v3.166q-5.167.75-8.583 4.646Q6.25 14.75 6.25 19.958q0 5.209 3.396 9.104 3.396 3.896 8.562 4.646zM20 28.417L11.542 20l2.083-2.083 4.917 4.916v-11.25h2.916v11.25l4.875-4.916L28.417 20zm1.792 8.458v-3.167q1.833-.25 3.541-.958 1.709-.708 3.167-1.875l2.333 2.292q-1.958 1.583-4.25 2.541-2.291.959-4.791 1.167zm6.791-27.792q-1.541-1.125-3.25-1.854-1.708-.729-3.541-1.021V3.042q2.5.25 4.77 1.208 2.271.958 4.271 2.5zm4.584 21.584l-2.25-2.25q1.166-1.5 1.854-3.209.687-1.708.937-3.541h3.209q-.292 2.5-1.229 4.791-.938 2.292-2.521 4.209zm.541-12.417q-.291-1.833-.958-3.562-.667-1.73-1.833-3.188l2.375-2.208q1.541 1.916 2.458 4.208.917 2.292 1.167 4.75z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download">\n      <path d="M10.8 40.55q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h26.35v-7.7h3.4v7.7q0 1.4-1 2.4t-2.4 1zM24 32.1L13.9 22.05l2.45-2.45 5.95 5.95V7.15h3.4v18.4l5.95-5.95 2.45 2.45z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download-done">\n      <path d="M9.8 40.5v-3.45h28.4v3.45zm9.2-9.05L7.4 19.85l2.45-2.35L19 26.65l19.2-19.2 2.4 2.4z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download-off">\n      <path d="M4.9 4.75L43.25 43.1 41 45.3l-4.75-4.75q-.05.05-.075.025-.025-.025-.075-.025H10.8q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h22.05l-7-7-1.85 1.8L13.9 21.9l1.85-1.85L2.7 7zm26.75 14.7l2.45 2.45-3.75 3.8-2.45-2.5zM25.7 7.15V21.1l-3.4-3.45V7.15z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-share">\n      <path d="M36 32.17c-1.52 0-2.89.59-3.93 1.54L17.82 25.4c.11-.45.18-.92.18-1.4s-.07-.95-.18-1.4l14.1-8.23c1.07 1 2.5 1.62 4.08 1.62 3.31 0 6-2.69 6-6s-2.69-6-6-6-6 2.69-6 6c0 .48.07.95.18 1.4l-14.1 8.23c-1.07-1-2.5-1.62-4.08-1.62-3.31 0-6 2.69-6 6s2.69 6 6 6c1.58 0 3.01-.62 4.08-1.62l14.25 8.31c-.1.42-.16.86-.16 1.31A5.83 5.83 0 1 0 36 32.17z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-cog">\n      <path d="M38.86 25.95c.08-.64.14-1.29.14-1.95s-.06-1.31-.14-1.95l4.23-3.31c.38-.3.49-.84.24-1.28l-4-6.93c-.25-.43-.77-.61-1.22-.43l-4.98 2.01c-1.03-.79-2.16-1.46-3.38-1.97L29 4.84c-.09-.47-.5-.84-1-.84h-8c-.5 0-.91.37-.99.84l-.75 5.3a14.8 14.8 0 0 0-3.38 1.97L9.9 10.1a1 1 0 0 0-1.22.43l-4 6.93c-.25.43-.14.97.24 1.28l4.22 3.31C9.06 22.69 9 23.34 9 24s.06 1.31.14 1.95l-4.22 3.31c-.38.3-.49.84-.24 1.28l4 6.93c.25.43.77.61 1.22.43l4.98-2.01c1.03.79 2.16 1.46 3.38 1.97l.75 5.3c.08.47.49.84.99.84h8c.5 0 .91-.37.99-.84l.75-5.3a14.8 14.8 0 0 0 3.38-1.97l4.98 2.01a1 1 0 0 0 1.22-.43l4-6.93c.25-.43.14-.97-.24-1.28l-4.22-3.31zM24 31c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-square">\n      <path d="M36 8H12c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h24c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zm0 28H12V12h24v24z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-circle">\n      <circle cx="24" cy="24" r="20"></circle>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-circle-outline">\n      <path d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-circle-inner-circle">\n      <path d="M24 4C12.97 4 4 12.97 4 24s8.97 20 20 20 20-8.97 20-20S35.03 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16zm6-16c0 3.31-2.69 6-6 6s-6-2.69-6-6 2.69-6 6-6 6 2.69 6 6z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-cancel">\n      <path d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm10 27.17L31.17 34 24 26.83 16.83 34 14 31.17 21.17 24 14 16.83 16.83 14 24 21.17 31.17 14 34 16.83 26.83 24 34 31.17z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-replay">\n      <path d="M24 10V2L14 12l10 10v-8c6.63 0 12 5.37 12 12s-5.37 12-12 12-12-5.37-12-12H8c0 8.84 7.16 16 16 16s16-7.16 16-16-7.16-16-16-16z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-repeat">\n      <path d="M14 14h20v6l8-8-8-8v6H10v12h4v-8zm20 20H14v-6l-8 8 8 8v-6h24V26h-4v8z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-5">\n      <path d="M17.689 98l-8.697 8.696 8.697 8.697 2.486-2.485-4.32-4.319h1.302c4.93 0 9.071 1.722 12.424 5.165 3.352 3.443 5.029 7.638 5.029 12.584h3.55c0-2.958-.553-5.73-1.658-8.313-1.104-2.583-2.622-4.841-4.555-6.774-1.932-1.932-4.19-3.45-6.773-4.555-2.584-1.104-5.355-1.657-8.313-1.657H15.5l4.615-4.615zm-8.08 21.659v13.861h11.357v5.008H9.609V143h12.7c.834 0 1.55-.298 2.146-.894.596-.597.895-1.31.895-2.145v-7.781c0-.835-.299-1.55-.895-2.147a2.929 2.929 0 0 0-2.147-.894h-8.227v-5.096H25.35v-4.384z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-10">\n      <path d="M42.315 125.63c0-4.997-1.694-9.235-5.08-12.713-3.388-3.479-7.571-5.218-12.552-5.218h-1.315l4.363 4.363-2.51 2.51-8.787-8.786L25.221 97l2.45 2.45-4.662 4.663h1.375c2.988 0 5.788.557 8.397 1.673 2.61 1.116 4.892 2.65 6.844 4.602 1.953 1.953 3.487 4.234 4.602 6.844 1.116 2.61 1.674 5.41 1.674 8.398zM8.183 142v-19.657H3.176V117.8h9.643V142zm13.63 0c-1.156 0-2.127-.393-2.912-1.178-.778-.778-1.168-1.746-1.168-2.902v-16.04c0-1.156.393-2.127 1.178-2.912.779-.779 1.746-1.168 2.902-1.168h7.696c1.156 0 2.126.392 2.911 1.177.779.78 1.168 1.747 1.168 2.903v16.04c0 1.156-.392 2.127-1.177 2.912-.779.779-1.746 1.168-2.902 1.168zm.556-4.636h6.583v-15.02H22.37z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-30">\n      <path d="M26.047 97l-8.733 8.732 8.733 8.733 2.496-2.494-4.336-4.338h1.307c4.95 0 9.108 1.73 12.474 5.187 3.367 3.458 5.051 7.668 5.051 12.635h3.565c0-2.97-.556-5.751-1.665-8.346-1.109-2.594-2.633-4.862-4.574-6.802-1.94-1.941-4.208-3.466-6.803-4.575-2.594-1.109-5.375-1.664-8.345-1.664H23.85l4.634-4.634zM2.555 117.531v4.688h10.297v5.25H5.873v4.687h6.979v5.156H2.555V142H13.36c1.061 0 1.95-.395 2.668-1.186.718-.79 1.076-1.772 1.076-2.94v-16.218c0-1.168-.358-2.149-1.076-2.94-.717-.79-1.607-1.185-2.668-1.185zm22.482.14c-1.149 0-2.11.39-2.885 1.165-.78.78-1.172 1.744-1.172 2.893v15.943c0 1.149.388 2.11 1.163 2.885.78.78 1.745 1.172 2.894 1.172h7.649c1.148 0 2.11-.388 2.884-1.163.78-.78 1.17-1.745 1.17-2.894v-15.943c0-1.15-.386-2.111-1.16-2.885-.78-.78-1.746-1.172-2.894-1.172zm.553 4.518h6.545v14.93H25.59z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-5">\n      <path d="M29.508 97l-2.431 2.43 4.625 4.625h-1.364c-2.965 0-5.742.554-8.332 1.66-2.589 1.107-4.851 2.629-6.788 4.566-1.937 1.937-3.458 4.2-4.565 6.788-1.107 2.59-1.66 5.367-1.66 8.331h3.557c0-4.957 1.68-9.16 5.04-12.611 3.36-3.45 7.51-5.177 12.451-5.177h1.304l-4.326 4.33 2.49 2.49 8.715-8.716zm-9.783 21.61v13.89h11.382v5.018H19.725V142h12.727a2.93 2.93 0 0 0 2.15-.896 2.93 2.93 0 0 0 .896-2.15v-7.798c0-.837-.299-1.554-.896-2.152a2.93 2.93 0 0 0-2.15-.896h-8.245V123h11.29v-4.392z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-10">\n      <path d="M23.119 97l-2.386 2.383 4.538 4.538h-1.339c-2.908 0-5.633.543-8.173 1.63-2.54 1.085-4.76 2.577-6.66 4.478-1.9 1.9-3.392 4.12-4.478 6.66-1.085 2.54-1.629 5.264-1.629 8.172h3.49c0-4.863 1.648-8.986 4.944-12.372 3.297-3.385 7.368-5.078 12.216-5.078h1.279l-4.245 4.247 2.443 2.442 8.55-8.55zm-9.52 21.45v4.42h4.871V142h4.513v-23.55zm18.136 0c-1.125 0-2.066.377-2.824 1.135-.764.764-1.148 1.709-1.148 2.834v15.612c0 1.124.38 2.066 1.139 2.824.764.764 1.708 1.145 2.833 1.145h7.489c1.125 0 2.066-.378 2.824-1.136.764-.764 1.145-1.709 1.145-2.833v-15.612c0-1.125-.378-2.067-1.136-2.825-.764-.764-1.708-1.145-2.833-1.145zm.54 4.42h6.408v14.617h-6.407z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-30">\n      <path d="M25.549 97l-2.437 2.434 4.634 4.635H26.38c-2.97 0-5.753.555-8.347 1.664-2.594 1.109-4.861 2.633-6.802 4.574-1.94 1.94-3.465 4.207-4.574 6.802-1.109 2.594-1.664 5.377-1.664 8.347h3.565c0-4.967 1.683-9.178 5.05-12.636 3.366-3.458 7.525-5.187 12.475-5.187h1.307l-4.335 4.338 2.495 2.494 8.732-8.732zm-11.553 20.53v4.689h10.297v5.249h-6.978v4.688h6.978v5.156H13.996V142h10.808c1.06 0 1.948-.395 2.666-1.186.718-.79 1.077-1.771 1.077-2.94v-16.217c0-1.169-.36-2.15-1.077-2.94-.718-.79-1.605-1.186-2.666-1.186zm21.174.168c-1.149 0-2.11.389-2.884 1.163-.78.78-1.172 1.745-1.172 2.894v15.942c0 1.15.388 2.11 1.162 2.885.78.78 1.745 1.17 2.894 1.17h7.649c1.149 0 2.11-.386 2.885-1.16.78-.78 1.17-1.746 1.17-2.895v-15.942c0-1.15-.387-2.11-1.161-2.885-.78-.78-1.745-1.172-2.894-1.172zm.552 4.516h6.542v14.931h-6.542z"></path>\n    </symbol>\n    <symbol viewBox="0 0 512 512" id="vjs-icon-audio-description">\n      <g fill-rule="evenodd"><path d="M227.29 381.351V162.993c50.38-1.017 89.108-3.028 117.631 17.126 27.374 19.342 48.734 56.965 44.89 105.325-4.067 51.155-41.335 94.139-89.776 98.475-24.085 2.155-71.972 0-71.972 0s-.84-1.352-.773-2.568m48.755-54.804c31.43 1.26 53.208-16.633 56.495-45.386 4.403-38.51-21.188-63.552-58.041-60.796v103.612c-.036 1.466.575 2.22 1.546 2.57"></path><path d="M383.78 381.328c13.336 3.71 17.387-11.06 23.215-21.408 12.722-22.571 22.294-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.226 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894"></path><path d="M425.154 381.328c13.336 3.71 17.384-11.061 23.215-21.408 12.721-22.571 22.291-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.511c-.586 3.874 2.226 7.315 3.866 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894"></path><path d="M466.26 381.328c13.337 3.71 17.385-11.061 23.216-21.408 12.722-22.571 22.292-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.225 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894M4.477 383.005H72.58l18.573-28.484 64.169-.135s.065 19.413.065 28.62h48.756V160.307h-58.816c-5.653 9.537-140.85 222.697-140.85 222.697zm152.667-145.282v71.158l-40.453-.27 40.453-70.888z"></path></g>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-next-item">\n      <path d="M12 36l17-12-17-12v24zm20-24v24h4V12h-4z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-previous-item">\n      <path d="M12 12h4v24h-4zm7 12l17 12V12z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-shuffle">\n      <path d="M21.17 18.34L10.83 8 8 10.83l10.34 10.34 2.83-2.83zM29 8l4.09 4.09L8 37.17 10.83 40l25.09-25.09L40 19V8H29zm.66 18.83l-2.83 2.83 6.26 6.26L29 40h11V29l-4.09 4.09-6.25-6.26z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-cast">\n      <path d="M42 6H6c-2.21 0-4 1.79-4 4v6h4v-6h36v28H28v4h14c2.21 0 4-1.79 4-4V10c0-2.21-1.79-4-4-4zM2 36v6h6c0-3.31-2.69-6-6-6zm0-8v4c5.52 0 10 4.48 10 10h4c0-7.73-6.27-14-14-14zm0-8v4c9.94 0 18 8.06 18 18h4c0-12.15-9.85-22-22-22z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-picture-in-picture-enter">\n      <path d="M38 22H22v11.99h16V22zm8 16V9.96C46 7.76 44.2 6 42 6H6C3.8 6 2 7.76 2 9.96V38c0 2.2 1.8 4 4 4h36c2.2 0 4-1.8 4-4zm-4 .04H6V9.94h36v28.1z"></path>\n    </symbol>\n    <symbol viewBox="0 0 22 18" id="vjs-icon-picture-in-picture-exit">\n      <path d="M18 4H4v10h14V4zm4 12V1.98C22 .88 21.1 0 20 0H2C.9 0 0 .88 0 1.98V16c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H2V1.97h18v14.05z"></path>\n      <path fill="none" d="M-1-3h24v24H-1z"></path>\n    </symbol>\n    <symbol viewBox="0 0 1792 1792" id="vjs-icon-facebook">\n      <path d="M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759H734V905H479V609h255V391q0-186 104-288.5T1115 0q147 0 228 12z"></path>\n    </symbol>\n    <symbol viewBox="0 0 1792 1792" id="vjs-icon-linkedin">\n      <path d="M477 625v991H147V625h330zm21-306q1 73-50.5 122T312 490h-2q-82 0-132-49t-50-122q0-74 51.5-122.5T314 148t133 48.5T498 319zm1166 729v568h-329v-530q0-105-40.5-164.5T1168 862q-63 0-105.5 34.5T999 982q-11 30-11 81v553H659q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5T1285 602q171 0 275 113.5t104 332.5z"></path>\n    </symbol>\n    <symbol viewBox="0 0 1792 1792" id="vjs-icon-twitter">\n      <path d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5T1369.5 1125 1185 1335.5t-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5T285 1033q33 5 61 5 43 0 85-11-112-23-185.5-111.5T172 710v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5T884 653q-8-38-8-74 0-134 94.5-228.5T1199 256q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z"></path>\n    </symbol>\n    <symbol viewBox="0 0 1792 1792" id="vjs-icon-tumblr">\n      <path d="M1328 1329l80 237q-23 35-111 66t-177 32q-104 2-190.5-26T787 1564t-95-106-55.5-120-16.5-118V676H452V461q72-26 129-69.5t91-90 58-102 34-99T779 12q1-5 4.5-8.5T791 0h244v424h333v252h-334v518q0 30 6.5 56t22.5 52.5 49.5 41.5 81.5 14q78-2 134-29z"></path>\n    </symbol>\n    <symbol viewBox="0 0 1792 1792" id="vjs-icon-pinterest">\n      <path d="M1664 896q0 209-103 385.5T1281.5 1561 896 1664q-111 0-218-32 59-93 78-164 9-34 54-211 20 39 73 67.5t114 28.5q121 0 216-68.5t147-188.5 52-270q0-114-59.5-214T1180 449t-255-63q-105 0-196 29t-154.5 77-109 110.5-67 129.5T377 866q0 104 40 183t117 111q30 12 38-20 2-7 8-31t8-30q6-23-11-43-51-61-51-151 0-151 104.5-259.5T904 517q151 0 235.5 82t84.5 213q0 170-68.5 289T980 1220q-61 0-98-43.5T859 1072q8-35 26.5-93.5t30-103T927 800q0-50-27-83t-77-33q-62 0-105 57t-43 142q0 73 25 122l-99 418q-17 70-13 177-206-91-333-281T128 896q0-209 103-385.5T510.5 231 896 128t385.5 103T1561 510.5 1664 896z"></path>\n    </symbol>\n  </defs>\n</svg>';
  class MediaLoader extends Component$1 {
    /**
     * Create an instance of this class.
     *
     * @param { import('../player').default } player
     *        The `Player` that this class should attach to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {Function} [ready]
     *        The function that is run when this component is ready.
     */
    constructor(player, options, ready) {
      const options_ = merge$2({
        createEl: false
      }, options);
      super(player, options_, ready);
      if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {
        for (let i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {
          const techName = toTitleCase$1(j[i]);
          let tech = Tech.getTech(techName);
          if (!techName) {
            tech = Component$1.getComponent(techName);
          }
          if (tech && tech.isSupported()) {
            player.loadTech_(techName);
            break;
          }
        }
      } else {
        player.src(options.playerOptions.sources);
      }
    }
  }
  Component$1.registerComponent("MediaLoader", MediaLoader);
  class ClickableComponent extends Component$1 {
    /**
     * Creates an instance of this class.
     *
     * @param  { import('./player').default } player
     *         The `Player` that this class should be attached to.
     *
     * @param  {Object} [options]
     *         The key/value store of component options.
     *
     * @param  {function} [options.clickHandler]
     *         The function to call when the button is clicked / activated
     *
     * @param  {string} [options.controlText]
     *         The text to set on the button
     *
     * @param  {string} [options.className]
     *         A class or space separated list of classes to add the component
     *
     */
    constructor(player, options) {
      super(player, options);
      if (this.options_.controlText) {
        this.controlText(this.options_.controlText);
      }
      this.handleMouseOver_ = (e) => this.handleMouseOver(e);
      this.handleMouseOut_ = (e) => this.handleMouseOut(e);
      this.handleClick_ = (e) => this.handleClick(e);
      this.handleKeyDown_ = (e) => this.handleKeyDown(e);
      this.emitTapEvents();
      this.enable();
    }
    /**
     * Create the `ClickableComponent`s DOM element.
     *
     * @param {string} [tag=div]
     *        The element's node type.
     *
     * @param {Object} [props={}]
     *        An object of properties that should be set on the element.
     *
     * @param {Object} [attributes={}]
     *        An object of attributes that should be set on the element.
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl(tag = "div", props = {}, attributes = {}) {
      props = Object.assign({
        className: this.buildCSSClass(),
        tabIndex: 0
      }, props);
      if (tag === "button") {
        log$1.error(`Creating a ClickableComponent with an HTML element of ${tag} is not supported; use a Button instead.`);
      }
      attributes = Object.assign({
        role: "button"
      }, attributes);
      this.tabIndex_ = props.tabIndex;
      const el = createEl(tag, props, attributes);
      if (!this.player_.options_.experimentalSvgIcons) {
        el.appendChild(createEl("span", {
          className: "vjs-icon-placeholder"
        }, {
          "aria-hidden": true
        }));
      }
      this.createControlTextEl(el);
      return el;
    }
    dispose() {
      this.controlTextEl_ = null;
      super.dispose();
    }
    /**
     * Create a control text element on this `ClickableComponent`
     *
     * @param {Element} [el]
     *        Parent element for the control text.
     *
     * @return {Element}
     *         The control text element that gets created.
     */
    createControlTextEl(el) {
      this.controlTextEl_ = createEl("span", {
        className: "vjs-control-text"
      }, {
        // let the screen reader user know that the text of the element may change
        "aria-live": "polite"
      });
      if (el) {
        el.appendChild(this.controlTextEl_);
      }
      this.controlText(this.controlText_, el);
      return this.controlTextEl_;
    }
    /**
     * Get or set the localize text to use for the controls on the `ClickableComponent`.
     *
     * @param {string} [text]
     *        Control text for element.
     *
     * @param {Element} [el=this.el()]
     *        Element to set the title on.
     *
     * @return {string}
     *         - The control text when getting
     */
    controlText(text, el = this.el()) {
      if (text === void 0) {
        return this.controlText_ || "Need Text";
      }
      const localizedText = this.localize(text);
      this.controlText_ = text;
      textContent(this.controlTextEl_, localizedText);
      if (!this.nonIconControl && !this.player_.options_.noUITitleAttributes) {
        el.setAttribute("title", localizedText);
      }
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-control vjs-button ${super.buildCSSClass()}`;
    }
    /**
     * Enable this `ClickableComponent`
     */
    enable() {
      if (!this.enabled_) {
        this.enabled_ = true;
        this.removeClass("vjs-disabled");
        this.el_.setAttribute("aria-disabled", "false");
        if (typeof this.tabIndex_ !== "undefined") {
          this.el_.setAttribute("tabIndex", this.tabIndex_);
        }
        this.on(["tap", "click"], this.handleClick_);
        this.on("keydown", this.handleKeyDown_);
      }
    }
    /**
     * Disable this `ClickableComponent`
     */
    disable() {
      this.enabled_ = false;
      this.addClass("vjs-disabled");
      this.el_.setAttribute("aria-disabled", "true");
      if (typeof this.tabIndex_ !== "undefined") {
        this.el_.removeAttribute("tabIndex");
      }
      this.off("mouseover", this.handleMouseOver_);
      this.off("mouseout", this.handleMouseOut_);
      this.off(["tap", "click"], this.handleClick_);
      this.off("keydown", this.handleKeyDown_);
    }
    /**
     * Handles language change in ClickableComponent for the player in components
     *
     *
     */
    handleLanguagechange() {
      this.controlText(this.controlText_);
    }
    /**
     * Event handler that is called when a `ClickableComponent` receives a
     * `click` or `tap` event.
     *
     * @param {Event} event
     *        The `tap` or `click` event that caused this function to be called.
     *
     * @listens tap
     * @listens click
     * @abstract
     */
    handleClick(event) {
      if (this.options_.clickHandler) {
        this.options_.clickHandler.call(this, arguments);
      }
    }
    /**
     * Event handler that is called when a `ClickableComponent` receives a
     * `keydown` event.
     *
     * By default, if the key is Space or Enter, it will trigger a `click` event.
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      if (keycode.isEventKey(event, "Space") || keycode.isEventKey(event, "Enter")) {
        event.preventDefault();
        event.stopPropagation();
        this.trigger("click");
      } else {
        super.handleKeyDown(event);
      }
    }
  }
  Component$1.registerComponent("ClickableComponent", ClickableComponent);
  class PosterImage extends ClickableComponent {
    /**
     * Create an instance of this class.
     *
     * @param { import('./player').default } player
     *        The `Player` that this class should attach to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.update();
      this.update_ = (e) => this.update(e);
      player.on("posterchange", this.update_);
    }
    /**
     * Clean up and dispose of the `PosterImage`.
     */
    dispose() {
      this.player().off("posterchange", this.update_);
      super.dispose();
    }
    /**
     * Create the `PosterImage`s DOM element.
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl() {
      return createEl("div", {
        className: "vjs-poster"
      });
    }
    /**
     * Get or set the `PosterImage`'s crossOrigin option.
     *
     * @param {string|null} [value]
     *        The value to set the crossOrigin to. If an argument is
     *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.
     *
     * @return {string|null}
     *         - The current crossOrigin value of the `Player` when getting.
     *         - undefined when setting
     */
    crossOrigin(value) {
      if (typeof value === "undefined") {
        if (this.$("img")) {
          return this.$("img").crossOrigin;
        } else if (this.player_.tech_ && this.player_.tech_.isReady_) {
          return this.player_.crossOrigin();
        }
        return this.player_.options_.crossOrigin || this.player_.options_.crossorigin || null;
      }
      if (value !== null && value !== "anonymous" && value !== "use-credentials") {
        this.player_.log.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${value}"`);
        return;
      }
      if (this.$("img")) {
        this.$("img").crossOrigin = value;
      }
      return;
    }
    /**
     * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.
     *
     * @listens Player#posterchange
     *
     * @param {Event} [event]
     *        The `Player#posterchange` event that triggered this function.
     */
    update(event) {
      const url = this.player().poster();
      this.setSrc(url);
      if (url) {
        this.show();
      } else {
        this.hide();
      }
    }
    /**
     * Set the source of the `PosterImage` depending on the display method. (Re)creates
     * the inner picture and img elementss when needed.
     *
     * @param {string} [url]
     *        The URL to the source for the `PosterImage`. If not specified or falsy,
     *        any source and ant inner picture/img are removed.
     */
    setSrc(url) {
      if (!url) {
        this.el_.textContent = "";
        return;
      }
      if (!this.$("img")) {
        this.el_.appendChild(createEl("picture", {
          className: "vjs-poster",
          // Don't want poster to be tabbable.
          tabIndex: -1
        }, {}, createEl("img", {
          loading: "lazy",
          crossOrigin: this.crossOrigin()
        }, {
          alt: ""
        })));
      }
      this.$("img").src = url;
    }
    /**
     * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See
     * {@link ClickableComponent#handleClick} for instances where this will be triggered.
     *
     * @listens tap
     * @listens click
     * @listens keydown
     *
     * @param {Event} event
     +        The `click`, `tap` or `keydown` event that caused this function to be called.
     */
    handleClick(event) {
      if (!this.player_.controls()) {
        return;
      }
      if (this.player_.tech(true)) {
        this.player_.tech(true).focus();
      }
      if (this.player_.paused()) {
        silencePromise(this.player_.play());
      } else {
        this.player_.pause();
      }
    }
  }
  PosterImage.prototype.crossorigin = PosterImage.prototype.crossOrigin;
  Component$1.registerComponent("PosterImage", PosterImage);
  const darkGray = "#222";
  const lightGray = "#ccc";
  const fontMap = {
    monospace: "monospace",
    sansSerif: "sans-serif",
    serif: "serif",
    monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
    monospaceSerif: '"Courier New", monospace',
    proportionalSansSerif: "sans-serif",
    proportionalSerif: "serif",
    casual: '"Comic Sans MS", Impact, fantasy',
    script: '"Monotype Corsiva", cursive',
    smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
  };
  function constructColor(color, opacity) {
    let hex;
    if (color.length === 4) {
      hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
    } else if (color.length === 7) {
      hex = color.slice(1);
    } else {
      throw new Error("Invalid color code provided, " + color + "; must be formatted as e.g. #f0e or #f604e2.");
    }
    return "rgba(" + parseInt(hex.slice(0, 2), 16) + "," + parseInt(hex.slice(2, 4), 16) + "," + parseInt(hex.slice(4, 6), 16) + "," + opacity + ")";
  }
  function tryUpdateStyle(el, style, rule) {
    try {
      el.style[style] = rule;
    } catch (e) {
      return;
    }
  }
  function getCSSPositionValue(position2) {
    return position2 ? `${position2}px` : "";
  }
  class TextTrackDisplay extends Component$1 {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {Function} [ready]
     *        The function to call when `TextTrackDisplay` is ready.
     */
    constructor(player, options, ready) {
      super(player, options, ready);
      const updateDisplayTextHandler = (e) => this.updateDisplay(e);
      const updateDisplayHandler = (e) => {
        this.updateDisplayOverlay();
        this.updateDisplay(e);
      };
      player.on("loadstart", (e) => this.toggleDisplay(e));
      player.on("texttrackchange", updateDisplayTextHandler);
      player.on("loadedmetadata", (e) => {
        this.updateDisplayOverlay();
        this.preselectTrack(e);
      });
      player.ready(bind_(this, function() {
        if (player.tech_ && player.tech_.featuresNativeTextTracks) {
          this.hide();
          return;
        }
        player.on("fullscreenchange", updateDisplayHandler);
        player.on("playerresize", updateDisplayHandler);
        const screenOrientation = window.screen.orientation || window;
        const changeOrientationEvent = window.screen.orientation ? "change" : "orientationchange";
        screenOrientation.addEventListener(changeOrientationEvent, updateDisplayHandler);
        player.on("dispose", () => screenOrientation.removeEventListener(changeOrientationEvent, updateDisplayHandler));
        const tracks = this.options_.playerOptions.tracks || [];
        for (let i = 0; i < tracks.length; i++) {
          this.player_.addRemoteTextTrack(tracks[i], true);
        }
        this.preselectTrack();
      }));
    }
    /**
    * Preselect a track following this precedence:
    * - matches the previously selected {@link TextTrack}'s language and kind
    * - matches the previously selected {@link TextTrack}'s language only
    * - is the first default captions track
    * - is the first default descriptions track
    *
    * @listens Player#loadstart
    */
    preselectTrack() {
      const modes = {
        captions: 1,
        subtitles: 1
      };
      const trackList = this.player_.textTracks();
      const userPref = this.player_.cache_.selectedLanguage;
      let firstDesc;
      let firstCaptions;
      let preferredTrack;
      for (let i = 0; i < trackList.length; i++) {
        const track = trackList[i];
        if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {
          if (track.kind === userPref.kind) {
            preferredTrack = track;
          } else if (!preferredTrack) {
            preferredTrack = track;
          }
        } else if (userPref && !userPref.enabled) {
          preferredTrack = null;
          firstDesc = null;
          firstCaptions = null;
        } else if (track.default) {
          if (track.kind === "descriptions" && !firstDesc) {
            firstDesc = track;
          } else if (track.kind in modes && !firstCaptions) {
            firstCaptions = track;
          }
        }
      }
      if (preferredTrack) {
        preferredTrack.mode = "showing";
      } else if (firstCaptions) {
        firstCaptions.mode = "showing";
      } else if (firstDesc) {
        firstDesc.mode = "showing";
      }
    }
    /**
     * Turn display of {@link TextTrack}'s from the current state into the other state.
     * There are only two states:
     * - 'shown'
     * - 'hidden'
     *
     * @listens Player#loadstart
     */
    toggleDisplay() {
      if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {
        this.hide();
      } else {
        this.show();
      }
    }
    /**
     * Create the {@link Component}'s DOM element.
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl("div", {
        className: "vjs-text-track-display"
      }, {
        "translate": "yes",
        "aria-live": "off",
        "aria-atomic": "true"
      });
    }
    /**
     * Clear all displayed {@link TextTrack}s.
     */
    clearDisplay() {
      if (typeof window.WebVTT === "function") {
        window.WebVTT.processCues(window, [], this.el_);
      }
    }
    /**
     * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or
     * a {@link Player#fullscreenchange} is fired.
     *
     * @listens Player#texttrackchange
     * @listens Player#fullscreenchange
     */
    updateDisplay() {
      const tracks = this.player_.textTracks();
      const allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;
      this.clearDisplay();
      if (allowMultipleShowingTracks) {
        const showingTracks = [];
        for (let i2 = 0; i2 < tracks.length; ++i2) {
          const track = tracks[i2];
          if (track.mode !== "showing") {
            continue;
          }
          showingTracks.push(track);
        }
        this.updateForTrack(showingTracks);
        return;
      }
      let descriptionsTrack = null;
      let captionsSubtitlesTrack = null;
      let i = tracks.length;
      while (i--) {
        const track = tracks[i];
        if (track.mode === "showing") {
          if (track.kind === "descriptions") {
            descriptionsTrack = track;
          } else {
            captionsSubtitlesTrack = track;
          }
        }
      }
      if (captionsSubtitlesTrack) {
        if (this.getAttribute("aria-live") !== "off") {
          this.setAttribute("aria-live", "off");
        }
        this.updateForTrack(captionsSubtitlesTrack);
      } else if (descriptionsTrack) {
        if (this.getAttribute("aria-live") !== "assertive") {
          this.setAttribute("aria-live", "assertive");
        }
        this.updateForTrack(descriptionsTrack);
      }
    }
    /**
     * Updates the displayed TextTrack to be sure it overlays the video when a either
     * a {@link Player#texttrackchange} or a {@link Player#fullscreenchange} is fired.
     */
    updateDisplayOverlay() {
      if (!this.player_.videoHeight() || !window.CSS.supports("inset-inline: 10px")) {
        return;
      }
      const playerWidth = this.player_.currentWidth();
      const playerHeight = this.player_.currentHeight();
      const playerAspectRatio = playerWidth / playerHeight;
      const videoAspectRatio = this.player_.videoWidth() / this.player_.videoHeight();
      let insetInlineMatch = 0;
      let insetBlockMatch = 0;
      if (Math.abs(playerAspectRatio - videoAspectRatio) > 0.1) {
        if (playerAspectRatio > videoAspectRatio) {
          insetInlineMatch = Math.round((playerWidth - playerHeight * videoAspectRatio) / 2);
        } else {
          insetBlockMatch = Math.round((playerHeight - playerWidth / videoAspectRatio) / 2);
        }
      }
      tryUpdateStyle(this.el_, "insetInline", getCSSPositionValue(insetInlineMatch));
      tryUpdateStyle(this.el_, "insetBlock", getCSSPositionValue(insetBlockMatch));
    }
    /**
     * Style {@Link TextTrack} activeCues according to {@Link TextTrackSettings}.
     *
     * @param {TextTrack} track
     *        Text track object containing active cues to style.
     */
    updateDisplayState(track) {
      const overrides = this.player_.textTrackSettings.getValues();
      const cues = track.activeCues;
      let i = cues.length;
      while (i--) {
        const cue = cues[i];
        if (!cue) {
          continue;
        }
        const cueDiv = cue.displayState;
        if (overrides.color) {
          cueDiv.firstChild.style.color = overrides.color;
        }
        if (overrides.textOpacity) {
          tryUpdateStyle(cueDiv.firstChild, "color", constructColor(overrides.color || "#fff", overrides.textOpacity));
        }
        if (overrides.backgroundColor) {
          cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
        }
        if (overrides.backgroundOpacity) {
          tryUpdateStyle(cueDiv.firstChild, "backgroundColor", constructColor(overrides.backgroundColor || "#000", overrides.backgroundOpacity));
        }
        if (overrides.windowColor) {
          if (overrides.windowOpacity) {
            tryUpdateStyle(cueDiv, "backgroundColor", constructColor(overrides.windowColor, overrides.windowOpacity));
          } else {
            cueDiv.style.backgroundColor = overrides.windowColor;
          }
        }
        if (overrides.edgeStyle) {
          if (overrides.edgeStyle === "dropshadow") {
            cueDiv.firstChild.style.textShadow = `2px 2px 3px ${darkGray}, 2px 2px 4px ${darkGray}, 2px 2px 5px ${darkGray}`;
          } else if (overrides.edgeStyle === "raised") {
            cueDiv.firstChild.style.textShadow = `1px 1px ${darkGray}, 2px 2px ${darkGray}, 3px 3px ${darkGray}`;
          } else if (overrides.edgeStyle === "depressed") {
            cueDiv.firstChild.style.textShadow = `1px 1px ${lightGray}, 0 1px ${lightGray}, -1px -1px ${darkGray}, 0 -1px ${darkGray}`;
          } else if (overrides.edgeStyle === "uniform") {
            cueDiv.firstChild.style.textShadow = `0 0 4px ${darkGray}, 0 0 4px ${darkGray}, 0 0 4px ${darkGray}, 0 0 4px ${darkGray}`;
          }
        }
        if (overrides.fontPercent && overrides.fontPercent !== 1) {
          const fontSize = window.parseFloat(cueDiv.style.fontSize);
          cueDiv.style.fontSize = fontSize * overrides.fontPercent + "px";
          cueDiv.style.height = "auto";
          cueDiv.style.top = "auto";
        }
        if (overrides.fontFamily && overrides.fontFamily !== "default") {
          if (overrides.fontFamily === "small-caps") {
            cueDiv.firstChild.style.fontVariant = "small-caps";
          } else {
            cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
          }
        }
      }
    }
    /**
     * Add an {@link TextTrack} to to the {@link Tech}s {@link TextTrackList}.
     *
     * @param {TextTrack|TextTrack[]} tracks
     *        Text track object or text track array to be added to the list.
     */
    updateForTrack(tracks) {
      if (!Array.isArray(tracks)) {
        tracks = [tracks];
      }
      if (typeof window.WebVTT !== "function" || tracks.every((track) => {
        return !track.activeCues;
      })) {
        return;
      }
      const cues = [];
      for (let i = 0; i < tracks.length; ++i) {
        const track = tracks[i];
        for (let j = 0; j < track.activeCues.length; ++j) {
          cues.push(track.activeCues[j]);
        }
      }
      window.WebVTT.processCues(window, cues, this.el_);
      for (let i = 0; i < tracks.length; ++i) {
        const track = tracks[i];
        for (let j = 0; j < track.activeCues.length; ++j) {
          const cueEl = track.activeCues[j].displayState;
          addClass(cueEl, "vjs-text-track-cue", "vjs-text-track-cue-" + (track.language ? track.language : i));
          if (track.language) {
            setAttribute(cueEl, "lang", track.language);
          }
        }
        if (this.player_.textTrackSettings) {
          this.updateDisplayState(track);
        }
      }
    }
  }
  Component$1.registerComponent("TextTrackDisplay", TextTrackDisplay);
  class LoadingSpinner extends Component$1 {
    /**
     * Create the `LoadingSpinner`s DOM element.
     *
     * @return {Element}
     *         The dom element that gets created.
     */
    createEl() {
      const isAudio = this.player_.isAudio();
      const playerType = this.localize(isAudio ? "Audio Player" : "Video Player");
      const controlText = createEl("span", {
        className: "vjs-control-text",
        textContent: this.localize("{1} is loading.", [playerType])
      });
      const el = super.createEl("div", {
        className: "vjs-loading-spinner",
        dir: "ltr"
      });
      el.appendChild(controlText);
      return el;
    }
    /**
     * Update control text on languagechange
     */
    handleLanguagechange() {
      this.$(".vjs-control-text").textContent = this.localize("{1} is loading.", [this.player_.isAudio() ? "Audio Player" : "Video Player"]);
    }
  }
  Component$1.registerComponent("LoadingSpinner", LoadingSpinner);
  class Button extends ClickableComponent {
    /**
     * Create the `Button`s DOM element.
     *
     * @param {string} [tag="button"]
     *        The element's node type. This argument is IGNORED: no matter what
     *        is passed, it will always create a `button` element.
     *
     * @param {Object} [props={}]
     *        An object of properties that should be set on the element.
     *
     * @param {Object} [attributes={}]
     *        An object of attributes that should be set on the element.
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl(tag, props = {}, attributes = {}) {
      tag = "button";
      props = Object.assign({
        className: this.buildCSSClass()
      }, props);
      attributes = Object.assign({
        // Necessary since the default button type is "submit"
        type: "button"
      }, attributes);
      const el = createEl(tag, props, attributes);
      if (!this.player_.options_.experimentalSvgIcons) {
        el.appendChild(createEl("span", {
          className: "vjs-icon-placeholder"
        }, {
          "aria-hidden": true
        }));
      }
      this.createControlTextEl(el);
      return el;
    }
    /**
     * Add a child `Component` inside of this `Button`.
     *
     * @param {string|Component} child
     *        The name or instance of a child to add.
     *
     * @param {Object} [options={}]
     *        The key/value store of options that will get passed to children of
     *        the child.
     *
     * @return {Component}
     *         The `Component` that gets added as a child. When using a string the
     *         `Component` will get created by this process.
     *
     * @deprecated since version 5
     */
    addChild(child, options = {}) {
      const className = this.constructor.name;
      log$1.warn(`Adding an actionable (user controllable) child to a Button (${className}) is not supported; use a ClickableComponent instead.`);
      return Component$1.prototype.addChild.call(this, child, options);
    }
    /**
     * Enable the `Button` element so that it can be activated or clicked. Use this with
     * {@link Button#disable}.
     */
    enable() {
      super.enable();
      this.el_.removeAttribute("disabled");
    }
    /**
     * Disable the `Button` element so that it cannot be activated or clicked. Use this with
     * {@link Button#enable}.
     */
    disable() {
      super.disable();
      this.el_.setAttribute("disabled", "disabled");
    }
    /**
     * This gets called when a `Button` has focus and `keydown` is triggered via a key
     * press.
     *
     * @param {KeyboardEvent} event
     *        The event that caused this function to get called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      if (keycode.isEventKey(event, "Space") || keycode.isEventKey(event, "Enter")) {
        event.stopPropagation();
        return;
      }
      super.handleKeyDown(event);
    }
  }
  Component$1.registerComponent("Button", Button);
  class BigPlayButton extends Button {
    constructor(player, options) {
      super(player, options);
      this.mouseused_ = false;
      this.setIcon("play");
      this.on("mousedown", (e) => this.handleMouseDown(e));
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.
     */
    buildCSSClass() {
      return "vjs-big-play-button";
    }
    /**
     * This gets called when a `BigPlayButton` "clicked". See {@link ClickableComponent}
     * for more detailed information on what a click can be.
     *
     * @param {KeyboardEvent|MouseEvent|TouchEvent} event
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      const playPromise = this.player_.play();
      if (this.mouseused_ && "clientX" in event && "clientY" in event) {
        silencePromise(playPromise);
        if (this.player_.tech(true)) {
          this.player_.tech(true).focus();
        }
        return;
      }
      const cb = this.player_.getChild("controlBar");
      const playToggle = cb && cb.getChild("playToggle");
      if (!playToggle) {
        this.player_.tech(true).focus();
        return;
      }
      const playFocus = () => playToggle.focus();
      if (isPromise(playPromise)) {
        playPromise.then(playFocus, () => {
        });
      } else {
        this.setTimeout(playFocus, 1);
      }
    }
    /**
     * Event handler that is called when a `BigPlayButton` receives a
     * `keydown` event.
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      this.mouseused_ = false;
      super.handleKeyDown(event);
    }
    /**
     * Handle `mousedown` events on the `BigPlayButton`.
     *
     * @param {MouseEvent} event
     *        `mousedown` or `touchstart` event that triggered this function
     *
     * @listens mousedown
     */
    handleMouseDown(event) {
      this.mouseused_ = true;
    }
  }
  BigPlayButton.prototype.controlText_ = "Play Video";
  Component$1.registerComponent("BigPlayButton", BigPlayButton);
  class CloseButton extends Button {
    /**
    * Creates an instance of the this class.
    *
    * @param  { import('./player').default } player
    *         The `Player` that this class should be attached to.
    *
    * @param  {Object} [options]
    *         The key/value store of player options.
    */
    constructor(player, options) {
      super(player, options);
      this.setIcon("cancel");
      this.controlText(options && options.controlText || this.localize("Close"));
    }
    /**
    * Builds the default DOM `className`.
    *
    * @return {string}
    *         The DOM `className` for this object.
    */
    buildCSSClass() {
      return `vjs-close-button ${super.buildCSSClass()}`;
    }
    /**
     * This gets called when a `CloseButton` gets clicked. See
     * {@link ClickableComponent#handleClick} for more information on when
     * this will be triggered
     *
     * @param {Event} event
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     * @fires CloseButton#close
     */
    handleClick(event) {
      this.trigger({
        type: "close",
        bubbles: false
      });
    }
    /**
     * Event handler that is called when a `CloseButton` receives a
     * `keydown` event.
     *
     * By default, if the key is Esc, it will trigger a `click` event.
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      if (keycode.isEventKey(event, "Esc")) {
        event.preventDefault();
        event.stopPropagation();
        this.trigger("click");
      } else {
        super.handleKeyDown(event);
      }
    }
  }
  Component$1.registerComponent("CloseButton", CloseButton);
  class PlayToggle extends Button {
    /**
     * Creates an instance of this class.
     *
     * @param { import('./player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options={}]
     *        The key/value store of player options.
     */
    constructor(player, options = {}) {
      super(player, options);
      options.replay = options.replay === void 0 || options.replay;
      this.setIcon("play");
      this.on(player, "play", (e) => this.handlePlay(e));
      this.on(player, "pause", (e) => this.handlePause(e));
      if (options.replay) {
        this.on(player, "ended", (e) => this.handleEnded(e));
      }
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-play-control ${super.buildCSSClass()}`;
    }
    /**
     * This gets called when an `PlayToggle` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      if (this.player_.paused()) {
        silencePromise(this.player_.play());
      } else {
        this.player_.pause();
      }
    }
    /**
     * This gets called once after the video has ended and the user seeks so that
     * we can change the replay button back to a play button.
     *
     * @param {Event} [event]
     *        The event that caused this function to run.
     *
     * @listens Player#seeked
     */
    handleSeeked(event) {
      this.removeClass("vjs-ended");
      if (this.player_.paused()) {
        this.handlePause(event);
      } else {
        this.handlePlay(event);
      }
    }
    /**
     * Add the vjs-playing class to the element so it can change appearance.
     *
     * @param {Event} [event]
     *        The event that caused this function to run.
     *
     * @listens Player#play
     */
    handlePlay(event) {
      this.removeClass("vjs-ended", "vjs-paused");
      this.addClass("vjs-playing");
      this.setIcon("pause");
      this.controlText("Pause");
    }
    /**
     * Add the vjs-paused class to the element so it can change appearance.
     *
     * @param {Event} [event]
     *        The event that caused this function to run.
     *
     * @listens Player#pause
     */
    handlePause(event) {
      this.removeClass("vjs-playing");
      this.addClass("vjs-paused");
      this.setIcon("play");
      this.controlText("Play");
    }
    /**
     * Add the vjs-ended class to the element so it can change appearance
     *
     * @param {Event} [event]
     *        The event that caused this function to run.
     *
     * @listens Player#ended
     */
    handleEnded(event) {
      this.removeClass("vjs-playing");
      this.addClass("vjs-ended");
      this.setIcon("replay");
      this.controlText("Replay");
      this.one(this.player_, "seeked", (e) => this.handleSeeked(e));
    }
  }
  PlayToggle.prototype.controlText_ = "Play";
  Component$1.registerComponent("PlayToggle", PlayToggle);
  class TimeDisplay extends Component$1 {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.on(player, ["timeupdate", "ended", "seeking"], (e) => this.update(e));
      this.updateTextNode_();
    }
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const className = this.buildCSSClass();
      const el = super.createEl("div", {
        className: `${className} vjs-time-control vjs-control`
      });
      const span = createEl("span", {
        className: "vjs-control-text",
        textContent: `${this.localize(this.labelText_)}\xA0`
      }, {
        role: "presentation"
      });
      el.appendChild(span);
      this.contentEl_ = createEl("span", {
        className: `${className}-display`
      }, {
        // span elements have no implicit role, but some screen readers (notably VoiceOver)
        // treat them as a break between items in the DOM when using arrow keys
        // (or left-to-right swipes on iOS) to read contents of a page. Using
        // role='presentation' causes VoiceOver to NOT treat this span as a break.
        role: "presentation"
      });
      el.appendChild(this.contentEl_);
      return el;
    }
    dispose() {
      this.contentEl_ = null;
      this.textNode_ = null;
      super.dispose();
    }
    /**
     * Updates the displayed time according to the `updateContent` function which is defined in the child class.
     *
     * @param {Event} [event]
     *          The `timeupdate`, `ended` or `seeking` (if enableSmoothSeeking is true) event that caused this function to be called.
     */
    update(event) {
      if (!this.player_.options_.enableSmoothSeeking && event.type === "seeking") {
        return;
      }
      this.updateContent(event);
    }
    /**
     * Updates the time display text node with a new time
     *
     * @param {number} [time=0] the time to update to
     *
     * @private
     */
    updateTextNode_(time = 0) {
      time = formatTime(time);
      if (this.formattedTime_ === time) {
        return;
      }
      this.formattedTime_ = time;
      this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", () => {
        if (!this.contentEl_) {
          return;
        }
        let oldNode = this.textNode_;
        if (oldNode && this.contentEl_.firstChild !== oldNode) {
          oldNode = null;
          log$1.warn("TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.");
        }
        this.textNode_ = document.createTextNode(this.formattedTime_);
        if (!this.textNode_) {
          return;
        }
        if (oldNode) {
          this.contentEl_.replaceChild(this.textNode_, oldNode);
        } else {
          this.contentEl_.appendChild(this.textNode_);
        }
      });
    }
    /**
     * To be filled out in the child class, should update the displayed time
     * in accordance with the fact that the current time has changed.
     *
     * @param {Event} [event]
     *        The `timeupdate`  event that caused this to run.
     *
     * @listens Player#timeupdate
     */
    updateContent(event) {
    }
  }
  TimeDisplay.prototype.labelText_ = "Time";
  TimeDisplay.prototype.controlText_ = "Time";
  Component$1.registerComponent("TimeDisplay", TimeDisplay);
  class CurrentTimeDisplay extends TimeDisplay {
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return "vjs-current-time";
    }
    /**
     * Update current time display
     *
     * @param {Event} [event]
     *        The `timeupdate` event that caused this function to run.
     *
     * @listens Player#timeupdate
     */
    updateContent(event) {
      let time;
      if (this.player_.ended()) {
        time = this.player_.duration();
      } else {
        time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
      }
      this.updateTextNode_(time);
    }
  }
  CurrentTimeDisplay.prototype.labelText_ = "Current Time";
  CurrentTimeDisplay.prototype.controlText_ = "Current Time";
  Component$1.registerComponent("CurrentTimeDisplay", CurrentTimeDisplay);
  class DurationDisplay extends TimeDisplay {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      const updateContent = (e) => this.updateContent(e);
      this.on(player, "durationchange", updateContent);
      this.on(player, "loadstart", updateContent);
      this.on(player, "loadedmetadata", updateContent);
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return "vjs-duration";
    }
    /**
     * Update duration time display.
     *
     * @param {Event} [event]
     *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused
     *        this function to be called.
     *
     * @listens Player#durationchange
     * @listens Player#timeupdate
     * @listens Player#loadedmetadata
     */
    updateContent(event) {
      const duration2 = this.player_.duration();
      this.updateTextNode_(duration2);
    }
  }
  DurationDisplay.prototype.labelText_ = "Duration";
  DurationDisplay.prototype.controlText_ = "Duration";
  Component$1.registerComponent("DurationDisplay", DurationDisplay);
  class TimeDivider extends Component$1 {
    /**
     * Create the component's DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const el = super.createEl("div", {
        className: "vjs-time-control vjs-time-divider"
      }, {
        // this element and its contents can be hidden from assistive techs since
        // it is made extraneous by the announcement of the control text
        // for the current time and duration displays
        "aria-hidden": true
      });
      const div = super.createEl("div");
      const span = super.createEl("span", {
        textContent: "/"
      });
      div.appendChild(span);
      el.appendChild(div);
      return el;
    }
  }
  Component$1.registerComponent("TimeDivider", TimeDivider);
  class RemainingTimeDisplay extends TimeDisplay {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.on(player, "durationchange", (e) => this.updateContent(e));
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return "vjs-remaining-time";
    }
    /**
     * Create the `Component`'s DOM element with the "minus" character prepend to the time
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const el = super.createEl();
      if (this.options_.displayNegative !== false) {
        el.insertBefore(createEl("span", {}, {
          "aria-hidden": true
        }, "-"), this.contentEl_);
      }
      return el;
    }
    /**
     * Update remaining time display.
     *
     * @param {Event} [event]
     *        The `timeupdate` or `durationchange` event that caused this to run.
     *
     * @listens Player#timeupdate
     * @listens Player#durationchange
     */
    updateContent(event) {
      if (typeof this.player_.duration() !== "number") {
        return;
      }
      let time;
      if (this.player_.ended()) {
        time = 0;
      } else if (this.player_.remainingTimeDisplay) {
        time = this.player_.remainingTimeDisplay();
      } else {
        time = this.player_.remainingTime();
      }
      this.updateTextNode_(time);
    }
  }
  RemainingTimeDisplay.prototype.labelText_ = "Remaining Time";
  RemainingTimeDisplay.prototype.controlText_ = "Remaining Time";
  Component$1.registerComponent("RemainingTimeDisplay", RemainingTimeDisplay);
  class LiveDisplay extends Component$1 {
    /**
     * Creates an instance of this class.
     *
     * @param { import('./player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.updateShowing();
      this.on(this.player(), "durationchange", (e) => this.updateShowing(e));
    }
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const el = super.createEl("div", {
        className: "vjs-live-control vjs-control"
      });
      this.contentEl_ = createEl("div", {
        className: "vjs-live-display"
      }, {
        "aria-live": "off"
      });
      this.contentEl_.appendChild(createEl("span", {
        className: "vjs-control-text",
        textContent: `${this.localize("Stream Type")}\xA0`
      }));
      this.contentEl_.appendChild(document.createTextNode(this.localize("LIVE")));
      el.appendChild(this.contentEl_);
      return el;
    }
    dispose() {
      this.contentEl_ = null;
      super.dispose();
    }
    /**
     * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide
     * it accordingly
     *
     * @param {Event} [event]
     *        The {@link Player#durationchange} event that caused this function to run.
     *
     * @listens Player#durationchange
     */
    updateShowing(event) {
      if (this.player().duration() === Infinity) {
        this.show();
      } else {
        this.hide();
      }
    }
  }
  Component$1.registerComponent("LiveDisplay", LiveDisplay);
  class SeekToLive extends Button {
    /**
     * Creates an instance of this class.
     *
     * @param { import('./player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.updateLiveEdgeStatus();
      if (this.player_.liveTracker) {
        this.updateLiveEdgeStatusHandler_ = (e) => this.updateLiveEdgeStatus(e);
        this.on(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_);
      }
    }
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const el = super.createEl("button", {
        className: "vjs-seek-to-live-control vjs-control"
      });
      this.setIcon("circle", el);
      this.textEl_ = createEl("span", {
        className: "vjs-seek-to-live-text",
        textContent: this.localize("LIVE")
      }, {
        "aria-hidden": "true"
      });
      el.appendChild(this.textEl_);
      return el;
    }
    /**
     * Update the state of this button if we are at the live edge
     * or not
     */
    updateLiveEdgeStatus() {
      if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {
        this.setAttribute("aria-disabled", true);
        this.addClass("vjs-at-live-edge");
        this.controlText("Seek to live, currently playing live");
      } else {
        this.setAttribute("aria-disabled", false);
        this.removeClass("vjs-at-live-edge");
        this.controlText("Seek to live, currently behind live");
      }
    }
    /**
     * On click bring us as near to the live point as possible.
     * This requires that we wait for the next `live-seekable-change`
     * event which will happen every segment length seconds.
     */
    handleClick() {
      this.player_.liveTracker.seekToLiveEdge();
    }
    /**
     * Dispose of the element and stop tracking
     */
    dispose() {
      if (this.player_.liveTracker) {
        this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_);
      }
      this.textEl_ = null;
      super.dispose();
    }
  }
  SeekToLive.prototype.controlText_ = "Seek to live, currently playing live";
  Component$1.registerComponent("SeekToLive", SeekToLive);
  function clamp(number, min, max) {
    number = Number(number);
    return Math.min(max, Math.max(min, isNaN(number) ? min : number));
  }
  var Num = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    clamp
  });
  class Slider extends Component$1 {
    /**
    * Create an instance of this class
    *
    * @param { import('../player').default } player
    *        The `Player` that this class should be attached to.
    *
    * @param {Object} [options]
    *        The key/value store of player options.
    */
    constructor(player, options) {
      super(player, options);
      this.handleMouseDown_ = (e) => this.handleMouseDown(e);
      this.handleMouseUp_ = (e) => this.handleMouseUp(e);
      this.handleKeyDown_ = (e) => this.handleKeyDown(e);
      this.handleClick_ = (e) => this.handleClick(e);
      this.handleMouseMove_ = (e) => this.handleMouseMove(e);
      this.update_ = (e) => this.update(e);
      this.bar = this.getChild(this.options_.barName);
      this.vertical(!!this.options_.vertical);
      this.enable();
    }
    /**
     * Are controls are currently enabled for this slider or not.
     *
     * @return {boolean}
     *         true if controls are enabled, false otherwise
     */
    enabled() {
      return this.enabled_;
    }
    /**
     * Enable controls for this slider if they are disabled
     */
    enable() {
      if (this.enabled()) {
        return;
      }
      this.on("mousedown", this.handleMouseDown_);
      this.on("touchstart", this.handleMouseDown_);
      this.on("keydown", this.handleKeyDown_);
      this.on("click", this.handleClick_);
      this.on(this.player_, "controlsvisible", this.update);
      if (this.playerEvent) {
        this.on(this.player_, this.playerEvent, this.update);
      }
      this.removeClass("disabled");
      this.setAttribute("tabindex", 0);
      this.enabled_ = true;
    }
    /**
     * Disable controls for this slider if they are enabled
     */
    disable() {
      if (!this.enabled()) {
        return;
      }
      const doc = this.bar.el_.ownerDocument;
      this.off("mousedown", this.handleMouseDown_);
      this.off("touchstart", this.handleMouseDown_);
      this.off("keydown", this.handleKeyDown_);
      this.off("click", this.handleClick_);
      this.off(this.player_, "controlsvisible", this.update_);
      this.off(doc, "mousemove", this.handleMouseMove_);
      this.off(doc, "mouseup", this.handleMouseUp_);
      this.off(doc, "touchmove", this.handleMouseMove_);
      this.off(doc, "touchend", this.handleMouseUp_);
      this.removeAttribute("tabindex");
      this.addClass("disabled");
      if (this.playerEvent) {
        this.off(this.player_, this.playerEvent, this.update);
      }
      this.enabled_ = false;
    }
    /**
     * Create the `Slider`s DOM element.
     *
     * @param {string} type
     *        Type of element to create.
     *
     * @param {Object} [props={}]
     *        List of properties in Object form.
     *
     * @param {Object} [attributes={}]
     *        list of attributes in Object form.
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl(type, props = {}, attributes = {}) {
      props.className = props.className + " vjs-slider";
      props = Object.assign({
        tabIndex: 0
      }, props);
      attributes = Object.assign({
        "role": "slider",
        "aria-valuenow": 0,
        "aria-valuemin": 0,
        "aria-valuemax": 100
      }, attributes);
      return super.createEl(type, props, attributes);
    }
    /**
     * Handle `mousedown` or `touchstart` events on the `Slider`.
     *
     * @param {MouseEvent} event
     *        `mousedown` or `touchstart` event that triggered this function
     *
     * @listens mousedown
     * @listens touchstart
     * @fires Slider#slideractive
     */
    handleMouseDown(event) {
      const doc = this.bar.el_.ownerDocument;
      if (event.type === "mousedown") {
        event.preventDefault();
      }
      if (event.type === "touchstart" && !IS_CHROME) {
        event.preventDefault();
      }
      blockTextSelection();
      this.addClass("vjs-sliding");
      this.trigger("slideractive");
      this.on(doc, "mousemove", this.handleMouseMove_);
      this.on(doc, "mouseup", this.handleMouseUp_);
      this.on(doc, "touchmove", this.handleMouseMove_);
      this.on(doc, "touchend", this.handleMouseUp_);
      this.handleMouseMove(event, true);
    }
    /**
     * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.
     * The `mousemove` and `touchmove` events will only only trigger this function during
     * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and
     * {@link Slider#handleMouseUp}.
     *
     * @param {MouseEvent} event
     *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered
     *        this function
     * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false.
     *
     * @listens mousemove
     * @listens touchmove
     */
    handleMouseMove(event) {
    }
    /**
     * Handle `mouseup` or `touchend` events on the `Slider`.
     *
     * @param {MouseEvent} event
     *        `mouseup` or `touchend` event that triggered this function.
     *
     * @listens touchend
     * @listens mouseup
     * @fires Slider#sliderinactive
     */
    handleMouseUp(event) {
      const doc = this.bar.el_.ownerDocument;
      unblockTextSelection();
      this.removeClass("vjs-sliding");
      this.trigger("sliderinactive");
      this.off(doc, "mousemove", this.handleMouseMove_);
      this.off(doc, "mouseup", this.handleMouseUp_);
      this.off(doc, "touchmove", this.handleMouseMove_);
      this.off(doc, "touchend", this.handleMouseUp_);
      this.update();
    }
    /**
     * Update the progress bar of the `Slider`.
     *
     * @return {number}
     *          The percentage of progress the progress bar represents as a
     *          number from 0 to 1.
     */
    update() {
      if (!this.el_ || !this.bar) {
        return;
      }
      const progress = this.getProgress();
      if (progress === this.progress_) {
        return progress;
      }
      this.progress_ = progress;
      this.requestNamedAnimationFrame("Slider#update", () => {
        const sizeKey = this.vertical() ? "height" : "width";
        this.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + "%";
      });
      return progress;
    }
    /**
     * Get the percentage of the bar that should be filled
     * but clamped and rounded.
     *
     * @return {number}
     *         percentage filled that the slider is
     */
    getProgress() {
      return Number(clamp(this.getPercent(), 0, 1).toFixed(4));
    }
    /**
     * Calculate distance for slider
     *
     * @param {Event} event
     *        The event that caused this function to run.
     *
     * @return {number}
     *         The current position of the Slider.
     *         - position.x for vertical `Slider`s
     *         - position.y for horizontal `Slider`s
     */
    calculateDistance(event) {
      const position2 = getPointerPosition(this.el_, event);
      if (this.vertical()) {
        return position2.y;
      }
      return position2.x;
    }
    /**
     * Handle a `keydown` event on the `Slider`. Watches for left, right, up, and down
     * arrow keys. This function will only be called when the slider has focus. See
     * {@link Slider#handleFocus} and {@link Slider#handleBlur}.
     *
     * @param {KeyboardEvent} event
     *        the `keydown` event that caused this function to run.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      if (keycode.isEventKey(event, "Left") || keycode.isEventKey(event, "Down")) {
        event.preventDefault();
        event.stopPropagation();
        this.stepBack();
      } else if (keycode.isEventKey(event, "Right") || keycode.isEventKey(event, "Up")) {
        event.preventDefault();
        event.stopPropagation();
        this.stepForward();
      } else {
        super.handleKeyDown(event);
      }
    }
    /**
     * Listener for click events on slider, used to prevent clicks
     *   from bubbling up to parent elements like button menus.
     *
     * @param {Object} event
     *        Event that caused this object to run
     */
    handleClick(event) {
      event.stopPropagation();
      event.preventDefault();
    }
    /**
     * Get/set if slider is horizontal for vertical
     *
     * @param {boolean} [bool]
     *        - true if slider is vertical,
     *        - false is horizontal
     *
     * @return {boolean}
     *         - true if slider is vertical, and getting
     *         - false if the slider is horizontal, and getting
     */
    vertical(bool) {
      if (bool === void 0) {
        return this.vertical_ || false;
      }
      this.vertical_ = !!bool;
      if (this.vertical_) {
        this.addClass("vjs-slider-vertical");
      } else {
        this.addClass("vjs-slider-horizontal");
      }
    }
  }
  Component$1.registerComponent("Slider", Slider);
  const percentify = (time, end) => clamp(time / end * 100, 0, 100).toFixed(2) + "%";
  class LoadProgressBar extends Component$1 {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.partEls_ = [];
      this.on(player, "progress", (e) => this.update(e));
    }
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const el = super.createEl("div", {
        className: "vjs-load-progress"
      });
      const wrapper = createEl("span", {
        className: "vjs-control-text"
      });
      const loadedText = createEl("span", {
        textContent: this.localize("Loaded")
      });
      const separator = document.createTextNode(": ");
      this.percentageEl_ = createEl("span", {
        className: "vjs-control-text-loaded-percentage",
        textContent: "0%"
      });
      el.appendChild(wrapper);
      wrapper.appendChild(loadedText);
      wrapper.appendChild(separator);
      wrapper.appendChild(this.percentageEl_);
      return el;
    }
    dispose() {
      this.partEls_ = null;
      this.percentageEl_ = null;
      super.dispose();
    }
    /**
     * Update progress bar
     *
     * @param {Event} [event]
     *        The `progress` event that caused this function to run.
     *
     * @listens Player#progress
     */
    update(event) {
      this.requestNamedAnimationFrame("LoadProgressBar#update", () => {
        const liveTracker = this.player_.liveTracker;
        const buffered = this.player_.buffered();
        const duration2 = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();
        const bufferedEnd = this.player_.bufferedEnd();
        const children = this.partEls_;
        const percent = percentify(bufferedEnd, duration2);
        if (this.percent_ !== percent) {
          this.el_.style.width = percent;
          textContent(this.percentageEl_, percent);
          this.percent_ = percent;
        }
        for (let i = 0; i < buffered.length; i++) {
          const start = buffered.start(i);
          const end = buffered.end(i);
          let part = children[i];
          if (!part) {
            part = this.el_.appendChild(createEl());
            children[i] = part;
          }
          if (part.dataset.start === start && part.dataset.end === end) {
            continue;
          }
          part.dataset.start = start;
          part.dataset.end = end;
          part.style.left = percentify(start, bufferedEnd);
          part.style.width = percentify(end - start, bufferedEnd);
        }
        for (let i = children.length; i > buffered.length; i--) {
          this.el_.removeChild(children[i - 1]);
        }
        children.length = buffered.length;
      });
    }
  }
  Component$1.registerComponent("LoadProgressBar", LoadProgressBar);
  class TimeTooltip extends Component$1 {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The {@link Player} that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
    }
    /**
     * Create the time tooltip DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl("div", {
        className: "vjs-time-tooltip"
      }, {
        "aria-hidden": "true"
      });
    }
    /**
     * Updates the position of the time tooltip relative to the `SeekBar`.
     *
     * @param {Object} seekBarRect
     *        The `ClientRect` for the {@link SeekBar} element.
     *
     * @param {number} seekBarPoint
     *        A number from 0 to 1, representing a horizontal reference point
     *        from the left edge of the {@link SeekBar}
     */
    update(seekBarRect, seekBarPoint, content) {
      const tooltipRect = findPosition(this.el_);
      const playerRect = getBoundingClientRect(this.player_.el());
      const seekBarPointPx = seekBarRect.width * seekBarPoint;
      if (!playerRect || !tooltipRect) {
        return;
      }
      const spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;
      const spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);
      let pullTooltipBy = tooltipRect.width / 2;
      if (spaceLeftOfPoint < pullTooltipBy) {
        pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
      } else if (spaceRightOfPoint < pullTooltipBy) {
        pullTooltipBy = spaceRightOfPoint;
      }
      if (pullTooltipBy < 0) {
        pullTooltipBy = 0;
      } else if (pullTooltipBy > tooltipRect.width) {
        pullTooltipBy = tooltipRect.width;
      }
      pullTooltipBy = Math.round(pullTooltipBy);
      this.el_.style.right = `-${pullTooltipBy}px`;
      this.write(content);
    }
    /**
     * Write the time to the tooltip DOM element.
     *
     * @param {string} content
     *        The formatted time for the tooltip.
     */
    write(content) {
      textContent(this.el_, content);
    }
    /**
     * Updates the position of the time tooltip relative to the `SeekBar`.
     *
     * @param {Object} seekBarRect
     *        The `ClientRect` for the {@link SeekBar} element.
     *
     * @param {number} seekBarPoint
     *        A number from 0 to 1, representing a horizontal reference point
     *        from the left edge of the {@link SeekBar}
     *
     * @param {number} time
     *        The time to update the tooltip to, not used during live playback
     *
     * @param {Function} cb
     *        A function that will be called during the request animation frame
     *        for tooltips that need to do additional animations from the default
     */
    updateTime(seekBarRect, seekBarPoint, time, cb) {
      this.requestNamedAnimationFrame("TimeTooltip#updateTime", () => {
        let content;
        const duration2 = this.player_.duration();
        if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
          const liveWindow = this.player_.liveTracker.liveWindow();
          const secondsBehind = liveWindow - seekBarPoint * liveWindow;
          content = (secondsBehind < 1 ? "" : "-") + formatTime(secondsBehind, liveWindow);
        } else {
          content = formatTime(time, duration2);
        }
        this.update(seekBarRect, seekBarPoint, content);
        if (cb) {
          cb();
        }
      });
    }
  }
  Component$1.registerComponent("TimeTooltip", TimeTooltip);
  class PlayProgressBar extends Component$1 {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The {@link Player} that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.setIcon("circle");
      this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
    }
    /**
     * Create the the DOM element for this class.
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl("div", {
        className: "vjs-play-progress vjs-slider-bar"
      }, {
        "aria-hidden": "true"
      });
    }
    /**
     * Enqueues updates to its own DOM as well as the DOM of its
     * {@link TimeTooltip} child.
     *
     * @param {Object} seekBarRect
     *        The `ClientRect` for the {@link SeekBar} element.
     *
     * @param {number} seekBarPoint
     *        A number from 0 to 1, representing a horizontal reference point
     *        from the left edge of the {@link SeekBar}
     */
    update(seekBarRect, seekBarPoint) {
      const timeTooltip = this.getChild("timeTooltip");
      if (!timeTooltip) {
        return;
      }
      const time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
      timeTooltip.updateTime(seekBarRect, seekBarPoint, time);
    }
  }
  PlayProgressBar.prototype.options_ = {
    children: []
  };
  if (!IS_IOS && !IS_ANDROID) {
    PlayProgressBar.prototype.options_.children.push("timeTooltip");
  }
  Component$1.registerComponent("PlayProgressBar", PlayProgressBar);
  class MouseTimeDisplay extends Component$1 {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The {@link Player} that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
    }
    /**
     * Create the DOM element for this class.
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl("div", {
        className: "vjs-mouse-display"
      });
    }
    /**
     * Enqueues updates to its own DOM as well as the DOM of its
     * {@link TimeTooltip} child.
     *
     * @param {Object} seekBarRect
     *        The `ClientRect` for the {@link SeekBar} element.
     *
     * @param {number} seekBarPoint
     *        A number from 0 to 1, representing a horizontal reference point
     *        from the left edge of the {@link SeekBar}
     */
    update(seekBarRect, seekBarPoint) {
      const time = seekBarPoint * this.player_.duration();
      this.getChild("timeTooltip").updateTime(seekBarRect, seekBarPoint, time, () => {
        this.el_.style.left = `${seekBarRect.width * seekBarPoint}px`;
      });
    }
  }
  MouseTimeDisplay.prototype.options_ = {
    children: ["timeTooltip"]
  };
  Component$1.registerComponent("MouseTimeDisplay", MouseTimeDisplay);
  const STEP_SECONDS = 5;
  const PAGE_KEY_MULTIPLIER = 12;
  class SeekBar extends Slider {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.setEventHandlers_();
    }
    /**
     * Sets the event handlers
     *
     * @private
     */
    setEventHandlers_() {
      this.update_ = bind_(this, this.update);
      this.update = throttle(this.update_, UPDATE_REFRESH_INTERVAL);
      this.on(this.player_, ["ended", "durationchange", "timeupdate"], this.update);
      if (this.player_.liveTracker) {
        this.on(this.player_.liveTracker, "liveedgechange", this.update);
      }
      this.updateInterval = null;
      this.enableIntervalHandler_ = (e) => this.enableInterval_(e);
      this.disableIntervalHandler_ = (e) => this.disableInterval_(e);
      this.on(this.player_, ["playing"], this.enableIntervalHandler_);
      this.on(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_);
      if ("hidden" in document && "visibilityState" in document) {
        this.on(document, "visibilitychange", this.toggleVisibility_);
      }
    }
    toggleVisibility_(e) {
      if (document.visibilityState === "hidden") {
        this.cancelNamedAnimationFrame("SeekBar#update");
        this.cancelNamedAnimationFrame("Slider#update");
        this.disableInterval_(e);
      } else {
        if (!this.player_.ended() && !this.player_.paused()) {
          this.enableInterval_();
        }
        this.update();
      }
    }
    enableInterval_() {
      if (this.updateInterval) {
        return;
      }
      this.updateInterval = this.setInterval(this.update, UPDATE_REFRESH_INTERVAL);
    }
    disableInterval_(e) {
      if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== "ended") {
        return;
      }
      if (!this.updateInterval) {
        return;
      }
      this.clearInterval(this.updateInterval);
      this.updateInterval = null;
    }
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl("div", {
        className: "vjs-progress-holder"
      }, {
        "aria-label": this.localize("Progress Bar")
      });
    }
    /**
     * This function updates the play progress bar and accessibility
     * attributes to whatever is passed in.
     *
     * @param {Event} [event]
     *        The `timeupdate` or `ended` event that caused this to run.
     *
     * @listens Player#timeupdate
     *
     * @return {number}
     *          The current percent at a number from 0-1
     */
    update(event) {
      if (document.visibilityState === "hidden") {
        return;
      }
      const percent = super.update();
      this.requestNamedAnimationFrame("SeekBar#update", () => {
        const currentTime = this.player_.ended() ? this.player_.duration() : this.getCurrentTime_();
        const liveTracker = this.player_.liveTracker;
        let duration2 = this.player_.duration();
        if (liveTracker && liveTracker.isLive()) {
          duration2 = this.player_.liveTracker.liveCurrentTime();
        }
        if (this.percent_ !== percent) {
          this.el_.setAttribute("aria-valuenow", (percent * 100).toFixed(2));
          this.percent_ = percent;
        }
        if (this.currentTime_ !== currentTime || this.duration_ !== duration2) {
          this.el_.setAttribute("aria-valuetext", this.localize("progress bar timing: currentTime={1} duration={2}", [formatTime(currentTime, duration2), formatTime(duration2, duration2)], "{1} of {2}"));
          this.currentTime_ = currentTime;
          this.duration_ = duration2;
        }
        if (this.bar) {
          this.bar.update(getBoundingClientRect(this.el()), this.getProgress());
        }
      });
      return percent;
    }
    /**
     * Prevent liveThreshold from causing seeks to seem like they
     * are not happening from a user perspective.
     *
     * @param {number} ct
     *        current time to seek to
     */
    userSeek_(ct) {
      if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
        this.player_.liveTracker.nextSeekedFromUser();
      }
      this.player_.currentTime(ct);
    }
    /**
     * Get the value of current time but allows for smooth scrubbing,
     * when player can't keep up.
     *
     * @return {number}
     *         The current time value to display
     *
     * @private
     */
    getCurrentTime_() {
      return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    }
    /**
     * Get the percentage of media played so far.
     *
     * @return {number}
     *         The percentage of media played so far (0 to 1).
     */
    getPercent() {
      const currentTime = this.getCurrentTime_();
      let percent;
      const liveTracker = this.player_.liveTracker;
      if (liveTracker && liveTracker.isLive()) {
        percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow();
        if (liveTracker.atLiveEdge()) {
          percent = 1;
        }
      } else {
        percent = currentTime / this.player_.duration();
      }
      return percent;
    }
    /**
     * Handle mouse down on seek bar
     *
     * @param {MouseEvent} event
     *        The `mousedown` event that caused this to run.
     *
     * @listens mousedown
     */
    handleMouseDown(event) {
      if (!isSingleLeftClick(event)) {
        return;
      }
      event.stopPropagation();
      this.videoWasPlaying = !this.player_.paused();
      this.player_.pause();
      super.handleMouseDown(event);
    }
    /**
     * Handle mouse move on seek bar
     *
     * @param {MouseEvent} event
     *        The `mousemove` event that caused this to run.
     * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false
     *
     * @listens mousemove
     */
    handleMouseMove(event, mouseDown = false) {
      if (!isSingleLeftClick(event) || isNaN(this.player_.duration())) {
        return;
      }
      if (!mouseDown && !this.player_.scrubbing()) {
        this.player_.scrubbing(true);
      }
      let newTime;
      const distance = this.calculateDistance(event);
      const liveTracker = this.player_.liveTracker;
      if (!liveTracker || !liveTracker.isLive()) {
        newTime = distance * this.player_.duration();
        if (newTime === this.player_.duration()) {
          newTime = newTime - 0.1;
        }
      } else {
        if (distance >= 0.99) {
          liveTracker.seekToLiveEdge();
          return;
        }
        const seekableStart = liveTracker.seekableStart();
        const seekableEnd = liveTracker.liveCurrentTime();
        newTime = seekableStart + distance * liveTracker.liveWindow();
        if (newTime >= seekableEnd) {
          newTime = seekableEnd;
        }
        if (newTime <= seekableStart) {
          newTime = seekableStart + 0.1;
        }
        if (newTime === Infinity) {
          return;
        }
      }
      this.userSeek_(newTime);
      if (this.player_.options_.enableSmoothSeeking) {
        this.update();
      }
    }
    enable() {
      super.enable();
      const mouseTimeDisplay = this.getChild("mouseTimeDisplay");
      if (!mouseTimeDisplay) {
        return;
      }
      mouseTimeDisplay.show();
    }
    disable() {
      super.disable();
      const mouseTimeDisplay = this.getChild("mouseTimeDisplay");
      if (!mouseTimeDisplay) {
        return;
      }
      mouseTimeDisplay.hide();
    }
    /**
     * Handle mouse up on seek bar
     *
     * @param {MouseEvent} event
     *        The `mouseup` event that caused this to run.
     *
     * @listens mouseup
     */
    handleMouseUp(event) {
      super.handleMouseUp(event);
      if (event) {
        event.stopPropagation();
      }
      this.player_.scrubbing(false);
      this.player_.trigger({
        type: "timeupdate",
        target: this,
        manuallyTriggered: true
      });
      if (this.videoWasPlaying) {
        silencePromise(this.player_.play());
      } else {
        this.update_();
      }
    }
    /**
     * Move more quickly fast forward for keyboard-only users
     */
    stepForward() {
      this.userSeek_(this.player_.currentTime() + STEP_SECONDS);
    }
    /**
     * Move more quickly rewind for keyboard-only users
     */
    stepBack() {
      this.userSeek_(this.player_.currentTime() - STEP_SECONDS);
    }
    /**
     * Toggles the playback state of the player
     * This gets called when enter or space is used on the seekbar
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called
     *
     */
    handleAction(event) {
      if (this.player_.paused()) {
        this.player_.play();
      } else {
        this.player_.pause();
      }
    }
    /**
     * Called when this SeekBar has focus and a key gets pressed down.
     * Supports the following keys:
     *
     *   Space or Enter key fire a click event
     *   Home key moves to start of the timeline
     *   End key moves to end of the timeline
     *   Digit "0" through "9" keys move to 0%, 10% ... 80%, 90% of the timeline
     *   PageDown key moves back a larger step than ArrowDown
     *   PageUp key moves forward a large step
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      const liveTracker = this.player_.liveTracker;
      if (keycode.isEventKey(event, "Space") || keycode.isEventKey(event, "Enter")) {
        event.preventDefault();
        event.stopPropagation();
        this.handleAction(event);
      } else if (keycode.isEventKey(event, "Home")) {
        event.preventDefault();
        event.stopPropagation();
        this.userSeek_(0);
      } else if (keycode.isEventKey(event, "End")) {
        event.preventDefault();
        event.stopPropagation();
        if (liveTracker && liveTracker.isLive()) {
          this.userSeek_(liveTracker.liveCurrentTime());
        } else {
          this.userSeek_(this.player_.duration());
        }
      } else if (/^[0-9]$/.test(keycode(event))) {
        event.preventDefault();
        event.stopPropagation();
        const gotoFraction = (keycode.codes[keycode(event)] - keycode.codes["0"]) * 10 / 100;
        if (liveTracker && liveTracker.isLive()) {
          this.userSeek_(liveTracker.seekableStart() + liveTracker.liveWindow() * gotoFraction);
        } else {
          this.userSeek_(this.player_.duration() * gotoFraction);
        }
      } else if (keycode.isEventKey(event, "PgDn")) {
        event.preventDefault();
        event.stopPropagation();
        this.userSeek_(this.player_.currentTime() - STEP_SECONDS * PAGE_KEY_MULTIPLIER);
      } else if (keycode.isEventKey(event, "PgUp")) {
        event.preventDefault();
        event.stopPropagation();
        this.userSeek_(this.player_.currentTime() + STEP_SECONDS * PAGE_KEY_MULTIPLIER);
      } else {
        super.handleKeyDown(event);
      }
    }
    dispose() {
      this.disableInterval_();
      this.off(this.player_, ["ended", "durationchange", "timeupdate"], this.update);
      if (this.player_.liveTracker) {
        this.off(this.player_.liveTracker, "liveedgechange", this.update);
      }
      this.off(this.player_, ["playing"], this.enableIntervalHandler_);
      this.off(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_);
      if ("hidden" in document && "visibilityState" in document) {
        this.off(document, "visibilitychange", this.toggleVisibility_);
      }
      super.dispose();
    }
  }
  SeekBar.prototype.options_ = {
    children: ["loadProgressBar", "playProgressBar"],
    barName: "playProgressBar"
  };
  if (!IS_IOS && !IS_ANDROID) {
    SeekBar.prototype.options_.children.splice(1, 0, "mouseTimeDisplay");
  }
  Component$1.registerComponent("SeekBar", SeekBar);
  class ProgressControl extends Component$1 {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.handleMouseMove = throttle(bind_(this, this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
      this.throttledHandleMouseSeek = throttle(bind_(this, this.handleMouseSeek), UPDATE_REFRESH_INTERVAL);
      this.handleMouseUpHandler_ = (e) => this.handleMouseUp(e);
      this.handleMouseDownHandler_ = (e) => this.handleMouseDown(e);
      this.enable();
    }
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl("div", {
        className: "vjs-progress-control vjs-control"
      });
    }
    /**
     * When the mouse moves over the `ProgressControl`, the pointer position
     * gets passed down to the `MouseTimeDisplay` component.
     *
     * @param {Event} event
     *        The `mousemove` event that caused this function to run.
     *
     * @listen mousemove
     */
    handleMouseMove(event) {
      const seekBar = this.getChild("seekBar");
      if (!seekBar) {
        return;
      }
      const playProgressBar = seekBar.getChild("playProgressBar");
      const mouseTimeDisplay = seekBar.getChild("mouseTimeDisplay");
      if (!playProgressBar && !mouseTimeDisplay) {
        return;
      }
      const seekBarEl = seekBar.el();
      const seekBarRect = findPosition(seekBarEl);
      let seekBarPoint = getPointerPosition(seekBarEl, event).x;
      seekBarPoint = clamp(seekBarPoint, 0, 1);
      if (mouseTimeDisplay) {
        mouseTimeDisplay.update(seekBarRect, seekBarPoint);
      }
      if (playProgressBar) {
        playProgressBar.update(seekBarRect, seekBar.getProgress());
      }
    }
    /**
     * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.
     *
     * @method ProgressControl#throttledHandleMouseSeek
     * @param {Event} event
     *        The `mousemove` event that caused this function to run.
     *
     * @listen mousemove
     * @listen touchmove
     */
    /**
     * Handle `mousemove` or `touchmove` events on the `ProgressControl`.
     *
     * @param {Event} event
     *        `mousedown` or `touchstart` event that triggered this function
     *
     * @listens mousemove
     * @listens touchmove
     */
    handleMouseSeek(event) {
      const seekBar = this.getChild("seekBar");
      if (seekBar) {
        seekBar.handleMouseMove(event);
      }
    }
    /**
     * Are controls are currently enabled for this progress control.
     *
     * @return {boolean}
     *         true if controls are enabled, false otherwise
     */
    enabled() {
      return this.enabled_;
    }
    /**
     * Disable all controls on the progress control and its children
     */
    disable() {
      this.children().forEach((child) => child.disable && child.disable());
      if (!this.enabled()) {
        return;
      }
      this.off(["mousedown", "touchstart"], this.handleMouseDownHandler_);
      this.off(this.el_, "mousemove", this.handleMouseMove);
      this.removeListenersAddedOnMousedownAndTouchstart();
      this.addClass("disabled");
      this.enabled_ = false;
      if (this.player_.scrubbing()) {
        const seekBar = this.getChild("seekBar");
        this.player_.scrubbing(false);
        if (seekBar.videoWasPlaying) {
          silencePromise(this.player_.play());
        }
      }
    }
    /**
     * Enable all controls on the progress control and its children
     */
    enable() {
      this.children().forEach((child) => child.enable && child.enable());
      if (this.enabled()) {
        return;
      }
      this.on(["mousedown", "touchstart"], this.handleMouseDownHandler_);
      this.on(this.el_, "mousemove", this.handleMouseMove);
      this.removeClass("disabled");
      this.enabled_ = true;
    }
    /**
     * Cleanup listeners after the user finishes interacting with the progress controls
     */
    removeListenersAddedOnMousedownAndTouchstart() {
      const doc = this.el_.ownerDocument;
      this.off(doc, "mousemove", this.throttledHandleMouseSeek);
      this.off(doc, "touchmove", this.throttledHandleMouseSeek);
      this.off(doc, "mouseup", this.handleMouseUpHandler_);
      this.off(doc, "touchend", this.handleMouseUpHandler_);
    }
    /**
     * Handle `mousedown` or `touchstart` events on the `ProgressControl`.
     *
     * @param {Event} event
     *        `mousedown` or `touchstart` event that triggered this function
     *
     * @listens mousedown
     * @listens touchstart
     */
    handleMouseDown(event) {
      const doc = this.el_.ownerDocument;
      const seekBar = this.getChild("seekBar");
      if (seekBar) {
        seekBar.handleMouseDown(event);
      }
      this.on(doc, "mousemove", this.throttledHandleMouseSeek);
      this.on(doc, "touchmove", this.throttledHandleMouseSeek);
      this.on(doc, "mouseup", this.handleMouseUpHandler_);
      this.on(doc, "touchend", this.handleMouseUpHandler_);
    }
    /**
     * Handle `mouseup` or `touchend` events on the `ProgressControl`.
     *
     * @param {Event} event
     *        `mouseup` or `touchend` event that triggered this function.
     *
     * @listens touchend
     * @listens mouseup
     */
    handleMouseUp(event) {
      const seekBar = this.getChild("seekBar");
      if (seekBar) {
        seekBar.handleMouseUp(event);
      }
      this.removeListenersAddedOnMousedownAndTouchstart();
    }
  }
  ProgressControl.prototype.options_ = {
    children: ["seekBar"]
  };
  Component$1.registerComponent("ProgressControl", ProgressControl);
  class PictureInPictureToggle extends Button {
    /**
     * Creates an instance of this class.
     *
     * @param { import('./player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @listens Player#enterpictureinpicture
     * @listens Player#leavepictureinpicture
     */
    constructor(player, options) {
      super(player, options);
      this.setIcon("picture-in-picture-enter");
      this.on(player, ["enterpictureinpicture", "leavepictureinpicture"], (e) => this.handlePictureInPictureChange(e));
      this.on(player, ["disablepictureinpicturechanged", "loadedmetadata"], (e) => this.handlePictureInPictureEnabledChange(e));
      this.on(player, ["loadedmetadata", "audioonlymodechange", "audiopostermodechange"], () => this.handlePictureInPictureAudioModeChange());
      this.disable();
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-picture-in-picture-control vjs-hidden ${super.buildCSSClass()}`;
    }
    /**
     * Displays or hides the button depending on the audio mode detection.
     * Exits picture-in-picture if it is enabled when switching to audio mode.
     */
    handlePictureInPictureAudioModeChange() {
      const isSourceAudio = this.player_.currentType().substring(0, 5) === "audio";
      const isAudioMode = isSourceAudio || this.player_.audioPosterMode() || this.player_.audioOnlyMode();
      if (!isAudioMode) {
        this.show();
        return;
      }
      if (this.player_.isInPictureInPicture()) {
        this.player_.exitPictureInPicture();
      }
      this.hide();
    }
    /**
     * Enables or disables button based on availability of a Picture-In-Picture mode.
     *
     * Enabled if
     * - `player.options().enableDocumentPictureInPicture` is true and
     *   window.documentPictureInPicture is available; or
     * - `player.disablePictureInPicture()` is false and
     *   element.requestPictureInPicture is available
     */
    handlePictureInPictureEnabledChange() {
      if (document.pictureInPictureEnabled && this.player_.disablePictureInPicture() === false || this.player_.options_.enableDocumentPictureInPicture && "documentPictureInPicture" in window) {
        this.enable();
      } else {
        this.disable();
      }
    }
    /**
     * Handles enterpictureinpicture and leavepictureinpicture on the player and change control text accordingly.
     *
     * @param {Event} [event]
     *        The {@link Player#enterpictureinpicture} or {@link Player#leavepictureinpicture} event that caused this function to be
     *        called.
     *
     * @listens Player#enterpictureinpicture
     * @listens Player#leavepictureinpicture
     */
    handlePictureInPictureChange(event) {
      if (this.player_.isInPictureInPicture()) {
        this.setIcon("picture-in-picture-exit");
        this.controlText("Exit Picture-in-Picture");
      } else {
        this.setIcon("picture-in-picture-enter");
        this.controlText("Picture-in-Picture");
      }
      this.handlePictureInPictureEnabledChange();
    }
    /**
     * This gets called when an `PictureInPictureToggle` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      if (!this.player_.isInPictureInPicture()) {
        this.player_.requestPictureInPicture();
      } else {
        this.player_.exitPictureInPicture();
      }
    }
    /**
     * Show the `Component`s element if it is hidden by removing the
     * 'vjs-hidden' class name from it only in browsers that support the Picture-in-Picture API.
     */
    show() {
      if (typeof document.exitPictureInPicture !== "function") {
        return;
      }
      super.show();
    }
  }
  PictureInPictureToggle.prototype.controlText_ = "Picture-in-Picture";
  Component$1.registerComponent("PictureInPictureToggle", PictureInPictureToggle);
  class FullscreenToggle extends Button {
    /**
     * Creates an instance of this class.
     *
     * @param { import('./player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.setIcon("fullscreen-enter");
      this.on(player, "fullscreenchange", (e) => this.handleFullscreenChange(e));
      if (document[player.fsApi_.fullscreenEnabled] === false) {
        this.disable();
      }
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-fullscreen-control ${super.buildCSSClass()}`;
    }
    /**
     * Handles fullscreenchange on the player and change control text accordingly.
     *
     * @param {Event} [event]
     *        The {@link Player#fullscreenchange} event that caused this function to be
     *        called.
     *
     * @listens Player#fullscreenchange
     */
    handleFullscreenChange(event) {
      if (this.player_.isFullscreen()) {
        this.controlText("Exit Fullscreen");
        this.setIcon("fullscreen-exit");
      } else {
        this.controlText("Fullscreen");
        this.setIcon("fullscreen-enter");
      }
    }
    /**
     * This gets called when an `FullscreenToggle` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      if (!this.player_.isFullscreen()) {
        this.player_.requestFullscreen();
      } else {
        this.player_.exitFullscreen();
      }
    }
  }
  FullscreenToggle.prototype.controlText_ = "Fullscreen";
  Component$1.registerComponent("FullscreenToggle", FullscreenToggle);
  const checkVolumeSupport = function(self2, player) {
    if (player.tech_ && !player.tech_.featuresVolumeControl) {
      self2.addClass("vjs-hidden");
    }
    self2.on(player, "loadstart", function() {
      if (!player.tech_.featuresVolumeControl) {
        self2.addClass("vjs-hidden");
      } else {
        self2.removeClass("vjs-hidden");
      }
    });
  };
  class VolumeLevel extends Component$1 {
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const el = super.createEl("div", {
        className: "vjs-volume-level"
      });
      this.setIcon("circle", el);
      el.appendChild(super.createEl("span", {
        className: "vjs-control-text"
      }));
      return el;
    }
  }
  Component$1.registerComponent("VolumeLevel", VolumeLevel);
  class VolumeLevelTooltip extends Component$1 {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The {@link Player} that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
    }
    /**
     * Create the volume tooltip DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl("div", {
        className: "vjs-volume-tooltip"
      }, {
        "aria-hidden": "true"
      });
    }
    /**
     * Updates the position of the tooltip relative to the `VolumeBar` and
     * its content text.
     *
     * @param {Object} rangeBarRect
     *        The `ClientRect` for the {@link VolumeBar} element.
     *
     * @param {number} rangeBarPoint
     *        A number from 0 to 1, representing a horizontal/vertical reference point
     *        from the left edge of the {@link VolumeBar}
     *
     * @param {boolean} vertical
     *        Referees to the Volume control position
     *        in the control bar{@link VolumeControl}
     *
     */
    update(rangeBarRect, rangeBarPoint, vertical, content) {
      if (!vertical) {
        const tooltipRect = getBoundingClientRect(this.el_);
        const playerRect = getBoundingClientRect(this.player_.el());
        const volumeBarPointPx = rangeBarRect.width * rangeBarPoint;
        if (!playerRect || !tooltipRect) {
          return;
        }
        const spaceLeftOfPoint = rangeBarRect.left - playerRect.left + volumeBarPointPx;
        const spaceRightOfPoint = rangeBarRect.width - volumeBarPointPx + (playerRect.right - rangeBarRect.right);
        let pullTooltipBy = tooltipRect.width / 2;
        if (spaceLeftOfPoint < pullTooltipBy) {
          pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
        } else if (spaceRightOfPoint < pullTooltipBy) {
          pullTooltipBy = spaceRightOfPoint;
        }
        if (pullTooltipBy < 0) {
          pullTooltipBy = 0;
        } else if (pullTooltipBy > tooltipRect.width) {
          pullTooltipBy = tooltipRect.width;
        }
        this.el_.style.right = `-${pullTooltipBy}px`;
      }
      this.write(`${content}%`);
    }
    /**
     * Write the volume to the tooltip DOM element.
     *
     * @param {string} content
     *        The formatted volume for the tooltip.
     */
    write(content) {
      textContent(this.el_, content);
    }
    /**
     * Updates the position of the volume tooltip relative to the `VolumeBar`.
     *
     * @param {Object} rangeBarRect
     *        The `ClientRect` for the {@link VolumeBar} element.
     *
     * @param {number} rangeBarPoint
     *        A number from 0 to 1, representing a horizontal/vertical reference point
     *        from the left edge of the {@link VolumeBar}
     *
     * @param {boolean} vertical
     *        Referees to the Volume control position
     *        in the control bar{@link VolumeControl}
     *
     * @param {number} volume
     *        The volume level to update the tooltip to
     *
     * @param {Function} cb
     *        A function that will be called during the request animation frame
     *        for tooltips that need to do additional animations from the default
     */
    updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, cb) {
      this.requestNamedAnimationFrame("VolumeLevelTooltip#updateVolume", () => {
        this.update(rangeBarRect, rangeBarPoint, vertical, volume.toFixed(0));
        if (cb) {
          cb();
        }
      });
    }
  }
  Component$1.registerComponent("VolumeLevelTooltip", VolumeLevelTooltip);
  class MouseVolumeLevelDisplay extends Component$1 {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The {@link Player} that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
    }
    /**
     * Create the DOM element for this class.
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl("div", {
        className: "vjs-mouse-display"
      });
    }
    /**
     * Enquires updates to its own DOM as well as the DOM of its
     * {@link VolumeLevelTooltip} child.
     *
     * @param {Object} rangeBarRect
     *        The `ClientRect` for the {@link VolumeBar} element.
     *
     * @param {number} rangeBarPoint
     *        A number from 0 to 1, representing a horizontal/vertical reference point
     *        from the left edge of the {@link VolumeBar}
     *
     * @param {boolean} vertical
     *        Referees to the Volume control position
     *        in the control bar{@link VolumeControl}
     *
     */
    update(rangeBarRect, rangeBarPoint, vertical) {
      const volume = 100 * rangeBarPoint;
      this.getChild("volumeLevelTooltip").updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, () => {
        if (vertical) {
          this.el_.style.bottom = `${rangeBarRect.height * rangeBarPoint}px`;
        } else {
          this.el_.style.left = `${rangeBarRect.width * rangeBarPoint}px`;
        }
      });
    }
  }
  MouseVolumeLevelDisplay.prototype.options_ = {
    children: ["volumeLevelTooltip"]
  };
  Component$1.registerComponent("MouseVolumeLevelDisplay", MouseVolumeLevelDisplay);
  class VolumeBar extends Slider {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.on("slideractive", (e) => this.updateLastVolume_(e));
      this.on(player, "volumechange", (e) => this.updateARIAAttributes(e));
      player.ready(() => this.updateARIAAttributes());
    }
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl("div", {
        className: "vjs-volume-bar vjs-slider-bar"
      }, {
        "aria-label": this.localize("Volume Level"),
        "aria-live": "polite"
      });
    }
    /**
     * Handle mouse down on volume bar
     *
     * @param {Event} event
     *        The `mousedown` event that caused this to run.
     *
     * @listens mousedown
     */
    handleMouseDown(event) {
      if (!isSingleLeftClick(event)) {
        return;
      }
      super.handleMouseDown(event);
    }
    /**
     * Handle movement events on the {@link VolumeMenuButton}.
     *
     * @param {Event} event
     *        The event that caused this function to run.
     *
     * @listens mousemove
     */
    handleMouseMove(event) {
      const mouseVolumeLevelDisplay = this.getChild("mouseVolumeLevelDisplay");
      if (mouseVolumeLevelDisplay) {
        const volumeBarEl = this.el();
        const volumeBarRect = getBoundingClientRect(volumeBarEl);
        const vertical = this.vertical();
        let volumeBarPoint = getPointerPosition(volumeBarEl, event);
        volumeBarPoint = vertical ? volumeBarPoint.y : volumeBarPoint.x;
        volumeBarPoint = clamp(volumeBarPoint, 0, 1);
        mouseVolumeLevelDisplay.update(volumeBarRect, volumeBarPoint, vertical);
      }
      if (!isSingleLeftClick(event)) {
        return;
      }
      this.checkMuted();
      this.player_.volume(this.calculateDistance(event));
    }
    /**
     * If the player is muted unmute it.
     */
    checkMuted() {
      if (this.player_.muted()) {
        this.player_.muted(false);
      }
    }
    /**
     * Get percent of volume level
     *
     * @return {number}
     *         Volume level percent as a decimal number.
     */
    getPercent() {
      if (this.player_.muted()) {
        return 0;
      }
      return this.player_.volume();
    }
    /**
     * Increase volume level for keyboard users
     */
    stepForward() {
      this.checkMuted();
      this.player_.volume(this.player_.volume() + 0.1);
    }
    /**
     * Decrease volume level for keyboard users
     */
    stepBack() {
      this.checkMuted();
      this.player_.volume(this.player_.volume() - 0.1);
    }
    /**
     * Update ARIA accessibility attributes
     *
     * @param {Event} [event]
     *        The `volumechange` event that caused this function to run.
     *
     * @listens Player#volumechange
     */
    updateARIAAttributes(event) {
      const ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();
      this.el_.setAttribute("aria-valuenow", ariaValue);
      this.el_.setAttribute("aria-valuetext", ariaValue + "%");
    }
    /**
     * Returns the current value of the player volume as a percentage
     *
     * @private
     */
    volumeAsPercentage_() {
      return Math.round(this.player_.volume() * 100);
    }
    /**
     * When user starts dragging the VolumeBar, store the volume and listen for
     * the end of the drag. When the drag ends, if the volume was set to zero,
     * set lastVolume to the stored volume.
     *
     * @listens slideractive
     * @private
     */
    updateLastVolume_() {
      const volumeBeforeDrag = this.player_.volume();
      this.one("sliderinactive", () => {
        if (this.player_.volume() === 0) {
          this.player_.lastVolume_(volumeBeforeDrag);
        }
      });
    }
  }
  VolumeBar.prototype.options_ = {
    children: ["volumeLevel"],
    barName: "volumeLevel"
  };
  if (!IS_IOS && !IS_ANDROID) {
    VolumeBar.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay");
  }
  VolumeBar.prototype.playerEvent = "volumechange";
  Component$1.registerComponent("VolumeBar", VolumeBar);
  class VolumeControl extends Component$1 {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options={}]
     *        The key/value store of player options.
     */
    constructor(player, options = {}) {
      options.vertical = options.vertical || false;
      if (typeof options.volumeBar === "undefined" || isPlain(options.volumeBar)) {
        options.volumeBar = options.volumeBar || {};
        options.volumeBar.vertical = options.vertical;
      }
      super(player, options);
      checkVolumeSupport(this, player);
      this.throttledHandleMouseMove = throttle(bind_(this, this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
      this.handleMouseUpHandler_ = (e) => this.handleMouseUp(e);
      this.on("mousedown", (e) => this.handleMouseDown(e));
      this.on("touchstart", (e) => this.handleMouseDown(e));
      this.on("mousemove", (e) => this.handleMouseMove(e));
      this.on(this.volumeBar, ["focus", "slideractive"], () => {
        this.volumeBar.addClass("vjs-slider-active");
        this.addClass("vjs-slider-active");
        this.trigger("slideractive");
      });
      this.on(this.volumeBar, ["blur", "sliderinactive"], () => {
        this.volumeBar.removeClass("vjs-slider-active");
        this.removeClass("vjs-slider-active");
        this.trigger("sliderinactive");
      });
    }
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      let orientationClass = "vjs-volume-horizontal";
      if (this.options_.vertical) {
        orientationClass = "vjs-volume-vertical";
      }
      return super.createEl("div", {
        className: `vjs-volume-control vjs-control ${orientationClass}`
      });
    }
    /**
     * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
     *
     * @param {Event} event
     *        `mousedown` or `touchstart` event that triggered this function
     *
     * @listens mousedown
     * @listens touchstart
     */
    handleMouseDown(event) {
      const doc = this.el_.ownerDocument;
      this.on(doc, "mousemove", this.throttledHandleMouseMove);
      this.on(doc, "touchmove", this.throttledHandleMouseMove);
      this.on(doc, "mouseup", this.handleMouseUpHandler_);
      this.on(doc, "touchend", this.handleMouseUpHandler_);
    }
    /**
     * Handle `mouseup` or `touchend` events on the `VolumeControl`.
     *
     * @param {Event} event
     *        `mouseup` or `touchend` event that triggered this function.
     *
     * @listens touchend
     * @listens mouseup
     */
    handleMouseUp(event) {
      const doc = this.el_.ownerDocument;
      this.off(doc, "mousemove", this.throttledHandleMouseMove);
      this.off(doc, "touchmove", this.throttledHandleMouseMove);
      this.off(doc, "mouseup", this.handleMouseUpHandler_);
      this.off(doc, "touchend", this.handleMouseUpHandler_);
    }
    /**
     * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
     *
     * @param {Event} event
     *        `mousedown` or `touchstart` event that triggered this function
     *
     * @listens mousedown
     * @listens touchstart
     */
    handleMouseMove(event) {
      this.volumeBar.handleMouseMove(event);
    }
  }
  VolumeControl.prototype.options_ = {
    children: ["volumeBar"]
  };
  Component$1.registerComponent("VolumeControl", VolumeControl);
  const checkMuteSupport = function(self2, player) {
    if (player.tech_ && !player.tech_.featuresMuteControl) {
      self2.addClass("vjs-hidden");
    }
    self2.on(player, "loadstart", function() {
      if (!player.tech_.featuresMuteControl) {
        self2.addClass("vjs-hidden");
      } else {
        self2.removeClass("vjs-hidden");
      }
    });
  };
  class MuteToggle extends Button {
    /**
     * Creates an instance of this class.
     *
     * @param { import('./player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      checkMuteSupport(this, player);
      this.on(player, ["loadstart", "volumechange"], (e) => this.update(e));
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-mute-control ${super.buildCSSClass()}`;
    }
    /**
     * This gets called when an `MuteToggle` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      const vol = this.player_.volume();
      const lastVolume = this.player_.lastVolume_();
      if (vol === 0) {
        const volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;
        this.player_.volume(volumeToSet);
        this.player_.muted(false);
      } else {
        this.player_.muted(this.player_.muted() ? false : true);
      }
    }
    /**
     * Update the `MuteToggle` button based on the state of `volume` and `muted`
     * on the player.
     *
     * @param {Event} [event]
     *        The {@link Player#loadstart} event if this function was called
     *        through an event.
     *
     * @listens Player#loadstart
     * @listens Player#volumechange
     */
    update(event) {
      this.updateIcon_();
      this.updateControlText_();
    }
    /**
     * Update the appearance of the `MuteToggle` icon.
     *
     * Possible states (given `level` variable below):
     * - 0: crossed out
     * - 1: zero bars of volume
     * - 2: one bar of volume
     * - 3: two bars of volume
     *
     * @private
     */
    updateIcon_() {
      const vol = this.player_.volume();
      let level = 3;
      this.setIcon("volume-high");
      if (IS_IOS && this.player_.tech_ && this.player_.tech_.el_) {
        this.player_.muted(this.player_.tech_.el_.muted);
      }
      if (vol === 0 || this.player_.muted()) {
        this.setIcon("volume-mute");
        level = 0;
      } else if (vol < 0.33) {
        this.setIcon("volume-low");
        level = 1;
      } else if (vol < 0.67) {
        this.setIcon("volume-medium");
        level = 2;
      }
      removeClass(this.el_, [0, 1, 2, 3].reduce((str, i) => str + `${i ? " " : ""}vjs-vol-${i}`, ""));
      addClass(this.el_, `vjs-vol-${level}`);
    }
    /**
     * If `muted` has changed on the player, update the control text
     * (`title` attribute on `vjs-mute-control` element and content of
     * `vjs-control-text` element).
     *
     * @private
     */
    updateControlText_() {
      const soundOff = this.player_.muted() || this.player_.volume() === 0;
      const text = soundOff ? "Unmute" : "Mute";
      if (this.controlText() !== text) {
        this.controlText(text);
      }
    }
  }
  MuteToggle.prototype.controlText_ = "Mute";
  Component$1.registerComponent("MuteToggle", MuteToggle);
  class VolumePanel extends Component$1 {
    /**
     * Creates an instance of this class.
     *
     * @param { import('./player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options={}]
     *        The key/value store of player options.
     */
    constructor(player, options = {}) {
      if (typeof options.inline !== "undefined") {
        options.inline = options.inline;
      } else {
        options.inline = true;
      }
      if (typeof options.volumeControl === "undefined" || isPlain(options.volumeControl)) {
        options.volumeControl = options.volumeControl || {};
        options.volumeControl.vertical = !options.inline;
      }
      super(player, options);
      this.handleKeyPressHandler_ = (e) => this.handleKeyPress(e);
      this.on(player, ["loadstart"], (e) => this.volumePanelState_(e));
      this.on(this.muteToggle, "keyup", (e) => this.handleKeyPress(e));
      this.on(this.volumeControl, "keyup", (e) => this.handleVolumeControlKeyUp(e));
      this.on("keydown", (e) => this.handleKeyPress(e));
      this.on("mouseover", (e) => this.handleMouseOver(e));
      this.on("mouseout", (e) => this.handleMouseOut(e));
      this.on(this.volumeControl, ["slideractive"], this.sliderActive_);
      this.on(this.volumeControl, ["sliderinactive"], this.sliderInactive_);
    }
    /**
     * Add vjs-slider-active class to the VolumePanel
     *
     * @listens VolumeControl#slideractive
     * @private
     */
    sliderActive_() {
      this.addClass("vjs-slider-active");
    }
    /**
     * Removes vjs-slider-active class to the VolumePanel
     *
     * @listens VolumeControl#sliderinactive
     * @private
     */
    sliderInactive_() {
      this.removeClass("vjs-slider-active");
    }
    /**
     * Adds vjs-hidden or vjs-mute-toggle-only to the VolumePanel
     * depending on MuteToggle and VolumeControl state
     *
     * @listens Player#loadstart
     * @private
     */
    volumePanelState_() {
      if (this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden")) {
        this.addClass("vjs-hidden");
      }
      if (this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden")) {
        this.addClass("vjs-mute-toggle-only");
      }
    }
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      let orientationClass = "vjs-volume-panel-horizontal";
      if (!this.options_.inline) {
        orientationClass = "vjs-volume-panel-vertical";
      }
      return super.createEl("div", {
        className: `vjs-volume-panel vjs-control ${orientationClass}`
      });
    }
    /**
     * Dispose of the `volume-panel` and all child components.
     */
    dispose() {
      this.handleMouseOut();
      super.dispose();
    }
    /**
     * Handles `keyup` events on the `VolumeControl`, looking for ESC, which closes
     * the volume panel and sets focus on `MuteToggle`.
     *
     * @param {Event} event
     *        The `keyup` event that caused this function to be called.
     *
     * @listens keyup
     */
    handleVolumeControlKeyUp(event) {
      if (keycode.isEventKey(event, "Esc")) {
        this.muteToggle.focus();
      }
    }
    /**
     * This gets called when a `VolumePanel` gains hover via a `mouseover` event.
     * Turns on listening for `mouseover` event. When they happen it
     * calls `this.handleMouseOver`.
     *
     * @param {Event} event
     *        The `mouseover` event that caused this function to be called.
     *
     * @listens mouseover
     */
    handleMouseOver(event) {
      this.addClass("vjs-hover");
      on(document, "keyup", this.handleKeyPressHandler_);
    }
    /**
     * This gets called when a `VolumePanel` gains hover via a `mouseout` event.
     * Turns on listening for `mouseout` event. When they happen it
     * calls `this.handleMouseOut`.
     *
     * @param {Event} event
     *        The `mouseout` event that caused this function to be called.
     *
     * @listens mouseout
     */
    handleMouseOut(event) {
      this.removeClass("vjs-hover");
      off(document, "keyup", this.handleKeyPressHandler_);
    }
    /**
     * Handles `keyup` event on the document or `keydown` event on the `VolumePanel`,
     * looking for ESC, which hides the `VolumeControl`.
     *
     * @param {Event} event
     *        The keypress that triggered this event.
     *
     * @listens keydown | keyup
     */
    handleKeyPress(event) {
      if (keycode.isEventKey(event, "Esc")) {
        this.handleMouseOut();
      }
    }
  }
  VolumePanel.prototype.options_ = {
    children: ["muteToggle", "volumeControl"]
  };
  Component$1.registerComponent("VolumePanel", VolumePanel);
  class SkipForward extends Button {
    constructor(player, options) {
      super(player, options);
      this.validOptions = [5, 10, 30];
      this.skipTime = this.getSkipForwardTime();
      if (this.skipTime && this.validOptions.includes(this.skipTime)) {
        this.setIcon(`forward-${this.skipTime}`);
        this.controlText(this.localize("Skip forward {1} seconds", [this.skipTime]));
        this.show();
      } else {
        this.hide();
      }
    }
    getSkipForwardTime() {
      const playerOptions = this.options_.playerOptions;
      return playerOptions.controlBar && playerOptions.controlBar.skipButtons && playerOptions.controlBar.skipButtons.forward;
    }
    buildCSSClass() {
      return `vjs-skip-forward-${this.getSkipForwardTime()} ${super.buildCSSClass()}`;
    }
    /**
     * On click, skips forward in the duration/seekable range by a configurable amount of seconds.
     * If the time left in the duration/seekable range is less than the configured 'skip forward' time,
     * skips to end of duration/seekable range.
     *
     * Handle a click on a `SkipForward` button
     *
     * @param {EventTarget~Event} event
     *        The `click` event that caused this function
     *        to be called
     */
    handleClick(event) {
      if (isNaN(this.player_.duration())) {
        return;
      }
      const currentVideoTime = this.player_.currentTime();
      const liveTracker = this.player_.liveTracker;
      const duration2 = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();
      let newTime;
      if (currentVideoTime + this.skipTime <= duration2) {
        newTime = currentVideoTime + this.skipTime;
      } else {
        newTime = duration2;
      }
      this.player_.currentTime(newTime);
    }
    /**
     * Update control text on languagechange
     */
    handleLanguagechange() {
      this.controlText(this.localize("Skip forward {1} seconds", [this.skipTime]));
    }
  }
  SkipForward.prototype.controlText_ = "Skip Forward";
  Component$1.registerComponent("SkipForward", SkipForward);
  class SkipBackward extends Button {
    constructor(player, options) {
      super(player, options);
      this.validOptions = [5, 10, 30];
      this.skipTime = this.getSkipBackwardTime();
      if (this.skipTime && this.validOptions.includes(this.skipTime)) {
        this.setIcon(`replay-${this.skipTime}`);
        this.controlText(this.localize("Skip backward {1} seconds", [this.skipTime]));
        this.show();
      } else {
        this.hide();
      }
    }
    getSkipBackwardTime() {
      const playerOptions = this.options_.playerOptions;
      return playerOptions.controlBar && playerOptions.controlBar.skipButtons && playerOptions.controlBar.skipButtons.backward;
    }
    buildCSSClass() {
      return `vjs-skip-backward-${this.getSkipBackwardTime()} ${super.buildCSSClass()}`;
    }
    /**
     * On click, skips backward in the video by a configurable amount of seconds.
     * If the current time in the video is less than the configured 'skip backward' time,
     * skips to beginning of video or seekable range.
     *
     * Handle a click on a `SkipBackward` button
     *
     * @param {EventTarget~Event} event
     *        The `click` event that caused this function
     *        to be called
     */
    handleClick(event) {
      const currentVideoTime = this.player_.currentTime();
      const liveTracker = this.player_.liveTracker;
      const seekableStart = liveTracker && liveTracker.isLive() && liveTracker.seekableStart();
      let newTime;
      if (seekableStart && currentVideoTime - this.skipTime <= seekableStart) {
        newTime = seekableStart;
      } else if (currentVideoTime >= this.skipTime) {
        newTime = currentVideoTime - this.skipTime;
      } else {
        newTime = 0;
      }
      this.player_.currentTime(newTime);
    }
    /**
     * Update control text on languagechange
     */
    handleLanguagechange() {
      this.controlText(this.localize("Skip backward {1} seconds", [this.skipTime]));
    }
  }
  SkipBackward.prototype.controlText_ = "Skip Backward";
  Component$1.registerComponent("SkipBackward", SkipBackward);
  class Menu extends Component$1 {
    /**
     * Create an instance of this class.
     *
     * @param { import('../player').default } player
     *        the player that this component should attach to
     *
     * @param {Object} [options]
     *        Object of option names and values
     *
     */
    constructor(player, options) {
      super(player, options);
      if (options) {
        this.menuButton_ = options.menuButton;
      }
      this.focusedChild_ = -1;
      this.on("keydown", (e) => this.handleKeyDown(e));
      this.boundHandleBlur_ = (e) => this.handleBlur(e);
      this.boundHandleTapClick_ = (e) => this.handleTapClick(e);
    }
    /**
     * Add event listeners to the {@link MenuItem}.
     *
     * @param {Object} component
     *        The instance of the `MenuItem` to add listeners to.
     *
     */
    addEventListenerForItem(component) {
      if (!(component instanceof Component$1)) {
        return;
      }
      this.on(component, "blur", this.boundHandleBlur_);
      this.on(component, ["tap", "click"], this.boundHandleTapClick_);
    }
    /**
     * Remove event listeners from the {@link MenuItem}.
     *
     * @param {Object} component
     *        The instance of the `MenuItem` to remove listeners.
     *
     */
    removeEventListenerForItem(component) {
      if (!(component instanceof Component$1)) {
        return;
      }
      this.off(component, "blur", this.boundHandleBlur_);
      this.off(component, ["tap", "click"], this.boundHandleTapClick_);
    }
    /**
     * This method will be called indirectly when the component has been added
     * before the component adds to the new menu instance by `addItem`.
     * In this case, the original menu instance will remove the component
     * by calling `removeChild`.
     *
     * @param {Object} component
     *        The instance of the `MenuItem`
     */
    removeChild(component) {
      if (typeof component === "string") {
        component = this.getChild(component);
      }
      this.removeEventListenerForItem(component);
      super.removeChild(component);
    }
    /**
     * Add a {@link MenuItem} to the menu.
     *
     * @param {Object|string} component
     *        The name or instance of the `MenuItem` to add.
     *
     */
    addItem(component) {
      const childComponent = this.addChild(component);
      if (childComponent) {
        this.addEventListenerForItem(childComponent);
      }
    }
    /**
     * Create the `Menu`s DOM element.
     *
     * @return {Element}
     *         the element that was created
     */
    createEl() {
      const contentElType = this.options_.contentElType || "ul";
      this.contentEl_ = createEl(contentElType, {
        className: "vjs-menu-content"
      });
      this.contentEl_.setAttribute("role", "menu");
      const el = super.createEl("div", {
        append: this.contentEl_,
        className: "vjs-menu"
      });
      el.appendChild(this.contentEl_);
      on(el, "click", function(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
      });
      return el;
    }
    dispose() {
      this.contentEl_ = null;
      this.boundHandleBlur_ = null;
      this.boundHandleTapClick_ = null;
      super.dispose();
    }
    /**
     * Called when a `MenuItem` loses focus.
     *
     * @param {Event} event
     *        The `blur` event that caused this function to be called.
     *
     * @listens blur
     */
    handleBlur(event) {
      const relatedTarget = event.relatedTarget || document.activeElement;
      if (!this.children().some((element) => {
        return element.el() === relatedTarget;
      })) {
        const btn = this.menuButton_;
        if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) {
          btn.unpressButton();
        }
      }
    }
    /**
     * Called when a `MenuItem` gets clicked or tapped.
     *
     * @param {Event} event
     *        The `click` or `tap` event that caused this function to be called.
     *
     * @listens click,tap
     */
    handleTapClick(event) {
      if (this.menuButton_) {
        this.menuButton_.unpressButton();
        const childComponents = this.children();
        if (!Array.isArray(childComponents)) {
          return;
        }
        const foundComponent = childComponents.filter((component) => component.el() === event.target)[0];
        if (!foundComponent) {
          return;
        }
        if (foundComponent.name() !== "CaptionSettingsMenuItem") {
          this.menuButton_.focus();
        }
      }
    }
    /**
     * Handle a `keydown` event on this menu. This listener is added in the constructor.
     *
     * @param {KeyboardEvent} event
     *        A `keydown` event that happened on the menu.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      if (keycode.isEventKey(event, "Left") || keycode.isEventKey(event, "Down")) {
        event.preventDefault();
        event.stopPropagation();
        this.stepForward();
      } else if (keycode.isEventKey(event, "Right") || keycode.isEventKey(event, "Up")) {
        event.preventDefault();
        event.stopPropagation();
        this.stepBack();
      }
    }
    /**
     * Move to next (lower) menu item for keyboard users.
     */
    stepForward() {
      let stepChild = 0;
      if (this.focusedChild_ !== void 0) {
        stepChild = this.focusedChild_ + 1;
      }
      this.focus(stepChild);
    }
    /**
     * Move to previous (higher) menu item for keyboard users.
     */
    stepBack() {
      let stepChild = 0;
      if (this.focusedChild_ !== void 0) {
        stepChild = this.focusedChild_ - 1;
      }
      this.focus(stepChild);
    }
    /**
     * Set focus on a {@link MenuItem} in the `Menu`.
     *
     * @param {Object|string} [item=0]
     *        Index of child item set focus on.
     */
    focus(item = 0) {
      const children = this.children().slice();
      const haveTitle = children.length && children[0].hasClass("vjs-menu-title");
      if (haveTitle) {
        children.shift();
      }
      if (children.length > 0) {
        if (item < 0) {
          item = 0;
        } else if (item >= children.length) {
          item = children.length - 1;
        }
        this.focusedChild_ = item;
        children[item].el_.focus();
      }
    }
  }
  Component$1.registerComponent("Menu", Menu);
  class MenuButton extends Component$1 {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options={}]
     *        The key/value store of player options.
     */
    constructor(player, options = {}) {
      super(player, options);
      this.menuButton_ = new Button(player, options);
      this.menuButton_.controlText(this.controlText_);
      this.menuButton_.el_.setAttribute("aria-haspopup", "true");
      const buttonClass = Button.prototype.buildCSSClass();
      this.menuButton_.el_.className = this.buildCSSClass() + " " + buttonClass;
      this.menuButton_.removeClass("vjs-control");
      this.addChild(this.menuButton_);
      this.update();
      this.enabled_ = true;
      const handleClick = (e) => this.handleClick(e);
      this.handleMenuKeyUp_ = (e) => this.handleMenuKeyUp(e);
      this.on(this.menuButton_, "tap", handleClick);
      this.on(this.menuButton_, "click", handleClick);
      this.on(this.menuButton_, "keydown", (e) => this.handleKeyDown(e));
      this.on(this.menuButton_, "mouseenter", () => {
        this.addClass("vjs-hover");
        this.menu.show();
        on(document, "keyup", this.handleMenuKeyUp_);
      });
      this.on("mouseleave", (e) => this.handleMouseLeave(e));
      this.on("keydown", (e) => this.handleSubmenuKeyDown(e));
    }
    /**
     * Update the menu based on the current state of its items.
     */
    update() {
      const menu = this.createMenu();
      if (this.menu) {
        this.menu.dispose();
        this.removeChild(this.menu);
      }
      this.menu = menu;
      this.addChild(menu);
      this.buttonPressed_ = false;
      this.menuButton_.el_.setAttribute("aria-expanded", "false");
      if (this.items && this.items.length <= this.hideThreshold_) {
        this.hide();
        this.menu.contentEl_.removeAttribute("role");
      } else {
        this.show();
        this.menu.contentEl_.setAttribute("role", "menu");
      }
    }
    /**
     * Create the menu and add all items to it.
     *
     * @return {Menu}
     *         The constructed menu
     */
    createMenu() {
      const menu = new Menu(this.player_, {
        menuButton: this
      });
      this.hideThreshold_ = 0;
      if (this.options_.title) {
        const titleEl = createEl("li", {
          className: "vjs-menu-title",
          textContent: toTitleCase$1(this.options_.title),
          tabIndex: -1
        });
        const titleComponent = new Component$1(this.player_, {
          el: titleEl
        });
        menu.addItem(titleComponent);
      }
      this.items = this.createItems();
      if (this.items) {
        for (let i = 0; i < this.items.length; i++) {
          menu.addItem(this.items[i]);
        }
      }
      return menu;
    }
    /**
     * Create the list of menu items. Specific to each subclass.
     *
     * @abstract
     */
    createItems() {
    }
    /**
     * Create the `MenuButtons`s DOM element.
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl() {
      return super.createEl("div", {
        className: this.buildWrapperCSSClass()
      }, {});
    }
    /**
     * Overwrites the `setIcon` method from `Component`.
     * In this case, we want the icon to be appended to the menuButton.
     *
     * @param {string} name
     *         The icon name to be added.
     */
    setIcon(name) {
      super.setIcon(name, this.menuButton_.el_);
    }
    /**
     * Allow sub components to stack CSS class names for the wrapper element
     *
     * @return {string}
     *         The constructed wrapper DOM `className`
     */
    buildWrapperCSSClass() {
      let menuButtonClass = "vjs-menu-button";
      if (this.options_.inline === true) {
        menuButtonClass += "-inline";
      } else {
        menuButtonClass += "-popup";
      }
      const buttonClass = Button.prototype.buildCSSClass();
      return `vjs-menu-button ${menuButtonClass} ${buttonClass} ${super.buildCSSClass()}`;
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      let menuButtonClass = "vjs-menu-button";
      if (this.options_.inline === true) {
        menuButtonClass += "-inline";
      } else {
        menuButtonClass += "-popup";
      }
      return `vjs-menu-button ${menuButtonClass} ${super.buildCSSClass()}`;
    }
    /**
     * Get or set the localized control text that will be used for accessibility.
     *
     * > NOTE: This will come from the internal `menuButton_` element.
     *
     * @param {string} [text]
     *        Control text for element.
     *
     * @param {Element} [el=this.menuButton_.el()]
     *        Element to set the title on.
     *
     * @return {string}
     *         - The control text when getting
     */
    controlText(text, el = this.menuButton_.el()) {
      return this.menuButton_.controlText(text, el);
    }
    /**
     * Dispose of the `menu-button` and all child components.
     */
    dispose() {
      this.handleMouseLeave();
      super.dispose();
    }
    /**
     * Handle a click on a `MenuButton`.
     * See {@link ClickableComponent#handleClick} for instances where this is called.
     *
     * @param {Event} event
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      if (this.buttonPressed_) {
        this.unpressButton();
      } else {
        this.pressButton();
      }
    }
    /**
     * Handle `mouseleave` for `MenuButton`.
     *
     * @param {Event} event
     *        The `mouseleave` event that caused this function to be called.
     *
     * @listens mouseleave
     */
    handleMouseLeave(event) {
      this.removeClass("vjs-hover");
      off(document, "keyup", this.handleMenuKeyUp_);
    }
    /**
     * Set the focus to the actual button, not to this element
     */
    focus() {
      this.menuButton_.focus();
    }
    /**
     * Remove the focus from the actual button, not this element
     */
    blur() {
      this.menuButton_.blur();
    }
    /**
     * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See
     * {@link ClickableComponent#handleKeyDown} for instances where this is called.
     *
     * @param {Event} event
     *        The `keydown` event that caused this function to be called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      if (keycode.isEventKey(event, "Esc") || keycode.isEventKey(event, "Tab")) {
        if (this.buttonPressed_) {
          this.unpressButton();
        }
        if (!keycode.isEventKey(event, "Tab")) {
          event.preventDefault();
          this.menuButton_.focus();
        }
      } else if (keycode.isEventKey(event, "Up") || keycode.isEventKey(event, "Down")) {
        if (!this.buttonPressed_) {
          event.preventDefault();
          this.pressButton();
        }
      }
    }
    /**
     * Handle a `keyup` event on a `MenuButton`. The listener for this is added in
     * the constructor.
     *
     * @param {Event} event
     *        Key press event
     *
     * @listens keyup
     */
    handleMenuKeyUp(event) {
      if (keycode.isEventKey(event, "Esc") || keycode.isEventKey(event, "Tab")) {
        this.removeClass("vjs-hover");
      }
    }
    /**
     * This method name now delegates to `handleSubmenuKeyDown`. This means
     * anyone calling `handleSubmenuKeyPress` will not see their method calls
     * stop working.
     *
     * @param {Event} event
     *        The event that caused this function to be called.
     */
    handleSubmenuKeyPress(event) {
      this.handleSubmenuKeyDown(event);
    }
    /**
     * Handle a `keydown` event on a sub-menu. The listener for this is added in
     * the constructor.
     *
     * @param {Event} event
     *        Key press event
     *
     * @listens keydown
     */
    handleSubmenuKeyDown(event) {
      if (keycode.isEventKey(event, "Esc") || keycode.isEventKey(event, "Tab")) {
        if (this.buttonPressed_) {
          this.unpressButton();
        }
        if (!keycode.isEventKey(event, "Tab")) {
          event.preventDefault();
          this.menuButton_.focus();
        }
      }
    }
    /**
     * Put the current `MenuButton` into a pressed state.
     */
    pressButton() {
      if (this.enabled_) {
        this.buttonPressed_ = true;
        this.menu.show();
        this.menu.lockShowing();
        this.menuButton_.el_.setAttribute("aria-expanded", "true");
        if (IS_IOS && isInFrame()) {
          return;
        }
        this.menu.focus();
      }
    }
    /**
     * Take the current `MenuButton` out of a pressed state.
     */
    unpressButton() {
      if (this.enabled_) {
        this.buttonPressed_ = false;
        this.menu.unlockShowing();
        this.menu.hide();
        this.menuButton_.el_.setAttribute("aria-expanded", "false");
      }
    }
    /**
     * Disable the `MenuButton`. Don't allow it to be clicked.
     */
    disable() {
      this.unpressButton();
      this.enabled_ = false;
      this.addClass("vjs-disabled");
      this.menuButton_.disable();
    }
    /**
     * Enable the `MenuButton`. Allow it to be clicked.
     */
    enable() {
      this.enabled_ = true;
      this.removeClass("vjs-disabled");
      this.menuButton_.enable();
    }
  }
  Component$1.registerComponent("MenuButton", MenuButton);
  class TrackButton extends MenuButton {
    /**
     * Creates an instance of this class.
     *
     * @param { import('./player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      const tracks = options.tracks;
      super(player, options);
      if (this.items.length <= 1) {
        this.hide();
      }
      if (!tracks) {
        return;
      }
      const updateHandler = bind_(this, this.update);
      tracks.addEventListener("removetrack", updateHandler);
      tracks.addEventListener("addtrack", updateHandler);
      tracks.addEventListener("labelchange", updateHandler);
      this.player_.on("ready", updateHandler);
      this.player_.on("dispose", function() {
        tracks.removeEventListener("removetrack", updateHandler);
        tracks.removeEventListener("addtrack", updateHandler);
        tracks.removeEventListener("labelchange", updateHandler);
      });
    }
  }
  Component$1.registerComponent("TrackButton", TrackButton);
  const MenuKeys = ["Tab", "Esc", "Up", "Down", "Right", "Left"];
  class MenuItem extends ClickableComponent {
    /**
     * Creates an instance of the this class.
     *
     * @param { import('../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options={}]
     *        The key/value store of player options.
     *
     */
    constructor(player, options) {
      super(player, options);
      this.selectable = options.selectable;
      this.isSelected_ = options.selected || false;
      this.multiSelectable = options.multiSelectable;
      this.selected(this.isSelected_);
      if (this.selectable) {
        if (this.multiSelectable) {
          this.el_.setAttribute("role", "menuitemcheckbox");
        } else {
          this.el_.setAttribute("role", "menuitemradio");
        }
      } else {
        this.el_.setAttribute("role", "menuitem");
      }
    }
    /**
     * Create the `MenuItem's DOM element
     *
     * @param {string} [type=li]
     *        Element's node type, not actually used, always set to `li`.
     *
     * @param {Object} [props={}]
     *        An object of properties that should be set on the element
     *
     * @param {Object} [attrs={}]
     *        An object of attributes that should be set on the element
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl(type, props, attrs) {
      this.nonIconControl = true;
      const el = super.createEl("li", Object.assign({
        className: "vjs-menu-item",
        tabIndex: -1
      }, props), attrs);
      const menuItemEl = createEl("span", {
        className: "vjs-menu-item-text",
        textContent: this.localize(this.options_.label)
      });
      if (this.player_.options_.experimentalSvgIcons) {
        el.appendChild(menuItemEl);
      } else {
        el.replaceChild(menuItemEl, el.querySelector(".vjs-icon-placeholder"));
      }
      return el;
    }
    /**
     * Ignore keys which are used by the menu, but pass any other ones up. See
     * {@link ClickableComponent#handleKeyDown} for instances where this is called.
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      if (!MenuKeys.some((key) => keycode.isEventKey(event, key))) {
        super.handleKeyDown(event);
      }
    }
    /**
     * Any click on a `MenuItem` puts it into the selected state.
     * See {@link ClickableComponent#handleClick} for instances where this is called.
     *
     * @param {Event} event
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      this.selected(true);
    }
    /**
     * Set the state for this menu item as selected or not.
     *
     * @param {boolean} selected
     *        if the menu item is selected or not
     */
    selected(selected) {
      if (this.selectable) {
        if (selected) {
          this.addClass("vjs-selected");
          this.el_.setAttribute("aria-checked", "true");
          this.controlText(", selected");
          this.isSelected_ = true;
        } else {
          this.removeClass("vjs-selected");
          this.el_.setAttribute("aria-checked", "false");
          this.controlText("");
          this.isSelected_ = false;
        }
      }
    }
  }
  Component$1.registerComponent("MenuItem", MenuItem);
  class TextTrackMenuItem extends MenuItem {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      const track = options.track;
      const tracks = player.textTracks();
      options.label = track.label || track.language || "Unknown";
      options.selected = track.mode === "showing";
      super(player, options);
      this.track = track;
      this.kinds = (options.kinds || [options.kind || this.track.kind]).filter(Boolean);
      const changeHandler = (...args) => {
        this.handleTracksChange.apply(this, args);
      };
      const selectedLanguageChangeHandler = (...args) => {
        this.handleSelectedLanguageChange.apply(this, args);
      };
      player.on(["loadstart", "texttrackchange"], changeHandler);
      tracks.addEventListener("change", changeHandler);
      tracks.addEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
      this.on("dispose", function() {
        player.off(["loadstart", "texttrackchange"], changeHandler);
        tracks.removeEventListener("change", changeHandler);
        tracks.removeEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
      });
      if (tracks.onchange === void 0) {
        let event;
        this.on(["tap", "click"], function() {
          if (typeof window.Event !== "object") {
            try {
              event = new window.Event("change");
            } catch (err) {
            }
          }
          if (!event) {
            event = document.createEvent("Event");
            event.initEvent("change", true, true);
          }
          tracks.dispatchEvent(event);
        });
      }
      this.handleTracksChange();
    }
    /**
     * This gets called when an `TextTrackMenuItem` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} event
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      const referenceTrack = this.track;
      const tracks = this.player_.textTracks();
      super.handleClick(event);
      if (!tracks) {
        return;
      }
      for (let i = 0; i < tracks.length; i++) {
        const track = tracks[i];
        if (this.kinds.indexOf(track.kind) === -1) {
          continue;
        }
        if (track === referenceTrack) {
          if (track.mode !== "showing") {
            track.mode = "showing";
          }
        } else if (track.mode !== "disabled") {
          track.mode = "disabled";
        }
      }
    }
    /**
     * Handle text track list change
     *
     * @param {Event} event
     *        The `change` event that caused this function to be called.
     *
     * @listens TextTrackList#change
     */
    handleTracksChange(event) {
      const shouldBeSelected = this.track.mode === "showing";
      if (shouldBeSelected !== this.isSelected_) {
        this.selected(shouldBeSelected);
      }
    }
    handleSelectedLanguageChange(event) {
      if (this.track.mode === "showing") {
        const selectedLanguage = this.player_.cache_.selectedLanguage;
        if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {
          return;
        }
        this.player_.cache_.selectedLanguage = {
          enabled: true,
          language: this.track.language,
          kind: this.track.kind
        };
      }
    }
    dispose() {
      this.track = null;
      super.dispose();
    }
  }
  Component$1.registerComponent("TextTrackMenuItem", TextTrackMenuItem);
  class OffTextTrackMenuItem extends TextTrackMenuItem {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      options.track = {
        player,
        // it is no longer necessary to store `kind` or `kinds` on the track itself
        // since they are now stored in the `kinds` property of all instances of
        // TextTrackMenuItem, but this will remain for backwards compatibility
        kind: options.kind,
        kinds: options.kinds,
        default: false,
        mode: "disabled"
      };
      if (!options.kinds) {
        options.kinds = [options.kind];
      }
      if (options.label) {
        options.track.label = options.label;
      } else {
        options.track.label = options.kinds.join(" and ") + " off";
      }
      options.selectable = true;
      options.multiSelectable = false;
      super(player, options);
    }
    /**
     * Handle text track change
     *
     * @param {Event} event
     *        The event that caused this function to run
     */
    handleTracksChange(event) {
      const tracks = this.player().textTracks();
      let shouldBeSelected = true;
      for (let i = 0, l = tracks.length; i < l; i++) {
        const track = tracks[i];
        if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === "showing") {
          shouldBeSelected = false;
          break;
        }
      }
      if (shouldBeSelected !== this.isSelected_) {
        this.selected(shouldBeSelected);
      }
    }
    handleSelectedLanguageChange(event) {
      const tracks = this.player().textTracks();
      let allHidden = true;
      for (let i = 0, l = tracks.length; i < l; i++) {
        const track = tracks[i];
        if (["captions", "descriptions", "subtitles"].indexOf(track.kind) > -1 && track.mode === "showing") {
          allHidden = false;
          break;
        }
      }
      if (allHidden) {
        this.player_.cache_.selectedLanguage = {
          enabled: false
        };
      }
    }
    /**
     * Update control text and label on languagechange
     */
    handleLanguagechange() {
      this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.label);
      super.handleLanguagechange();
    }
  }
  Component$1.registerComponent("OffTextTrackMenuItem", OffTextTrackMenuItem);
  class TextTrackButton extends TrackButton {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options={}]
     *        The key/value store of player options.
     */
    constructor(player, options = {}) {
      options.tracks = player.textTracks();
      super(player, options);
    }
    /**
     * Create a menu item for each text track
     *
     * @param {TextTrackMenuItem[]} [items=[]]
     *        Existing array of items to use during creation
     *
     * @return {TextTrackMenuItem[]}
     *         Array of menu items that were created
     */
    createItems(items = [], TrackMenuItem = TextTrackMenuItem) {
      let label;
      if (this.label_) {
        label = `${this.label_} off`;
      }
      items.push(new OffTextTrackMenuItem(this.player_, {
        kinds: this.kinds_,
        kind: this.kind_,
        label
      }));
      this.hideThreshold_ += 1;
      const tracks = this.player_.textTracks();
      if (!Array.isArray(this.kinds_)) {
        this.kinds_ = [this.kind_];
      }
      for (let i = 0; i < tracks.length; i++) {
        const track = tracks[i];
        if (this.kinds_.indexOf(track.kind) > -1) {
          const item = new TrackMenuItem(this.player_, {
            track,
            kinds: this.kinds_,
            kind: this.kind_,
            // MenuItem is selectable
            selectable: true,
            // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
            multiSelectable: false
          });
          item.addClass(`vjs-${track.kind}-menu-item`);
          items.push(item);
        }
      }
      return items;
    }
  }
  Component$1.registerComponent("TextTrackButton", TextTrackButton);
  class ChaptersTrackMenuItem extends MenuItem {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      const track = options.track;
      const cue = options.cue;
      const currentTime = player.currentTime();
      options.selectable = true;
      options.multiSelectable = false;
      options.label = cue.text;
      options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;
      super(player, options);
      this.track = track;
      this.cue = cue;
    }
    /**
     * This gets called when an `ChaptersTrackMenuItem` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      super.handleClick();
      this.player_.currentTime(this.cue.startTime);
    }
  }
  Component$1.registerComponent("ChaptersTrackMenuItem", ChaptersTrackMenuItem);
  class ChaptersButton extends TextTrackButton {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {Function} [ready]
     *        The function to call when this function is ready.
     */
    constructor(player, options, ready) {
      super(player, options, ready);
      this.setIcon("chapters");
      this.selectCurrentItem_ = () => {
        this.items.forEach((item) => {
          item.selected(this.track_.activeCues[0] === item.cue);
        });
      };
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-chapters-button ${super.buildCSSClass()}`;
    }
    buildWrapperCSSClass() {
      return `vjs-chapters-button ${super.buildWrapperCSSClass()}`;
    }
    /**
     * Update the menu based on the current state of its items.
     *
     * @param {Event} [event]
     *        An event that triggered this function to run.
     *
     * @listens TextTrackList#addtrack
     * @listens TextTrackList#removetrack
     * @listens TextTrackList#change
     */
    update(event) {
      if (event && event.track && event.track.kind !== "chapters") {
        return;
      }
      const track = this.findChaptersTrack();
      if (track !== this.track_) {
        this.setTrack(track);
        super.update();
      } else if (!this.items || track && track.cues && track.cues.length !== this.items.length) {
        super.update();
      }
    }
    /**
     * Set the currently selected track for the chapters button.
     *
     * @param {TextTrack} track
     *        The new track to select. Nothing will change if this is the currently selected
     *        track.
     */
    setTrack(track) {
      if (this.track_ === track) {
        return;
      }
      if (!this.updateHandler_) {
        this.updateHandler_ = this.update.bind(this);
      }
      if (this.track_) {
        const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
        if (remoteTextTrackEl) {
          remoteTextTrackEl.removeEventListener("load", this.updateHandler_);
        }
        this.track_.removeEventListener("cuechange", this.selectCurrentItem_);
        this.track_ = null;
      }
      this.track_ = track;
      if (this.track_) {
        this.track_.mode = "hidden";
        const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
        if (remoteTextTrackEl) {
          remoteTextTrackEl.addEventListener("load", this.updateHandler_);
        }
        this.track_.addEventListener("cuechange", this.selectCurrentItem_);
      }
    }
    /**
     * Find the track object that is currently in use by this ChaptersButton
     *
     * @return {TextTrack|undefined}
     *         The current track or undefined if none was found.
     */
    findChaptersTrack() {
      const tracks = this.player_.textTracks() || [];
      for (let i = tracks.length - 1; i >= 0; i--) {
        const track = tracks[i];
        if (track.kind === this.kind_) {
          return track;
        }
      }
    }
    /**
     * Get the caption for the ChaptersButton based on the track label. This will also
     * use the current tracks localized kind as a fallback if a label does not exist.
     *
     * @return {string}
     *         The tracks current label or the localized track kind.
     */
    getMenuCaption() {
      if (this.track_ && this.track_.label) {
        return this.track_.label;
      }
      return this.localize(toTitleCase$1(this.kind_));
    }
    /**
     * Create menu from chapter track
     *
     * @return { import('../../menu/menu').default }
     *         New menu for the chapter buttons
     */
    createMenu() {
      this.options_.title = this.getMenuCaption();
      return super.createMenu();
    }
    /**
     * Create a menu item for each text track
     *
     * @return  { import('./text-track-menu-item').default[] }
     *         Array of menu items
     */
    createItems() {
      const items = [];
      if (!this.track_) {
        return items;
      }
      const cues = this.track_.cues;
      if (!cues) {
        return items;
      }
      for (let i = 0, l = cues.length; i < l; i++) {
        const cue = cues[i];
        const mi = new ChaptersTrackMenuItem(this.player_, {
          track: this.track_,
          cue
        });
        items.push(mi);
      }
      return items;
    }
  }
  ChaptersButton.prototype.kind_ = "chapters";
  ChaptersButton.prototype.controlText_ = "Chapters";
  Component$1.registerComponent("ChaptersButton", ChaptersButton);
  class DescriptionsButton extends TextTrackButton {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {Function} [ready]
     *        The function to call when this component is ready.
     */
    constructor(player, options, ready) {
      super(player, options, ready);
      this.setIcon("audio-description");
      const tracks = player.textTracks();
      const changeHandler = bind_(this, this.handleTracksChange);
      tracks.addEventListener("change", changeHandler);
      this.on("dispose", function() {
        tracks.removeEventListener("change", changeHandler);
      });
    }
    /**
     * Handle text track change
     *
     * @param {Event} event
     *        The event that caused this function to run
     *
     * @listens TextTrackList#change
     */
    handleTracksChange(event) {
      const tracks = this.player().textTracks();
      let disabled = false;
      for (let i = 0, l = tracks.length; i < l; i++) {
        const track = tracks[i];
        if (track.kind !== this.kind_ && track.mode === "showing") {
          disabled = true;
          break;
        }
      }
      if (disabled) {
        this.disable();
      } else {
        this.enable();
      }
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-descriptions-button ${super.buildCSSClass()}`;
    }
    buildWrapperCSSClass() {
      return `vjs-descriptions-button ${super.buildWrapperCSSClass()}`;
    }
  }
  DescriptionsButton.prototype.kind_ = "descriptions";
  DescriptionsButton.prototype.controlText_ = "Descriptions";
  Component$1.registerComponent("DescriptionsButton", DescriptionsButton);
  class SubtitlesButton extends TextTrackButton {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {Function} [ready]
     *        The function to call when this component is ready.
     */
    constructor(player, options, ready) {
      super(player, options, ready);
      this.setIcon("subtitles");
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-subtitles-button ${super.buildCSSClass()}`;
    }
    buildWrapperCSSClass() {
      return `vjs-subtitles-button ${super.buildWrapperCSSClass()}`;
    }
  }
  SubtitlesButton.prototype.kind_ = "subtitles";
  SubtitlesButton.prototype.controlText_ = "Subtitles";
  Component$1.registerComponent("SubtitlesButton", SubtitlesButton);
  class CaptionSettingsMenuItem extends TextTrackMenuItem {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      options.track = {
        player,
        kind: options.kind,
        label: options.kind + " settings",
        selectable: false,
        default: false,
        mode: "disabled"
      };
      options.selectable = false;
      options.name = "CaptionSettingsMenuItem";
      super(player, options);
      this.addClass("vjs-texttrack-settings");
      this.controlText(", opens " + options.kind + " settings dialog");
    }
    /**
     * This gets called when an `CaptionSettingsMenuItem` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      this.player().getChild("textTrackSettings").open();
    }
    /**
     * Update control text and label on languagechange
     */
    handleLanguagechange() {
      this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.kind + " settings");
      super.handleLanguagechange();
    }
  }
  Component$1.registerComponent("CaptionSettingsMenuItem", CaptionSettingsMenuItem);
  class CaptionsButton extends TextTrackButton {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {Function} [ready]
     *        The function to call when this component is ready.
     */
    constructor(player, options, ready) {
      super(player, options, ready);
      this.setIcon("captions");
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-captions-button ${super.buildCSSClass()}`;
    }
    buildWrapperCSSClass() {
      return `vjs-captions-button ${super.buildWrapperCSSClass()}`;
    }
    /**
     * Create caption menu items
     *
     * @return {CaptionSettingsMenuItem[]}
     *         The array of current menu items.
     */
    createItems() {
      const items = [];
      if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
        items.push(new CaptionSettingsMenuItem(this.player_, {
          kind: this.kind_
        }));
        this.hideThreshold_ += 1;
      }
      return super.createItems(items);
    }
  }
  CaptionsButton.prototype.kind_ = "captions";
  CaptionsButton.prototype.controlText_ = "Captions";
  Component$1.registerComponent("CaptionsButton", CaptionsButton);
  class SubsCapsMenuItem extends TextTrackMenuItem {
    createEl(type, props, attrs) {
      const el = super.createEl(type, props, attrs);
      const parentSpan = el.querySelector(".vjs-menu-item-text");
      if (this.options_.track.kind === "captions") {
        if (this.player_.options_.experimentalSvgIcons) {
          this.setIcon("captions", el);
        } else {
          parentSpan.appendChild(createEl("span", {
            className: "vjs-icon-placeholder"
          }, {
            "aria-hidden": true
          }));
        }
        parentSpan.appendChild(createEl("span", {
          className: "vjs-control-text",
          // space added as the text will visually flow with the
          // label
          textContent: ` ${this.localize("Captions")}`
        }));
      }
      return el;
    }
  }
  Component$1.registerComponent("SubsCapsMenuItem", SubsCapsMenuItem);
  class SubsCapsButton extends TextTrackButton {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {Function} [ready]
     *        The function to call when this component is ready.
     */
    constructor(player, options = {}) {
      super(player, options);
      this.label_ = "subtitles";
      this.setIcon("subtitles");
      if (["en", "en-us", "en-ca", "fr-ca"].indexOf(this.player_.language_) > -1) {
        this.label_ = "captions";
        this.setIcon("captions");
      }
      this.menuButton_.controlText(toTitleCase$1(this.label_));
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-subs-caps-button ${super.buildCSSClass()}`;
    }
    buildWrapperCSSClass() {
      return `vjs-subs-caps-button ${super.buildWrapperCSSClass()}`;
    }
    /**
     * Create caption/subtitles menu items
     *
     * @return {CaptionSettingsMenuItem[]}
     *         The array of current menu items.
     */
    createItems() {
      let items = [];
      if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
        items.push(new CaptionSettingsMenuItem(this.player_, {
          kind: this.label_
        }));
        this.hideThreshold_ += 1;
      }
      items = super.createItems(items, SubsCapsMenuItem);
      return items;
    }
  }
  SubsCapsButton.prototype.kinds_ = ["captions", "subtitles"];
  SubsCapsButton.prototype.controlText_ = "Subtitles";
  Component$1.registerComponent("SubsCapsButton", SubsCapsButton);
  class AudioTrackMenuItem extends MenuItem {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      const track = options.track;
      const tracks = player.audioTracks();
      options.label = track.label || track.language || "Unknown";
      options.selected = track.enabled;
      super(player, options);
      this.track = track;
      this.addClass(`vjs-${track.kind}-menu-item`);
      const changeHandler = (...args) => {
        this.handleTracksChange.apply(this, args);
      };
      tracks.addEventListener("change", changeHandler);
      this.on("dispose", () => {
        tracks.removeEventListener("change", changeHandler);
      });
    }
    createEl(type, props, attrs) {
      const el = super.createEl(type, props, attrs);
      const parentSpan = el.querySelector(".vjs-menu-item-text");
      if (["main-desc", "description"].indexOf(this.options_.track.kind) >= 0) {
        parentSpan.appendChild(createEl("span", {
          className: "vjs-icon-placeholder"
        }, {
          "aria-hidden": true
        }));
        parentSpan.appendChild(createEl("span", {
          className: "vjs-control-text",
          textContent: " " + this.localize("Descriptions")
        }));
      }
      return el;
    }
    /**
     * This gets called when an `AudioTrackMenuItem is "clicked". See {@link ClickableComponent}
     * for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      super.handleClick(event);
      this.track.enabled = true;
      if (this.player_.tech_.featuresNativeAudioTracks) {
        const tracks = this.player_.audioTracks();
        for (let i = 0; i < tracks.length; i++) {
          const track = tracks[i];
          if (track === this.track) {
            continue;
          }
          track.enabled = track === this.track;
        }
      }
    }
    /**
     * Handle any {@link AudioTrack} change.
     *
     * @param {Event} [event]
     *        The {@link AudioTrackList#change} event that caused this to run.
     *
     * @listens AudioTrackList#change
     */
    handleTracksChange(event) {
      this.selected(this.track.enabled);
    }
  }
  Component$1.registerComponent("AudioTrackMenuItem", AudioTrackMenuItem);
  class AudioTrackButton extends TrackButton {
    /**
     * Creates an instance of this class.
     *
     * @param {Player} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options={}]
     *        The key/value store of player options.
     */
    constructor(player, options = {}) {
      options.tracks = player.audioTracks();
      super(player, options);
      this.setIcon("audio");
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-audio-button ${super.buildCSSClass()}`;
    }
    buildWrapperCSSClass() {
      return `vjs-audio-button ${super.buildWrapperCSSClass()}`;
    }
    /**
     * Create a menu item for each audio track
     *
     * @param {AudioTrackMenuItem[]} [items=[]]
     *        An array of existing menu items to use.
     *
     * @return {AudioTrackMenuItem[]}
     *         An array of menu items
     */
    createItems(items = []) {
      this.hideThreshold_ = 1;
      const tracks = this.player_.audioTracks();
      for (let i = 0; i < tracks.length; i++) {
        const track = tracks[i];
        items.push(new AudioTrackMenuItem(this.player_, {
          track,
          // MenuItem is selectable
          selectable: true,
          // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
          multiSelectable: false
        }));
      }
      return items;
    }
  }
  AudioTrackButton.prototype.controlText_ = "Audio Track";
  Component$1.registerComponent("AudioTrackButton", AudioTrackButton);
  class PlaybackRateMenuItem extends MenuItem {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      const label = options.rate;
      const rate = parseFloat(label, 10);
      options.label = label;
      options.selected = rate === player.playbackRate();
      options.selectable = true;
      options.multiSelectable = false;
      super(player, options);
      this.label = label;
      this.rate = rate;
      this.on(player, "ratechange", (e) => this.update(e));
    }
    /**
     * This gets called when an `PlaybackRateMenuItem` is "clicked". See
     * {@link ClickableComponent} for more detailed information on what a click can be.
     *
     * @param {Event} [event]
     *        The `keydown`, `tap`, or `click` event that caused this function to be
     *        called.
     *
     * @listens tap
     * @listens click
     */
    handleClick(event) {
      super.handleClick();
      this.player().playbackRate(this.rate);
    }
    /**
     * Update the PlaybackRateMenuItem when the playbackrate changes.
     *
     * @param {Event} [event]
     *        The `ratechange` event that caused this function to run.
     *
     * @listens Player#ratechange
     */
    update(event) {
      this.selected(this.player().playbackRate() === this.rate);
    }
  }
  PlaybackRateMenuItem.prototype.contentElType = "button";
  Component$1.registerComponent("PlaybackRateMenuItem", PlaybackRateMenuItem);
  class PlaybackRateMenuButton extends MenuButton {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../../player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.menuButton_.el_.setAttribute("aria-describedby", this.labelElId_);
      this.updateVisibility();
      this.updateLabel();
      this.on(player, "loadstart", (e) => this.updateVisibility(e));
      this.on(player, "ratechange", (e) => this.updateLabel(e));
      this.on(player, "playbackrateschange", (e) => this.handlePlaybackRateschange(e));
    }
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      const el = super.createEl();
      this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_;
      this.labelEl_ = createEl("div", {
        className: "vjs-playback-rate-value",
        id: this.labelElId_,
        textContent: "1x"
      });
      el.appendChild(this.labelEl_);
      return el;
    }
    dispose() {
      this.labelEl_ = null;
      super.dispose();
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-playback-rate ${super.buildCSSClass()}`;
    }
    buildWrapperCSSClass() {
      return `vjs-playback-rate ${super.buildWrapperCSSClass()}`;
    }
    /**
     * Create the list of menu items. Specific to each subclass.
     *
     */
    createItems() {
      const rates = this.playbackRates();
      const items = [];
      for (let i = rates.length - 1; i >= 0; i--) {
        items.push(new PlaybackRateMenuItem(this.player(), {
          rate: rates[i] + "x"
        }));
      }
      return items;
    }
    /**
     * On playbackrateschange, update the menu to account for the new items.
     *
     * @listens Player#playbackrateschange
     */
    handlePlaybackRateschange(event) {
      this.update();
    }
    /**
     * Get possible playback rates
     *
     * @return {Array}
     *         All possible playback rates
     */
    playbackRates() {
      const player = this.player();
      return player.playbackRates && player.playbackRates() || [];
    }
    /**
     * Get whether playback rates is supported by the tech
     * and an array of playback rates exists
     *
     * @return {boolean}
     *         Whether changing playback rate is supported
     */
    playbackRateSupported() {
      return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
    }
    /**
     * Hide playback rate controls when they're no playback rate options to select
     *
     * @param {Event} [event]
     *        The event that caused this function to run.
     *
     * @listens Player#loadstart
     */
    updateVisibility(event) {
      if (this.playbackRateSupported()) {
        this.removeClass("vjs-hidden");
      } else {
        this.addClass("vjs-hidden");
      }
    }
    /**
     * Update button label when rate changed
     *
     * @param {Event} [event]
     *        The event that caused this function to run.
     *
     * @listens Player#ratechange
     */
    updateLabel(event) {
      if (this.playbackRateSupported()) {
        this.labelEl_.textContent = this.player().playbackRate() + "x";
      }
    }
  }
  PlaybackRateMenuButton.prototype.controlText_ = "Playback Rate";
  Component$1.registerComponent("PlaybackRateMenuButton", PlaybackRateMenuButton);
  class Spacer extends Component$1 {
    /**
    * Builds the default DOM `className`.
    *
    * @return {string}
    *         The DOM `className` for this object.
    */
    buildCSSClass() {
      return `vjs-spacer ${super.buildCSSClass()}`;
    }
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl(tag = "div", props = {}, attributes = {}) {
      if (!props.className) {
        props.className = this.buildCSSClass();
      }
      return super.createEl(tag, props, attributes);
    }
  }
  Component$1.registerComponent("Spacer", Spacer);
  class CustomControlSpacer extends Spacer {
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     */
    buildCSSClass() {
      return `vjs-custom-control-spacer ${super.buildCSSClass()}`;
    }
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl("div", {
        className: this.buildCSSClass(),
        // No-flex/table-cell mode requires there be some content
        // in the cell to fill the remaining space of the table.
        textContent: "\xA0"
      });
    }
  }
  Component$1.registerComponent("CustomControlSpacer", CustomControlSpacer);
  class ControlBar extends Component$1 {
    /**
     * Create the `Component`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      return super.createEl("div", {
        className: "vjs-control-bar",
        dir: "ltr"
      });
    }
  }
  ControlBar.prototype.options_ = {
    children: ["playToggle", "skipBackward", "skipForward", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "seekToLive", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "pictureInPictureToggle", "fullscreenToggle"]
  };
  Component$1.registerComponent("ControlBar", ControlBar);
  class ErrorDisplay extends ModalDialog {
    /**
     * Creates an instance of this class.
     *
     * @param  { import('./player').default } player
     *         The `Player` that this class should be attached to.
     *
     * @param  {Object} [options]
     *         The key/value store of player options.
     */
    constructor(player, options) {
      super(player, options);
      this.on(player, "error", (e) => {
        this.close();
        this.open(e);
      });
    }
    /**
     * Builds the default DOM `className`.
     *
     * @return {string}
     *         The DOM `className` for this object.
     *
     * @deprecated Since version 5.
     */
    buildCSSClass() {
      return `vjs-error-display ${super.buildCSSClass()}`;
    }
    /**
     * Gets the localized error message based on the `Player`s error.
     *
     * @return {string}
     *         The `Player`s error message localized or an empty string.
     */
    content() {
      const error = this.player().error();
      return error ? this.localize(error.message) : "";
    }
  }
  ErrorDisplay.prototype.options_ = Object.assign({}, ModalDialog.prototype.options_, {
    pauseOnOpen: false,
    fillAlways: true,
    temporary: false,
    uncloseable: true
  });
  Component$1.registerComponent("ErrorDisplay", ErrorDisplay);
  const LOCAL_STORAGE_KEY$1 = "vjs-text-track-settings";
  const COLOR_BLACK = ["#000", "Black"];
  const COLOR_BLUE = ["#00F", "Blue"];
  const COLOR_CYAN = ["#0FF", "Cyan"];
  const COLOR_GREEN = ["#0F0", "Green"];
  const COLOR_MAGENTA = ["#F0F", "Magenta"];
  const COLOR_RED = ["#F00", "Red"];
  const COLOR_WHITE = ["#FFF", "White"];
  const COLOR_YELLOW = ["#FF0", "Yellow"];
  const OPACITY_OPAQUE = ["1", "Opaque"];
  const OPACITY_SEMI = ["0.5", "Semi-Transparent"];
  const OPACITY_TRANS = ["0", "Transparent"];
  const selectConfigs = {
    backgroundColor: {
      selector: ".vjs-bg-color > select",
      id: "captions-background-color-%s",
      label: "Color",
      options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
    },
    backgroundOpacity: {
      selector: ".vjs-bg-opacity > select",
      id: "captions-background-opacity-%s",
      label: "Opacity",
      options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]
    },
    color: {
      selector: ".vjs-text-color > select",
      id: "captions-foreground-color-%s",
      label: "Color",
      options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
    },
    edgeStyle: {
      selector: ".vjs-edge-style > select",
      id: "%s",
      label: "Text Edge Style",
      options: [["none", "None"], ["raised", "Raised"], ["depressed", "Depressed"], ["uniform", "Uniform"], ["dropshadow", "Drop shadow"]]
    },
    fontFamily: {
      selector: ".vjs-font-family > select",
      id: "captions-font-family-%s",
      label: "Font Family",
      options: [["proportionalSansSerif", "Proportional Sans-Serif"], ["monospaceSansSerif", "Monospace Sans-Serif"], ["proportionalSerif", "Proportional Serif"], ["monospaceSerif", "Monospace Serif"], ["casual", "Casual"], ["script", "Script"], ["small-caps", "Small Caps"]]
    },
    fontPercent: {
      selector: ".vjs-font-percent > select",
      id: "captions-font-size-%s",
      label: "Font Size",
      options: [["0.50", "50%"], ["0.75", "75%"], ["1.00", "100%"], ["1.25", "125%"], ["1.50", "150%"], ["1.75", "175%"], ["2.00", "200%"], ["3.00", "300%"], ["4.00", "400%"]],
      default: 2,
      parser: (v) => v === "1.00" ? null : Number(v)
    },
    textOpacity: {
      selector: ".vjs-text-opacity > select",
      id: "captions-foreground-opacity-%s",
      label: "Opacity",
      options: [OPACITY_OPAQUE, OPACITY_SEMI]
    },
    // Options for this object are defined below.
    windowColor: {
      selector: ".vjs-window-color > select",
      id: "captions-window-color-%s",
      label: "Color"
    },
    // Options for this object are defined below.
    windowOpacity: {
      selector: ".vjs-window-opacity > select",
      id: "captions-window-opacity-%s",
      label: "Opacity",
      options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]
    }
  };
  selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;
  function parseOptionValue(value, parser) {
    if (parser) {
      value = parser(value);
    }
    if (value && value !== "none") {
      return value;
    }
  }
  function getSelectedOptionValue(el, parser) {
    const value = el.options[el.options.selectedIndex].value;
    return parseOptionValue(value, parser);
  }
  function setSelectedOption(el, value, parser) {
    if (!value) {
      return;
    }
    for (let i = 0; i < el.options.length; i++) {
      if (parseOptionValue(el.options[i].value, parser) === value) {
        el.selectedIndex = i;
        break;
      }
    }
  }
  class TextTrackSettings extends ModalDialog {
    /**
     * Creates an instance of this class.
     *
     * @param { import('../player').default } player
     *         The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *         The key/value store of player options.
     */
    constructor(player, options) {
      options.temporary = false;
      super(player, options);
      this.updateDisplay = this.updateDisplay.bind(this);
      this.fill();
      this.hasBeenOpened_ = this.hasBeenFilled_ = true;
      this.endDialog = createEl("p", {
        className: "vjs-control-text",
        textContent: this.localize("End of dialog window.")
      });
      this.el().appendChild(this.endDialog);
      this.setDefaults();
      if (options.persistTextTrackSettings === void 0) {
        this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings;
      }
      this.on(this.$(".vjs-done-button"), "click", () => {
        this.saveSettings();
        this.close();
      });
      this.on(this.$(".vjs-default-button"), "click", () => {
        this.setDefaults();
        this.updateDisplay();
      });
      each(selectConfigs, (config) => {
        this.on(this.$(config.selector), "change", this.updateDisplay);
      });
      if (this.options_.persistTextTrackSettings) {
        this.restoreSettings();
      }
    }
    dispose() {
      this.endDialog = null;
      super.dispose();
    }
    /**
     * Create a <select> element with configured options.
     *
     * @param {string} key
     *        Configuration key to use during creation.
     *
     * @return {string}
     *         An HTML string.
     *
     * @private
     */
    createElSelect_(key, legendId = "", type = "label") {
      const config = selectConfigs[key];
      const id = config.id.replace("%s", this.id_);
      const selectLabelledbyIds = [legendId, id].join(" ").trim();
      return [`<${type} id="${id}" class="${type === "label" ? "vjs-label" : ""}">`, this.localize(config.label), `</${type}>`, `<select aria-labelledby="${selectLabelledbyIds}">`].concat(config.options.map((o) => {
        const optionId = id + "-" + o[1].replace(/\W+/g, "");
        return [`<option id="${optionId}" value="${o[0]}" `, `aria-labelledby="${selectLabelledbyIds} ${optionId}">`, this.localize(o[1]), "</option>"].join("");
      })).concat("</select>").join("");
    }
    /**
     * Create foreground color element for the component
     *
     * @return {string}
     *         An HTML string.
     *
     * @private
     */
    createElFgColor_() {
      const legendId = `captions-text-legend-${this.id_}`;
      return ['<fieldset class="vjs-fg vjs-track-setting">', `<legend id="${legendId}">`, this.localize("Text"), "</legend>", '<span class="vjs-text-color">', this.createElSelect_("color", legendId), "</span>", '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_("textOpacity", legendId), "</span>", "</fieldset>"].join("");
    }
    /**
     * Create background color element for the component
     *
     * @return {string}
     *         An HTML string.
     *
     * @private
     */
    createElBgColor_() {
      const legendId = `captions-background-${this.id_}`;
      return ['<fieldset class="vjs-bg vjs-track-setting">', `<legend id="${legendId}">`, this.localize("Text Background"), "</legend>", '<span class="vjs-bg-color">', this.createElSelect_("backgroundColor", legendId), "</span>", '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_("backgroundOpacity", legendId), "</span>", "</fieldset>"].join("");
    }
    /**
     * Create window color element for the component
     *
     * @return {string}
     *         An HTML string.
     *
     * @private
     */
    createElWinColor_() {
      const legendId = `captions-window-${this.id_}`;
      return ['<fieldset class="vjs-window vjs-track-setting">', `<legend id="${legendId}">`, this.localize("Caption Area Background"), "</legend>", '<span class="vjs-window-color">', this.createElSelect_("windowColor", legendId), "</span>", '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_("windowOpacity", legendId), "</span>", "</fieldset>"].join("");
    }
    /**
     * Create color elements for the component
     *
     * @return {Element}
     *         The element that was created
     *
     * @private
     */
    createElColors_() {
      return createEl("div", {
        className: "vjs-track-settings-colors",
        innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join("")
      });
    }
    /**
     * Create font elements for the component
     *
     * @return {Element}
     *         The element that was created.
     *
     * @private
     */
    createElFont_() {
      return createEl("div", {
        className: "vjs-track-settings-font",
        innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_("fontPercent", "", "legend"), "</fieldset>", '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_("edgeStyle", "", "legend"), "</fieldset>", '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_("fontFamily", "", "legend"), "</fieldset>"].join("")
      });
    }
    /**
     * Create controls for the component
     *
     * @return {Element}
     *         The element that was created.
     *
     * @private
     */
    createElControls_() {
      const defaultsDescription = this.localize("restore all settings to the default values");
      return createEl("div", {
        className: "vjs-track-settings-controls",
        innerHTML: [`<button type="button" class="vjs-default-button" title="${defaultsDescription}">`, this.localize("Reset"), `<span class="vjs-control-text"> ${defaultsDescription}</span>`, "</button>", `<button type="button" class="vjs-done-button">${this.localize("Done")}</button>`].join("")
      });
    }
    content() {
      return [this.createElColors_(), this.createElFont_(), this.createElControls_()];
    }
    label() {
      return this.localize("Caption Settings Dialog");
    }
    description() {
      return this.localize("Beginning of dialog window. Escape will cancel and close the window.");
    }
    buildCSSClass() {
      return super.buildCSSClass() + " vjs-text-track-settings";
    }
    /**
     * Gets an object of text track settings (or null).
     *
     * @return {Object}
     *         An object with config values parsed from the DOM or localStorage.
     */
    getValues() {
      return reduce(selectConfigs, (accum, config, key) => {
        const value = getSelectedOptionValue(this.$(config.selector), config.parser);
        if (value !== void 0) {
          accum[key] = value;
        }
        return accum;
      }, {});
    }
    /**
     * Sets text track settings from an object of values.
     *
     * @param {Object} values
     *        An object with config values parsed from the DOM or localStorage.
     */
    setValues(values2) {
      each(selectConfigs, (config, key) => {
        setSelectedOption(this.$(config.selector), values2[key], config.parser);
      });
    }
    /**
     * Sets all `<select>` elements to their default values.
     */
    setDefaults() {
      each(selectConfigs, (config) => {
        const index = config.hasOwnProperty("default") ? config.default : 0;
        this.$(config.selector).selectedIndex = index;
      });
    }
    /**
     * Restore texttrack settings from localStorage
     */
    restoreSettings() {
      let values2;
      try {
        values2 = JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY$1));
      } catch (err) {
        log$1.warn(err);
      }
      if (values2) {
        this.setValues(values2);
      }
    }
    /**
     * Save text track settings to localStorage
     */
    saveSettings() {
      if (!this.options_.persistTextTrackSettings) {
        return;
      }
      const values2 = this.getValues();
      try {
        if (Object.keys(values2).length) {
          window.localStorage.setItem(LOCAL_STORAGE_KEY$1, JSON.stringify(values2));
        } else {
          window.localStorage.removeItem(LOCAL_STORAGE_KEY$1);
        }
      } catch (err) {
        log$1.warn(err);
      }
    }
    /**
     * Update display of text track settings
     */
    updateDisplay() {
      const ttDisplay = this.player_.getChild("textTrackDisplay");
      if (ttDisplay) {
        ttDisplay.updateDisplay();
      }
    }
    /**
     * conditionally blur the element and refocus the captions button
     *
     * @private
     */
    conditionalBlur_() {
      this.previouslyActiveEl_ = null;
      const cb = this.player_.controlBar;
      const subsCapsBtn = cb && cb.subsCapsButton;
      const ccBtn = cb && cb.captionsButton;
      if (subsCapsBtn) {
        subsCapsBtn.focus();
      } else if (ccBtn) {
        ccBtn.focus();
      }
    }
    /**
     * Repopulate dialog with new localizations on languagechange
     */
    handleLanguagechange() {
      this.fill();
    }
  }
  Component$1.registerComponent("TextTrackSettings", TextTrackSettings);
  class ResizeManager extends Component$1 {
    /**
     * Create the ResizeManager.
     *
     * @param {Object} player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of ResizeManager options.
     *
     * @param {Object} [options.ResizeObserver]
     *        A polyfill for ResizeObserver can be passed in here.
     *        If this is set to null it will ignore the native ResizeObserver and fall back to the iframe fallback.
     */
    constructor(player, options) {
      let RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window.ResizeObserver;
      if (options.ResizeObserver === null) {
        RESIZE_OBSERVER_AVAILABLE = false;
      }
      const options_ = merge$2({
        createEl: !RESIZE_OBSERVER_AVAILABLE,
        reportTouchActivity: false
      }, options);
      super(player, options_);
      this.ResizeObserver = options.ResizeObserver || window.ResizeObserver;
      this.loadListener_ = null;
      this.resizeObserver_ = null;
      this.debouncedHandler_ = debounce(() => {
        this.resizeHandler();
      }, 100, false, this);
      if (RESIZE_OBSERVER_AVAILABLE) {
        this.resizeObserver_ = new this.ResizeObserver(this.debouncedHandler_);
        this.resizeObserver_.observe(player.el());
      } else {
        this.loadListener_ = () => {
          if (!this.el_ || !this.el_.contentWindow) {
            return;
          }
          const debouncedHandler_ = this.debouncedHandler_;
          let unloadListener_ = this.unloadListener_ = function() {
            off(this, "resize", debouncedHandler_);
            off(this, "unload", unloadListener_);
            unloadListener_ = null;
          };
          on(this.el_.contentWindow, "unload", unloadListener_);
          on(this.el_.contentWindow, "resize", debouncedHandler_);
        };
        this.one("load", this.loadListener_);
      }
    }
    createEl() {
      return super.createEl("iframe", {
        className: "vjs-resize-manager",
        tabIndex: -1,
        title: this.localize("No content")
      }, {
        "aria-hidden": "true"
      });
    }
    /**
     * Called when a resize is triggered on the iframe or a resize is observed via the ResizeObserver
     *
     * @fires Player#playerresize
     */
    resizeHandler() {
      if (!this.player_ || !this.player_.trigger) {
        return;
      }
      this.player_.trigger("playerresize");
    }
    dispose() {
      if (this.debouncedHandler_) {
        this.debouncedHandler_.cancel();
      }
      if (this.resizeObserver_) {
        if (this.player_.el()) {
          this.resizeObserver_.unobserve(this.player_.el());
        }
        this.resizeObserver_.disconnect();
      }
      if (this.loadListener_) {
        this.off("load", this.loadListener_);
      }
      if (this.el_ && this.el_.contentWindow && this.unloadListener_) {
        this.unloadListener_.call(this.el_.contentWindow);
      }
      this.ResizeObserver = null;
      this.resizeObserver = null;
      this.debouncedHandler_ = null;
      this.loadListener_ = null;
      super.dispose();
    }
  }
  Component$1.registerComponent("ResizeManager", ResizeManager);
  const defaults = {
    trackingThreshold: 20,
    liveTolerance: 15
  };
  class LiveTracker extends Component$1 {
    /**
     * Creates an instance of this class.
     *
     * @param { import('./player').default } player
     *        The `Player` that this class should be attached to.
     *
     * @param {Object} [options]
     *        The key/value store of player options.
     *
     * @param {number} [options.trackingThreshold=20]
     *        Number of seconds of live window (seekableEnd - seekableStart) that
     *        media needs to have before the liveui will be shown.
     *
     * @param {number} [options.liveTolerance=15]
     *        Number of seconds behind live that we have to be
     *        before we will be considered non-live. Note that this will only
     *        be used when playing at the live edge. This allows large seekable end
     *        changes to not effect whether we are live or not.
     */
    constructor(player, options) {
      const options_ = merge$2(defaults, options, {
        createEl: false
      });
      super(player, options_);
      this.trackLiveHandler_ = () => this.trackLive_();
      this.handlePlay_ = (e) => this.handlePlay(e);
      this.handleFirstTimeupdate_ = (e) => this.handleFirstTimeupdate(e);
      this.handleSeeked_ = (e) => this.handleSeeked(e);
      this.seekToLiveEdge_ = (e) => this.seekToLiveEdge(e);
      this.reset_();
      this.on(this.player_, "durationchange", (e) => this.handleDurationchange(e));
      this.on(this.player_, "canplay", () => this.toggleTracking());
    }
    /**
     * all the functionality for tracking when seek end changes
     * and for tracking how far past seek end we should be
     */
    trackLive_() {
      const seekable2 = this.player_.seekable();
      if (!seekable2 || !seekable2.length) {
        return;
      }
      const newTime = Number(window.performance.now().toFixed(4));
      const deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1e3;
      this.lastTime_ = newTime;
      this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;
      const liveCurrentTime = this.liveCurrentTime();
      const currentTime = this.player_.currentTime();
      let isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance;
      if (!this.timeupdateSeen_ || liveCurrentTime === Infinity) {
        isBehind = false;
      }
      if (isBehind !== this.behindLiveEdge_) {
        this.behindLiveEdge_ = isBehind;
        this.trigger("liveedgechange");
      }
    }
    /**
     * handle a durationchange event on the player
     * and start/stop tracking accordingly.
     */
    handleDurationchange() {
      this.toggleTracking();
    }
    /**
     * start/stop tracking
     */
    toggleTracking() {
      if (this.player_.duration() === Infinity && this.liveWindow() >= this.options_.trackingThreshold) {
        if (this.player_.options_.liveui) {
          this.player_.addClass("vjs-liveui");
        }
        this.startTracking();
      } else {
        this.player_.removeClass("vjs-liveui");
        this.stopTracking();
      }
    }
    /**
     * start tracking live playback
     */
    startTracking() {
      if (this.isTracking()) {
        return;
      }
      if (!this.timeupdateSeen_) {
        this.timeupdateSeen_ = this.player_.hasStarted();
      }
      this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, UPDATE_REFRESH_INTERVAL);
      this.trackLive_();
      this.on(this.player_, ["play", "pause"], this.trackLiveHandler_);
      if (!this.timeupdateSeen_) {
        this.one(this.player_, "play", this.handlePlay_);
        this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_);
      } else {
        this.on(this.player_, "seeked", this.handleSeeked_);
      }
    }
    /**
     * handle the first timeupdate on the player if it wasn't already playing
     * when live tracker started tracking.
     */
    handleFirstTimeupdate() {
      this.timeupdateSeen_ = true;
      this.on(this.player_, "seeked", this.handleSeeked_);
    }
    /**
     * Keep track of what time a seek starts, and listen for seeked
     * to find where a seek ends.
     */
    handleSeeked() {
      const timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
      this.seekedBehindLive_ = this.nextSeekedFromUser_ && timeDiff > 2;
      this.nextSeekedFromUser_ = false;
      this.trackLive_();
    }
    /**
     * handle the first play on the player, and make sure that we seek
     * right to the live edge.
     */
    handlePlay() {
      this.one(this.player_, "timeupdate", this.seekToLiveEdge_);
    }
    /**
     * Stop tracking, and set all internal variables to
     * their initial value.
     */
    reset_() {
      this.lastTime_ = -1;
      this.pastSeekEnd_ = 0;
      this.lastSeekEnd_ = -1;
      this.behindLiveEdge_ = true;
      this.timeupdateSeen_ = false;
      this.seekedBehindLive_ = false;
      this.nextSeekedFromUser_ = false;
      this.clearInterval(this.trackingInterval_);
      this.trackingInterval_ = null;
      this.off(this.player_, ["play", "pause"], this.trackLiveHandler_);
      this.off(this.player_, "seeked", this.handleSeeked_);
      this.off(this.player_, "play", this.handlePlay_);
      this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_);
      this.off(this.player_, "timeupdate", this.seekToLiveEdge_);
    }
    /**
     * The next seeked event is from the user. Meaning that any seek
     * > 2s behind live will be considered behind live for real and
     * liveTolerance will be ignored.
     */
    nextSeekedFromUser() {
      this.nextSeekedFromUser_ = true;
    }
    /**
     * stop tracking live playback
     */
    stopTracking() {
      if (!this.isTracking()) {
        return;
      }
      this.reset_();
      this.trigger("liveedgechange");
    }
    /**
     * A helper to get the player seekable end
     * so that we don't have to null check everywhere
     *
     * @return {number}
     *         The furthest seekable end or Infinity.
     */
    seekableEnd() {
      const seekable2 = this.player_.seekable();
      const seekableEnds = [];
      let i = seekable2 ? seekable2.length : 0;
      while (i--) {
        seekableEnds.push(seekable2.end(i));
      }
      return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : Infinity;
    }
    /**
     * A helper to get the player seekable start
     * so that we don't have to null check everywhere
     *
     * @return {number}
     *         The earliest seekable start or 0.
     */
    seekableStart() {
      const seekable2 = this.player_.seekable();
      const seekableStarts = [];
      let i = seekable2 ? seekable2.length : 0;
      while (i--) {
        seekableStarts.push(seekable2.start(i));
      }
      return seekableStarts.length ? seekableStarts.sort()[0] : 0;
    }
    /**
     * Get the live time window aka
     * the amount of time between seekable start and
     * live current time.
     *
     * @return {number}
     *         The amount of seconds that are seekable in
     *         the live video.
     */
    liveWindow() {
      const liveCurrentTime = this.liveCurrentTime();
      if (liveCurrentTime === Infinity) {
        return 0;
      }
      return liveCurrentTime - this.seekableStart();
    }
    /**
     * Determines if the player is live, only checks if this component
     * is tracking live playback or not
     *
     * @return {boolean}
     *         Whether liveTracker is tracking
     */
    isLive() {
      return this.isTracking();
    }
    /**
     * Determines if currentTime is at the live edge and won't fall behind
     * on each seekableendchange
     *
     * @return {boolean}
     *         Whether playback is at the live edge
     */
    atLiveEdge() {
      return !this.behindLiveEdge();
    }
    /**
     * get what we expect the live current time to be
     *
     * @return {number}
     *         The expected live current time
     */
    liveCurrentTime() {
      return this.pastSeekEnd() + this.seekableEnd();
    }
    /**
     * The number of seconds that have occurred after seekable end
     * changed. This will be reset to 0 once seekable end changes.
     *
     * @return {number}
     *         Seconds past the current seekable end
     */
    pastSeekEnd() {
      const seekableEnd = this.seekableEnd();
      if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) {
        this.pastSeekEnd_ = 0;
      }
      this.lastSeekEnd_ = seekableEnd;
      return this.pastSeekEnd_;
    }
    /**
     * If we are currently behind the live edge, aka currentTime will be
     * behind on a seekableendchange
     *
     * @return {boolean}
     *         If we are behind the live edge
     */
    behindLiveEdge() {
      return this.behindLiveEdge_;
    }
    /**
     * Whether live tracker is currently tracking or not.
     */
    isTracking() {
      return typeof this.trackingInterval_ === "number";
    }
    /**
     * Seek to the live edge if we are behind the live edge
     */
    seekToLiveEdge() {
      this.seekedBehindLive_ = false;
      if (this.atLiveEdge()) {
        return;
      }
      this.nextSeekedFromUser_ = false;
      this.player_.currentTime(this.liveCurrentTime());
    }
    /**
     * Dispose of liveTracker
     */
    dispose() {
      this.stopTracking();
      super.dispose();
    }
  }
  Component$1.registerComponent("LiveTracker", LiveTracker);
  class TitleBar extends Component$1 {
    constructor(player, options) {
      super(player, options);
      this.on("statechanged", (e) => this.updateDom_());
      this.updateDom_();
    }
    /**
     * Create the `TitleBar`'s DOM element
     *
     * @return {Element}
     *         The element that was created.
     */
    createEl() {
      this.els = {
        title: createEl("div", {
          className: "vjs-title-bar-title",
          id: `vjs-title-bar-title-${newGUID()}`
        }),
        description: createEl("div", {
          className: "vjs-title-bar-description",
          id: `vjs-title-bar-description-${newGUID()}`
        })
      };
      return createEl("div", {
        className: "vjs-title-bar"
      }, {}, values$1(this.els));
    }
    /**
     * Updates the DOM based on the component's state object.
     */
    updateDom_() {
      const tech = this.player_.tech_;
      const techEl = tech && tech.el_;
      const techAriaAttrs = {
        title: "aria-labelledby",
        description: "aria-describedby"
      };
      ["title", "description"].forEach((k) => {
        const value = this.state[k];
        const el = this.els[k];
        const techAriaAttr = techAriaAttrs[k];
        emptyEl(el);
        if (value) {
          textContent(el, value);
        }
        if (techEl) {
          techEl.removeAttribute(techAriaAttr);
          if (value) {
            techEl.setAttribute(techAriaAttr, el.id);
          }
        }
      });
      if (this.state.title || this.state.description) {
        this.show();
      } else {
        this.hide();
      }
    }
    /**
     * Update the contents of the title bar component with new title and
     * description text.
     *
     * If both title and description are missing, the title bar will be hidden.
     *
     * If either title or description are present, the title bar will be visible.
     *
     * NOTE: Any previously set value will be preserved. To unset a previously
     * set value, you must pass an empty string or null.
     *
     * For example:
     *
     * ```
     * update({title: 'foo', description: 'bar'}) // title: 'foo', description: 'bar'
     * update({description: 'bar2'}) // title: 'foo', description: 'bar2'
     * update({title: ''}) // title: '', description: 'bar2'
     * update({title: 'foo', description: null}) // title: 'foo', description: null
     * ```
     *
     * @param  {Object} [options={}]
     *         An options object. When empty, the title bar will be hidden.
     *
     * @param  {string} [options.title]
     *         A title to display in the title bar.
     *
     * @param  {string} [options.description]
     *         A description to display in the title bar.
     */
    update(options) {
      this.setState(options);
    }
    /**
     * Dispose the component.
     */
    dispose() {
      const tech = this.player_.tech_;
      const techEl = tech && tech.el_;
      if (techEl) {
        techEl.removeAttribute("aria-labelledby");
        techEl.removeAttribute("aria-describedby");
      }
      super.dispose();
      this.els = null;
    }
  }
  Component$1.registerComponent("TitleBar", TitleBar);
  const sourcesetLoad = (tech) => {
    const el = tech.el();
    if (el.hasAttribute("src")) {
      tech.triggerSourceset(el.src);
      return true;
    }
    const sources = tech.$$("source");
    const srcUrls = [];
    let src = "";
    if (!sources.length) {
      return false;
    }
    for (let i = 0; i < sources.length; i++) {
      const url = sources[i].src;
      if (url && srcUrls.indexOf(url) === -1) {
        srcUrls.push(url);
      }
    }
    if (!srcUrls.length) {
      return false;
    }
    if (srcUrls.length === 1) {
      src = srcUrls[0];
    }
    tech.triggerSourceset(src);
    return true;
  };
  const innerHTMLDescriptorPolyfill = Object.defineProperty({}, "innerHTML", {
    get() {
      return this.cloneNode(true).innerHTML;
    },
    set(v) {
      const dummy = document.createElement(this.nodeName.toLowerCase());
      dummy.innerHTML = v;
      const docFrag = document.createDocumentFragment();
      while (dummy.childNodes.length) {
        docFrag.appendChild(dummy.childNodes[0]);
      }
      this.innerText = "";
      window.Element.prototype.appendChild.call(this, docFrag);
      return this.innerHTML;
    }
  });
  const getDescriptor = (priority, prop) => {
    let descriptor = {};
    for (let i = 0; i < priority.length; i++) {
      descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);
      if (descriptor && descriptor.set && descriptor.get) {
        break;
      }
    }
    descriptor.enumerable = true;
    descriptor.configurable = true;
    return descriptor;
  };
  const getInnerHTMLDescriptor = (tech) => getDescriptor([tech.el(), window.HTMLMediaElement.prototype, window.Element.prototype, innerHTMLDescriptorPolyfill], "innerHTML");
  const firstSourceWatch = function(tech) {
    const el = tech.el();
    if (el.resetSourceWatch_) {
      return;
    }
    const old = {};
    const innerDescriptor = getInnerHTMLDescriptor(tech);
    const appendWrapper = (appendFn) => (...args) => {
      const retval = appendFn.apply(el, args);
      sourcesetLoad(tech);
      return retval;
    };
    ["append", "appendChild", "insertAdjacentHTML"].forEach((k) => {
      if (!el[k]) {
        return;
      }
      old[k] = el[k];
      el[k] = appendWrapper(old[k]);
    });
    Object.defineProperty(el, "innerHTML", merge$2(innerDescriptor, {
      set: appendWrapper(innerDescriptor.set)
    }));
    el.resetSourceWatch_ = () => {
      el.resetSourceWatch_ = null;
      Object.keys(old).forEach((k) => {
        el[k] = old[k];
      });
      Object.defineProperty(el, "innerHTML", innerDescriptor);
    };
    tech.one("sourceset", el.resetSourceWatch_);
  };
  const srcDescriptorPolyfill = Object.defineProperty({}, "src", {
    get() {
      if (this.hasAttribute("src")) {
        return getAbsoluteURL(window.Element.prototype.getAttribute.call(this, "src"));
      }
      return "";
    },
    set(v) {
      window.Element.prototype.setAttribute.call(this, "src", v);
      return v;
    }
  });
  const getSrcDescriptor = (tech) => getDescriptor([tech.el(), window.HTMLMediaElement.prototype, srcDescriptorPolyfill], "src");
  const setupSourceset = function(tech) {
    if (!tech.featuresSourceset) {
      return;
    }
    const el = tech.el();
    if (el.resetSourceset_) {
      return;
    }
    const srcDescriptor = getSrcDescriptor(tech);
    const oldSetAttribute = el.setAttribute;
    const oldLoad = el.load;
    Object.defineProperty(el, "src", merge$2(srcDescriptor, {
      set: (v) => {
        const retval = srcDescriptor.set.call(el, v);
        tech.triggerSourceset(el.src);
        return retval;
      }
    }));
    el.setAttribute = (n, v) => {
      const retval = oldSetAttribute.call(el, n, v);
      if (/src/i.test(n)) {
        tech.triggerSourceset(el.src);
      }
      return retval;
    };
    el.load = () => {
      const retval = oldLoad.call(el);
      if (!sourcesetLoad(tech)) {
        tech.triggerSourceset("");
        firstSourceWatch(tech);
      }
      return retval;
    };
    if (el.currentSrc) {
      tech.triggerSourceset(el.currentSrc);
    } else if (!sourcesetLoad(tech)) {
      firstSourceWatch(tech);
    }
    el.resetSourceset_ = () => {
      el.resetSourceset_ = null;
      el.load = oldLoad;
      el.setAttribute = oldSetAttribute;
      Object.defineProperty(el, "src", srcDescriptor);
      if (el.resetSourceWatch_) {
        el.resetSourceWatch_();
      }
    };
  };
  class Html5 extends Tech {
    /**
    * Create an instance of this Tech.
    *
    * @param {Object} [options]
    *        The key/value store of player options.
    *
    * @param {Function} [ready]
    *        Callback function to call when the `HTML5` Tech is ready.
    */
    constructor(options, ready) {
      super(options, ready);
      const source = options.source;
      let crossoriginTracks = false;
      this.featuresVideoFrameCallback = this.featuresVideoFrameCallback && this.el_.tagName === "VIDEO";
      if (source && (this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
        this.setSource(source);
      } else {
        this.handleLateInit_(this.el_);
      }
      if (options.enableSourceset) {
        this.setupSourcesetHandling_();
      }
      this.isScrubbing_ = false;
      if (this.el_.hasChildNodes()) {
        const nodes = this.el_.childNodes;
        let nodesLength = nodes.length;
        const removeNodes = [];
        while (nodesLength--) {
          const node = nodes[nodesLength];
          const nodeName = node.nodeName.toLowerCase();
          if (nodeName === "track") {
            if (!this.featuresNativeTextTracks) {
              removeNodes.push(node);
            } else {
              this.remoteTextTrackEls().addTrackElement_(node);
              this.remoteTextTracks().addTrack(node.track);
              this.textTracks().addTrack(node.track);
              if (!crossoriginTracks && !this.el_.hasAttribute("crossorigin") && isCrossOrigin(node.src)) {
                crossoriginTracks = true;
              }
            }
          }
        }
        for (let i = 0; i < removeNodes.length; i++) {
          this.el_.removeChild(removeNodes[i]);
        }
      }
      this.proxyNativeTracks_();
      if (this.featuresNativeTextTracks && crossoriginTracks) {
        log$1.warn("Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\nThis may prevent text tracks from loading.");
      }
      this.restoreMetadataTracksInIOSNativePlayer_();
      if ((TOUCH_ENABLED || IS_IPHONE) && options.nativeControlsForTouch === true) {
        this.setControls(true);
      }
      this.proxyWebkitFullscreen_();
      this.triggerReady();
    }
    /**
     * Dispose of `HTML5` media element and remove all tracks.
     */
    dispose() {
      if (this.el_ && this.el_.resetSourceset_) {
        this.el_.resetSourceset_();
      }
      Html5.disposeMediaElement(this.el_);
      this.options_ = null;
      super.dispose();
    }
    /**
     * Modify the media element so that we can detect when
     * the source is changed. Fires `sourceset` just after the source has changed
     */
    setupSourcesetHandling_() {
      setupSourceset(this);
    }
    /**
     * When a captions track is enabled in the iOS Safari native player, all other
     * tracks are disabled (including metadata tracks), which nulls all of their
     * associated cue points. This will restore metadata tracks to their pre-fullscreen
     * state in those cases so that cue points are not needlessly lost.
     *
     * @private
     */
    restoreMetadataTracksInIOSNativePlayer_() {
      const textTracks = this.textTracks();
      let metadataTracksPreFullscreenState;
      const takeMetadataTrackSnapshot = () => {
        metadataTracksPreFullscreenState = [];
        for (let i = 0; i < textTracks.length; i++) {
          const track = textTracks[i];
          if (track.kind === "metadata") {
            metadataTracksPreFullscreenState.push({
              track,
              storedMode: track.mode
            });
          }
        }
      };
      takeMetadataTrackSnapshot();
      textTracks.addEventListener("change", takeMetadataTrackSnapshot);
      this.on("dispose", () => textTracks.removeEventListener("change", takeMetadataTrackSnapshot));
      const restoreTrackMode = () => {
        for (let i = 0; i < metadataTracksPreFullscreenState.length; i++) {
          const storedTrack = metadataTracksPreFullscreenState[i];
          if (storedTrack.track.mode === "disabled" && storedTrack.track.mode !== storedTrack.storedMode) {
            storedTrack.track.mode = storedTrack.storedMode;
          }
        }
        textTracks.removeEventListener("change", restoreTrackMode);
      };
      this.on("webkitbeginfullscreen", () => {
        textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
        textTracks.removeEventListener("change", restoreTrackMode);
        textTracks.addEventListener("change", restoreTrackMode);
      });
      this.on("webkitendfullscreen", () => {
        textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
        textTracks.addEventListener("change", takeMetadataTrackSnapshot);
        textTracks.removeEventListener("change", restoreTrackMode);
      });
    }
    /**
     * Attempt to force override of tracks for the given type
     *
     * @param {string} type - Track type to override, possible values include 'Audio',
     * 'Video', and 'Text'.
     * @param {boolean} override - If set to true native audio/video will be overridden,
     * otherwise native audio/video will potentially be used.
     * @private
     */
    overrideNative_(type, override) {
      if (override !== this[`featuresNative${type}Tracks`]) {
        return;
      }
      const lowerCaseType = type.toLowerCase();
      if (this[`${lowerCaseType}TracksListeners_`]) {
        Object.keys(this[`${lowerCaseType}TracksListeners_`]).forEach((eventName) => {
          const elTracks = this.el()[`${lowerCaseType}Tracks`];
          elTracks.removeEventListener(eventName, this[`${lowerCaseType}TracksListeners_`][eventName]);
        });
      }
      this[`featuresNative${type}Tracks`] = !override;
      this[`${lowerCaseType}TracksListeners_`] = null;
      this.proxyNativeTracksForType_(lowerCaseType);
    }
    /**
     * Attempt to force override of native audio tracks.
     *
     * @param {boolean} override - If set to true native audio will be overridden,
     * otherwise native audio will potentially be used.
     */
    overrideNativeAudioTracks(override) {
      this.overrideNative_("Audio", override);
    }
    /**
     * Attempt to force override of native video tracks.
     *
     * @param {boolean} override - If set to true native video will be overridden,
     * otherwise native video will potentially be used.
     */
    overrideNativeVideoTracks(override) {
      this.overrideNative_("Video", override);
    }
    /**
     * Proxy native track list events for the given type to our track
     * lists if the browser we are playing in supports that type of track list.
     *
     * @param {string} name - Track type; values include 'audio', 'video', and 'text'
     * @private
     */
    proxyNativeTracksForType_(name) {
      const props = NORMAL[name];
      const elTracks = this.el()[props.getterName];
      const techTracks = this[props.getterName]();
      if (!this[`featuresNative${props.capitalName}Tracks`] || !elTracks || !elTracks.addEventListener) {
        return;
      }
      const listeners = {
        change: (e) => {
          const event = {
            type: "change",
            target: techTracks,
            currentTarget: techTracks,
            srcElement: techTracks
          };
          techTracks.trigger(event);
          if (name === "text") {
            this[REMOTE.remoteText.getterName]().trigger(event);
          }
        },
        addtrack(e) {
          techTracks.addTrack(e.track);
        },
        removetrack(e) {
          techTracks.removeTrack(e.track);
        }
      };
      const removeOldTracks = function() {
        const removeTracks = [];
        for (let i = 0; i < techTracks.length; i++) {
          let found = false;
          for (let j = 0; j < elTracks.length; j++) {
            if (elTracks[j] === techTracks[i]) {
              found = true;
              break;
            }
          }
          if (!found) {
            removeTracks.push(techTracks[i]);
          }
        }
        while (removeTracks.length) {
          techTracks.removeTrack(removeTracks.shift());
        }
      };
      this[props.getterName + "Listeners_"] = listeners;
      Object.keys(listeners).forEach((eventName) => {
        const listener = listeners[eventName];
        elTracks.addEventListener(eventName, listener);
        this.on("dispose", (e) => elTracks.removeEventListener(eventName, listener));
      });
      this.on("loadstart", removeOldTracks);
      this.on("dispose", (e) => this.off("loadstart", removeOldTracks));
    }
    /**
     * Proxy all native track list events to our track lists if the browser we are playing
     * in supports that type of track list.
     *
     * @private
     */
    proxyNativeTracks_() {
      NORMAL.names.forEach((name) => {
        this.proxyNativeTracksForType_(name);
      });
    }
    /**
     * Create the `Html5` Tech's DOM element.
     *
     * @return {Element}
     *         The element that gets created.
     */
    createEl() {
      let el = this.options_.tag;
      if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
        if (el) {
          const clone = el.cloneNode(true);
          if (el.parentNode) {
            el.parentNode.insertBefore(clone, el);
          }
          Html5.disposeMediaElement(el);
          el = clone;
        } else {
          el = document.createElement("video");
          const tagAttributes = this.options_.tag && getAttributes(this.options_.tag);
          const attributes = merge$2({}, tagAttributes);
          if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
            delete attributes.controls;
          }
          setAttributes(el, Object.assign(attributes, {
            id: this.options_.techId,
            class: "vjs-tech"
          }));
        }
        el.playerId = this.options_.playerId;
      }
      if (typeof this.options_.preload !== "undefined") {
        setAttribute(el, "preload", this.options_.preload);
      }
      if (this.options_.disablePictureInPicture !== void 0) {
        el.disablePictureInPicture = this.options_.disablePictureInPicture;
      }
      const settingsAttrs = ["loop", "muted", "playsinline", "autoplay"];
      for (let i = 0; i < settingsAttrs.length; i++) {
        const attr = settingsAttrs[i];
        const value = this.options_[attr];
        if (typeof value !== "undefined") {
          if (value) {
            setAttribute(el, attr, attr);
          } else {
            removeAttribute(el, attr);
          }
          el[attr] = value;
        }
      }
      return el;
    }
    /**
     * This will be triggered if the loadstart event has already fired, before videojs was
     * ready. Two known examples of when this can happen are:
     * 1. If we're loading the playback object after it has started loading
     * 2. The media is already playing the (often with autoplay on) then
     *
     * This function will fire another loadstart so that videojs can catchup.
     *
     * @fires Tech#loadstart
     *
     * @return {undefined}
     *         returns nothing.
     */
    handleLateInit_(el) {
      if (el.networkState === 0 || el.networkState === 3) {
        return;
      }
      if (el.readyState === 0) {
        let loadstartFired = false;
        const setLoadstartFired = function() {
          loadstartFired = true;
        };
        this.on("loadstart", setLoadstartFired);
        const triggerLoadstart = function() {
          if (!loadstartFired) {
            this.trigger("loadstart");
          }
        };
        this.on("loadedmetadata", triggerLoadstart);
        this.ready(function() {
          this.off("loadstart", setLoadstartFired);
          this.off("loadedmetadata", triggerLoadstart);
          if (!loadstartFired) {
            this.trigger("loadstart");
          }
        });
        return;
      }
      const eventsToTrigger = ["loadstart"];
      eventsToTrigger.push("loadedmetadata");
      if (el.readyState >= 2) {
        eventsToTrigger.push("loadeddata");
      }
      if (el.readyState >= 3) {
        eventsToTrigger.push("canplay");
      }
      if (el.readyState >= 4) {
        eventsToTrigger.push("canplaythrough");
      }
      this.ready(function() {
        eventsToTrigger.forEach(function(type) {
          this.trigger(type);
        }, this);
      });
    }
    /**
     * Set whether we are scrubbing or not.
     * This is used to decide whether we should use `fastSeek` or not.
     * `fastSeek` is used to provide trick play on Safari browsers.
     *
     * @param {boolean} isScrubbing
     *                  - true for we are currently scrubbing
     *                  - false for we are no longer scrubbing
     */
    setScrubbing(isScrubbing) {
      this.isScrubbing_ = isScrubbing;
    }
    /**
     * Get whether we are scrubbing or not.
     *
     * @return {boolean} isScrubbing
     *                  - true for we are currently scrubbing
     *                  - false for we are no longer scrubbing
     */
    scrubbing() {
      return this.isScrubbing_;
    }
    /**
     * Set current time for the `HTML5` tech.
     *
     * @param {number} seconds
     *        Set the current time of the media to this.
     */
    setCurrentTime(seconds) {
      try {
        if (this.isScrubbing_ && this.el_.fastSeek && IS_ANY_SAFARI) {
          this.el_.fastSeek(seconds);
        } else {
          this.el_.currentTime = seconds;
        }
      } catch (e) {
        log$1(e, "Video is not ready. (Video.js)");
      }
    }
    /**
     * Get the current duration of the HTML5 media element.
     *
     * @return {number}
     *         The duration of the media or 0 if there is no duration.
     */
    duration() {
      if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {
        const checkProgress = () => {
          if (this.el_.currentTime > 0) {
            if (this.el_.duration === Infinity) {
              this.trigger("durationchange");
            }
            this.off("timeupdate", checkProgress);
          }
        };
        this.on("timeupdate", checkProgress);
        return NaN;
      }
      return this.el_.duration || NaN;
    }
    /**
     * Get the current width of the HTML5 media element.
     *
     * @return {number}
     *         The width of the HTML5 media element.
     */
    width() {
      return this.el_.offsetWidth;
    }
    /**
     * Get the current height of the HTML5 media element.
     *
     * @return {number}
     *         The height of the HTML5 media element.
     */
    height() {
      return this.el_.offsetHeight;
    }
    /**
     * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into
     * `fullscreenchange` event.
     *
     * @private
     * @fires fullscreenchange
     * @listens webkitendfullscreen
     * @listens webkitbeginfullscreen
     * @listens webkitbeginfullscreen
     */
    proxyWebkitFullscreen_() {
      if (!("webkitDisplayingFullscreen" in this.el_)) {
        return;
      }
      const endFn = function() {
        this.trigger("fullscreenchange", {
          isFullscreen: false
        });
        if (this.el_.controls && !this.options_.nativeControlsForTouch && this.controls()) {
          this.el_.controls = false;
        }
      };
      const beginFn = function() {
        if ("webkitPresentationMode" in this.el_ && this.el_.webkitPresentationMode !== "picture-in-picture") {
          this.one("webkitendfullscreen", endFn);
          this.trigger("fullscreenchange", {
            isFullscreen: true,
            // set a flag in case another tech triggers fullscreenchange
            nativeIOSFullscreen: true
          });
        }
      };
      this.on("webkitbeginfullscreen", beginFn);
      this.on("dispose", () => {
        this.off("webkitbeginfullscreen", beginFn);
        this.off("webkitendfullscreen", endFn);
      });
    }
    /**
     * Check if fullscreen is supported on the video el.
     *
     * @return {boolean}
     *         - True if fullscreen is supported.
     *         - False if fullscreen is not supported.
     */
    supportsFullScreen() {
      return typeof this.el_.webkitEnterFullScreen === "function";
    }
    /**
     * Request that the `HTML5` Tech enter fullscreen.
     */
    enterFullScreen() {
      const video = this.el_;
      if (video.paused && video.networkState <= video.HAVE_METADATA) {
        silencePromise(this.el_.play());
        this.setTimeout(function() {
          video.pause();
          try {
            video.webkitEnterFullScreen();
          } catch (e) {
            this.trigger("fullscreenerror", e);
          }
        }, 0);
      } else {
        try {
          video.webkitEnterFullScreen();
        } catch (e) {
          this.trigger("fullscreenerror", e);
        }
      }
    }
    /**
     * Request that the `HTML5` Tech exit fullscreen.
     */
    exitFullScreen() {
      if (!this.el_.webkitDisplayingFullscreen) {
        this.trigger("fullscreenerror", new Error("The video is not fullscreen"));
        return;
      }
      this.el_.webkitExitFullScreen();
    }
    /**
     * Create a floating video window always on top of other windows so that users may
     * continue consuming media while they interact with other content sites, or
     * applications on their device.
     *
     * @see [Spec]{@link https://wicg.github.io/picture-in-picture}
     *
     * @return {Promise}
     *         A promise with a Picture-in-Picture window.
     */
    requestPictureInPicture() {
      return this.el_.requestPictureInPicture();
    }
    /**
     * Native requestVideoFrameCallback if supported by browser/tech, or fallback
     * Don't use rVCF on Safari when DRM is playing, as it doesn't fire
     * Needs to be checked later than the constructor
     * This will be a false positive for clear sources loaded after a Fairplay source
     *
     * @param {function} cb function to call
     * @return {number} id of request
     */
    requestVideoFrameCallback(cb) {
      if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {
        return this.el_.requestVideoFrameCallback(cb);
      }
      return super.requestVideoFrameCallback(cb);
    }
    /**
     * Native or fallback requestVideoFrameCallback
     *
     * @param {number} id request id to cancel
     */
    cancelVideoFrameCallback(id) {
      if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {
        this.el_.cancelVideoFrameCallback(id);
      } else {
        super.cancelVideoFrameCallback(id);
      }
    }
    /**
     * A getter/setter for the `Html5` Tech's source object.
     * > Note: Please use {@link Html5#setSource}
     *
     * @param {Tech~SourceObject} [src]
     *        The source object you want to set on the `HTML5` techs element.
     *
     * @return {Tech~SourceObject|undefined}
     *         - The current source object when a source is not passed in.
     *         - undefined when setting
     *
     * @deprecated Since version 5.
     */
    src(src) {
      if (src === void 0) {
        return this.el_.src;
      }
      this.setSrc(src);
    }
    /**
     * Reset the tech by removing all sources and then calling
     * {@link Html5.resetMediaElement}.
     */
    reset() {
      Html5.resetMediaElement(this.el_);
    }
    /**
     * Get the current source on the `HTML5` Tech. Falls back to returning the source from
     * the HTML5 media element.
     *
     * @return {Tech~SourceObject}
     *         The current source object from the HTML5 tech. With a fallback to the
     *         elements source.
     */
    currentSrc() {
      if (this.currentSource_) {
        return this.currentSource_.src;
      }
      return this.el_.currentSrc;
    }
    /**
     * Set controls attribute for the HTML5 media Element.
     *
     * @param {string} val
     *        Value to set the controls attribute to
     */
    setControls(val) {
      this.el_.controls = !!val;
    }
    /**
     * Create and returns a remote {@link TextTrack} object.
     *
     * @param {string} kind
     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
     *
     * @param {string} [label]
     *        Label to identify the text track
     *
     * @param {string} [language]
     *        Two letter language abbreviation
     *
     * @return {TextTrack}
     *         The TextTrack that gets created.
     */
    addTextTrack(kind, label, language) {
      if (!this.featuresNativeTextTracks) {
        return super.addTextTrack(kind, label, language);
      }
      return this.el_.addTextTrack(kind, label, language);
    }
    /**
     * Creates either native TextTrack or an emulated TextTrack depending
     * on the value of `featuresNativeTextTracks`
     *
     * @param {Object} options
     *        The object should contain the options to initialize the TextTrack with.
     *
     * @param {string} [options.kind]
     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
     *
     * @param {string} [options.label]
     *        Label to identify the text track
     *
     * @param {string} [options.language]
     *        Two letter language abbreviation.
     *
     * @param {boolean} [options.default]
     *        Default this track to on.
     *
     * @param {string} [options.id]
     *        The internal id to assign this track.
     *
     * @param {string} [options.src]
     *        A source url for the track.
     *
     * @return {HTMLTrackElement}
     *         The track element that gets created.
     */
    createRemoteTextTrack(options) {
      if (!this.featuresNativeTextTracks) {
        return super.createRemoteTextTrack(options);
      }
      const htmlTrackElement = document.createElement("track");
      if (options.kind) {
        htmlTrackElement.kind = options.kind;
      }
      if (options.label) {
        htmlTrackElement.label = options.label;
      }
      if (options.language || options.srclang) {
        htmlTrackElement.srclang = options.language || options.srclang;
      }
      if (options.default) {
        htmlTrackElement.default = options.default;
      }
      if (options.id) {
        htmlTrackElement.id = options.id;
      }
      if (options.src) {
        htmlTrackElement.src = options.src;
      }
      return htmlTrackElement;
    }
    /**
     * Creates a remote text track object and returns an html track element.
     *
     * @param {Object} options The object should contain values for
     * kind, language, label, and src (location of the WebVTT file)
     * @param {boolean} [manualCleanup=false] if set to true, the TextTrack
     * will not be removed from the TextTrackList and HtmlTrackElementList
     * after a source change
     * @return {HTMLTrackElement} An Html Track Element.
     * This can be an emulated {@link HTMLTrackElement} or a native one.
     *
     */
    addRemoteTextTrack(options, manualCleanup) {
      const htmlTrackElement = super.addRemoteTextTrack(options, manualCleanup);
      if (this.featuresNativeTextTracks) {
        this.el().appendChild(htmlTrackElement);
      }
      return htmlTrackElement;
    }
    /**
     * Remove remote `TextTrack` from `TextTrackList` object
     *
     * @param {TextTrack} track
     *        `TextTrack` object to remove
     */
    removeRemoteTextTrack(track) {
      super.removeRemoteTextTrack(track);
      if (this.featuresNativeTextTracks) {
        const tracks = this.$$("track");
        let i = tracks.length;
        while (i--) {
          if (track === tracks[i] || track === tracks[i].track) {
            this.el().removeChild(tracks[i]);
          }
        }
      }
    }
    /**
     * Gets available media playback quality metrics as specified by the W3C's Media
     * Playback Quality API.
     *
     * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
     *
     * @return {Object}
     *         An object with supported media playback quality metrics
     */
    getVideoPlaybackQuality() {
      if (typeof this.el().getVideoPlaybackQuality === "function") {
        return this.el().getVideoPlaybackQuality();
      }
      const videoPlaybackQuality = {};
      if (typeof this.el().webkitDroppedFrameCount !== "undefined" && typeof this.el().webkitDecodedFrameCount !== "undefined") {
        videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
        videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
      }
      if (window.performance) {
        videoPlaybackQuality.creationTime = window.performance.now();
      }
      return videoPlaybackQuality;
    }
  }
  defineLazyProperty(Html5, "TEST_VID", function() {
    if (!isReal()) {
      return;
    }
    const video = document.createElement("video");
    const track = document.createElement("track");
    track.kind = "captions";
    track.srclang = "en";
    track.label = "English";
    video.appendChild(track);
    return video;
  });
  Html5.isSupported = function() {
    try {
      Html5.TEST_VID.volume = 0.5;
    } catch (e) {
      return false;
    }
    return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
  };
  Html5.canPlayType = function(type) {
    return Html5.TEST_VID.canPlayType(type);
  };
  Html5.canPlaySource = function(srcObj, options) {
    return Html5.canPlayType(srcObj.type);
  };
  Html5.canControlVolume = function() {
    try {
      const volume = Html5.TEST_VID.volume;
      Html5.TEST_VID.volume = volume / 2 + 0.1;
      const canControl = volume !== Html5.TEST_VID.volume;
      if (canControl && IS_IOS) {
        window.setTimeout(() => {
          if (Html5 && Html5.prototype) {
            Html5.prototype.featuresVolumeControl = volume !== Html5.TEST_VID.volume;
          }
        });
        return false;
      }
      return canControl;
    } catch (e) {
      return false;
    }
  };
  Html5.canMuteVolume = function() {
    try {
      const muted = Html5.TEST_VID.muted;
      Html5.TEST_VID.muted = !muted;
      if (Html5.TEST_VID.muted) {
        setAttribute(Html5.TEST_VID, "muted", "muted");
      } else {
        removeAttribute(Html5.TEST_VID, "muted", "muted");
      }
      return muted !== Html5.TEST_VID.muted;
    } catch (e) {
      return false;
    }
  };
  Html5.canControlPlaybackRate = function() {
    if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {
      return false;
    }
    try {
      const playbackRate = Html5.TEST_VID.playbackRate;
      Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
      return playbackRate !== Html5.TEST_VID.playbackRate;
    } catch (e) {
      return false;
    }
  };
  Html5.canOverrideAttributes = function() {
    try {
      const noop2 = () => {
      };
      Object.defineProperty(document.createElement("video"), "src", {
        get: noop2,
        set: noop2
      });
      Object.defineProperty(document.createElement("audio"), "src", {
        get: noop2,
        set: noop2
      });
      Object.defineProperty(document.createElement("video"), "innerHTML", {
        get: noop2,
        set: noop2
      });
      Object.defineProperty(document.createElement("audio"), "innerHTML", {
        get: noop2,
        set: noop2
      });
    } catch (e) {
      return false;
    }
    return true;
  };
  Html5.supportsNativeTextTracks = function() {
    return IS_ANY_SAFARI || IS_IOS && IS_CHROME;
  };
  Html5.supportsNativeVideoTracks = function() {
    return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
  };
  Html5.supportsNativeAudioTracks = function() {
    return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
  };
  Html5.Events = ["loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange"];
  [["featuresMuteControl", "canMuteVolume"], ["featuresPlaybackRate", "canControlPlaybackRate"], ["featuresSourceset", "canOverrideAttributes"], ["featuresNativeTextTracks", "supportsNativeTextTracks"], ["featuresNativeVideoTracks", "supportsNativeVideoTracks"], ["featuresNativeAudioTracks", "supportsNativeAudioTracks"]].forEach(function([key, fn]) {
    defineLazyProperty(Html5.prototype, key, () => Html5[fn](), true);
  });
  Html5.prototype.featuresVolumeControl = Html5.canControlVolume();
  Html5.prototype.movingMediaElementInDOM = !IS_IOS;
  Html5.prototype.featuresFullscreenResize = true;
  Html5.prototype.featuresProgressEvents = true;
  Html5.prototype.featuresTimeupdateEvents = true;
  Html5.prototype.featuresVideoFrameCallback = !!(Html5.TEST_VID && Html5.TEST_VID.requestVideoFrameCallback);
  Html5.disposeMediaElement = function(el) {
    if (!el) {
      return;
    }
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
    while (el.hasChildNodes()) {
      el.removeChild(el.firstChild);
    }
    el.removeAttribute("src");
    if (typeof el.load === "function") {
      (function() {
        try {
          el.load();
        } catch (e) {
        }
      })();
    }
  };
  Html5.resetMediaElement = function(el) {
    if (!el) {
      return;
    }
    const sources = el.querySelectorAll("source");
    let i = sources.length;
    while (i--) {
      el.removeChild(sources[i]);
    }
    el.removeAttribute("src");
    if (typeof el.load === "function") {
      (function() {
        try {
          el.load();
        } catch (e) {
        }
      })();
    }
  };
  [
    /**
     * Get the value of `muted` from the media element. `muted` indicates
     * that the volume for the media should be set to silent. This does not actually change
     * the `volume` attribute.
     *
     * @method Html5#muted
     * @return {boolean}
     *         - True if the value of `volume` should be ignored and the audio set to silent.
     *         - False if the value of `volume` should be used.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
     */
    "muted",
    /**
     * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
     * whether the media should start muted or not. Only changes the default state of the
     * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
     * current state.
     *
     * @method Html5#defaultMuted
     * @return {boolean}
     *         - The value of `defaultMuted` from the media element.
     *         - True indicates that the media should start muted.
     *         - False indicates that the media should not start muted
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
     */
    "defaultMuted",
    /**
     * Get the value of `autoplay` from the media element. `autoplay` indicates
     * that the media should start to play as soon as the page is ready.
     *
     * @method Html5#autoplay
     * @return {boolean}
     *         - The value of `autoplay` from the media element.
     *         - True indicates that the media should start as soon as the page loads.
     *         - False indicates that the media should not start as soon as the page loads.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
     */
    "autoplay",
    /**
     * Get the value of `controls` from the media element. `controls` indicates
     * whether the native media controls should be shown or hidden.
     *
     * @method Html5#controls
     * @return {boolean}
     *         - The value of `controls` from the media element.
     *         - True indicates that native controls should be showing.
     *         - False indicates that native controls should be hidden.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
     */
    "controls",
    /**
     * Get the value of `loop` from the media element. `loop` indicates
     * that the media should return to the start of the media and continue playing once
     * it reaches the end.
     *
     * @method Html5#loop
     * @return {boolean}
     *         - The value of `loop` from the media element.
     *         - True indicates that playback should seek back to start once
     *           the end of a media is reached.
     *         - False indicates that playback should not loop back to the start when the
     *           end of the media is reached.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
     */
    "loop",
    /**
     * Get the value of `playsinline` from the media element. `playsinline` indicates
     * to the browser that non-fullscreen playback is preferred when fullscreen
     * playback is the native default, such as in iOS Safari.
     *
     * @method Html5#playsinline
     * @return {boolean}
     *         - The value of `playsinline` from the media element.
     *         - True indicates that the media should play inline.
     *         - False indicates that the media should not play inline.
     *
     * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
     */
    "playsinline"
  ].forEach(function(prop) {
    Html5.prototype[prop] = function() {
      return this.el_[prop] || this.el_.hasAttribute(prop);
    };
  });
  [
    /**
     * Set the value of `muted` on the media element. `muted` indicates that the current
     * audio level should be silent.
     *
     * @method Html5#setMuted
     * @param {boolean} muted
     *        - True if the audio should be set to silent
     *        - False otherwise
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
     */
    "muted",
    /**
     * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
     * audio level should be silent, but will only effect the muted level on initial playback..
     *
     * @method Html5.prototype.setDefaultMuted
     * @param {boolean} defaultMuted
     *        - True if the audio should be set to silent
     *        - False otherwise
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
     */
    "defaultMuted",
    /**
     * Set the value of `autoplay` on the media element. `autoplay` indicates
     * that the media should start to play as soon as the page is ready.
     *
     * @method Html5#setAutoplay
     * @param {boolean} autoplay
     *         - True indicates that the media should start as soon as the page loads.
     *         - False indicates that the media should not start as soon as the page loads.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
     */
    "autoplay",
    /**
     * Set the value of `loop` on the media element. `loop` indicates
     * that the media should return to the start of the media and continue playing once
     * it reaches the end.
     *
     * @method Html5#setLoop
     * @param {boolean} loop
     *         - True indicates that playback should seek back to start once
     *           the end of a media is reached.
     *         - False indicates that playback should not loop back to the start when the
     *           end of the media is reached.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
     */
    "loop",
    /**
     * Set the value of `playsinline` from the media element. `playsinline` indicates
     * to the browser that non-fullscreen playback is preferred when fullscreen
     * playback is the native default, such as in iOS Safari.
     *
     * @method Html5#setPlaysinline
     * @param {boolean} playsinline
     *         - True indicates that the media should play inline.
     *         - False indicates that the media should not play inline.
     *
     * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
     */
    "playsinline"
  ].forEach(function(prop) {
    Html5.prototype["set" + toTitleCase$1(prop)] = function(v) {
      this.el_[prop] = v;
      if (v) {
        this.el_.setAttribute(prop, prop);
      } else {
        this.el_.removeAttribute(prop);
      }
    };
  });
  [
    /**
     * Get the value of `paused` from the media element. `paused` indicates whether the media element
     * is currently paused or not.
     *
     * @method Html5#paused
     * @return {boolean}
     *         The value of `paused` from the media element.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
     */
    "paused",
    /**
     * Get the value of `currentTime` from the media element. `currentTime` indicates
     * the current second that the media is at in playback.
     *
     * @method Html5#currentTime
     * @return {number}
     *         The value of `currentTime` from the media element.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
     */
    "currentTime",
    /**
     * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
     * object that represents the parts of the media that are already downloaded and
     * available for playback.
     *
     * @method Html5#buffered
     * @return {TimeRange}
     *         The value of `buffered` from the media element.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
     */
    "buffered",
    /**
     * Get the value of `volume` from the media element. `volume` indicates
     * the current playback volume of audio for a media. `volume` will be a value from 0
     * (silent) to 1 (loudest and default).
     *
     * @method Html5#volume
     * @return {number}
     *         The value of `volume` from the media element. Value will be between 0-1.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
     */
    "volume",
    /**
     * Get the value of `poster` from the media element. `poster` indicates
     * that the url of an image file that can/will be shown when no media data is available.
     *
     * @method Html5#poster
     * @return {string}
     *         The value of `poster` from the media element. Value will be a url to an
     *         image.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
     */
    "poster",
    /**
     * Get the value of `preload` from the media element. `preload` indicates
     * what should download before the media is interacted with. It can have the following
     * values:
     * - none: nothing should be downloaded
     * - metadata: poster and the first few frames of the media may be downloaded to get
     *   media dimensions and other metadata
     * - auto: allow the media and metadata for the media to be downloaded before
     *    interaction
     *
     * @method Html5#preload
     * @return {string}
     *         The value of `preload` from the media element. Will be 'none', 'metadata',
     *         or 'auto'.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
     */
    "preload",
    /**
     * Get the value of the `error` from the media element. `error` indicates any
     * MediaError that may have occurred during playback. If error returns null there is no
     * current error.
     *
     * @method Html5#error
     * @return {MediaError|null}
     *         The value of `error` from the media element. Will be `MediaError` if there
     *         is a current error and null otherwise.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
     */
    "error",
    /**
     * Get the value of `seeking` from the media element. `seeking` indicates whether the
     * media is currently seeking to a new position or not.
     *
     * @method Html5#seeking
     * @return {boolean}
     *         - The value of `seeking` from the media element.
     *         - True indicates that the media is currently seeking to a new position.
     *         - False indicates that the media is not seeking to a new position at this time.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
     */
    "seeking",
    /**
     * Get the value of `seekable` from the media element. `seekable` returns a
     * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
     *
     * @method Html5#seekable
     * @return {TimeRange}
     *         The value of `seekable` from the media element. A `TimeRange` object
     *         indicating the current ranges of time that can be seeked to.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
     */
    "seekable",
    /**
     * Get the value of `ended` from the media element. `ended` indicates whether
     * the media has reached the end or not.
     *
     * @method Html5#ended
     * @return {boolean}
     *         - The value of `ended` from the media element.
     *         - True indicates that the media has ended.
     *         - False indicates that the media has not ended.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
     */
    "ended",
    /**
     * Get the value of `playbackRate` from the media element. `playbackRate` indicates
     * the rate at which the media is currently playing back. Examples:
     *   - if playbackRate is set to 2, media will play twice as fast.
     *   - if playbackRate is set to 0.5, media will play half as fast.
     *
     * @method Html5#playbackRate
     * @return {number}
     *         The value of `playbackRate` from the media element. A number indicating
     *         the current playback speed of the media, where 1 is normal speed.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
     */
    "playbackRate",
    /**
     * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
     * the rate at which the media is currently playing back. This value will not indicate the current
     * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
     *
     * Examples:
     *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
     *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
     *
     * @method Html5.prototype.defaultPlaybackRate
     * @return {number}
     *         The value of `defaultPlaybackRate` from the media element. A number indicating
     *         the current playback speed of the media, where 1 is normal speed.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
     */
    "defaultPlaybackRate",
    /**
     * Get the value of 'disablePictureInPicture' from the video element.
     *
     * @method Html5#disablePictureInPicture
     * @return {boolean} value
     *         - The value of `disablePictureInPicture` from the video element.
     *         - True indicates that the video can't be played in Picture-In-Picture mode
     *         - False indicates that the video can be played in Picture-In-Picture mode
     *
     * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
     */
    "disablePictureInPicture",
    /**
     * Get the value of `played` from the media element. `played` returns a `TimeRange`
     * object representing points in the media timeline that have been played.
     *
     * @method Html5#played
     * @return {TimeRange}
     *         The value of `played` from the media element. A `TimeRange` object indicating
     *         the ranges of time that have been played.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
     */
    "played",
    /**
     * Get the value of `networkState` from the media element. `networkState` indicates
     * the current network state. It returns an enumeration from the following list:
     * - 0: NETWORK_EMPTY
     * - 1: NETWORK_IDLE
     * - 2: NETWORK_LOADING
     * - 3: NETWORK_NO_SOURCE
     *
     * @method Html5#networkState
     * @return {number}
     *         The value of `networkState` from the media element. This will be a number
     *         from the list in the description.
     *
     * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
     */
    "networkState",
    /**
     * Get the value of `readyState` from the media element. `readyState` indicates
     * the current state of the media element. It returns an enumeration from the
     * following list:
     * - 0: HAVE_NOTHING
     * - 1: HAVE_METADATA
     * - 2: HAVE_CURRENT_DATA
     * - 3: HAVE_FUTURE_DATA
     * - 4: HAVE_ENOUGH_DATA
     *
     * @method Html5#readyState
     * @return {number}
     *         The value of `readyState` from the media element. This will be a number
     *         from the list in the description.
     *
     * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
     */
    "readyState",
    /**
     * Get the value of `videoWidth` from the video element. `videoWidth` indicates
     * the current width of the video in css pixels.
     *
     * @method Html5#videoWidth
     * @return {number}
     *         The value of `videoWidth` from the video element. This will be a number
     *         in css pixels.
     *
     * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
     */
    "videoWidth",
    /**
     * Get the value of `videoHeight` from the video element. `videoHeight` indicates
     * the current height of the video in css pixels.
     *
     * @method Html5#videoHeight
     * @return {number}
     *         The value of `videoHeight` from the video element. This will be a number
     *         in css pixels.
     *
     * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
     */
    "videoHeight",
    /**
     * Get the value of `crossOrigin` from the media element. `crossOrigin` indicates
     * to the browser that should sent the cookies along with the requests for the
     * different assets/playlists
     *
     * @method Html5#crossOrigin
     * @return {string}
     *         - anonymous indicates that the media should not sent cookies.
     *         - use-credentials indicates that the media should sent cookies along the requests.
     *
     * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
     */
    "crossOrigin"
  ].forEach(function(prop) {
    Html5.prototype[prop] = function() {
      return this.el_[prop];
    };
  });
  [
    /**
     * Set the value of `volume` on the media element. `volume` indicates the current
     * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
     * so on.
     *
     * @method Html5#setVolume
     * @param {number} percentAsDecimal
     *        The volume percent as a decimal. Valid range is from 0-1.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
     */
    "volume",
    /**
     * Set the value of `src` on the media element. `src` indicates the current
     * {@link Tech~SourceObject} for the media.
     *
     * @method Html5#setSrc
     * @param {Tech~SourceObject} src
     *        The source object to set as the current source.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
     */
    "src",
    /**
     * Set the value of `poster` on the media element. `poster` is the url to
     * an image file that can/will be shown when no media data is available.
     *
     * @method Html5#setPoster
     * @param {string} poster
     *        The url to an image that should be used as the `poster` for the media
     *        element.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
     */
    "poster",
    /**
     * Set the value of `preload` on the media element. `preload` indicates
     * what should download before the media is interacted with. It can have the following
     * values:
     * - none: nothing should be downloaded
     * - metadata: poster and the first few frames of the media may be downloaded to get
     *   media dimensions and other metadata
     * - auto: allow the media and metadata for the media to be downloaded before
     *    interaction
     *
     * @method Html5#setPreload
     * @param {string} preload
     *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
     *         or 'auto'.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
     */
    "preload",
    /**
     * Set the value of `playbackRate` on the media element. `playbackRate` indicates
     * the rate at which the media should play back. Examples:
     *   - if playbackRate is set to 2, media will play twice as fast.
     *   - if playbackRate is set to 0.5, media will play half as fast.
     *
     * @method Html5#setPlaybackRate
     * @return {number}
     *         The value of `playbackRate` from the media element. A number indicating
     *         the current playback speed of the media, where 1 is normal speed.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
     */
    "playbackRate",
    /**
     * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
     * the rate at which the media should play back upon initial startup. Changing this value
     * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
     *
     * Example Values:
     *   - if playbackRate is set to 2, media will play twice as fast.
     *   - if playbackRate is set to 0.5, media will play half as fast.
     *
     * @method Html5.prototype.setDefaultPlaybackRate
     * @return {number}
     *         The value of `defaultPlaybackRate` from the media element. A number indicating
     *         the current playback speed of the media, where 1 is normal speed.
     *
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
     */
    "defaultPlaybackRate",
    /**
     * Prevents the browser from suggesting a Picture-in-Picture context menu
     * or to request Picture-in-Picture automatically in some cases.
     *
     * @method Html5#setDisablePictureInPicture
     * @param {boolean} value
     *         The true value will disable Picture-in-Picture mode.
     *
     * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
     */
    "disablePictureInPicture",
    /**
     * Set the value of `crossOrigin` from the media element. `crossOrigin` indicates
     * to the browser that should sent the cookies along with the requests for the
     * different assets/playlists
     *
     * @method Html5#setCrossOrigin
     * @param {string} crossOrigin
     *         - anonymous indicates that the media should not sent cookies.
     *         - use-credentials indicates that the media should sent cookies along the requests.
     *
     * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
     */
    "crossOrigin"
  ].forEach(function(prop) {
    Html5.prototype["set" + toTitleCase$1(prop)] = function(v) {
      this.el_[prop] = v;
    };
  });
  [
    /**
     * A wrapper around the media elements `pause` function. This will call the `HTML5`
     * media elements `pause` function.
     *
     * @method Html5#pause
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
     */
    "pause",
    /**
     * A wrapper around the media elements `load` function. This will call the `HTML5`s
     * media element `load` function.
     *
     * @method Html5#load
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
     */
    "load",
    /**
     * A wrapper around the media elements `play` function. This will call the `HTML5`s
     * media element `play` function.
     *
     * @method Html5#play
     * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
     */
    "play"
  ].forEach(function(prop) {
    Html5.prototype[prop] = function() {
      return this.el_[prop]();
    };
  });
  Tech.withSourceHandlers(Html5);
  Html5.nativeSourceHandler = {};
  Html5.nativeSourceHandler.canPlayType = function(type) {
    try {
      return Html5.TEST_VID.canPlayType(type);
    } catch (e) {
      return "";
    }
  };
  Html5.nativeSourceHandler.canHandleSource = function(source, options) {
    if (source.type) {
      return Html5.nativeSourceHandler.canPlayType(source.type);
    } else if (source.src) {
      const ext = getFileExtension(source.src);
      return Html5.nativeSourceHandler.canPlayType(`video/${ext}`);
    }
    return "";
  };
  Html5.nativeSourceHandler.handleSource = function(source, tech, options) {
    tech.setSrc(source.src);
  };
  Html5.nativeSourceHandler.dispose = function() {
  };
  Html5.registerSourceHandler(Html5.nativeSourceHandler);
  Tech.registerTech("Html5", Html5);
  const TECH_EVENTS_RETRIGGER = [
    /**
     * Fired while the user agent is downloading media data.
     *
     * @event Player#progress
     * @type {Event}
     */
    /**
     * Retrigger the `progress` event that was triggered by the {@link Tech}.
     *
     * @private
     * @method Player#handleTechProgress_
     * @fires Player#progress
     * @listens Tech#progress
     */
    "progress",
    /**
     * Fires when the loading of an audio/video is aborted.
     *
     * @event Player#abort
     * @type {Event}
     */
    /**
     * Retrigger the `abort` event that was triggered by the {@link Tech}.
     *
     * @private
     * @method Player#handleTechAbort_
     * @fires Player#abort
     * @listens Tech#abort
     */
    "abort",
    /**
     * Fires when the browser is intentionally not getting media data.
     *
     * @event Player#suspend
     * @type {Event}
     */
    /**
     * Retrigger the `suspend` event that was triggered by the {@link Tech}.
     *
     * @private
     * @method Player#handleTechSuspend_
     * @fires Player#suspend
     * @listens Tech#suspend
     */
    "suspend",
    /**
     * Fires when the current playlist is empty.
     *
     * @event Player#emptied
     * @type {Event}
     */
    /**
     * Retrigger the `emptied` event that was triggered by the {@link Tech}.
     *
     * @private
     * @method Player#handleTechEmptied_
     * @fires Player#emptied
     * @listens Tech#emptied
     */
    "emptied",
    /**
     * Fires when the browser is trying to get media data, but data is not available.
     *
     * @event Player#stalled
     * @type {Event}
     */
    /**
     * Retrigger the `stalled` event that was triggered by the {@link Tech}.
     *
     * @private
     * @method Player#handleTechStalled_
     * @fires Player#stalled
     * @listens Tech#stalled
     */
    "stalled",
    /**
     * Fires when the browser has loaded meta data for the audio/video.
     *
     * @event Player#loadedmetadata
     * @type {Event}
     */
    /**
     * Retrigger the `loadedmetadata` event that was triggered by the {@link Tech}.
     *
     * @private
     * @method Player#handleTechLoadedmetadata_
     * @fires Player#loadedmetadata
     * @listens Tech#loadedmetadata
     */
    "loadedmetadata",
    /**
     * Fires when the browser has loaded the current frame of the audio/video.
     *
     * @event Player#loadeddata
     * @type {event}
     */
    /**
     * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
     *
     * @private
     * @method Player#handleTechLoaddeddata_
     * @fires Player#loadeddata
     * @listens Tech#loadeddata
     */
    "loadeddata",
    /**
     * Fires when the current playback position has changed.
     *
     * @event Player#timeupdate
     * @type {event}
     */
    /**
     * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
     *
     * @private
     * @method Player#handleTechTimeUpdate_
     * @fires Player#timeupdate
     * @listens Tech#timeupdate
     */
    "timeupdate",
    /**
     * Fires when the video's intrinsic dimensions change
     *
     * @event Player#resize
     * @type {event}
     */
    /**
     * Retrigger the `resize` event that was triggered by the {@link Tech}.
     *
     * @private
     * @method Player#handleTechResize_
     * @fires Player#resize
     * @listens Tech#resize
     */
    "resize",
    /**
     * Fires when the volume has been changed
     *
     * @event Player#volumechange
     * @type {event}
     */
    /**
     * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
     *
     * @private
     * @method Player#handleTechVolumechange_
     * @fires Player#volumechange
     * @listens Tech#volumechange
     */
    "volumechange",
    /**
     * Fires when the text track has been changed
     *
     * @event Player#texttrackchange
     * @type {event}
     */
    /**
     * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
     *
     * @private
     * @method Player#handleTechTexttrackchange_
     * @fires Player#texttrackchange
     * @listens Tech#texttrackchange
     */
    "texttrackchange"
  ];
  const TECH_EVENTS_QUEUE = {
    canplay: "CanPlay",
    canplaythrough: "CanPlayThrough",
    playing: "Playing",
    seeked: "Seeked"
  };
  const BREAKPOINT_ORDER = ["tiny", "xsmall", "small", "medium", "large", "xlarge", "huge"];
  const BREAKPOINT_CLASSES = {};
  BREAKPOINT_ORDER.forEach((k) => {
    const v = k.charAt(0) === "x" ? `x-${k.substring(1)}` : k;
    BREAKPOINT_CLASSES[k] = `vjs-layout-${v}`;
  });
  const DEFAULT_BREAKPOINTS = {
    tiny: 210,
    xsmall: 320,
    small: 425,
    medium: 768,
    large: 1440,
    xlarge: 2560,
    huge: Infinity
  };
  class Player extends Component$1 {
    /**
     * Create an instance of this class.
     *
     * @param {Element} tag
     *        The original video DOM element used for configuring options.
     *
     * @param {Object} [options]
     *        Object of option names and values.
     *
     * @param {Function} [ready]
     *        Ready callback function.
     */
    constructor(tag, options, ready) {
      tag.id = tag.id || options.id || `vjs_video_${newGUID()}`;
      options = Object.assign(Player.getTagSettings(tag), options);
      options.initChildren = false;
      options.createEl = false;
      options.evented = false;
      options.reportTouchActivity = false;
      if (!options.language) {
        const closest = tag.closest("[lang]");
        if (closest) {
          options.language = closest.getAttribute("lang");
        }
      }
      super(null, options, ready);
      this.boundDocumentFullscreenChange_ = (e) => this.documentFullscreenChange_(e);
      this.boundFullWindowOnEscKey_ = (e) => this.fullWindowOnEscKey(e);
      this.boundUpdateStyleEl_ = (e) => this.updateStyleEl_(e);
      this.boundApplyInitTime_ = (e) => this.applyInitTime_(e);
      this.boundUpdateCurrentBreakpoint_ = (e) => this.updateCurrentBreakpoint_(e);
      this.boundHandleTechClick_ = (e) => this.handleTechClick_(e);
      this.boundHandleTechDoubleClick_ = (e) => this.handleTechDoubleClick_(e);
      this.boundHandleTechTouchStart_ = (e) => this.handleTechTouchStart_(e);
      this.boundHandleTechTouchMove_ = (e) => this.handleTechTouchMove_(e);
      this.boundHandleTechTouchEnd_ = (e) => this.handleTechTouchEnd_(e);
      this.boundHandleTechTap_ = (e) => this.handleTechTap_(e);
      this.isFullscreen_ = false;
      this.log = createLogger(this.id_);
      this.fsApi_ = FullscreenApi;
      this.isPosterFromTech_ = false;
      this.queuedCallbacks_ = [];
      this.isReady_ = false;
      this.hasStarted_ = false;
      this.userActive_ = false;
      this.debugEnabled_ = false;
      this.audioOnlyMode_ = false;
      this.audioPosterMode_ = false;
      this.audioOnlyCache_ = {
        playerHeight: null,
        hiddenChildren: []
      };
      if (!this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) {
        throw new Error("No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?");
      }
      this.tag = tag;
      this.tagAttributes = tag && getAttributes(tag);
      this.language(this.options_.language);
      if (options.languages) {
        const languagesToLower = {};
        Object.getOwnPropertyNames(options.languages).forEach(function(name) {
          languagesToLower[name.toLowerCase()] = options.languages[name];
        });
        this.languages_ = languagesToLower;
      } else {
        this.languages_ = Player.prototype.options_.languages;
      }
      this.resetCache_();
      this.poster_ = options.poster || "";
      this.controls_ = !!options.controls;
      tag.controls = false;
      tag.removeAttribute("controls");
      this.changingSrc_ = false;
      this.playCallbacks_ = [];
      this.playTerminatedQueue_ = [];
      if (tag.hasAttribute("autoplay")) {
        this.autoplay(true);
      } else {
        this.autoplay(this.options_.autoplay);
      }
      if (options.plugins) {
        Object.keys(options.plugins).forEach((name) => {
          if (typeof this[name] !== "function") {
            throw new Error(`plugin "${name}" does not exist`);
          }
        });
      }
      this.scrubbing_ = false;
      this.el_ = this.createEl();
      evented(this, {
        eventBusKey: "el_"
      });
      if (this.fsApi_.requestFullscreen) {
        on(document, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
        this.on(this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
      }
      if (this.fluid_) {
        this.on(["playerreset", "resize"], this.boundUpdateStyleEl_);
      }
      const playerOptionsCopy = merge$2(this.options_);
      if (options.plugins) {
        Object.keys(options.plugins).forEach((name) => {
          this[name](options.plugins[name]);
        });
      }
      if (options.debug) {
        this.debug(true);
      }
      this.options_.playerOptions = playerOptionsCopy;
      this.middleware_ = [];
      this.playbackRates(options.playbackRates);
      if (options.experimentalSvgIcons) {
        const parser = new window.DOMParser();
        const parsedSVG = parser.parseFromString(icons, "image/svg+xml");
        const errorNode = parsedSVG.querySelector("parsererror");
        if (errorNode) {
          log$1.warn("Failed to load SVG Icons. Falling back to Font Icons.");
          this.options_.experimentalSvgIcons = null;
        } else {
          const sprite = parsedSVG.documentElement;
          sprite.style.display = "none";
          this.el_.appendChild(sprite);
          this.addClass("vjs-svg-icons-enabled");
        }
      }
      this.initChildren();
      this.isAudio(tag.nodeName.toLowerCase() === "audio");
      if (this.controls()) {
        this.addClass("vjs-controls-enabled");
      } else {
        this.addClass("vjs-controls-disabled");
      }
      this.el_.setAttribute("role", "region");
      if (this.isAudio()) {
        this.el_.setAttribute("aria-label", this.localize("Audio Player"));
      } else {
        this.el_.setAttribute("aria-label", this.localize("Video Player"));
      }
      if (this.isAudio()) {
        this.addClass("vjs-audio");
      }
      if (TOUCH_ENABLED) {
        this.addClass("vjs-touch-enabled");
      }
      if (!IS_IOS) {
        this.addClass("vjs-workinghover");
      }
      Player.players[this.id_] = this;
      const majorVersion = version$5.split(".")[0];
      this.addClass(`vjs-v${majorVersion}`);
      this.userActive(true);
      this.reportUserActivity();
      this.one("play", (e) => this.listenForUserActivity_(e));
      this.on("keydown", (e) => this.handleKeyDown(e));
      this.on("languagechange", (e) => this.handleLanguagechange(e));
      this.breakpoints(this.options_.breakpoints);
      this.responsive(this.options_.responsive);
      this.on("ready", () => {
        this.audioPosterMode(this.options_.audioPosterMode);
        this.audioOnlyMode(this.options_.audioOnlyMode);
      });
    }
    /**
     * Destroys the video player and does any necessary cleanup.
     *
     * This is especially helpful if you are dynamically adding and removing videos
     * to/from the DOM.
     *
     * @fires Player#dispose
     */
    dispose() {
      this.trigger("dispose");
      this.off("dispose");
      off(document, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
      off(document, "keydown", this.boundFullWindowOnEscKey_);
      if (this.styleEl_ && this.styleEl_.parentNode) {
        this.styleEl_.parentNode.removeChild(this.styleEl_);
        this.styleEl_ = null;
      }
      Player.players[this.id_] = null;
      if (this.tag && this.tag.player) {
        this.tag.player = null;
      }
      if (this.el_ && this.el_.player) {
        this.el_.player = null;
      }
      if (this.tech_) {
        this.tech_.dispose();
        this.isPosterFromTech_ = false;
        this.poster_ = "";
      }
      if (this.playerElIngest_) {
        this.playerElIngest_ = null;
      }
      if (this.tag) {
        this.tag = null;
      }
      clearCacheForPlayer(this);
      ALL.names.forEach((name) => {
        const props = ALL[name];
        const list = this[props.getterName]();
        if (list && list.off) {
          list.off();
        }
      });
      super.dispose({
        restoreEl: this.options_.restoreEl
      });
    }
    /**
     * Create the `Player`'s DOM element.
     *
     * @return {Element}
     *         The DOM element that gets created.
     */
    createEl() {
      let tag = this.tag;
      let el;
      let playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute("data-vjs-player");
      const divEmbed = this.tag.tagName.toLowerCase() === "video-js";
      if (playerElIngest) {
        el = this.el_ = tag.parentNode;
      } else if (!divEmbed) {
        el = this.el_ = super.createEl("div");
      }
      const attrs = getAttributes(tag);
      if (divEmbed) {
        el = this.el_ = tag;
        tag = this.tag = document.createElement("video");
        while (el.children.length) {
          tag.appendChild(el.firstChild);
        }
        if (!hasClass(el, "video-js")) {
          addClass(el, "video-js");
        }
        el.appendChild(tag);
        playerElIngest = this.playerElIngest_ = el;
        Object.keys(el).forEach((k) => {
          try {
            tag[k] = el[k];
          } catch (e) {
          }
        });
      }
      tag.setAttribute("tabindex", "-1");
      attrs.tabindex = "-1";
      if (IS_CHROME && IS_WINDOWS) {
        tag.setAttribute("role", "application");
        attrs.role = "application";
      }
      tag.removeAttribute("width");
      tag.removeAttribute("height");
      if ("width" in attrs) {
        delete attrs.width;
      }
      if ("height" in attrs) {
        delete attrs.height;
      }
      Object.getOwnPropertyNames(attrs).forEach(function(attr) {
        if (!(divEmbed && attr === "class")) {
          el.setAttribute(attr, attrs[attr]);
        }
        if (divEmbed) {
          tag.setAttribute(attr, attrs[attr]);
        }
      });
      tag.playerId = tag.id;
      tag.id += "_html5_api";
      tag.className = "vjs-tech";
      tag.player = el.player = this;
      this.addClass("vjs-paused");
      if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true) {
        this.styleEl_ = createStyleElement("vjs-styles-dimensions");
        const defaultsStyleEl = $(".vjs-styles-defaults");
        const head = $("head");
        head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
      }
      this.fill_ = false;
      this.fluid_ = false;
      this.width(this.options_.width);
      this.height(this.options_.height);
      this.fill(this.options_.fill);
      this.fluid(this.options_.fluid);
      this.aspectRatio(this.options_.aspectRatio);
      this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
      const links = tag.getElementsByTagName("a");
      for (let i = 0; i < links.length; i++) {
        const linkEl = links.item(i);
        addClass(linkEl, "vjs-hidden");
        linkEl.setAttribute("hidden", "hidden");
      }
      tag.initNetworkState_ = tag.networkState;
      if (tag.parentNode && !playerElIngest) {
        tag.parentNode.insertBefore(el, tag);
      }
      prependTo(tag, el);
      this.children_.unshift(tag);
      this.el_.setAttribute("lang", this.language_);
      this.el_.setAttribute("translate", "no");
      this.el_ = el;
      return el;
    }
    /**
     * Get or set the `Player`'s crossOrigin option. For the HTML5 player, this
     * sets the `crossOrigin` property on the `<video>` tag to control the CORS
     * behavior.
     *
     * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}
     *
     * @param {string|null} [value]
     *        The value to set the `Player`'s crossOrigin to. If an argument is
     *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.
     *
     * @return {string|null|undefined}
     *         - The current crossOrigin value of the `Player` when getting.
     *         - undefined when setting
     */
    crossOrigin(value) {
      if (typeof value === "undefined") {
        return this.techGet_("crossOrigin");
      }
      if (value !== null && value !== "anonymous" && value !== "use-credentials") {
        log$1.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${value}"`);
        return;
      }
      this.techCall_("setCrossOrigin", value);
      if (this.posterImage) {
        this.posterImage.crossOrigin(value);
      }
      return;
    }
    /**
     * A getter/setter for the `Player`'s width. Returns the player's configured value.
     * To get the current width use `currentWidth()`.
     *
     * @param {number|string} [value]
     *        CSS value to set the `Player`'s width to.
     *
     * @return {number|undefined}
     *         - The current width of the `Player` when getting.
     *         - Nothing when setting
     */
    width(value) {
      return this.dimension("width", value);
    }
    /**
     * A getter/setter for the `Player`'s height. Returns the player's configured value.
     * To get the current height use `currentheight()`.
     *
     * @param {number|string} [value]
     *        CSS value to set the `Player`'s height to.
     *
     * @return {number|undefined}
     *         - The current height of the `Player` when getting.
     *         - Nothing when setting
     */
    height(value) {
      return this.dimension("height", value);
    }
    /**
     * A getter/setter for the `Player`'s width & height.
     *
     * @param {string} dimension
     *        This string can be:
     *        - 'width'
     *        - 'height'
     *
     * @param {number|string} [value]
     *        Value for dimension specified in the first argument.
     *
     * @return {number}
     *         The dimension arguments value when getting (width/height).
     */
    dimension(dimension, value) {
      const privDimension = dimension + "_";
      if (value === void 0) {
        return this[privDimension] || 0;
      }
      if (value === "" || value === "auto") {
        this[privDimension] = void 0;
        this.updateStyleEl_();
        return;
      }
      const parsedVal = parseFloat(value);
      if (isNaN(parsedVal)) {
        log$1.error(`Improper value "${value}" supplied for for ${dimension}`);
        return;
      }
      this[privDimension] = parsedVal;
      this.updateStyleEl_();
    }
    /**
     * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.
     *
     * Turning this on will turn off fill mode.
     *
     * @param {boolean} [bool]
     *        - A value of true adds the class.
     *        - A value of false removes the class.
     *        - No value will be a getter.
     *
     * @return {boolean|undefined}
     *         - The value of fluid when getting.
     *         - `undefined` when setting.
     */
    fluid(bool) {
      if (bool === void 0) {
        return !!this.fluid_;
      }
      this.fluid_ = !!bool;
      if (isEvented(this)) {
        this.off(["playerreset", "resize"], this.boundUpdateStyleEl_);
      }
      if (bool) {
        this.addClass("vjs-fluid");
        this.fill(false);
        addEventedCallback(this, () => {
          this.on(["playerreset", "resize"], this.boundUpdateStyleEl_);
        });
      } else {
        this.removeClass("vjs-fluid");
      }
      this.updateStyleEl_();
    }
    /**
     * A getter/setter/toggler for the vjs-fill `className` on the `Player`.
     *
     * Turning this on will turn off fluid mode.
     *
     * @param {boolean} [bool]
     *        - A value of true adds the class.
     *        - A value of false removes the class.
     *        - No value will be a getter.
     *
     * @return {boolean|undefined}
     *         - The value of fluid when getting.
     *         - `undefined` when setting.
     */
    fill(bool) {
      if (bool === void 0) {
        return !!this.fill_;
      }
      this.fill_ = !!bool;
      if (bool) {
        this.addClass("vjs-fill");
        this.fluid(false);
      } else {
        this.removeClass("vjs-fill");
      }
    }
    /**
     * Get/Set the aspect ratio
     *
     * @param {string} [ratio]
     *        Aspect ratio for player
     *
     * @return {string|undefined}
     *         returns the current aspect ratio when getting
     */
    /**
     * A getter/setter for the `Player`'s aspect ratio.
     *
     * @param {string} [ratio]
     *        The value to set the `Player`'s aspect ratio to.
     *
     * @return {string|undefined}
     *         - The current aspect ratio of the `Player` when getting.
     *         - undefined when setting
     */
    aspectRatio(ratio) {
      if (ratio === void 0) {
        return this.aspectRatio_;
      }
      if (!/^\d+\:\d+$/.test(ratio)) {
        throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.");
      }
      this.aspectRatio_ = ratio;
      this.fluid(true);
      this.updateStyleEl_();
    }
    /**
     * Update styles of the `Player` element (height, width and aspect ratio).
     *
     * @private
     * @listens Tech#loadedmetadata
     */
    updateStyleEl_() {
      if (window.VIDEOJS_NO_DYNAMIC_STYLE === true) {
        const width2 = typeof this.width_ === "number" ? this.width_ : this.options_.width;
        const height2 = typeof this.height_ === "number" ? this.height_ : this.options_.height;
        const techEl = this.tech_ && this.tech_.el();
        if (techEl) {
          if (width2 >= 0) {
            techEl.width = width2;
          }
          if (height2 >= 0) {
            techEl.height = height2;
          }
        }
        return;
      }
      let width;
      let height;
      let aspectRatio;
      let idClass;
      if (this.aspectRatio_ !== void 0 && this.aspectRatio_ !== "auto") {
        aspectRatio = this.aspectRatio_;
      } else if (this.videoWidth() > 0) {
        aspectRatio = this.videoWidth() + ":" + this.videoHeight();
      } else {
        aspectRatio = "16:9";
      }
      const ratioParts = aspectRatio.split(":");
      const ratioMultiplier = ratioParts[1] / ratioParts[0];
      if (this.width_ !== void 0) {
        width = this.width_;
      } else if (this.height_ !== void 0) {
        width = this.height_ / ratioMultiplier;
      } else {
        width = this.videoWidth() || 300;
      }
      if (this.height_ !== void 0) {
        height = this.height_;
      } else {
        height = width * ratioMultiplier;
      }
      if (/^[^a-zA-Z]/.test(this.id())) {
        idClass = "dimensions-" + this.id();
      } else {
        idClass = this.id() + "-dimensions";
      }
      this.addClass(idClass);
      setTextContent(this.styleEl_, `
      .${idClass} {
        width: ${width}px;
        height: ${height}px;
      }

      .${idClass}.vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: ${ratioMultiplier * 100}%;
      }
    `);
    }
    /**
     * Load/Create an instance of playback {@link Tech} including element
     * and API methods. Then append the `Tech` element in `Player` as a child.
     *
     * @param {string} techName
     *        name of the playback technology
     *
     * @param {string} source
     *        video source
     *
     * @private
     */
    loadTech_(techName, source) {
      if (this.tech_) {
        this.unloadTech_();
      }
      const titleTechName = toTitleCase$1(techName);
      const camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);
      if (titleTechName !== "Html5" && this.tag) {
        Tech.getTech("Html5").disposeMediaElement(this.tag);
        this.tag.player = null;
        this.tag = null;
      }
      this.techName_ = titleTechName;
      this.isReady_ = false;
      let autoplay = this.autoplay();
      if (typeof this.autoplay() === "string" || this.autoplay() === true && this.options_.normalizeAutoplay) {
        autoplay = false;
      }
      const techOptions = {
        source,
        autoplay,
        "nativeControlsForTouch": this.options_.nativeControlsForTouch,
        "playerId": this.id(),
        "techId": `${this.id()}_${camelTechName}_api`,
        "playsinline": this.options_.playsinline,
        "preload": this.options_.preload,
        "loop": this.options_.loop,
        "disablePictureInPicture": this.options_.disablePictureInPicture,
        "muted": this.options_.muted,
        "poster": this.poster(),
        "language": this.language(),
        "playerElIngest": this.playerElIngest_ || false,
        "vtt.js": this.options_["vtt.js"],
        "canOverridePoster": !!this.options_.techCanOverridePoster,
        "enableSourceset": this.options_.enableSourceset
      };
      ALL.names.forEach((name) => {
        const props = ALL[name];
        techOptions[props.getterName] = this[props.privateName];
      });
      Object.assign(techOptions, this.options_[titleTechName]);
      Object.assign(techOptions, this.options_[camelTechName]);
      Object.assign(techOptions, this.options_[techName.toLowerCase()]);
      if (this.tag) {
        techOptions.tag = this.tag;
      }
      if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {
        techOptions.startTime = this.cache_.currentTime;
      }
      const TechClass = Tech.getTech(techName);
      if (!TechClass) {
        throw new Error(`No Tech named '${titleTechName}' exists! '${titleTechName}' should be registered using videojs.registerTech()'`);
      }
      this.tech_ = new TechClass(techOptions);
      this.tech_.ready(bind_(this, this.handleTechReady_), true);
      textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);
      TECH_EVENTS_RETRIGGER.forEach((event) => {
        this.on(this.tech_, event, (e) => this[`handleTech${toTitleCase$1(event)}_`](e));
      });
      Object.keys(TECH_EVENTS_QUEUE).forEach((event) => {
        this.on(this.tech_, event, (eventObj) => {
          if (this.tech_.playbackRate() === 0 && this.tech_.seeking()) {
            this.queuedCallbacks_.push({
              callback: this[`handleTech${TECH_EVENTS_QUEUE[event]}_`].bind(this),
              event: eventObj
            });
            return;
          }
          this[`handleTech${TECH_EVENTS_QUEUE[event]}_`](eventObj);
        });
      });
      this.on(this.tech_, "loadstart", (e) => this.handleTechLoadStart_(e));
      this.on(this.tech_, "sourceset", (e) => this.handleTechSourceset_(e));
      this.on(this.tech_, "waiting", (e) => this.handleTechWaiting_(e));
      this.on(this.tech_, "ended", (e) => this.handleTechEnded_(e));
      this.on(this.tech_, "seeking", (e) => this.handleTechSeeking_(e));
      this.on(this.tech_, "play", (e) => this.handleTechPlay_(e));
      this.on(this.tech_, "pause", (e) => this.handleTechPause_(e));
      this.on(this.tech_, "durationchange", (e) => this.handleTechDurationChange_(e));
      this.on(this.tech_, "fullscreenchange", (e, data) => this.handleTechFullscreenChange_(e, data));
      this.on(this.tech_, "fullscreenerror", (e, err) => this.handleTechFullscreenError_(e, err));
      this.on(this.tech_, "enterpictureinpicture", (e) => this.handleTechEnterPictureInPicture_(e));
      this.on(this.tech_, "leavepictureinpicture", (e) => this.handleTechLeavePictureInPicture_(e));
      this.on(this.tech_, "error", (e) => this.handleTechError_(e));
      this.on(this.tech_, "posterchange", (e) => this.handleTechPosterChange_(e));
      this.on(this.tech_, "textdata", (e) => this.handleTechTextData_(e));
      this.on(this.tech_, "ratechange", (e) => this.handleTechRateChange_(e));
      this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_);
      this.usingNativeControls(this.techGet_("controls"));
      if (this.controls() && !this.usingNativeControls()) {
        this.addTechControlsListeners_();
      }
      if (this.tech_.el().parentNode !== this.el() && (titleTechName !== "Html5" || !this.tag)) {
        prependTo(this.tech_.el(), this.el());
      }
      if (this.tag) {
        this.tag.player = null;
        this.tag = null;
      }
    }
    /**
     * Unload and dispose of the current playback {@link Tech}.
     *
     * @private
     */
    unloadTech_() {
      ALL.names.forEach((name) => {
        const props = ALL[name];
        this[props.privateName] = this[props.getterName]();
      });
      this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);
      this.isReady_ = false;
      this.tech_.dispose();
      this.tech_ = false;
      if (this.isPosterFromTech_) {
        this.poster_ = "";
        this.trigger("posterchange");
      }
      this.isPosterFromTech_ = false;
    }
    /**
     * Return a reference to the current {@link Tech}.
     * It will print a warning by default about the danger of using the tech directly
     * but any argument that is passed in will silence the warning.
     *
     * @param {*} [safety]
     *        Anything passed in to silence the warning
     *
     * @return {Tech}
     *         The Tech
     */
    tech(safety) {
      if (safety === void 0) {
        log$1.warn("Using the tech directly can be dangerous. I hope you know what you're doing.\nSee https://github.com/videojs/video.js/issues/2617 for more info.\n");
      }
      return this.tech_;
    }
    /**
     * Set up click and touch listeners for the playback element
     *
     * - On desktops: a click on the video itself will toggle playback
     * - On mobile devices: a click on the video toggles controls
     *   which is done by toggling the user state between active and
     *   inactive
     * - A tap can signal that a user has become active or has become inactive
     *   e.g. a quick tap on an iPhone movie should reveal the controls. Another
     *   quick tap should hide them again (signaling the user is in an inactive
     *   viewing state)
     * - In addition to this, we still want the user to be considered inactive after
     *   a few seconds of inactivity.
     *
     * > Note: the only part of iOS interaction we can't mimic with this setup
     * is a touch and hold on the video element counting as activity in order to
     * keep the controls showing, but that shouldn't be an issue. A touch and hold
     * on any controls will still keep the user active
     *
     * @private
     */
    addTechControlsListeners_() {
      this.removeTechControlsListeners_();
      this.on(this.tech_, "click", this.boundHandleTechClick_);
      this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
      this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
      this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
      this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
      this.on(this.tech_, "tap", this.boundHandleTechTap_);
    }
    /**
     * Remove the listeners used for click and tap controls. This is needed for
     * toggling to controls disabled, where a tap/touch should do nothing.
     *
     * @private
     */
    removeTechControlsListeners_() {
      this.off(this.tech_, "tap", this.boundHandleTechTap_);
      this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
      this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
      this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
      this.off(this.tech_, "click", this.boundHandleTechClick_);
      this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
    }
    /**
     * Player waits for the tech to be ready
     *
     * @private
     */
    handleTechReady_() {
      this.triggerReady();
      if (this.cache_.volume) {
        this.techCall_("setVolume", this.cache_.volume);
      }
      this.handleTechPosterChange_();
      this.handleTechDurationChange_();
    }
    /**
     * Retrigger the `loadstart` event that was triggered by the {@link Tech}.
     *
     * @fires Player#loadstart
     * @listens Tech#loadstart
     * @private
     */
    handleTechLoadStart_() {
      this.removeClass("vjs-ended", "vjs-seeking");
      this.error(null);
      this.handleTechDurationChange_();
      if (!this.paused()) {
        this.trigger("loadstart");
      } else {
        this.hasStarted(false);
        this.trigger("loadstart");
      }
      this.manualAutoplay_(this.autoplay() === true && this.options_.normalizeAutoplay ? "play" : this.autoplay());
    }
    /**
     * Handle autoplay string values, rather than the typical boolean
     * values that should be handled by the tech. Note that this is not
     * part of any specification. Valid values and what they do can be
     * found on the autoplay getter at Player#autoplay()
     */
    manualAutoplay_(type) {
      if (!this.tech_ || typeof type !== "string") {
        return;
      }
      const resolveMuted = () => {
        const previouslyMuted = this.muted();
        this.muted(true);
        const restoreMuted = () => {
          this.muted(previouslyMuted);
        };
        this.playTerminatedQueue_.push(restoreMuted);
        const mutedPromise = this.play();
        if (!isPromise(mutedPromise)) {
          return;
        }
        return mutedPromise.catch((err) => {
          restoreMuted();
          throw new Error(`Rejection at manualAutoplay. Restoring muted value. ${err ? err : ""}`);
        });
      };
      let promise;
      if (type === "any" && !this.muted()) {
        promise = this.play();
        if (isPromise(promise)) {
          promise = promise.catch(resolveMuted);
        }
      } else if (type === "muted" && !this.muted()) {
        promise = resolveMuted();
      } else {
        promise = this.play();
      }
      if (!isPromise(promise)) {
        return;
      }
      return promise.then(() => {
        this.trigger({
          type: "autoplay-success",
          autoplay: type
        });
      }).catch(() => {
        this.trigger({
          type: "autoplay-failure",
          autoplay: type
        });
      });
    }
    /**
     * Update the internal source caches so that we return the correct source from
     * `src()`, `currentSource()`, and `currentSources()`.
     *
     * > Note: `currentSources` will not be updated if the source that is passed in exists
     *         in the current `currentSources` cache.
     *
     *
     * @param {Tech~SourceObject} srcObj
     *        A string or object source to update our caches to.
     */
    updateSourceCaches_(srcObj = "") {
      let src = srcObj;
      let type = "";
      if (typeof src !== "string") {
        src = srcObj.src;
        type = srcObj.type;
      }
      this.cache_.source = this.cache_.source || {};
      this.cache_.sources = this.cache_.sources || [];
      if (src && !type) {
        type = findMimetype(this, src);
      }
      this.cache_.source = merge$2({}, srcObj, {
        src,
        type
      });
      const matchingSources = this.cache_.sources.filter((s) => s.src && s.src === src);
      const sourceElSources = [];
      const sourceEls = this.$$("source");
      const matchingSourceEls = [];
      for (let i = 0; i < sourceEls.length; i++) {
        const sourceObj = getAttributes(sourceEls[i]);
        sourceElSources.push(sourceObj);
        if (sourceObj.src && sourceObj.src === src) {
          matchingSourceEls.push(sourceObj.src);
        }
      }
      if (matchingSourceEls.length && !matchingSources.length) {
        this.cache_.sources = sourceElSources;
      } else if (!matchingSources.length) {
        this.cache_.sources = [this.cache_.source];
      }
      this.cache_.src = src;
    }
    /**
     * *EXPERIMENTAL* Fired when the source is set or changed on the {@link Tech}
     * causing the media element to reload.
     *
     * It will fire for the initial source and each subsequent source.
     * This event is a custom event from Video.js and is triggered by the {@link Tech}.
     *
     * The event object for this event contains a `src` property that will contain the source
     * that was available when the event was triggered. This is generally only necessary if Video.js
     * is switching techs while the source was being changed.
     *
     * It is also fired when `load` is called on the player (or media element)
     * because the {@link https://html.spec.whatwg.org/multipage/media.html#dom-media-load|specification for `load`}
     * says that the resource selection algorithm needs to be aborted and restarted.
     * In this case, it is very likely that the `src` property will be set to the
     * empty string `""` to indicate we do not know what the source will be but
     * that it is changing.
     *
     * *This event is currently still experimental and may change in minor releases.*
     * __To use this, pass `enableSourceset` option to the player.__
     *
     * @event Player#sourceset
     * @type {Event}
     * @prop {string} src
     *                The source url available when the `sourceset` was triggered.
     *                It will be an empty string if we cannot know what the source is
     *                but know that the source will change.
     */
    /**
     * Retrigger the `sourceset` event that was triggered by the {@link Tech}.
     *
     * @fires Player#sourceset
     * @listens Tech#sourceset
     * @private
     */
    handleTechSourceset_(event) {
      if (!this.changingSrc_) {
        let updateSourceCaches = (src) => this.updateSourceCaches_(src);
        const playerSrc = this.currentSource().src;
        const eventSrc = event.src;
        if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {
          if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {
            updateSourceCaches = () => {
            };
          }
        }
        updateSourceCaches(eventSrc);
        if (!event.src) {
          this.tech_.any(["sourceset", "loadstart"], (e) => {
            if (e.type === "sourceset") {
              return;
            }
            const techSrc = this.techGet_("currentSrc");
            this.lastSource_.tech = techSrc;
            this.updateSourceCaches_(techSrc);
          });
        }
      }
      this.lastSource_ = {
        player: this.currentSource().src,
        tech: event.src
      };
      this.trigger({
        src: event.src,
        type: "sourceset"
      });
    }
    /**
     * Add/remove the vjs-has-started class
     *
     *
     * @param {boolean} request
     *        - true: adds the class
     *        - false: remove the class
     *
     * @return {boolean}
     *         the boolean value of hasStarted_
     */
    hasStarted(request) {
      if (request === void 0) {
        return this.hasStarted_;
      }
      if (request === this.hasStarted_) {
        return;
      }
      this.hasStarted_ = request;
      if (this.hasStarted_) {
        this.addClass("vjs-has-started");
      } else {
        this.removeClass("vjs-has-started");
      }
    }
    /**
     * Fired whenever the media begins or resumes playback
     *
     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}
     * @fires Player#play
     * @listens Tech#play
     * @private
     */
    handleTechPlay_() {
      this.removeClass("vjs-ended", "vjs-paused");
      this.addClass("vjs-playing");
      this.hasStarted(true);
      this.trigger("play");
    }
    /**
     * Retrigger the `ratechange` event that was triggered by the {@link Tech}.
     *
     * If there were any events queued while the playback rate was zero, fire
     * those events now.
     *
     * @private
     * @method Player#handleTechRateChange_
     * @fires Player#ratechange
     * @listens Tech#ratechange
     */
    handleTechRateChange_() {
      if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {
        this.queuedCallbacks_.forEach((queued) => queued.callback(queued.event));
        this.queuedCallbacks_ = [];
      }
      this.cache_.lastPlaybackRate = this.tech_.playbackRate();
      this.trigger("ratechange");
    }
    /**
     * Retrigger the `waiting` event that was triggered by the {@link Tech}.
     *
     * @fires Player#waiting
     * @listens Tech#waiting
     * @private
     */
    handleTechWaiting_() {
      this.addClass("vjs-waiting");
      this.trigger("waiting");
      const timeWhenWaiting = this.currentTime();
      const timeUpdateListener = () => {
        if (timeWhenWaiting !== this.currentTime()) {
          this.removeClass("vjs-waiting");
          this.off("timeupdate", timeUpdateListener);
        }
      };
      this.on("timeupdate", timeUpdateListener);
    }
    /**
     * Retrigger the `canplay` event that was triggered by the {@link Tech}.
     * > Note: This is not consistent between browsers. See #1351
     *
     * @fires Player#canplay
     * @listens Tech#canplay
     * @private
     */
    handleTechCanPlay_() {
      this.removeClass("vjs-waiting");
      this.trigger("canplay");
    }
    /**
     * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.
     *
     * @fires Player#canplaythrough
     * @listens Tech#canplaythrough
     * @private
     */
    handleTechCanPlayThrough_() {
      this.removeClass("vjs-waiting");
      this.trigger("canplaythrough");
    }
    /**
     * Retrigger the `playing` event that was triggered by the {@link Tech}.
     *
     * @fires Player#playing
     * @listens Tech#playing
     * @private
     */
    handleTechPlaying_() {
      this.removeClass("vjs-waiting");
      this.trigger("playing");
    }
    /**
     * Retrigger the `seeking` event that was triggered by the {@link Tech}.
     *
     * @fires Player#seeking
     * @listens Tech#seeking
     * @private
     */
    handleTechSeeking_() {
      this.addClass("vjs-seeking");
      this.trigger("seeking");
    }
    /**
     * Retrigger the `seeked` event that was triggered by the {@link Tech}.
     *
     * @fires Player#seeked
     * @listens Tech#seeked
     * @private
     */
    handleTechSeeked_() {
      this.removeClass("vjs-seeking", "vjs-ended");
      this.trigger("seeked");
    }
    /**
     * Retrigger the `pause` event that was triggered by the {@link Tech}.
     *
     * @fires Player#pause
     * @listens Tech#pause
     * @private
     */
    handleTechPause_() {
      this.removeClass("vjs-playing");
      this.addClass("vjs-paused");
      this.trigger("pause");
    }
    /**
     * Retrigger the `ended` event that was triggered by the {@link Tech}.
     *
     * @fires Player#ended
     * @listens Tech#ended
     * @private
     */
    handleTechEnded_() {
      this.addClass("vjs-ended");
      this.removeClass("vjs-waiting");
      if (this.options_.loop) {
        this.currentTime(0);
        this.play();
      } else if (!this.paused()) {
        this.pause();
      }
      this.trigger("ended");
    }
    /**
     * Fired when the duration of the media resource is first known or changed
     *
     * @listens Tech#durationchange
     * @private
     */
    handleTechDurationChange_() {
      this.duration(this.techGet_("duration"));
    }
    /**
     * Handle a click on the media element to play/pause
     *
     * @param {Event} event
     *        the event that caused this function to trigger
     *
     * @listens Tech#click
     * @private
     */
    handleTechClick_(event) {
      if (!this.controls_) {
        return;
      }
      if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.click === void 0 || this.options_.userActions.click !== false) {
        if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.click === "function") {
          this.options_.userActions.click.call(this, event);
        } else if (this.paused()) {
          silencePromise(this.play());
        } else {
          this.pause();
        }
      }
    }
    /**
     * Handle a double-click on the media element to enter/exit fullscreen
     *
     * @param {Event} event
     *        the event that caused this function to trigger
     *
     * @listens Tech#dblclick
     * @private
     */
    handleTechDoubleClick_(event) {
      if (!this.controls_) {
        return;
      }
      const inAllowedEls = Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), (el) => el.contains(event.target));
      if (!inAllowedEls) {
        if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.doubleClick === void 0 || this.options_.userActions.doubleClick !== false) {
          if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.doubleClick === "function") {
            this.options_.userActions.doubleClick.call(this, event);
          } else if (this.isFullscreen()) {
            this.exitFullscreen();
          } else {
            this.requestFullscreen();
          }
        }
      }
    }
    /**
     * Handle a tap on the media element. It will toggle the user
     * activity state, which hides and shows the controls.
     *
     * @listens Tech#tap
     * @private
     */
    handleTechTap_() {
      this.userActive(!this.userActive());
    }
    /**
     * Handle touch to start
     *
     * @listens Tech#touchstart
     * @private
     */
    handleTechTouchStart_() {
      this.userWasActive = this.userActive();
    }
    /**
     * Handle touch to move
     *
     * @listens Tech#touchmove
     * @private
     */
    handleTechTouchMove_() {
      if (this.userWasActive) {
        this.reportUserActivity();
      }
    }
    /**
     * Handle touch to end
     *
     * @param {Event} event
     *        the touchend event that triggered
     *        this function
     *
     * @listens Tech#touchend
     * @private
     */
    handleTechTouchEnd_(event) {
      if (event.cancelable) {
        event.preventDefault();
      }
    }
    /**
     * @private
     */
    toggleFullscreenClass_() {
      if (this.isFullscreen()) {
        this.addClass("vjs-fullscreen");
      } else {
        this.removeClass("vjs-fullscreen");
      }
    }
    /**
     * when the document fschange event triggers it calls this
     */
    documentFullscreenChange_(e) {
      const targetPlayer = e.target.player;
      if (targetPlayer && targetPlayer !== this) {
        return;
      }
      const el = this.el();
      let isFs = document[this.fsApi_.fullscreenElement] === el;
      if (!isFs && el.matches) {
        isFs = el.matches(":" + this.fsApi_.fullscreen);
      }
      this.isFullscreen(isFs);
    }
    /**
     * Handle Tech Fullscreen Change
     *
     * @param {Event} event
     *        the fullscreenchange event that triggered this function
     *
     * @param {Object} data
     *        the data that was sent with the event
     *
     * @private
     * @listens Tech#fullscreenchange
     * @fires Player#fullscreenchange
     */
    handleTechFullscreenChange_(event, data) {
      if (data) {
        if (data.nativeIOSFullscreen) {
          this.addClass("vjs-ios-native-fs");
          this.tech_.one("webkitendfullscreen", () => {
            this.removeClass("vjs-ios-native-fs");
          });
        }
        this.isFullscreen(data.isFullscreen);
      }
    }
    handleTechFullscreenError_(event, err) {
      this.trigger("fullscreenerror", err);
    }
    /**
     * @private
     */
    togglePictureInPictureClass_() {
      if (this.isInPictureInPicture()) {
        this.addClass("vjs-picture-in-picture");
      } else {
        this.removeClass("vjs-picture-in-picture");
      }
    }
    /**
     * Handle Tech Enter Picture-in-Picture.
     *
     * @param {Event} event
     *        the enterpictureinpicture event that triggered this function
     *
     * @private
     * @listens Tech#enterpictureinpicture
     */
    handleTechEnterPictureInPicture_(event) {
      this.isInPictureInPicture(true);
    }
    /**
     * Handle Tech Leave Picture-in-Picture.
     *
     * @param {Event} event
     *        the leavepictureinpicture event that triggered this function
     *
     * @private
     * @listens Tech#leavepictureinpicture
     */
    handleTechLeavePictureInPicture_(event) {
      this.isInPictureInPicture(false);
    }
    /**
     * Fires when an error occurred during the loading of an audio/video.
     *
     * @private
     * @listens Tech#error
     */
    handleTechError_() {
      const error = this.tech_.error();
      if (error) {
        this.error(error);
      }
    }
    /**
     * Retrigger the `textdata` event that was triggered by the {@link Tech}.
     *
     * @fires Player#textdata
     * @listens Tech#textdata
     * @private
     */
    handleTechTextData_() {
      let data = null;
      if (arguments.length > 1) {
        data = arguments[1];
      }
      this.trigger("textdata", data);
    }
    /**
     * Get object for cached values.
     *
     * @return {Object}
     *         get the current object cache
     */
    getCache() {
      return this.cache_;
    }
    /**
     * Resets the internal cache object.
     *
     * Using this function outside the player constructor or reset method may
     * have unintended side-effects.
     *
     * @private
     */
    resetCache_() {
      this.cache_ = {
        // Right now, the currentTime is not _really_ cached because it is always
        // retrieved from the tech (see: currentTime). However, for completeness,
        // we set it to zero here to ensure that if we do start actually caching
        // it, we reset it along with everything else.
        currentTime: 0,
        initTime: 0,
        inactivityTimeout: this.options_.inactivityTimeout,
        duration: NaN,
        lastVolume: 1,
        lastPlaybackRate: this.defaultPlaybackRate(),
        media: null,
        src: "",
        source: {},
        sources: [],
        playbackRates: [],
        volume: 1
      };
    }
    /**
     * Pass values to the playback tech
     *
     * @param {string} [method]
     *        the method to call
     *
     * @param {Object} [arg]
     *        the argument to pass
     *
     * @private
     */
    techCall_(method, arg) {
      this.ready(function() {
        if (method in allowedSetters) {
          return set(this.middleware_, this.tech_, method, arg);
        } else if (method in allowedMediators) {
          return mediate(this.middleware_, this.tech_, method, arg);
        }
        try {
          if (this.tech_) {
            this.tech_[method](arg);
          }
        } catch (e) {
          log$1(e);
          throw e;
        }
      }, true);
    }
    /**
     * Mediate attempt to call playback tech method
     * and return the value of the method called.
     *
     * @param {string} method
     *        Tech method
     *
     * @return {*}
     *         Value returned by the tech method called, undefined if tech
     *         is not ready or tech method is not present
     *
     * @private
     */
    techGet_(method) {
      if (!this.tech_ || !this.tech_.isReady_) {
        return;
      }
      if (method in allowedGetters) {
        return get(this.middleware_, this.tech_, method);
      } else if (method in allowedMediators) {
        return mediate(this.middleware_, this.tech_, method);
      }
      try {
        return this.tech_[method]();
      } catch (e) {
        if (this.tech_[method] === void 0) {
          log$1(`Video.js: ${method} method not defined for ${this.techName_} playback technology.`, e);
          throw e;
        }
        if (e.name === "TypeError") {
          log$1(`Video.js: ${method} unavailable on ${this.techName_} playback technology element.`, e);
          this.tech_.isReady_ = false;
          throw e;
        }
        log$1(e);
        throw e;
      }
    }
    /**
     * Attempt to begin playback at the first opportunity.
     *
     * @return {Promise|undefined}
     *         Returns a promise if the browser supports Promises (or one
     *         was passed in as an option). This promise will be resolved on
     *         the return value of play. If this is undefined it will fulfill the
     *         promise chain otherwise the promise chain will be fulfilled when
     *         the promise from play is fulfilled.
     */
    play() {
      return new Promise((resolve) => {
        this.play_(resolve);
      });
    }
    /**
     * The actual logic for play, takes a callback that will be resolved on the
     * return value of play. This allows us to resolve to the play promise if there
     * is one on modern browsers.
     *
     * @private
     * @param {Function} [callback]
     *        The callback that should be called when the techs play is actually called
     */
    play_(callback = silencePromise) {
      this.playCallbacks_.push(callback);
      const isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));
      const isSafariOrIOS = Boolean(IS_ANY_SAFARI || IS_IOS);
      if (this.waitToPlay_) {
        this.off(["ready", "loadstart"], this.waitToPlay_);
        this.waitToPlay_ = null;
      }
      if (!this.isReady_ || !isSrcReady) {
        this.waitToPlay_ = (e) => {
          this.play_();
        };
        this.one(["ready", "loadstart"], this.waitToPlay_);
        if (!isSrcReady && isSafariOrIOS) {
          this.load();
        }
        return;
      }
      const val = this.techGet_("play");
      const isNativeReplay = isSafariOrIOS && this.hasClass("vjs-ended");
      if (isNativeReplay) {
        this.resetProgressBar_();
      }
      if (val === null) {
        this.runPlayTerminatedQueue_();
      } else {
        this.runPlayCallbacks_(val);
      }
    }
    /**
     * These functions will be run when if play is terminated. If play
     * runPlayCallbacks_ is run these function will not be run. This allows us
     * to differentiate between a terminated play and an actual call to play.
     */
    runPlayTerminatedQueue_() {
      const queue = this.playTerminatedQueue_.slice(0);
      this.playTerminatedQueue_ = [];
      queue.forEach(function(q) {
        q();
      });
    }
    /**
     * When a callback to play is delayed we have to run these
     * callbacks when play is actually called on the tech. This function
     * runs the callbacks that were delayed and accepts the return value
     * from the tech.
     *
     * @param {undefined|Promise} val
     *        The return value from the tech.
     */
    runPlayCallbacks_(val) {
      const callbacks = this.playCallbacks_.slice(0);
      this.playCallbacks_ = [];
      this.playTerminatedQueue_ = [];
      callbacks.forEach(function(cb) {
        cb(val);
      });
    }
    /**
     * Pause the video playback
     */
    pause() {
      this.techCall_("pause");
    }
    /**
     * Check if the player is paused or has yet to play
     *
     * @return {boolean}
     *         - false: if the media is currently playing
     *         - true: if media is not currently playing
     */
    paused() {
      return this.techGet_("paused") === false ? false : true;
    }
    /**
     * Get a TimeRange object representing the current ranges of time that the user
     * has played.
     *
     * @return { import('./utils/time').TimeRange }
     *         A time range object that represents all the increments of time that have
     *         been played.
     */
    played() {
      return this.techGet_("played") || createTimeRanges$1(0, 0);
    }
    /**
     * Sets or returns whether or not the user is "scrubbing". Scrubbing is
     * when the user has clicked the progress bar handle and is
     * dragging it along the progress bar.
     *
     * @param {boolean} [isScrubbing]
     *        whether the user is or is not scrubbing
     *
     * @return {boolean|undefined}
     *         - The value of scrubbing when getting
     *         - Nothing when setting
     */
    scrubbing(isScrubbing) {
      if (typeof isScrubbing === "undefined") {
        return this.scrubbing_;
      }
      this.scrubbing_ = !!isScrubbing;
      this.techCall_("setScrubbing", this.scrubbing_);
      if (isScrubbing) {
        this.addClass("vjs-scrubbing");
      } else {
        this.removeClass("vjs-scrubbing");
      }
    }
    /**
     * Get or set the current time (in seconds)
     *
     * @param {number|string} [seconds]
     *        The time to seek to in seconds
     *
     * @return {number|undefined}
     *         - the current time in seconds when getting
     *         - Nothing when setting
     */
    currentTime(seconds) {
      if (seconds === void 0) {
        this.cache_.currentTime = this.techGet_("currentTime") || 0;
        return this.cache_.currentTime;
      }
      if (seconds < 0) {
        seconds = 0;
      }
      if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
        this.cache_.initTime = seconds;
        this.off("canplay", this.boundApplyInitTime_);
        this.one("canplay", this.boundApplyInitTime_);
        return;
      }
      this.techCall_("setCurrentTime", seconds);
      this.cache_.initTime = 0;
      if (isFinite(seconds)) {
        this.cache_.currentTime = Number(seconds);
      }
    }
    /**
     * Apply the value of initTime stored in cache as currentTime.
     *
     * @private
     */
    applyInitTime_() {
      this.currentTime(this.cache_.initTime);
    }
    /**
     * Normally gets the length in time of the video in seconds;
     * in all but the rarest use cases an argument will NOT be passed to the method
     *
     * > **NOTE**: The video must have started loading before the duration can be
     * known, and depending on preload behaviour may not be known until the video starts
     * playing.
     *
     * @fires Player#durationchange
     *
     * @param {number} [seconds]
     *        The duration of the video to set in seconds
     *
     * @return {number|undefined}
     *         - The duration of the video in seconds when getting
     *         - Nothing when setting
     */
    duration(seconds) {
      if (seconds === void 0) {
        return this.cache_.duration !== void 0 ? this.cache_.duration : NaN;
      }
      seconds = parseFloat(seconds);
      if (seconds < 0) {
        seconds = Infinity;
      }
      if (seconds !== this.cache_.duration) {
        this.cache_.duration = seconds;
        if (seconds === Infinity) {
          this.addClass("vjs-live");
        } else {
          this.removeClass("vjs-live");
        }
        if (!isNaN(seconds)) {
          this.trigger("durationchange");
        }
      }
    }
    /**
     * Calculates how much time is left in the video. Not part
     * of the native video API.
     *
     * @return {number}
     *         The time remaining in seconds
     */
    remainingTime() {
      return this.duration() - this.currentTime();
    }
    /**
     * A remaining time function that is intended to be used when
     * the time is to be displayed directly to the user.
     *
     * @return {number}
     *         The rounded time remaining in seconds
     */
    remainingTimeDisplay() {
      return Math.floor(this.duration()) - Math.floor(this.currentTime());
    }
    //
    // Kind of like an array of portions of the video that have been downloaded.
    /**
     * Get a TimeRange object with an array of the times of the video
     * that have been downloaded. If you just want the percent of the
     * video that's been downloaded, use bufferedPercent.
     *
     * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}
     *
     * @return { import('./utils/time').TimeRange }
     *         A mock {@link TimeRanges} object (following HTML spec)
     */
    buffered() {
      let buffered = this.techGet_("buffered");
      if (!buffered || !buffered.length) {
        buffered = createTimeRanges$1(0, 0);
      }
      return buffered;
    }
    /**
     * Get the TimeRanges of the media that are currently available
     * for seeking to.
     *
     * @see [Seekable Spec]{@link https://html.spec.whatwg.org/multipage/media.html#dom-media-seekable}
     *
     * @return { import('./utils/time').TimeRange }
     *         A mock {@link TimeRanges} object (following HTML spec)
     */
    seekable() {
      let seekable2 = this.techGet_("seekable");
      if (!seekable2 || !seekable2.length) {
        seekable2 = createTimeRanges$1(0, 0);
      }
      return seekable2;
    }
    /**
     * Returns whether the player is in the "seeking" state.
     *
     * @return {boolean} True if the player is in the seeking state, false if not.
     */
    seeking() {
      return this.techGet_("seeking");
    }
    /**
     * Returns whether the player is in the "ended" state.
     *
     * @return {boolean} True if the player is in the ended state, false if not.
     */
    ended() {
      return this.techGet_("ended");
    }
    /**
     * Returns the current state of network activity for the element, from
     * the codes in the list below.
     * - NETWORK_EMPTY (numeric value 0)
     *   The element has not yet been initialised. All attributes are in
     *   their initial states.
     * - NETWORK_IDLE (numeric value 1)
     *   The element's resource selection algorithm is active and has
     *   selected a resource, but it is not actually using the network at
     *   this time.
     * - NETWORK_LOADING (numeric value 2)
     *   The user agent is actively trying to download data.
     * - NETWORK_NO_SOURCE (numeric value 3)
     *   The element's resource selection algorithm is active, but it has
     *   not yet found a resource to use.
     *
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
     * @return {number} the current network activity state
     */
    networkState() {
      return this.techGet_("networkState");
    }
    /**
     * Returns a value that expresses the current state of the element
     * with respect to rendering the current playback position, from the
     * codes in the list below.
     * - HAVE_NOTHING (numeric value 0)
     *   No information regarding the media resource is available.
     * - HAVE_METADATA (numeric value 1)
     *   Enough of the resource has been obtained that the duration of the
     *   resource is available.
     * - HAVE_CURRENT_DATA (numeric value 2)
     *   Data for the immediate current playback position is available.
     * - HAVE_FUTURE_DATA (numeric value 3)
     *   Data for the immediate current playback position is available, as
     *   well as enough data for the user agent to advance the current
     *   playback position in the direction of playback.
     * - HAVE_ENOUGH_DATA (numeric value 4)
     *   The user agent estimates that enough data is available for
     *   playback to proceed uninterrupted.
     *
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
     * @return {number} the current playback rendering state
     */
    readyState() {
      return this.techGet_("readyState");
    }
    /**
     * Get the percent (as a decimal) of the video that's been downloaded.
     * This method is not a part of the native HTML video API.
     *
     * @return {number}
     *         A decimal between 0 and 1 representing the percent
     *         that is buffered 0 being 0% and 1 being 100%
     */
    bufferedPercent() {
      return bufferedPercent(this.buffered(), this.duration());
    }
    /**
     * Get the ending time of the last buffered time range
     * This is used in the progress bar to encapsulate all time ranges.
     *
     * @return {number}
     *         The end of the last buffered time range
     */
    bufferedEnd() {
      const buffered = this.buffered();
      const duration2 = this.duration();
      let end = buffered.end(buffered.length - 1);
      if (end > duration2) {
        end = duration2;
      }
      return end;
    }
    /**
     * Get or set the current volume of the media
     *
     * @param  {number} [percentAsDecimal]
     *         The new volume as a decimal percent:
     *         - 0 is muted/0%/off
     *         - 1.0 is 100%/full
     *         - 0.5 is half volume or 50%
     *
     * @return {number|undefined}
     *         The current volume as a percent when getting
     */
    volume(percentAsDecimal) {
      let vol;
      if (percentAsDecimal !== void 0) {
        vol = Math.max(0, Math.min(1, percentAsDecimal));
        this.cache_.volume = vol;
        this.techCall_("setVolume", vol);
        if (vol > 0) {
          this.lastVolume_(vol);
        }
        return;
      }
      vol = parseFloat(this.techGet_("volume"));
      return isNaN(vol) ? 1 : vol;
    }
    /**
     * Get the current muted state, or turn mute on or off
     *
     * @param {boolean} [muted]
     *        - true to mute
     *        - false to unmute
     *
     * @return {boolean|undefined}
     *         - true if mute is on and getting
     *         - false if mute is off and getting
     *         - nothing if setting
     */
    muted(muted) {
      if (muted !== void 0) {
        this.techCall_("setMuted", muted);
        return;
      }
      return this.techGet_("muted") || false;
    }
    /**
     * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted
     * indicates the state of muted on initial playback.
     *
     * ```js
     *   var myPlayer = videojs('some-player-id');
     *
     *   myPlayer.src("http://www.example.com/path/to/video.mp4");
     *
     *   // get, should be false
     *   console.log(myPlayer.defaultMuted());
     *   // set to true
     *   myPlayer.defaultMuted(true);
     *   // get should be true
     *   console.log(myPlayer.defaultMuted());
     * ```
     *
     * @param {boolean} [defaultMuted]
     *        - true to mute
     *        - false to unmute
     *
     * @return {boolean|undefined}
     *         - true if defaultMuted is on and getting
     *         - false if defaultMuted is off and getting
     *         - Nothing when setting
     */
    defaultMuted(defaultMuted) {
      if (defaultMuted !== void 0) {
        this.techCall_("setDefaultMuted", defaultMuted);
      }
      return this.techGet_("defaultMuted") || false;
    }
    /**
     * Get the last volume, or set it
     *
     * @param  {number} [percentAsDecimal]
     *         The new last volume as a decimal percent:
     *         - 0 is muted/0%/off
     *         - 1.0 is 100%/full
     *         - 0.5 is half volume or 50%
     *
     * @return {number|undefined}
     *         - The current value of lastVolume as a percent when getting
     *         - Nothing when setting
     *
     * @private
     */
    lastVolume_(percentAsDecimal) {
      if (percentAsDecimal !== void 0 && percentAsDecimal !== 0) {
        this.cache_.lastVolume = percentAsDecimal;
        return;
      }
      return this.cache_.lastVolume;
    }
    /**
     * Check if current tech can support native fullscreen
     * (e.g. with built in controls like iOS)
     *
     * @return {boolean}
     *         if native fullscreen is supported
     */
    supportsFullScreen() {
      return this.techGet_("supportsFullScreen") || false;
    }
    /**
     * Check if the player is in fullscreen mode or tell the player that it
     * is or is not in fullscreen mode.
     *
     * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
     * property and instead document.fullscreenElement is used. But isFullscreen is
     * still a valuable property for internal player workings.
     *
     * @param  {boolean} [isFS]
     *         Set the players current fullscreen state
     *
     * @return {boolean|undefined}
     *         - true if fullscreen is on and getting
     *         - false if fullscreen is off and getting
     *         - Nothing when setting
     */
    isFullscreen(isFS) {
      if (isFS !== void 0) {
        const oldValue = this.isFullscreen_;
        this.isFullscreen_ = Boolean(isFS);
        if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) {
          this.trigger("fullscreenchange");
        }
        this.toggleFullscreenClass_();
        return;
      }
      return this.isFullscreen_;
    }
    /**
     * Increase the size of the video to full screen
     * In some browsers, full screen is not supported natively, so it enters
     * "full window mode", where the video fills the browser window.
     * In browsers and devices that support native full screen, sometimes the
     * browser's default controls will be shown, and not the Video.js custom skin.
     * This includes most mobile devices (iOS, Android) and older versions of
     * Safari.
     *
     * @param  {Object} [fullscreenOptions]
     *         Override the player fullscreen options
     *
     * @fires Player#fullscreenchange
     */
    requestFullscreen(fullscreenOptions) {
      if (this.isInPictureInPicture()) {
        this.exitPictureInPicture();
      }
      const self2 = this;
      return new Promise((resolve, reject) => {
        function offHandler() {
          self2.off("fullscreenerror", errorHandler);
          self2.off("fullscreenchange", changeHandler);
        }
        function changeHandler() {
          offHandler();
          resolve();
        }
        function errorHandler(e, err) {
          offHandler();
          reject(err);
        }
        self2.one("fullscreenchange", changeHandler);
        self2.one("fullscreenerror", errorHandler);
        const promise = self2.requestFullscreenHelper_(fullscreenOptions);
        if (promise) {
          promise.then(offHandler, offHandler);
          promise.then(resolve, reject);
        }
      });
    }
    requestFullscreenHelper_(fullscreenOptions) {
      let fsOptions;
      if (!this.fsApi_.prefixed) {
        fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};
        if (fullscreenOptions !== void 0) {
          fsOptions = fullscreenOptions;
        }
      }
      if (this.fsApi_.requestFullscreen) {
        const promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);
        if (promise) {
          promise.then(() => this.isFullscreen(true), () => this.isFullscreen(false));
        }
        return promise;
      } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
        this.techCall_("enterFullScreen");
      } else {
        this.enterFullWindow();
      }
    }
    /**
     * Return the video to its normal size after having been in full screen mode
     *
     * @fires Player#fullscreenchange
     */
    exitFullscreen() {
      const self2 = this;
      return new Promise((resolve, reject) => {
        function offHandler() {
          self2.off("fullscreenerror", errorHandler);
          self2.off("fullscreenchange", changeHandler);
        }
        function changeHandler() {
          offHandler();
          resolve();
        }
        function errorHandler(e, err) {
          offHandler();
          reject(err);
        }
        self2.one("fullscreenchange", changeHandler);
        self2.one("fullscreenerror", errorHandler);
        const promise = self2.exitFullscreenHelper_();
        if (promise) {
          promise.then(offHandler, offHandler);
          promise.then(resolve, reject);
        }
      });
    }
    exitFullscreenHelper_() {
      if (this.fsApi_.requestFullscreen) {
        const promise = document[this.fsApi_.exitFullscreen]();
        if (promise) {
          silencePromise(promise.then(() => this.isFullscreen(false)));
        }
        return promise;
      } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
        this.techCall_("exitFullScreen");
      } else {
        this.exitFullWindow();
      }
    }
    /**
     * When fullscreen isn't supported we can stretch the
     * video container to as wide as the browser will let us.
     *
     * @fires Player#enterFullWindow
     */
    enterFullWindow() {
      this.isFullscreen(true);
      this.isFullWindow = true;
      this.docOrigOverflow = document.documentElement.style.overflow;
      on(document, "keydown", this.boundFullWindowOnEscKey_);
      document.documentElement.style.overflow = "hidden";
      addClass(document.body, "vjs-full-window");
      this.trigger("enterFullWindow");
    }
    /**
     * Check for call to either exit full window or
     * full screen on ESC key
     *
     * @param {string} event
     *        Event to check for key press
     */
    fullWindowOnEscKey(event) {
      if (keycode.isEventKey(event, "Esc")) {
        if (this.isFullscreen() === true) {
          if (!this.isFullWindow) {
            this.exitFullscreen();
          } else {
            this.exitFullWindow();
          }
        }
      }
    }
    /**
     * Exit full window
     *
     * @fires Player#exitFullWindow
     */
    exitFullWindow() {
      this.isFullscreen(false);
      this.isFullWindow = false;
      off(document, "keydown", this.boundFullWindowOnEscKey_);
      document.documentElement.style.overflow = this.docOrigOverflow;
      removeClass(document.body, "vjs-full-window");
      this.trigger("exitFullWindow");
    }
    /**
     * Get or set disable Picture-in-Picture mode.
     *
     * @param {boolean} [value]
     *                  - true will disable Picture-in-Picture mode
     *                  - false will enable Picture-in-Picture mode
     */
    disablePictureInPicture(value) {
      if (value === void 0) {
        return this.techGet_("disablePictureInPicture");
      }
      this.techCall_("setDisablePictureInPicture", value);
      this.options_.disablePictureInPicture = value;
      this.trigger("disablepictureinpicturechanged");
    }
    /**
     * Check if the player is in Picture-in-Picture mode or tell the player that it
     * is or is not in Picture-in-Picture mode.
     *
     * @param  {boolean} [isPiP]
     *         Set the players current Picture-in-Picture state
     *
     * @return {boolean|undefined}
     *         - true if Picture-in-Picture is on and getting
     *         - false if Picture-in-Picture is off and getting
     *         - nothing if setting
     */
    isInPictureInPicture(isPiP) {
      if (isPiP !== void 0) {
        this.isInPictureInPicture_ = !!isPiP;
        this.togglePictureInPictureClass_();
        return;
      }
      return !!this.isInPictureInPicture_;
    }
    /**
     * Create a floating video window always on top of other windows so that users may
     * continue consuming media while they interact with other content sites, or
     * applications on their device.
     *
     * This can use document picture-in-picture or element picture in picture
     *
     * Set `enableDocumentPictureInPicture` to `true` to use docPiP on a supported browser
     * Else set `disablePictureInPicture` to `false` to disable elPiP on a supported browser
     *
     *
     * @see [Spec]{@link https://w3c.github.io/picture-in-picture/}
     * @see [Spec]{@link https://wicg.github.io/document-picture-in-picture/}
     *
     * @fires Player#enterpictureinpicture
     *
     * @return {Promise}
     *         A promise with a Picture-in-Picture window.
     */
    requestPictureInPicture() {
      if (this.options_.enableDocumentPictureInPicture && window.documentPictureInPicture) {
        const pipContainer = document.createElement(this.el().tagName);
        pipContainer.classList = this.el().classList;
        pipContainer.classList.add("vjs-pip-container");
        if (this.posterImage) {
          pipContainer.appendChild(this.posterImage.el().cloneNode(true));
        }
        if (this.titleBar) {
          pipContainer.appendChild(this.titleBar.el().cloneNode(true));
        }
        pipContainer.appendChild(createEl("p", {
          className: "vjs-pip-text"
        }, {}, this.localize("Playing in picture-in-picture")));
        return window.documentPictureInPicture.requestWindow({
          // The aspect ratio won't be correct, Chrome bug https://crbug.com/1407629
          width: this.videoWidth(),
          height: this.videoHeight()
        }).then((pipWindow) => {
          copyStyleSheetsToWindow(pipWindow);
          this.el_.parentNode.insertBefore(pipContainer, this.el_);
          pipWindow.document.body.appendChild(this.el_);
          pipWindow.document.body.classList.add("vjs-pip-window");
          this.player_.isInPictureInPicture(true);
          this.player_.trigger("enterpictureinpicture");
          pipWindow.addEventListener("pagehide", (event) => {
            const pipVideo = event.target.querySelector(".video-js");
            pipContainer.parentNode.replaceChild(pipVideo, pipContainer);
            this.player_.isInPictureInPicture(false);
            this.player_.trigger("leavepictureinpicture");
          });
          return pipWindow;
        });
      }
      if ("pictureInPictureEnabled" in document && this.disablePictureInPicture() === false) {
        return this.techGet_("requestPictureInPicture");
      }
      return Promise.reject("No PiP mode is available");
    }
    /**
     * Exit Picture-in-Picture mode.
     *
     * @see [Spec]{@link https://wicg.github.io/picture-in-picture}
     *
     * @fires Player#leavepictureinpicture
     *
     * @return {Promise}
     *         A promise.
     */
    exitPictureInPicture() {
      if (window.documentPictureInPicture && window.documentPictureInPicture.window) {
        window.documentPictureInPicture.window.close();
        return Promise.resolve();
      }
      if ("pictureInPictureEnabled" in document) {
        return document.exitPictureInPicture();
      }
    }
    /**
     * Called when this Player has focus and a key gets pressed down, or when
     * any Component of this player receives a key press that it doesn't handle.
     * This allows player-wide hotkeys (either as defined below, or optionally
     * by an external function).
     *
     * @param {KeyboardEvent} event
     *        The `keydown` event that caused this function to be called.
     *
     * @listens keydown
     */
    handleKeyDown(event) {
      const {
        userActions
      } = this.options_;
      if (!userActions || !userActions.hotkeys) {
        return;
      }
      const excludeElement = (el) => {
        const tagName = el.tagName.toLowerCase();
        if (el.isContentEditable) {
          return true;
        }
        const allowedInputTypes = ["button", "checkbox", "hidden", "radio", "reset", "submit"];
        if (tagName === "input") {
          return allowedInputTypes.indexOf(el.type) === -1;
        }
        const excludedTags = ["textarea"];
        return excludedTags.indexOf(tagName) !== -1;
      };
      if (excludeElement(this.el_.ownerDocument.activeElement)) {
        return;
      }
      if (typeof userActions.hotkeys === "function") {
        userActions.hotkeys.call(this, event);
      } else {
        this.handleHotkeys(event);
      }
    }
    /**
     * Called when this Player receives a hotkey keydown event.
     * Supported player-wide hotkeys are:
     *
     *   f          - toggle fullscreen
     *   m          - toggle mute
     *   k or Space - toggle play/pause
     *
     * @param {Event} event
     *        The `keydown` event that caused this function to be called.
     */
    handleHotkeys(event) {
      const hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {};
      const {
        fullscreenKey = (keydownEvent) => keycode.isEventKey(keydownEvent, "f"),
        muteKey = (keydownEvent) => keycode.isEventKey(keydownEvent, "m"),
        playPauseKey = (keydownEvent) => keycode.isEventKey(keydownEvent, "k") || keycode.isEventKey(keydownEvent, "Space")
      } = hotkeys;
      if (fullscreenKey.call(this, event)) {
        event.preventDefault();
        event.stopPropagation();
        const FSToggle = Component$1.getComponent("FullscreenToggle");
        if (document[this.fsApi_.fullscreenEnabled] !== false) {
          FSToggle.prototype.handleClick.call(this, event);
        }
      } else if (muteKey.call(this, event)) {
        event.preventDefault();
        event.stopPropagation();
        const MuteToggle2 = Component$1.getComponent("MuteToggle");
        MuteToggle2.prototype.handleClick.call(this, event);
      } else if (playPauseKey.call(this, event)) {
        event.preventDefault();
        event.stopPropagation();
        const PlayToggle2 = Component$1.getComponent("PlayToggle");
        PlayToggle2.prototype.handleClick.call(this, event);
      }
    }
    /**
     * Check whether the player can play a given mimetype
     *
     * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype
     *
     * @param {string} type
     *        The mimetype to check
     *
     * @return {string}
     *         'probably', 'maybe', or '' (empty string)
     */
    canPlayType(type) {
      let can;
      for (let i = 0, j = this.options_.techOrder; i < j.length; i++) {
        const techName = j[i];
        let tech = Tech.getTech(techName);
        if (!tech) {
          tech = Component$1.getComponent(techName);
        }
        if (!tech) {
          log$1.error(`The "${techName}" tech is undefined. Skipped browser support check for that tech.`);
          continue;
        }
        if (tech.isSupported()) {
          can = tech.canPlayType(type);
          if (can) {
            return can;
          }
        }
      }
      return "";
    }
    /**
     * Select source based on tech-order or source-order
     * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,
     * defaults to tech-order selection
     *
     * @param {Array} sources
     *        The sources for a media asset
     *
     * @return {Object|boolean}
     *         Object of source and tech order or false
     */
    selectSource(sources) {
      const techs = this.options_.techOrder.map((techName) => {
        return [techName, Tech.getTech(techName)];
      }).filter(([techName, tech]) => {
        if (tech) {
          return tech.isSupported();
        }
        log$1.error(`The "${techName}" tech is undefined. Skipped browser support check for that tech.`);
        return false;
      });
      const findFirstPassingTechSourcePair = function(outerArray, innerArray, tester) {
        let found;
        outerArray.some((outerChoice) => {
          return innerArray.some((innerChoice) => {
            found = tester(outerChoice, innerChoice);
            if (found) {
              return true;
            }
          });
        });
        return found;
      };
      let foundSourceAndTech;
      const flip = (fn) => (a, b) => fn(b, a);
      const finder = ([techName, tech], source) => {
        if (tech.canPlaySource(source, this.options_[techName.toLowerCase()])) {
          return {
            source,
            tech: techName
          };
        }
      };
      if (this.options_.sourceOrder) {
        foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));
      } else {
        foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
      }
      return foundSourceAndTech || false;
    }
    /**
     * Executes source setting and getting logic
     *
     * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]
     *        A SourceObject, an array of SourceObjects, or a string referencing
     *        a URL to a media source. It is _highly recommended_ that an object
     *        or array of objects is used here, so that source selection
     *        algorithms can take the `type` into account.
     *
     *        If not provided, this method acts as a getter.
     * @param {boolean} [isRetry]
     *        Indicates whether this is being called internally as a result of a retry
     *
     * @return {string|undefined}
     *         If the `source` argument is missing, returns the current source
     *         URL. Otherwise, returns nothing/undefined.
     */
    handleSrc_(source, isRetry) {
      if (typeof source === "undefined") {
        return this.cache_.src || "";
      }
      if (this.resetRetryOnError_) {
        this.resetRetryOnError_();
      }
      const sources = filterSource(source);
      if (!sources.length) {
        this.setTimeout(function() {
          this.error({
            code: 4,
            message: this.options_.notSupportedMessage
          });
        }, 0);
        return;
      }
      this.changingSrc_ = true;
      if (!isRetry) {
        this.cache_.sources = sources;
      }
      this.updateSourceCaches_(sources[0]);
      setSource(this, sources[0], (middlewareSource, mws) => {
        this.middleware_ = mws;
        if (!isRetry) {
          this.cache_.sources = sources;
        }
        this.updateSourceCaches_(middlewareSource);
        const err = this.src_(middlewareSource);
        if (err) {
          if (sources.length > 1) {
            return this.handleSrc_(sources.slice(1));
          }
          this.changingSrc_ = false;
          this.setTimeout(function() {
            this.error({
              code: 4,
              message: this.options_.notSupportedMessage
            });
          }, 0);
          this.triggerReady();
          return;
        }
        setTech(mws, this.tech_);
      });
      if (sources.length > 1) {
        const retry = () => {
          this.error(null);
          this.handleSrc_(sources.slice(1), true);
        };
        const stopListeningForErrors = () => {
          this.off("error", retry);
        };
        this.one("error", retry);
        this.one("playing", stopListeningForErrors);
        this.resetRetryOnError_ = () => {
          this.off("error", retry);
          this.off("playing", stopListeningForErrors);
        };
      }
    }
    /**
     * Get or set the video source.
     *
     * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]
     *        A SourceObject, an array of SourceObjects, or a string referencing
     *        a URL to a media source. It is _highly recommended_ that an object
     *        or array of objects is used here, so that source selection
     *        algorithms can take the `type` into account.
     *
     *        If not provided, this method acts as a getter.
     *
     * @return {string|undefined}
     *         If the `source` argument is missing, returns the current source
     *         URL. Otherwise, returns nothing/undefined.
     */
    src(source) {
      return this.handleSrc_(source, false);
    }
    /**
     * Set the source object on the tech, returns a boolean that indicates whether
     * there is a tech that can play the source or not
     *
     * @param {Tech~SourceObject} source
     *        The source object to set on the Tech
     *
     * @return {boolean}
     *         - True if there is no Tech to playback this source
     *         - False otherwise
     *
     * @private
     */
    src_(source) {
      const sourceTech = this.selectSource([source]);
      if (!sourceTech) {
        return true;
      }
      if (!titleCaseEquals(sourceTech.tech, this.techName_)) {
        this.changingSrc_ = true;
        this.loadTech_(sourceTech.tech, sourceTech.source);
        this.tech_.ready(() => {
          this.changingSrc_ = false;
        });
        return false;
      }
      this.ready(function() {
        if (this.tech_.constructor.prototype.hasOwnProperty("setSource")) {
          this.techCall_("setSource", source);
        } else {
          this.techCall_("src", source.src);
        }
        this.changingSrc_ = false;
      }, true);
      return false;
    }
    /**
     * Begin loading the src data.
     */
    load() {
      if (this.tech_ && this.tech_.vhs) {
        this.src(this.currentSource());
        return;
      }
      this.techCall_("load");
    }
    /**
     * Reset the player. Loads the first tech in the techOrder,
     * removes all the text tracks in the existing `tech`,
     * and calls `reset` on the `tech`.
     */
    reset() {
      if (this.paused()) {
        this.doReset_();
      } else {
        const playPromise = this.play();
        silencePromise(playPromise.then(() => this.doReset_()));
      }
    }
    doReset_() {
      if (this.tech_) {
        this.tech_.clearTracks("text");
      }
      this.removeClass("vjs-playing");
      this.addClass("vjs-paused");
      this.resetCache_();
      this.poster("");
      this.loadTech_(this.options_.techOrder[0], null);
      this.techCall_("reset");
      this.resetControlBarUI_();
      this.error(null);
      if (this.titleBar) {
        this.titleBar.update({
          title: void 0,
          description: void 0
        });
      }
      if (isEvented(this)) {
        this.trigger("playerreset");
      }
    }
    /**
     * Reset Control Bar's UI by calling sub-methods that reset
     * all of Control Bar's components
     */
    resetControlBarUI_() {
      this.resetProgressBar_();
      this.resetPlaybackRate_();
      this.resetVolumeBar_();
    }
    /**
     * Reset tech's progress so progress bar is reset in the UI
     */
    resetProgressBar_() {
      this.currentTime(0);
      const {
        currentTimeDisplay,
        durationDisplay,
        progressControl,
        remainingTimeDisplay
      } = this.controlBar || {};
      const {
        seekBar
      } = progressControl || {};
      if (currentTimeDisplay) {
        currentTimeDisplay.updateContent();
      }
      if (durationDisplay) {
        durationDisplay.updateContent();
      }
      if (remainingTimeDisplay) {
        remainingTimeDisplay.updateContent();
      }
      if (seekBar) {
        seekBar.update();
        if (seekBar.loadProgressBar) {
          seekBar.loadProgressBar.update();
        }
      }
    }
    /**
     * Reset Playback ratio
     */
    resetPlaybackRate_() {
      this.playbackRate(this.defaultPlaybackRate());
      this.handleTechRateChange_();
    }
    /**
     * Reset Volume bar
     */
    resetVolumeBar_() {
      this.volume(1);
      this.trigger("volumechange");
    }
    /**
     * Returns all of the current source objects.
     *
     * @return {Tech~SourceObject[]}
     *         The current source objects
     */
    currentSources() {
      const source = this.currentSource();
      const sources = [];
      if (Object.keys(source).length !== 0) {
        sources.push(source);
      }
      return this.cache_.sources || sources;
    }
    /**
     * Returns the current source object.
     *
     * @return {Tech~SourceObject}
     *         The current source object
     */
    currentSource() {
      return this.cache_.source || {};
    }
    /**
     * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
     * Can be used in conjunction with `currentType` to assist in rebuilding the current source object.
     *
     * @return {string}
     *         The current source
     */
    currentSrc() {
      return this.currentSource() && this.currentSource().src || "";
    }
    /**
     * Get the current source type e.g. video/mp4
     * This can allow you rebuild the current source object so that you could load the same
     * source and tech later
     *
     * @return {string}
     *         The source MIME type
     */
    currentType() {
      return this.currentSource() && this.currentSource().type || "";
    }
    /**
     * Get or set the preload attribute
     *
     * @param {'none'|'auto'|'metadata'} [value]
     *        Preload mode to pass to tech
     *
     * @return {string|undefined}
     *         - The preload attribute value when getting
     *         - Nothing when setting
     */
    preload(value) {
      if (value !== void 0) {
        this.techCall_("setPreload", value);
        this.options_.preload = value;
        return;
      }
      return this.techGet_("preload");
    }
    /**
     * Get or set the autoplay option. When this is a boolean it will
     * modify the attribute on the tech. When this is a string the attribute on
     * the tech will be removed and `Player` will handle autoplay on loadstarts.
     *
     * @param {boolean|'play'|'muted'|'any'} [value]
     *        - true: autoplay using the browser behavior
     *        - false: do not autoplay
     *        - 'play': call play() on every loadstart
     *        - 'muted': call muted() then play() on every loadstart
     *        - 'any': call play() on every loadstart. if that fails call muted() then play().
     *        - *: values other than those listed here will be set `autoplay` to true
     *
     * @return {boolean|string|undefined}
     *         - The current value of autoplay when getting
     *         - Nothing when setting
     */
    autoplay(value) {
      if (value === void 0) {
        return this.options_.autoplay || false;
      }
      let techAutoplay;
      if (typeof value === "string" && /(any|play|muted)/.test(value) || value === true && this.options_.normalizeAutoplay) {
        this.options_.autoplay = value;
        this.manualAutoplay_(typeof value === "string" ? value : "play");
        techAutoplay = false;
      } else if (!value) {
        this.options_.autoplay = false;
      } else {
        this.options_.autoplay = true;
      }
      techAutoplay = typeof techAutoplay === "undefined" ? this.options_.autoplay : techAutoplay;
      if (this.tech_) {
        this.techCall_("setAutoplay", techAutoplay);
      }
    }
    /**
     * Set or unset the playsinline attribute.
     * Playsinline tells the browser that non-fullscreen playback is preferred.
     *
     * @param {boolean} [value]
     *        - true means that we should try to play inline by default
     *        - false means that we should use the browser's default playback mode,
     *          which in most cases is inline. iOS Safari is a notable exception
     *          and plays fullscreen by default.
     *
     * @return {string|undefined}
     *         - the current value of playsinline
     *         - Nothing when setting
     *
     * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
     */
    playsinline(value) {
      if (value !== void 0) {
        this.techCall_("setPlaysinline", value);
        this.options_.playsinline = value;
      }
      return this.techGet_("playsinline");
    }
    /**
     * Get or set the loop attribute on the video element.
     *
     * @param {boolean} [value]
     *        - true means that we should loop the video
     *        - false means that we should not loop the video
     *
     * @return {boolean|undefined}
     *         - The current value of loop when getting
     *         - Nothing when setting
     */
    loop(value) {
      if (value !== void 0) {
        this.techCall_("setLoop", value);
        this.options_.loop = value;
        return;
      }
      return this.techGet_("loop");
    }
    /**
     * Get or set the poster image source url
     *
     * @fires Player#posterchange
     *
     * @param {string} [src]
     *        Poster image source URL
     *
     * @return {string|undefined}
     *         - The current value of poster when getting
     *         - Nothing when setting
     */
    poster(src) {
      if (src === void 0) {
        return this.poster_;
      }
      if (!src) {
        src = "";
      }
      if (src === this.poster_) {
        return;
      }
      this.poster_ = src;
      this.techCall_("setPoster", src);
      this.isPosterFromTech_ = false;
      this.trigger("posterchange");
    }
    /**
     * Some techs (e.g. YouTube) can provide a poster source in an
     * asynchronous way. We want the poster component to use this
     * poster source so that it covers up the tech's controls.
     * (YouTube's play button). However we only want to use this
     * source if the player user hasn't set a poster through
     * the normal APIs.
     *
     * @fires Player#posterchange
     * @listens Tech#posterchange
     * @private
     */
    handleTechPosterChange_() {
      if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
        const newPoster = this.tech_.poster() || "";
        if (newPoster !== this.poster_) {
          this.poster_ = newPoster;
          this.isPosterFromTech_ = true;
          this.trigger("posterchange");
        }
      }
    }
    /**
     * Get or set whether or not the controls are showing.
     *
     * @fires Player#controlsenabled
     *
     * @param {boolean} [bool]
     *        - true to turn controls on
     *        - false to turn controls off
     *
     * @return {boolean|undefined}
     *         - The current value of controls when getting
     *         - Nothing when setting
     */
    controls(bool) {
      if (bool === void 0) {
        return !!this.controls_;
      }
      bool = !!bool;
      if (this.controls_ === bool) {
        return;
      }
      this.controls_ = bool;
      if (this.usingNativeControls()) {
        this.techCall_("setControls", bool);
      }
      if (this.controls_) {
        this.removeClass("vjs-controls-disabled");
        this.addClass("vjs-controls-enabled");
        this.trigger("controlsenabled");
        if (!this.usingNativeControls()) {
          this.addTechControlsListeners_();
        }
      } else {
        this.removeClass("vjs-controls-enabled");
        this.addClass("vjs-controls-disabled");
        this.trigger("controlsdisabled");
        if (!this.usingNativeControls()) {
          this.removeTechControlsListeners_();
        }
      }
    }
    /**
     * Toggle native controls on/off. Native controls are the controls built into
     * devices (e.g. default iPhone controls) or other techs
     * (e.g. Vimeo Controls)
     * **This should only be set by the current tech, because only the tech knows
     * if it can support native controls**
     *
     * @fires Player#usingnativecontrols
     * @fires Player#usingcustomcontrols
     *
     * @param {boolean} [bool]
     *        - true to turn native controls on
     *        - false to turn native controls off
     *
     * @return {boolean|undefined}
     *         - The current value of native controls when getting
     *         - Nothing when setting
     */
    usingNativeControls(bool) {
      if (bool === void 0) {
        return !!this.usingNativeControls_;
      }
      bool = !!bool;
      if (this.usingNativeControls_ === bool) {
        return;
      }
      this.usingNativeControls_ = bool;
      if (this.usingNativeControls_) {
        this.addClass("vjs-using-native-controls");
        this.trigger("usingnativecontrols");
      } else {
        this.removeClass("vjs-using-native-controls");
        this.trigger("usingcustomcontrols");
      }
    }
    /**
     * Set or get the current MediaError
     *
     * @fires Player#error
     *
     * @param  {MediaError|string|number} [err]
     *         A MediaError or a string/number to be turned
     *         into a MediaError
     *
     * @return {MediaError|null|undefined}
     *         - The current MediaError when getting (or null)
     *         - Nothing when setting
     */
    error(err) {
      if (err === void 0) {
        return this.error_ || null;
      }
      hooks("beforeerror").forEach((hookFunction) => {
        const newErr = hookFunction(this, err);
        if (!(isObject$1(newErr) && !Array.isArray(newErr) || typeof newErr === "string" || typeof newErr === "number" || newErr === null)) {
          this.log.error("please return a value that MediaError expects in beforeerror hooks");
          return;
        }
        err = newErr;
      });
      if (this.options_.suppressNotSupportedError && err && err.code === 4) {
        const triggerSuppressedError = function() {
          this.error(err);
        };
        this.options_.suppressNotSupportedError = false;
        this.any(["click", "touchstart"], triggerSuppressedError);
        this.one("loadstart", function() {
          this.off(["click", "touchstart"], triggerSuppressedError);
        });
        return;
      }
      if (err === null) {
        this.error_ = null;
        this.removeClass("vjs-error");
        if (this.errorDisplay) {
          this.errorDisplay.close();
        }
        return;
      }
      this.error_ = new MediaError(err);
      this.addClass("vjs-error");
      log$1.error(`(CODE:${this.error_.code} ${MediaError.errorTypes[this.error_.code]})`, this.error_.message, this.error_);
      this.trigger("error");
      hooks("error").forEach((hookFunction) => hookFunction(this, this.error_));
      return;
    }
    /**
     * Report user activity
     *
     * @param {Object} event
     *        Event object
     */
    reportUserActivity(event) {
      this.userActivity_ = true;
    }
    /**
     * Get/set if user is active
     *
     * @fires Player#useractive
     * @fires Player#userinactive
     *
     * @param {boolean} [bool]
     *        - true if the user is active
     *        - false if the user is inactive
     *
     * @return {boolean|undefined}
     *         - The current value of userActive when getting
     *         - Nothing when setting
     */
    userActive(bool) {
      if (bool === void 0) {
        return this.userActive_;
      }
      bool = !!bool;
      if (bool === this.userActive_) {
        return;
      }
      this.userActive_ = bool;
      if (this.userActive_) {
        this.userActivity_ = true;
        this.removeClass("vjs-user-inactive");
        this.addClass("vjs-user-active");
        this.trigger("useractive");
        return;
      }
      if (this.tech_) {
        this.tech_.one("mousemove", function(e) {
          e.stopPropagation();
          e.preventDefault();
        });
      }
      this.userActivity_ = false;
      this.removeClass("vjs-user-active");
      this.addClass("vjs-user-inactive");
      this.trigger("userinactive");
    }
    /**
     * Listen for user activity based on timeout value
     *
     * @private
     */
    listenForUserActivity_() {
      let mouseInProgress;
      let lastMoveX;
      let lastMoveY;
      const handleActivity = bind_(this, this.reportUserActivity);
      const handleMouseMove = function(e) {
        if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
          lastMoveX = e.screenX;
          lastMoveY = e.screenY;
          handleActivity();
        }
      };
      const handleMouseDown = function() {
        handleActivity();
        this.clearInterval(mouseInProgress);
        mouseInProgress = this.setInterval(handleActivity, 250);
      };
      const handleMouseUpAndMouseLeave = function(event) {
        handleActivity();
        this.clearInterval(mouseInProgress);
      };
      this.on("mousedown", handleMouseDown);
      this.on("mousemove", handleMouseMove);
      this.on("mouseup", handleMouseUpAndMouseLeave);
      this.on("mouseleave", handleMouseUpAndMouseLeave);
      const controlBar = this.getChild("controlBar");
      if (controlBar && !IS_IOS && !IS_ANDROID) {
        controlBar.on("mouseenter", function(event) {
          if (this.player().options_.inactivityTimeout !== 0) {
            this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout;
          }
          this.player().options_.inactivityTimeout = 0;
        });
        controlBar.on("mouseleave", function(event) {
          this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
        });
      }
      this.on("keydown", handleActivity);
      this.on("keyup", handleActivity);
      let inactivityTimeout;
      const activityCheck = function() {
        if (!this.userActivity_) {
          return;
        }
        this.userActivity_ = false;
        this.userActive(true);
        this.clearTimeout(inactivityTimeout);
        const timeout = this.options_.inactivityTimeout;
        if (timeout <= 0) {
          return;
        }
        inactivityTimeout = this.setTimeout(function() {
          if (!this.userActivity_) {
            this.userActive(false);
          }
        }, timeout);
      };
      this.setInterval(activityCheck, 250);
    }
    /**
     * Gets or sets the current playback rate. A playback rate of
     * 1.0 represents normal speed and 0.5 would indicate half-speed
     * playback, for instance.
     *
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate
     *
     * @param {number} [rate]
     *       New playback rate to set.
     *
     * @return {number|undefined}
     *         - The current playback rate when getting or 1.0
     *         - Nothing when setting
     */
    playbackRate(rate) {
      if (rate !== void 0) {
        this.techCall_("setPlaybackRate", rate);
        return;
      }
      if (this.tech_ && this.tech_.featuresPlaybackRate) {
        return this.cache_.lastPlaybackRate || this.techGet_("playbackRate");
      }
      return 1;
    }
    /**
     * Gets or sets the current default playback rate. A default playback rate of
     * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.
     * defaultPlaybackRate will only represent what the initial playbackRate of a video was, not
     * not the current playbackRate.
     *
     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate
     *
     * @param {number} [rate]
     *       New default playback rate to set.
     *
     * @return {number|undefined}
     *         - The default playback rate when getting or 1.0
     *         - Nothing when setting
     */
    defaultPlaybackRate(rate) {
      if (rate !== void 0) {
        return this.techCall_("setDefaultPlaybackRate", rate);
      }
      if (this.tech_ && this.tech_.featuresPlaybackRate) {
        return this.techGet_("defaultPlaybackRate");
      }
      return 1;
    }
    /**
     * Gets or sets the audio flag
     *
     * @param {boolean} [bool]
     *        - true signals that this is an audio player
     *        - false signals that this is not an audio player
     *
     * @return {boolean|undefined}
     *         - The current value of isAudio when getting
     *         - Nothing when setting
     */
    isAudio(bool) {
      if (bool !== void 0) {
        this.isAudio_ = !!bool;
        return;
      }
      return !!this.isAudio_;
    }
    enableAudioOnlyUI_() {
      this.addClass("vjs-audio-only-mode");
      const playerChildren = this.children();
      const controlBar = this.getChild("ControlBar");
      const controlBarHeight = controlBar && controlBar.currentHeight();
      playerChildren.forEach((child) => {
        if (child === controlBar) {
          return;
        }
        if (child.el_ && !child.hasClass("vjs-hidden")) {
          child.hide();
          this.audioOnlyCache_.hiddenChildren.push(child);
        }
      });
      this.audioOnlyCache_.playerHeight = this.currentHeight();
      this.height(controlBarHeight);
      this.trigger("audioonlymodechange");
    }
    disableAudioOnlyUI_() {
      this.removeClass("vjs-audio-only-mode");
      this.audioOnlyCache_.hiddenChildren.forEach((child) => child.show());
      this.height(this.audioOnlyCache_.playerHeight);
      this.trigger("audioonlymodechange");
    }
    /**
     * Get the current audioOnlyMode state or set audioOnlyMode to true or false.
     *
     * Setting this to `true` will hide all player components except the control bar,
     * as well as control bar components needed only for video.
     *
     * @param {boolean} [value]
     *         The value to set audioOnlyMode to.
     *
     * @return {Promise|boolean}
     *        A Promise is returned when setting the state, and a boolean when getting
     *        the present state
     */
    audioOnlyMode(value) {
      if (typeof value !== "boolean" || value === this.audioOnlyMode_) {
        return this.audioOnlyMode_;
      }
      this.audioOnlyMode_ = value;
      if (value) {
        const exitPromises = [];
        if (this.isInPictureInPicture()) {
          exitPromises.push(this.exitPictureInPicture());
        }
        if (this.isFullscreen()) {
          exitPromises.push(this.exitFullscreen());
        }
        if (this.audioPosterMode()) {
          exitPromises.push(this.audioPosterMode(false));
        }
        return Promise.all(exitPromises).then(() => this.enableAudioOnlyUI_());
      }
      return Promise.resolve().then(() => this.disableAudioOnlyUI_());
    }
    enablePosterModeUI_() {
      const tech = this.tech_ && this.tech_;
      tech.hide();
      this.addClass("vjs-audio-poster-mode");
      this.trigger("audiopostermodechange");
    }
    disablePosterModeUI_() {
      const tech = this.tech_ && this.tech_;
      tech.show();
      this.removeClass("vjs-audio-poster-mode");
      this.trigger("audiopostermodechange");
    }
    /**
     * Get the current audioPosterMode state or set audioPosterMode to true or false
     *
     * @param {boolean} [value]
     *         The value to set audioPosterMode to.
     *
     * @return {Promise|boolean}
     *         A Promise is returned when setting the state, and a boolean when getting
     *        the present state
     */
    audioPosterMode(value) {
      if (typeof value !== "boolean" || value === this.audioPosterMode_) {
        return this.audioPosterMode_;
      }
      this.audioPosterMode_ = value;
      if (value) {
        if (this.audioOnlyMode()) {
          const audioOnlyModePromise = this.audioOnlyMode(false);
          return audioOnlyModePromise.then(() => {
            this.enablePosterModeUI_();
          });
        }
        return Promise.resolve().then(() => {
          this.enablePosterModeUI_();
        });
      }
      return Promise.resolve().then(() => {
        this.disablePosterModeUI_();
      });
    }
    /**
     * A helper method for adding a {@link TextTrack} to our
     * {@link TextTrackList}.
     *
     * In addition to the W3C settings we allow adding additional info through options.
     *
     * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
     *
     * @param {string} [kind]
     *        the kind of TextTrack you are adding
     *
     * @param {string} [label]
     *        the label to give the TextTrack label
     *
     * @param {string} [language]
     *        the language to set on the TextTrack
     *
     * @return {TextTrack|undefined}
     *         the TextTrack that was added or undefined
     *         if there is no tech
     */
    addTextTrack(kind, label, language) {
      if (this.tech_) {
        return this.tech_.addTextTrack(kind, label, language);
      }
    }
    /**
     * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}.
     *
     * @param {Object} options
     *        Options to pass to {@link HTMLTrackElement} during creation. See
     *        {@link HTMLTrackElement} for object properties that you should use.
     *
     * @param {boolean} [manualCleanup=false] if set to true, the TextTrack will not be removed
     *                                        from the TextTrackList and HtmlTrackElementList
     *                                        after a source change
     *
     * @return { import('./tracks/html-track-element').default }
     *         the HTMLTrackElement that was created and added
     *         to the HtmlTrackElementList and the remote
     *         TextTrackList
     *
     */
    addRemoteTextTrack(options, manualCleanup) {
      if (this.tech_) {
        return this.tech_.addRemoteTextTrack(options, manualCleanup);
      }
    }
    /**
     * Remove a remote {@link TextTrack} from the respective
     * {@link TextTrackList} and {@link HtmlTrackElementList}.
     *
     * @param {Object} track
     *        Remote {@link TextTrack} to remove
     *
     * @return {undefined}
     *         does not return anything
     */
    removeRemoteTextTrack(obj = {}) {
      let {
        track
      } = obj;
      if (!track) {
        track = obj;
      }
      if (this.tech_) {
        return this.tech_.removeRemoteTextTrack(track);
      }
    }
    /**
     * Gets available media playback quality metrics as specified by the W3C's Media
     * Playback Quality API.
     *
     * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
     *
     * @return {Object|undefined}
     *         An object with supported media playback quality metrics or undefined if there
     *         is no tech or the tech does not support it.
     */
    getVideoPlaybackQuality() {
      return this.techGet_("getVideoPlaybackQuality");
    }
    /**
     * Get video width
     *
     * @return {number}
     *         current video width
     */
    videoWidth() {
      return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
    }
    /**
     * Get video height
     *
     * @return {number}
     *         current video height
     */
    videoHeight() {
      return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
    }
    /**
     * Set or get the player's language code.
     *
     * Changing the language will trigger
     * [languagechange]{@link Player#event:languagechange}
     * which Components can use to update control text.
     * ClickableComponent will update its control text by default on
     * [languagechange]{@link Player#event:languagechange}.
     *
     * @fires Player#languagechange
     *
     * @param {string} [code]
     *        the language code to set the player to
     *
     * @return {string|undefined}
     *         - The current language code when getting
     *         - Nothing when setting
     */
    language(code) {
      if (code === void 0) {
        return this.language_;
      }
      if (this.language_ !== String(code).toLowerCase()) {
        this.language_ = String(code).toLowerCase();
        if (isEvented(this)) {
          this.trigger("languagechange");
        }
      }
    }
    /**
     * Get the player's language dictionary
     * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time
     * Languages specified directly in the player options have precedence
     *
     * @return {Array}
     *         An array of of supported languages
     */
    languages() {
      return merge$2(Player.prototype.options_.languages, this.languages_);
    }
    /**
     * returns a JavaScript object representing the current track
     * information. **DOES not return it as JSON**
     *
     * @return {Object}
     *         Object representing the current of track info
     */
    toJSON() {
      const options = merge$2(this.options_);
      const tracks = options.tracks;
      options.tracks = [];
      for (let i = 0; i < tracks.length; i++) {
        let track = tracks[i];
        track = merge$2(track);
        track.player = void 0;
        options.tracks[i] = track;
      }
      return options;
    }
    /**
     * Creates a simple modal dialog (an instance of the {@link ModalDialog}
     * component) that immediately overlays the player with arbitrary
     * content and removes itself when closed.
     *
     * @param {string|Function|Element|Array|null} content
     *        Same as {@link ModalDialog#content}'s param of the same name.
     *        The most straight-forward usage is to provide a string or DOM
     *        element.
     *
     * @param {Object} [options]
     *        Extra options which will be passed on to the {@link ModalDialog}.
     *
     * @return {ModalDialog}
     *         the {@link ModalDialog} that was created
     */
    createModal(content, options) {
      options = options || {};
      options.content = content || "";
      const modal = new ModalDialog(this, options);
      this.addChild(modal);
      modal.on("dispose", () => {
        this.removeChild(modal);
      });
      modal.open();
      return modal;
    }
    /**
     * Change breakpoint classes when the player resizes.
     *
     * @private
     */
    updateCurrentBreakpoint_() {
      if (!this.responsive()) {
        return;
      }
      const currentBreakpoint = this.currentBreakpoint();
      const currentWidth = this.currentWidth();
      for (let i = 0; i < BREAKPOINT_ORDER.length; i++) {
        const candidateBreakpoint = BREAKPOINT_ORDER[i];
        const maxWidth = this.breakpoints_[candidateBreakpoint];
        if (currentWidth <= maxWidth) {
          if (currentBreakpoint === candidateBreakpoint) {
            return;
          }
          if (currentBreakpoint) {
            this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);
          }
          this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);
          this.breakpoint_ = candidateBreakpoint;
          break;
        }
      }
    }
    /**
     * Removes the current breakpoint.
     *
     * @private
     */
    removeCurrentBreakpoint_() {
      const className = this.currentBreakpointClass();
      this.breakpoint_ = "";
      if (className) {
        this.removeClass(className);
      }
    }
    /**
     * Get or set breakpoints on the player.
     *
     * Calling this method with an object or `true` will remove any previous
     * custom breakpoints and start from the defaults again.
     *
     * @param  {Object|boolean} [breakpoints]
     *         If an object is given, it can be used to provide custom
     *         breakpoints. If `true` is given, will set default breakpoints.
     *         If this argument is not given, will simply return the current
     *         breakpoints.
     *
     * @param  {number} [breakpoints.tiny]
     *         The maximum width for the "vjs-layout-tiny" class.
     *
     * @param  {number} [breakpoints.xsmall]
     *         The maximum width for the "vjs-layout-x-small" class.
     *
     * @param  {number} [breakpoints.small]
     *         The maximum width for the "vjs-layout-small" class.
     *
     * @param  {number} [breakpoints.medium]
     *         The maximum width for the "vjs-layout-medium" class.
     *
     * @param  {number} [breakpoints.large]
     *         The maximum width for the "vjs-layout-large" class.
     *
     * @param  {number} [breakpoints.xlarge]
     *         The maximum width for the "vjs-layout-x-large" class.
     *
     * @param  {number} [breakpoints.huge]
     *         The maximum width for the "vjs-layout-huge" class.
     *
     * @return {Object}
     *         An object mapping breakpoint names to maximum width values.
     */
    breakpoints(breakpoints) {
      if (breakpoints === void 0) {
        return Object.assign(this.breakpoints_);
      }
      this.breakpoint_ = "";
      this.breakpoints_ = Object.assign({}, DEFAULT_BREAKPOINTS, breakpoints);
      this.updateCurrentBreakpoint_();
      return Object.assign(this.breakpoints_);
    }
    /**
     * Get or set a flag indicating whether or not this player should adjust
     * its UI based on its dimensions.
     *
     * @param  {boolean} [value]
     *         Should be `true` if the player should adjust its UI based on its
     *         dimensions; otherwise, should be `false`.
     *
     * @return {boolean|undefined}
     *         Will be `true` if this player should adjust its UI based on its
     *         dimensions; otherwise, will be `false`.
     *         Nothing if setting
     */
    responsive(value) {
      if (value === void 0) {
        return this.responsive_;
      }
      value = Boolean(value);
      const current = this.responsive_;
      if (value === current) {
        return;
      }
      this.responsive_ = value;
      if (value) {
        this.on("playerresize", this.boundUpdateCurrentBreakpoint_);
        this.updateCurrentBreakpoint_();
      } else {
        this.off("playerresize", this.boundUpdateCurrentBreakpoint_);
        this.removeCurrentBreakpoint_();
      }
      return value;
    }
    /**
     * Get current breakpoint name, if any.
     *
     * @return {string}
     *         If there is currently a breakpoint set, returns a the key from the
     *         breakpoints object matching it. Otherwise, returns an empty string.
     */
    currentBreakpoint() {
      return this.breakpoint_;
    }
    /**
     * Get the current breakpoint class name.
     *
     * @return {string}
     *         The matching class name (e.g. `"vjs-layout-tiny"` or
     *         `"vjs-layout-large"`) for the current breakpoint. Empty string if
     *         there is no current breakpoint.
     */
    currentBreakpointClass() {
      return BREAKPOINT_CLASSES[this.breakpoint_] || "";
    }
    /**
     * An object that describes a single piece of media.
     *
     * Properties that are not part of this type description will be retained; so,
     * this can be viewed as a generic metadata storage mechanism as well.
     *
     * @see      {@link https://wicg.github.io/mediasession/#the-mediametadata-interface}
     * @typedef  {Object} Player~MediaObject
     *
     * @property {string} [album]
     *           Unused, except if this object is passed to the `MediaSession`
     *           API.
     *
     * @property {string} [artist]
     *           Unused, except if this object is passed to the `MediaSession`
     *           API.
     *
     * @property {Object[]} [artwork]
     *           Unused, except if this object is passed to the `MediaSession`
     *           API. If not specified, will be populated via the `poster`, if
     *           available.
     *
     * @property {string} [poster]
     *           URL to an image that will display before playback.
     *
     * @property {Tech~SourceObject|Tech~SourceObject[]|string} [src]
     *           A single source object, an array of source objects, or a string
     *           referencing a URL to a media source. It is _highly recommended_
     *           that an object or array of objects is used here, so that source
     *           selection algorithms can take the `type` into account.
     *
     * @property {string} [title]
     *           Unused, except if this object is passed to the `MediaSession`
     *           API.
     *
     * @property {Object[]} [textTracks]
     *           An array of objects to be used to create text tracks, following
     *           the {@link https://www.w3.org/TR/html50/embedded-content-0.html#the-track-element|native track element format}.
     *           For ease of removal, these will be created as "remote" text
     *           tracks and set to automatically clean up on source changes.
     *
     *           These objects may have properties like `src`, `kind`, `label`,
     *           and `language`, see {@link Tech#createRemoteTextTrack}.
     */
    /**
     * Populate the player using a {@link Player~MediaObject|MediaObject}.
     *
     * @param  {Player~MediaObject} media
     *         A media object.
     *
     * @param  {Function} ready
     *         A callback to be called when the player is ready.
     */
    loadMedia(media, ready) {
      if (!media || typeof media !== "object") {
        return;
      }
      const crossOrigin = this.crossOrigin();
      this.reset();
      this.cache_.media = merge$2(media);
      const {
        artist,
        artwork,
        description,
        poster,
        src,
        textTracks,
        title
      } = this.cache_.media;
      if (!artwork && poster) {
        this.cache_.media.artwork = [{
          src: poster,
          type: getMimetype(poster)
        }];
      }
      if (crossOrigin) {
        this.crossOrigin(crossOrigin);
      }
      if (src) {
        this.src(src);
      }
      if (poster) {
        this.poster(poster);
      }
      if (Array.isArray(textTracks)) {
        textTracks.forEach((tt) => this.addRemoteTextTrack(tt, false));
      }
      if (this.titleBar) {
        this.titleBar.update({
          title,
          description: description || artist || ""
        });
      }
      this.ready(ready);
    }
    /**
     * Get a clone of the current {@link Player~MediaObject} for this player.
     *
     * If the `loadMedia` method has not been used, will attempt to return a
     * {@link Player~MediaObject} based on the current state of the player.
     *
     * @return {Player~MediaObject}
     */
    getMedia() {
      if (!this.cache_.media) {
        const poster = this.poster();
        const src = this.currentSources();
        const textTracks = Array.prototype.map.call(this.remoteTextTracks(), (tt) => ({
          kind: tt.kind,
          label: tt.label,
          language: tt.language,
          src: tt.src
        }));
        const media = {
          src,
          textTracks
        };
        if (poster) {
          media.poster = poster;
          media.artwork = [{
            src: media.poster,
            type: getMimetype(media.poster)
          }];
        }
        return media;
      }
      return merge$2(this.cache_.media);
    }
    /**
     * Gets tag settings
     *
     * @param {Element} tag
     *        The player tag
     *
     * @return {Object}
     *         An object containing all of the settings
     *         for a player tag
     */
    static getTagSettings(tag) {
      const baseOptions = {
        sources: [],
        tracks: []
      };
      const tagOptions = getAttributes(tag);
      const dataSetup = tagOptions["data-setup"];
      if (hasClass(tag, "vjs-fill")) {
        tagOptions.fill = true;
      }
      if (hasClass(tag, "vjs-fluid")) {
        tagOptions.fluid = true;
      }
      if (dataSetup !== null) {
        const [err, data] = tuple(dataSetup || "{}");
        if (err) {
          log$1.error(err);
        }
        Object.assign(tagOptions, data);
      }
      Object.assign(baseOptions, tagOptions);
      if (tag.hasChildNodes()) {
        const children = tag.childNodes;
        for (let i = 0, j = children.length; i < j; i++) {
          const child = children[i];
          const childName = child.nodeName.toLowerCase();
          if (childName === "source") {
            baseOptions.sources.push(getAttributes(child));
          } else if (childName === "track") {
            baseOptions.tracks.push(getAttributes(child));
          }
        }
      }
      return baseOptions;
    }
    /**
     * Set debug mode to enable/disable logs at info level.
     *
     * @param {boolean} enabled
     * @fires Player#debugon
     * @fires Player#debugoff
     * @return {boolean|undefined}
     */
    debug(enabled) {
      if (enabled === void 0) {
        return this.debugEnabled_;
      }
      if (enabled) {
        this.trigger("debugon");
        this.previousLogLevel_ = this.log.level;
        this.log.level("debug");
        this.debugEnabled_ = true;
      } else {
        this.trigger("debugoff");
        this.log.level(this.previousLogLevel_);
        this.previousLogLevel_ = void 0;
        this.debugEnabled_ = false;
      }
    }
    /**
     * Set or get current playback rates.
     * Takes an array and updates the playback rates menu with the new items.
     * Pass in an empty array to hide the menu.
     * Values other than arrays are ignored.
     *
     * @fires Player#playbackrateschange
     * @param {number[]} newRates
     *                   The new rates that the playback rates menu should update to.
     *                   An empty array will hide the menu
     * @return {number[]} When used as a getter will return the current playback rates
     */
    playbackRates(newRates) {
      if (newRates === void 0) {
        return this.cache_.playbackRates;
      }
      if (!Array.isArray(newRates)) {
        return;
      }
      if (!newRates.every((rate) => typeof rate === "number")) {
        return;
      }
      this.cache_.playbackRates = newRates;
      this.trigger("playbackrateschange");
    }
  }
  ALL.names.forEach(function(name) {
    const props = ALL[name];
    Player.prototype[props.getterName] = function() {
      if (this.tech_) {
        return this.tech_[props.getterName]();
      }
      this[props.privateName] = this[props.privateName] || new props.ListClass();
      return this[props.privateName];
    };
  });
  Player.prototype.crossorigin = Player.prototype.crossOrigin;
  Player.players = {};
  const navigator2 = window.navigator;
  Player.prototype.options_ = {
    // Default order of fallback technology
    techOrder: Tech.defaultTechOrder_,
    html5: {},
    // enable sourceset by default
    enableSourceset: true,
    // default inactivity timeout
    inactivityTimeout: 2e3,
    // default playback rates
    playbackRates: [],
    // Add playback rate selection by adding rates
    // 'playbackRates': [0.5, 1, 1.5, 2],
    liveui: false,
    // Included control sets
    children: ["mediaLoader", "posterImage", "titleBar", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "liveTracker", "controlBar", "errorDisplay", "textTrackSettings", "resizeManager"],
    language: navigator2 && (navigator2.languages && navigator2.languages[0] || navigator2.userLanguage || navigator2.language) || "en",
    // locales and their language translations
    languages: {},
    // Default message to show when a video cannot be played.
    notSupportedMessage: "No compatible source was found for this media.",
    normalizeAutoplay: false,
    fullscreen: {
      options: {
        navigationUI: "hide"
      }
    },
    breakpoints: {},
    responsive: false,
    audioOnlyMode: false,
    audioPosterMode: false,
    // Default smooth seeking to false
    enableSmoothSeeking: false
  };
  TECH_EVENTS_RETRIGGER.forEach(function(event) {
    Player.prototype[`handleTech${toTitleCase$1(event)}_`] = function() {
      return this.trigger(event);
    };
  });
  Component$1.registerComponent("Player", Player);
  const BASE_PLUGIN_NAME = "plugin";
  const PLUGIN_CACHE_KEY = "activePlugins_";
  const pluginStorage = {};
  const pluginExists = (name) => pluginStorage.hasOwnProperty(name);
  const getPlugin = (name) => pluginExists(name) ? pluginStorage[name] : void 0;
  const markPluginAsActive = (player, name) => {
    player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
    player[PLUGIN_CACHE_KEY][name] = true;
  };
  const triggerSetupEvent = (player, hash, before) => {
    const eventName = (before ? "before" : "") + "pluginsetup";
    player.trigger(eventName, hash);
    player.trigger(eventName + ":" + hash.name, hash);
  };
  const createBasicPlugin = function(name, plugin) {
    const basicPluginWrapper = function() {
      triggerSetupEvent(this, {
        name,
        plugin,
        instance: null
      }, true);
      const instance = plugin.apply(this, arguments);
      markPluginAsActive(this, name);
      triggerSetupEvent(this, {
        name,
        plugin,
        instance
      });
      return instance;
    };
    Object.keys(plugin).forEach(function(prop) {
      basicPluginWrapper[prop] = plugin[prop];
    });
    return basicPluginWrapper;
  };
  const createPluginFactory = (name, PluginSubClass) => {
    PluginSubClass.prototype.name = name;
    return function(...args) {
      triggerSetupEvent(this, {
        name,
        plugin: PluginSubClass,
        instance: null
      }, true);
      const instance = new PluginSubClass(...[this, ...args]);
      this[name] = () => instance;
      triggerSetupEvent(this, instance.getEventHash());
      return instance;
    };
  };
  class Plugin {
    /**
     * Creates an instance of this class.
     *
     * Sub-classes should call `super` to ensure plugins are properly initialized.
     *
     * @param {Player} player
     *        A Video.js player instance.
     */
    constructor(player) {
      if (this.constructor === Plugin) {
        throw new Error("Plugin must be sub-classed; not directly instantiated.");
      }
      this.player = player;
      if (!this.log) {
        this.log = this.player.log.createLogger(this.name);
      }
      evented(this);
      delete this.trigger;
      stateful(this, this.constructor.defaultState);
      markPluginAsActive(player, this.name);
      this.dispose = this.dispose.bind(this);
      player.on("dispose", this.dispose);
    }
    /**
     * Get the version of the plugin that was set on <pluginName>.VERSION
     */
    version() {
      return this.constructor.VERSION;
    }
    /**
     * Each event triggered by plugins includes a hash of additional data with
     * conventional properties.
     *
     * This returns that object or mutates an existing hash.
     *
     * @param   {Object} [hash={}]
     *          An object to be used as event an event hash.
     *
     * @return {PluginEventHash}
     *          An event hash object with provided properties mixed-in.
     */
    getEventHash(hash = {}) {
      hash.name = this.name;
      hash.plugin = this.constructor;
      hash.instance = this;
      return hash;
    }
    /**
     * Triggers an event on the plugin object and overrides
     * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.
     *
     * @param   {string|Object} event
     *          An event type or an object with a type property.
     *
     * @param   {Object} [hash={}]
     *          Additional data hash to merge with a
     *          {@link PluginEventHash|PluginEventHash}.
     *
     * @return {boolean}
     *          Whether or not default was prevented.
     */
    trigger(event, hash = {}) {
      return trigger(this.eventBusEl_, event, this.getEventHash(hash));
    }
    /**
     * Handles "statechanged" events on the plugin. No-op by default, override by
     * subclassing.
     *
     * @abstract
     * @param    {Event} e
     *           An event object provided by a "statechanged" event.
     *
     * @param    {Object} e.changes
     *           An object describing changes that occurred with the "statechanged"
     *           event.
     */
    handleStateChanged(e) {
    }
    /**
     * Disposes a plugin.
     *
     * Subclasses can override this if they want, but for the sake of safety,
     * it's probably best to subscribe the "dispose" event.
     *
     * @fires Plugin#dispose
     */
    dispose() {
      const {
        name,
        player
      } = this;
      this.trigger("dispose");
      this.off();
      player.off("dispose", this.dispose);
      player[PLUGIN_CACHE_KEY][name] = false;
      this.player = this.state = null;
      player[name] = createPluginFactory(name, pluginStorage[name]);
    }
    /**
     * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).
     *
     * @param   {string|Function} plugin
     *          If a string, matches the name of a plugin. If a function, will be
     *          tested directly.
     *
     * @return {boolean}
     *          Whether or not a plugin is a basic plugin.
     */
    static isBasic(plugin) {
      const p = typeof plugin === "string" ? getPlugin(plugin) : plugin;
      return typeof p === "function" && !Plugin.prototype.isPrototypeOf(p.prototype);
    }
    /**
     * Register a Video.js plugin.
     *
     * @param   {string} name
     *          The name of the plugin to be registered. Must be a string and
     *          must not match an existing plugin or a method on the `Player`
     *          prototype.
     *
     * @param   {typeof Plugin|Function} plugin
     *          A sub-class of `Plugin` or a function for basic plugins.
     *
     * @return {typeof Plugin|Function}
     *          For advanced plugins, a factory function for that plugin. For
     *          basic plugins, a wrapper function that initializes the plugin.
     */
    static registerPlugin(name, plugin) {
      if (typeof name !== "string") {
        throw new Error(`Illegal plugin name, "${name}", must be a string, was ${typeof name}.`);
      }
      if (pluginExists(name)) {
        log$1.warn(`A plugin named "${name}" already exists. You may want to avoid re-registering plugins!`);
      } else if (Player.prototype.hasOwnProperty(name)) {
        throw new Error(`Illegal plugin name, "${name}", cannot share a name with an existing player method!`);
      }
      if (typeof plugin !== "function") {
        throw new Error(`Illegal plugin for "${name}", must be a function, was ${typeof plugin}.`);
      }
      pluginStorage[name] = plugin;
      if (name !== BASE_PLUGIN_NAME) {
        if (Plugin.isBasic(plugin)) {
          Player.prototype[name] = createBasicPlugin(name, plugin);
        } else {
          Player.prototype[name] = createPluginFactory(name, plugin);
        }
      }
      return plugin;
    }
    /**
     * De-register a Video.js plugin.
     *
     * @param  {string} name
     *         The name of the plugin to be de-registered. Must be a string that
     *         matches an existing plugin.
     *
     * @throws {Error}
     *         If an attempt is made to de-register the base plugin.
     */
    static deregisterPlugin(name) {
      if (name === BASE_PLUGIN_NAME) {
        throw new Error("Cannot de-register base plugin.");
      }
      if (pluginExists(name)) {
        delete pluginStorage[name];
        delete Player.prototype[name];
      }
    }
    /**
     * Gets an object containing multiple Video.js plugins.
     *
     * @param   {Array} [names]
     *          If provided, should be an array of plugin names. Defaults to _all_
     *          plugin names.
     *
     * @return {Object|undefined}
     *          An object containing plugin(s) associated with their name(s) or
     *          `undefined` if no matching plugins exist).
     */
    static getPlugins(names = Object.keys(pluginStorage)) {
      let result;
      names.forEach((name) => {
        const plugin = getPlugin(name);
        if (plugin) {
          result = result || {};
          result[name] = plugin;
        }
      });
      return result;
    }
    /**
     * Gets a plugin's version, if available
     *
     * @param   {string} name
     *          The name of a plugin.
     *
     * @return {string}
     *          The plugin's version or an empty string.
     */
    static getPluginVersion(name) {
      const plugin = getPlugin(name);
      return plugin && plugin.VERSION || "";
    }
  }
  Plugin.getPlugin = getPlugin;
  Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;
  Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);
  Player.prototype.usingPlugin = function(name) {
    return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
  };
  Player.prototype.hasPlugin = function(name) {
    return !!pluginExists(name);
  };
  function deprecate(message, fn) {
    let warned = false;
    return function(...args) {
      if (!warned) {
        log$1.warn(message);
      }
      warned = true;
      return fn.apply(this, args);
    };
  }
  function deprecateForMajor(major, oldName, newName, fn) {
    return deprecate(`${oldName} is deprecated and will be removed in ${major}.0; please use ${newName} instead.`, fn);
  }
  const normalizeId = (id) => id.indexOf("#") === 0 ? id.slice(1) : id;
  function videojs(id, options, ready) {
    let player = videojs.getPlayer(id);
    if (player) {
      if (options) {
        log$1.warn(`Player "${id}" is already initialised. Options will not be applied.`);
      }
      if (ready) {
        player.ready(ready);
      }
      return player;
    }
    const el = typeof id === "string" ? $("#" + normalizeId(id)) : id;
    if (!isEl(el)) {
      throw new TypeError("The element or ID supplied is not valid. (videojs)");
    }
    const inShadowDom = "getRootNode" in el ? el.getRootNode() instanceof window.ShadowRoot : false;
    const rootNode = inShadowDom ? el.getRootNode() : el.ownerDocument.body;
    if (!el.ownerDocument.defaultView || !rootNode.contains(el)) {
      log$1.warn("The element supplied is not included in the DOM");
    }
    options = options || {};
    if (options.restoreEl === true) {
      options.restoreEl = (el.parentNode && el.parentNode.hasAttribute("data-vjs-player") ? el.parentNode : el).cloneNode(true);
    }
    hooks("beforesetup").forEach((hookFunction) => {
      const opts = hookFunction(el, merge$2(options));
      if (!isObject$1(opts) || Array.isArray(opts)) {
        log$1.error("please return an object in beforesetup hooks");
        return;
      }
      options = merge$2(options, opts);
    });
    const PlayerComponent = Component$1.getComponent("Player");
    player = new PlayerComponent(el, options, ready);
    hooks("setup").forEach((hookFunction) => hookFunction(player));
    return player;
  }
  videojs.hooks_ = hooks_;
  videojs.hooks = hooks;
  videojs.hook = hook;
  videojs.hookOnce = hookOnce;
  videojs.removeHook = removeHook;
  if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {
    let style = $(".vjs-styles-defaults");
    if (!style) {
      style = createStyleElement("vjs-styles-defaults");
      const head = $("head");
      if (head) {
        head.insertBefore(style, head.firstChild);
      }
      setTextContent(style, `
      .video-js {
        width: 300px;
        height: 150px;
      }

      .vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: 56.25%
      }
    `);
    }
  }
  autoSetupTimeout(1, videojs);
  videojs.VERSION = version$5;
  videojs.options = Player.prototype.options_;
  videojs.getPlayers = () => Player.players;
  videojs.getPlayer = (id) => {
    const players = Player.players;
    let tag;
    if (typeof id === "string") {
      const nId = normalizeId(id);
      const player = players[nId];
      if (player) {
        return player;
      }
      tag = $("#" + nId);
    } else {
      tag = id;
    }
    if (isEl(tag)) {
      const {
        player,
        playerId
      } = tag;
      if (player || players[playerId]) {
        return player || players[playerId];
      }
    }
  };
  videojs.getAllPlayers = () => (
    // Disposed players leave a key with a `null` value, so we need to make sure
    // we filter those out.
    Object.keys(Player.players).map((k) => Player.players[k]).filter(Boolean)
  );
  videojs.players = Player.players;
  videojs.getComponent = Component$1.getComponent;
  videojs.registerComponent = (name, comp) => {
    if (Tech.isTech(comp)) {
      log$1.warn(`The ${name} tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)`);
    }
    return Component$1.registerComponent.call(Component$1, name, comp);
  };
  videojs.getTech = Tech.getTech;
  videojs.registerTech = Tech.registerTech;
  videojs.use = use;
  Object.defineProperty(videojs, "middleware", {
    value: {},
    writeable: false,
    enumerable: true
  });
  Object.defineProperty(videojs.middleware, "TERMINATOR", {
    value: TERMINATOR,
    writeable: false,
    enumerable: true
  });
  videojs.browser = browser;
  videojs.obj = Obj;
  videojs.mergeOptions = deprecateForMajor(9, "videojs.mergeOptions", "videojs.obj.merge", merge$2);
  videojs.defineLazyProperty = deprecateForMajor(9, "videojs.defineLazyProperty", "videojs.obj.defineLazyProperty", defineLazyProperty);
  videojs.bind = deprecateForMajor(9, "videojs.bind", "native Function.prototype.bind", bind_);
  videojs.registerPlugin = Plugin.registerPlugin;
  videojs.deregisterPlugin = Plugin.deregisterPlugin;
  videojs.plugin = (name, plugin) => {
    log$1.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead");
    return Plugin.registerPlugin(name, plugin);
  };
  videojs.getPlugins = Plugin.getPlugins;
  videojs.getPlugin = Plugin.getPlugin;
  videojs.getPluginVersion = Plugin.getPluginVersion;
  videojs.addLanguage = function(code, data) {
    code = ("" + code).toLowerCase();
    videojs.options.languages = merge$2(videojs.options.languages, {
      [code]: data
    });
    return videojs.options.languages[code];
  };
  videojs.log = log$1;
  videojs.createLogger = createLogger;
  videojs.time = Time;
  videojs.createTimeRange = deprecateForMajor(9, "videojs.createTimeRange", "videojs.time.createTimeRanges", createTimeRanges$1);
  videojs.createTimeRanges = deprecateForMajor(9, "videojs.createTimeRanges", "videojs.time.createTimeRanges", createTimeRanges$1);
  videojs.formatTime = deprecateForMajor(9, "videojs.formatTime", "videojs.time.formatTime", formatTime);
  videojs.setFormatTime = deprecateForMajor(9, "videojs.setFormatTime", "videojs.time.setFormatTime", setFormatTime);
  videojs.resetFormatTime = deprecateForMajor(9, "videojs.resetFormatTime", "videojs.time.resetFormatTime", resetFormatTime);
  videojs.parseUrl = deprecateForMajor(9, "videojs.parseUrl", "videojs.url.parseUrl", parseUrl);
  videojs.isCrossOrigin = deprecateForMajor(9, "videojs.isCrossOrigin", "videojs.url.isCrossOrigin", isCrossOrigin);
  videojs.EventTarget = EventTarget$2;
  videojs.any = any;
  videojs.on = on;
  videojs.one = one;
  videojs.off = off;
  videojs.trigger = trigger;
  videojs.xhr = lib;
  videojs.TextTrack = TextTrack;
  videojs.AudioTrack = AudioTrack;
  videojs.VideoTrack = VideoTrack;
  ["isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent"].forEach((k) => {
    videojs[k] = function() {
      log$1.warn(`videojs.${k}() is deprecated; use videojs.dom.${k}() instead`);
      return Dom[k].apply(null, arguments);
    };
  });
  videojs.computedStyle = deprecateForMajor(9, "videojs.computedStyle", "videojs.dom.computedStyle", computedStyle);
  videojs.dom = Dom;
  videojs.fn = Fn;
  videojs.num = Num;
  videojs.str = Str;
  videojs.url = Url;
  createCommonjsModule(function(module2, exports2) {
    /*! @name videojs-contrib-quality-levels @version 4.0.0 @license Apache-2.0 */
    (function(global2, factory2) {
      module2.exports = factory2(videojs);
    })(commonjsGlobal, function(videojs2) {
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : {
          "default": e
        };
      }
      var videojs__default = /* @__PURE__ */ _interopDefaultLegacy(videojs2);
      class QualityLevel {
        /**
         * Creates a QualityLevel
         *
         * @param {Representation|Object} representation The representation of the quality level
         * @param {string}   representation.id        Unique id of the QualityLevel
         * @param {number=}  representation.width     Resolution width of the QualityLevel
         * @param {number=}  representation.height    Resolution height of the QualityLevel
         * @param {number}   representation.bandwidth Bitrate of the QualityLevel
         * @param {number=}  representation.frameRate Frame-rate of the QualityLevel
         * @param {Function} representation.enabled   Callback to enable/disable QualityLevel
         */
        constructor(representation) {
          let level = this;
          level.id = representation.id;
          level.label = level.id;
          level.width = representation.width;
          level.height = representation.height;
          level.bitrate = representation.bandwidth;
          level.frameRate = representation.frameRate;
          level.enabled_ = representation.enabled;
          Object.defineProperty(level, "enabled", {
            /**
             * Get whether the QualityLevel is enabled.
             *
             * @return {boolean} True if the QualityLevel is enabled.
             */
            get() {
              return level.enabled_();
            },
            /**
             * Enable or disable the QualityLevel.
             *
             * @param {boolean} enable true to enable QualityLevel, false to disable.
             */
            set(enable) {
              level.enabled_(enable);
            }
          });
          return level;
        }
      }
      class QualityLevelList extends videojs__default["default"].EventTarget {
        /**
         * Creates a QualityLevelList.
         */
        constructor() {
          super();
          let list = this;
          list.levels_ = [];
          list.selectedIndex_ = -1;
          Object.defineProperty(list, "selectedIndex", {
            get() {
              return list.selectedIndex_;
            }
          });
          Object.defineProperty(list, "length", {
            get() {
              return list.levels_.length;
            }
          });
          list[Symbol.iterator] = () => list.levels_.values();
          return list;
        }
        /**
         * Adds a quality level to the list.
         *
         * @param {Representation|Object} representation The representation of the quality level
         * @param {string}   representation.id        Unique id of the QualityLevel
         * @param {number=}  representation.width     Resolution width of the QualityLevel
         * @param {number=}  representation.height    Resolution height of the QualityLevel
         * @param {number}   representation.bandwidth Bitrate of the QualityLevel
         * @param {number=}  representation.frameRate Frame-rate of the QualityLevel
         * @param {Function} representation.enabled   Callback to enable/disable QualityLevel
         * @return {QualityLevel} the QualityLevel added to the list
         * @method addQualityLevel
         */
        addQualityLevel(representation) {
          let qualityLevel = this.getQualityLevelById(representation.id);
          if (qualityLevel) {
            return qualityLevel;
          }
          const index = this.levels_.length;
          qualityLevel = new QualityLevel(representation);
          if (!("" + index in this)) {
            Object.defineProperty(this, index, {
              get() {
                return this.levels_[index];
              }
            });
          }
          this.levels_.push(qualityLevel);
          this.trigger({
            qualityLevel,
            type: "addqualitylevel"
          });
          return qualityLevel;
        }
        /**
         * Removes a quality level from the list.
         *
         * @param {QualityLevel} qualityLevel The QualityLevel to remove from the list.
         * @return {QualityLevel|null} the QualityLevel removed or null if nothing removed
         * @method removeQualityLevel
         */
        removeQualityLevel(qualityLevel) {
          let removed = null;
          for (let i = 0, l = this.length; i < l; i++) {
            if (this[i] === qualityLevel) {
              removed = this.levels_.splice(i, 1)[0];
              if (this.selectedIndex_ === i) {
                this.selectedIndex_ = -1;
              } else if (this.selectedIndex_ > i) {
                this.selectedIndex_--;
              }
              break;
            }
          }
          if (removed) {
            this.trigger({
              qualityLevel,
              type: "removequalitylevel"
            });
          }
          return removed;
        }
        /**
         * Searches for a QualityLevel with the given id.
         *
         * @param {string} id The id of the QualityLevel to find.
         * @return {QualityLevel|null} The QualityLevel with id, or null if not found.
         * @method getQualityLevelById
         */
        getQualityLevelById(id) {
          for (let i = 0, l = this.length; i < l; i++) {
            const level = this[i];
            if (level.id === id) {
              return level;
            }
          }
          return null;
        }
        /**
         * Resets the list of QualityLevels to empty
         *
         * @method dispose
         */
        dispose() {
          this.selectedIndex_ = -1;
          this.levels_.length = 0;
        }
      }
      QualityLevelList.prototype.allowedEvents_ = {
        change: "change",
        addqualitylevel: "addqualitylevel",
        removequalitylevel: "removequalitylevel"
      };
      for (const event in QualityLevelList.prototype.allowedEvents_) {
        QualityLevelList.prototype["on" + event] = null;
      }
      var version2 = "4.0.0";
      const initPlugin2 = function(player, options) {
        const originalPluginFn = player.qualityLevels;
        const qualityLevelList = new QualityLevelList();
        const disposeHandler = function() {
          qualityLevelList.dispose();
          player.qualityLevels = originalPluginFn;
          player.off("dispose", disposeHandler);
        };
        player.on("dispose", disposeHandler);
        player.qualityLevels = () => qualityLevelList;
        player.qualityLevels.VERSION = version2;
        return qualityLevelList;
      };
      const qualityLevels = function(options) {
        return initPlugin2(this, videojs__default["default"].obj.merge({}, options));
      };
      videojs__default["default"].registerPlugin("qualityLevels", qualityLevels);
      qualityLevels.VERSION = version2;
      return qualityLevels;
    });
  });
  var urlToolkit = createCommonjsModule(function(module2, exports2) {
    (function(root) {
      var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
      var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
      var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
      var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
      var URLToolkit = {
        // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
        // E.g
        // With opts.alwaysNormalize = false (default, spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
        // With opts.alwaysNormalize = true (not spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
        buildAbsoluteURL: function(baseURL, relativeURL, opts) {
          opts = opts || {};
          baseURL = baseURL.trim();
          relativeURL = relativeURL.trim();
          if (!relativeURL) {
            if (!opts.alwaysNormalize) {
              return baseURL;
            }
            var basePartsForNormalise = URLToolkit.parseURL(baseURL);
            if (!basePartsForNormalise) {
              throw new Error("Error trying to parse base URL.");
            }
            basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
            return URLToolkit.buildURLFromParts(basePartsForNormalise);
          }
          var relativeParts = URLToolkit.parseURL(relativeURL);
          if (!relativeParts) {
            throw new Error("Error trying to parse relative URL.");
          }
          if (relativeParts.scheme) {
            if (!opts.alwaysNormalize) {
              return relativeURL;
            }
            relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
            return URLToolkit.buildURLFromParts(relativeParts);
          }
          var baseParts = URLToolkit.parseURL(baseURL);
          if (!baseParts) {
            throw new Error("Error trying to parse base URL.");
          }
          if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
            var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
            baseParts.netLoc = pathParts[1];
            baseParts.path = pathParts[2];
          }
          if (baseParts.netLoc && !baseParts.path) {
            baseParts.path = "/";
          }
          var builtParts = {
            // 2c) Otherwise, the embedded URL inherits the scheme of
            // the base URL.
            scheme: baseParts.scheme,
            netLoc: relativeParts.netLoc,
            path: null,
            params: relativeParts.params,
            query: relativeParts.query,
            fragment: relativeParts.fragment
          };
          if (!relativeParts.netLoc) {
            builtParts.netLoc = baseParts.netLoc;
            if (relativeParts.path[0] !== "/") {
              if (!relativeParts.path) {
                builtParts.path = baseParts.path;
                if (!relativeParts.params) {
                  builtParts.params = baseParts.params;
                  if (!relativeParts.query) {
                    builtParts.query = baseParts.query;
                  }
                }
              } else {
                var baseURLPath = baseParts.path;
                var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
                builtParts.path = URLToolkit.normalizePath(newPath);
              }
            }
          }
          if (builtParts.path === null) {
            builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
          }
          return URLToolkit.buildURLFromParts(builtParts);
        },
        parseURL: function(url) {
          var parts = URL_REGEX.exec(url);
          if (!parts) {
            return null;
          }
          return {
            scheme: parts[1] || "",
            netLoc: parts[2] || "",
            path: parts[3] || "",
            params: parts[4] || "",
            query: parts[5] || "",
            fragment: parts[6] || ""
          };
        },
        normalizePath: function(path) {
          path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
          while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) {
          }
          return path.split("").reverse().join("");
        },
        buildURLFromParts: function(parts) {
          return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
        }
      };
      module2.exports = URLToolkit;
    })();
  });
  var DEFAULT_LOCATION = "http://example.com";
  var resolveUrl$1 = function resolveUrl2(baseUrl, relativeUrl) {
    if (/^[a-z]+:/i.test(relativeUrl)) {
      return relativeUrl;
    }
    if (/^data:/.test(baseUrl)) {
      baseUrl = window.location && window.location.href || "";
    }
    var nativeURL = typeof window.URL === "function";
    var protocolLess = /^\/\//.test(baseUrl);
    var removeLocation = !window.location && !/\/\//i.test(baseUrl);
    if (nativeURL) {
      baseUrl = new window.URL(baseUrl, window.location || DEFAULT_LOCATION);
    } else if (!/\/\//i.test(baseUrl)) {
      baseUrl = urlToolkit.buildAbsoluteURL(window.location && window.location.href || "", baseUrl);
    }
    if (nativeURL) {
      var newUrl = new URL(relativeUrl, baseUrl);
      if (removeLocation) {
        return newUrl.href.slice(DEFAULT_LOCATION.length);
      } else if (protocolLess) {
        return newUrl.href.slice(newUrl.protocol.length);
      }
      return newUrl.href;
    }
    return urlToolkit.buildAbsoluteURL(baseUrl, relativeUrl);
  };
  var Stream = /* @__PURE__ */ function() {
    function Stream2() {
      this.listeners = {};
    }
    var _proto = Stream2.prototype;
    _proto.on = function on2(type, listener) {
      if (!this.listeners[type]) {
        this.listeners[type] = [];
      }
      this.listeners[type].push(listener);
    };
    _proto.off = function off2(type, listener) {
      if (!this.listeners[type]) {
        return false;
      }
      var index = this.listeners[type].indexOf(listener);
      this.listeners[type] = this.listeners[type].slice(0);
      this.listeners[type].splice(index, 1);
      return index > -1;
    };
    _proto.trigger = function trigger2(type) {
      var callbacks = this.listeners[type];
      if (!callbacks) {
        return;
      }
      if (arguments.length === 2) {
        var length = callbacks.length;
        for (var i = 0; i < length; ++i) {
          callbacks[i].call(this, arguments[1]);
        }
      } else {
        var args = Array.prototype.slice.call(arguments, 1);
        var _length = callbacks.length;
        for (var _i = 0; _i < _length; ++_i) {
          callbacks[_i].apply(this, args);
        }
      }
    };
    _proto.dispose = function dispose() {
      this.listeners = {};
    };
    _proto.pipe = function pipe(destination) {
      this.on("data", function(data) {
        destination.push(data);
      });
    };
    return Stream2;
  }();
  var atob$1 = function atob3(s) {
    return window.atob ? window.atob(s) : Buffer.from(s, "base64").toString("binary");
  };
  function decodeB64ToUint8Array$1(b64Text) {
    var decodedString = atob$1(b64Text);
    var array = new Uint8Array(decodedString.length);
    for (var i = 0; i < decodedString.length; i++) {
      array[i] = decodedString.charCodeAt(i);
    }
    return array;
  }
  /*! @name m3u8-parser @version 7.1.0 @license Apache-2.0 */
  class LineStream extends Stream {
    constructor() {
      super();
      this.buffer = "";
    }
    /**
     * Add new data to be parsed.
     *
     * @param {string} data the text to process
     */
    push(data) {
      let nextNewline;
      this.buffer += data;
      nextNewline = this.buffer.indexOf("\n");
      for (; nextNewline > -1; nextNewline = this.buffer.indexOf("\n")) {
        this.trigger("data", this.buffer.substring(0, nextNewline));
        this.buffer = this.buffer.substring(nextNewline + 1);
      }
    }
  }
  const TAB = String.fromCharCode(9);
  const parseByterange = function(byterangeString) {
    const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || "");
    const result = {};
    if (match[1]) {
      result.length = parseInt(match[1], 10);
    }
    if (match[2]) {
      result.offset = parseInt(match[2], 10);
    }
    return result;
  };
  const attributeSeparator = function() {
    const key = "[^=]*";
    const value = '"[^"]*"|[^,]*';
    const keyvalue = "(?:" + key + ")=(?:" + value + ")";
    return new RegExp("(?:^|,)(" + keyvalue + ")");
  };
  const parseAttributes$1 = function(attributes) {
    const result = {};
    if (!attributes) {
      return result;
    }
    const attrs = attributes.split(attributeSeparator());
    let i = attrs.length;
    let attr;
    while (i--) {
      if (attrs[i] === "") {
        continue;
      }
      attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1);
      attr[0] = attr[0].replace(/^\s+|\s+$/g, "");
      attr[1] = attr[1].replace(/^\s+|\s+$/g, "");
      attr[1] = attr[1].replace(/^['"](.*)['"]$/g, "$1");
      result[attr[0]] = attr[1];
    }
    return result;
  };
  class ParseStream extends Stream {
    constructor() {
      super();
      this.customParsers = [];
      this.tagMappers = [];
    }
    /**
     * Parses an additional line of input.
     *
     * @param {string} line a single line of an M3U8 file to parse
     */
    push(line) {
      let match;
      let event;
      line = line.trim();
      if (line.length === 0) {
        return;
      }
      if (line[0] !== "#") {
        this.trigger("data", {
          type: "uri",
          uri: line
        });
        return;
      }
      const newLines = this.tagMappers.reduce((acc, mapper) => {
        const mappedLine = mapper(line);
        if (mappedLine === line) {
          return acc;
        }
        return acc.concat([mappedLine]);
      }, [line]);
      newLines.forEach((newLine) => {
        for (let i = 0; i < this.customParsers.length; i++) {
          if (this.customParsers[i].call(this, newLine)) {
            return;
          }
        }
        if (newLine.indexOf("#EXT") !== 0) {
          this.trigger("data", {
            type: "comment",
            text: newLine.slice(1)
          });
          return;
        }
        newLine = newLine.replace("\r", "");
        match = /^#EXTM3U/.exec(newLine);
        if (match) {
          this.trigger("data", {
            type: "tag",
            tagType: "m3u"
          });
          return;
        }
        match = /^#EXTINF:([0-9\.]*)?,?(.*)?$/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "inf"
          };
          if (match[1]) {
            event.duration = parseFloat(match[1]);
          }
          if (match[2]) {
            event.title = match[2];
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "targetduration"
          };
          if (match[1]) {
            event.duration = parseInt(match[1], 10);
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "version"
          };
          if (match[1]) {
            event.version = parseInt(match[1], 10);
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-MEDIA-SEQUENCE:(\-?[0-9.]*)?/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "media-sequence"
          };
          if (match[1]) {
            event.number = parseInt(match[1], 10);
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\-?[0-9.]*)?/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "discontinuity-sequence"
          };
          if (match[1]) {
            event.number = parseInt(match[1], 10);
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "playlist-type"
          };
          if (match[1]) {
            event.playlistType = match[1];
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);
        if (match) {
          event = _extends$1(parseByterange(match[1]), {
            type: "tag",
            tagType: "byterange"
          });
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "allow-cache"
          };
          if (match[1]) {
            event.allowed = !/NO/.test(match[1]);
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-MAP:(.*)$/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "map"
          };
          if (match[1]) {
            const attributes = parseAttributes$1(match[1]);
            if (attributes.URI) {
              event.uri = attributes.URI;
            }
            if (attributes.BYTERANGE) {
              event.byterange = parseByterange(attributes.BYTERANGE);
            }
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "stream-inf"
          };
          if (match[1]) {
            event.attributes = parseAttributes$1(match[1]);
            if (event.attributes.RESOLUTION) {
              const split2 = event.attributes.RESOLUTION.split("x");
              const resolution = {};
              if (split2[0]) {
                resolution.width = parseInt(split2[0], 10);
              }
              if (split2[1]) {
                resolution.height = parseInt(split2[1], 10);
              }
              event.attributes.RESOLUTION = resolution;
            }
            if (event.attributes.BANDWIDTH) {
              event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);
            }
            if (event.attributes["FRAME-RATE"]) {
              event.attributes["FRAME-RATE"] = parseFloat(event.attributes["FRAME-RATE"]);
            }
            if (event.attributes["PROGRAM-ID"]) {
              event.attributes["PROGRAM-ID"] = parseInt(event.attributes["PROGRAM-ID"], 10);
            }
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "media"
          };
          if (match[1]) {
            event.attributes = parseAttributes$1(match[1]);
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-ENDLIST/.exec(newLine);
        if (match) {
          this.trigger("data", {
            type: "tag",
            tagType: "endlist"
          });
          return;
        }
        match = /^#EXT-X-DISCONTINUITY/.exec(newLine);
        if (match) {
          this.trigger("data", {
            type: "tag",
            tagType: "discontinuity"
          });
          return;
        }
        match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "program-date-time"
          };
          if (match[1]) {
            event.dateTimeString = match[1];
            event.dateTimeObject = new Date(match[1]);
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-KEY:(.*)$/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "key"
          };
          if (match[1]) {
            event.attributes = parseAttributes$1(match[1]);
            if (event.attributes.IV) {
              if (event.attributes.IV.substring(0, 2).toLowerCase() === "0x") {
                event.attributes.IV = event.attributes.IV.substring(2);
              }
              event.attributes.IV = event.attributes.IV.match(/.{8}/g);
              event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);
              event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);
              event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);
              event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);
              event.attributes.IV = new Uint32Array(event.attributes.IV);
            }
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-START:(.*)$/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "start"
          };
          if (match[1]) {
            event.attributes = parseAttributes$1(match[1]);
            event.attributes["TIME-OFFSET"] = parseFloat(event.attributes["TIME-OFFSET"]);
            event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "cue-out-cont"
          };
          if (match[1]) {
            event.data = match[1];
          } else {
            event.data = "";
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "cue-out"
          };
          if (match[1]) {
            event.data = match[1];
          } else {
            event.data = "";
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-CUE-IN:(.*)?$/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "cue-in"
          };
          if (match[1]) {
            event.data = match[1];
          } else {
            event.data = "";
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);
        if (match && match[1]) {
          event = {
            type: "tag",
            tagType: "skip"
          };
          event.attributes = parseAttributes$1(match[1]);
          if (event.attributes.hasOwnProperty("SKIPPED-SEGMENTS")) {
            event.attributes["SKIPPED-SEGMENTS"] = parseInt(event.attributes["SKIPPED-SEGMENTS"], 10);
          }
          if (event.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES")) {
            event.attributes["RECENTLY-REMOVED-DATERANGES"] = event.attributes["RECENTLY-REMOVED-DATERANGES"].split(TAB);
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-PART:(.*)$/.exec(newLine);
        if (match && match[1]) {
          event = {
            type: "tag",
            tagType: "part"
          };
          event.attributes = parseAttributes$1(match[1]);
          ["DURATION"].forEach(function(key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = parseFloat(event.attributes[key]);
            }
          });
          ["INDEPENDENT", "GAP"].forEach(function(key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = /YES/.test(event.attributes[key]);
            }
          });
          if (event.attributes.hasOwnProperty("BYTERANGE")) {
            event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);
        if (match && match[1]) {
          event = {
            type: "tag",
            tagType: "server-control"
          };
          event.attributes = parseAttributes$1(match[1]);
          ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach(function(key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = parseFloat(event.attributes[key]);
            }
          });
          ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach(function(key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = /YES/.test(event.attributes[key]);
            }
          });
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);
        if (match && match[1]) {
          event = {
            type: "tag",
            tagType: "part-inf"
          };
          event.attributes = parseAttributes$1(match[1]);
          ["PART-TARGET"].forEach(function(key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = parseFloat(event.attributes[key]);
            }
          });
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);
        if (match && match[1]) {
          event = {
            type: "tag",
            tagType: "preload-hint"
          };
          event.attributes = parseAttributes$1(match[1]);
          ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach(function(key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = parseInt(event.attributes[key], 10);
              const subkey = key === "BYTERANGE-LENGTH" ? "length" : "offset";
              event.attributes.byterange = event.attributes.byterange || {};
              event.attributes.byterange[subkey] = event.attributes[key];
              delete event.attributes[key];
            }
          });
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);
        if (match && match[1]) {
          event = {
            type: "tag",
            tagType: "rendition-report"
          };
          event.attributes = parseAttributes$1(match[1]);
          ["LAST-MSN", "LAST-PART"].forEach(function(key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = parseInt(event.attributes[key], 10);
            }
          });
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-DATERANGE:(.*)$/.exec(newLine);
        if (match && match[1]) {
          event = {
            type: "tag",
            tagType: "daterange"
          };
          event.attributes = parseAttributes$1(match[1]);
          ["ID", "CLASS"].forEach(function(key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = String(event.attributes[key]);
            }
          });
          ["START-DATE", "END-DATE"].forEach(function(key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = new Date(event.attributes[key]);
            }
          });
          ["DURATION", "PLANNED-DURATION"].forEach(function(key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = parseFloat(event.attributes[key]);
            }
          });
          ["END-ON-NEXT"].forEach(function(key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = /YES/i.test(event.attributes[key]);
            }
          });
          ["SCTE35-CMD", " SCTE35-OUT", "SCTE35-IN"].forEach(function(key) {
            if (event.attributes.hasOwnProperty(key)) {
              event.attributes[key] = event.attributes[key].toString(16);
            }
          });
          const clientAttributePattern = /^X-([A-Z]+-)+[A-Z]+$/;
          for (const key in event.attributes) {
            if (!clientAttributePattern.test(key)) {
              continue;
            }
            const isHexaDecimal = /[0-9A-Fa-f]{6}/g.test(event.attributes[key]);
            const isDecimalFloating = /^\d+(\.\d+)?$/.test(event.attributes[key]);
            event.attributes[key] = isHexaDecimal ? event.attributes[key].toString(16) : isDecimalFloating ? parseFloat(event.attributes[key]) : String(event.attributes[key]);
          }
          this.trigger("data", event);
          return;
        }
        match = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(newLine);
        if (match) {
          this.trigger("data", {
            type: "tag",
            tagType: "independent-segments"
          });
          return;
        }
        match = /^#EXT-X-CONTENT-STEERING:(.*)$/.exec(newLine);
        if (match) {
          event = {
            type: "tag",
            tagType: "content-steering"
          };
          event.attributes = parseAttributes$1(match[1]);
          this.trigger("data", event);
          return;
        }
        this.trigger("data", {
          type: "tag",
          data: newLine.slice(4)
        });
      });
    }
    /**
     * Add a parser for custom headers
     *
     * @param {Object}   options              a map of options for the added parser
     * @param {RegExp}   options.expression   a regular expression to match the custom header
     * @param {string}   options.customType   the custom type to register to the output
     * @param {Function} [options.dataParser] function to parse the line into an object
     * @param {boolean}  [options.segment]    should tag data be attached to the segment object
     */
    addParser({
      expression,
      customType,
      dataParser,
      segment
    }) {
      if (typeof dataParser !== "function") {
        dataParser = (line) => line;
      }
      this.customParsers.push((line) => {
        const match = expression.exec(line);
        if (match) {
          this.trigger("data", {
            type: "custom",
            data: dataParser(line),
            customType,
            segment
          });
          return true;
        }
      });
    }
    /**
     * Add a custom header mapper
     *
     * @param {Object}   options
     * @param {RegExp}   options.expression   a regular expression to match the custom header
     * @param {Function} options.map          function to translate tag into a different tag
     */
    addTagMapper({
      expression,
      map
    }) {
      const mapFn = (line) => {
        if (expression.test(line)) {
          return map(line);
        }
        return line;
      };
      this.tagMappers.push(mapFn);
    }
  }
  const camelCase = (str) => str.toLowerCase().replace(/-(\w)/g, (a) => a[1].toUpperCase());
  const camelCaseKeys = function(attributes) {
    const result = {};
    Object.keys(attributes).forEach(function(key) {
      result[camelCase(key)] = attributes[key];
    });
    return result;
  };
  const setHoldBack = function(manifest) {
    const {
      serverControl,
      targetDuration,
      partTargetDuration
    } = manifest;
    if (!serverControl) {
      return;
    }
    const tag = "#EXT-X-SERVER-CONTROL";
    const hb = "holdBack";
    const phb = "partHoldBack";
    const minTargetDuration = targetDuration && targetDuration * 3;
    const minPartDuration = partTargetDuration && partTargetDuration * 2;
    if (targetDuration && !serverControl.hasOwnProperty(hb)) {
      serverControl[hb] = minTargetDuration;
      this.trigger("info", {
        message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`
      });
    }
    if (minTargetDuration && serverControl[hb] < minTargetDuration) {
      this.trigger("warn", {
        message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`
      });
      serverControl[hb] = minTargetDuration;
    }
    if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {
      serverControl[phb] = partTargetDuration * 3;
      this.trigger("info", {
        message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`
      });
    }
    if (partTargetDuration && serverControl[phb] < minPartDuration) {
      this.trigger("warn", {
        message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`
      });
      serverControl[phb] = minPartDuration;
    }
  };
  class Parser extends Stream {
    constructor() {
      super();
      this.lineStream = new LineStream();
      this.parseStream = new ParseStream();
      this.lineStream.pipe(this.parseStream);
      this.lastProgramDateTime = null;
      const self2 = this;
      const uris = [];
      let currentUri = {};
      let currentMap;
      let key;
      let hasParts = false;
      const noop2 = function() {
      };
      const defaultMediaGroups = {
        "AUDIO": {},
        "VIDEO": {},
        "CLOSED-CAPTIONS": {},
        "SUBTITLES": {}
      };
      const widevineUuid = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
      let currentTimeline = 0;
      this.manifest = {
        allowCache: true,
        discontinuityStarts: [],
        dateRanges: [],
        segments: []
      };
      let lastByterangeEnd = 0;
      let lastPartByterangeEnd = 0;
      const dateRangeTags = {};
      this.on("end", () => {
        if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {
          return;
        }
        if (!currentUri.map && currentMap) {
          currentUri.map = currentMap;
        }
        if (!currentUri.key && key) {
          currentUri.key = key;
        }
        if (!currentUri.timeline && typeof currentTimeline === "number") {
          currentUri.timeline = currentTimeline;
        }
        this.manifest.preloadSegment = currentUri;
      });
      this.parseStream.on("data", function(entry) {
        let mediaGroup;
        let rendition;
        ({
          tag() {
            ({
              version() {
                if (entry.version) {
                  this.manifest.version = entry.version;
                }
              },
              "allow-cache"() {
                this.manifest.allowCache = entry.allowed;
                if (!("allowed" in entry)) {
                  this.trigger("info", {
                    message: "defaulting allowCache to YES"
                  });
                  this.manifest.allowCache = true;
                }
              },
              byterange() {
                const byterange = {};
                if ("length" in entry) {
                  currentUri.byterange = byterange;
                  byterange.length = entry.length;
                  if (!("offset" in entry)) {
                    entry.offset = lastByterangeEnd;
                  }
                }
                if ("offset" in entry) {
                  currentUri.byterange = byterange;
                  byterange.offset = entry.offset;
                }
                lastByterangeEnd = byterange.offset + byterange.length;
              },
              endlist() {
                this.manifest.endList = true;
              },
              inf() {
                if (!("mediaSequence" in this.manifest)) {
                  this.manifest.mediaSequence = 0;
                  this.trigger("info", {
                    message: "defaulting media sequence to zero"
                  });
                }
                if (!("discontinuitySequence" in this.manifest)) {
                  this.manifest.discontinuitySequence = 0;
                  this.trigger("info", {
                    message: "defaulting discontinuity sequence to zero"
                  });
                }
                if (entry.title) {
                  currentUri.title = entry.title;
                }
                if (entry.duration > 0) {
                  currentUri.duration = entry.duration;
                }
                if (entry.duration === 0) {
                  currentUri.duration = 0.01;
                  this.trigger("info", {
                    message: "updating zero segment duration to a small value"
                  });
                }
                this.manifest.segments = uris;
              },
              key() {
                if (!entry.attributes) {
                  this.trigger("warn", {
                    message: "ignoring key declaration without attribute list"
                  });
                  return;
                }
                if (entry.attributes.METHOD === "NONE") {
                  key = null;
                  return;
                }
                if (!entry.attributes.URI) {
                  this.trigger("warn", {
                    message: "ignoring key declaration without URI"
                  });
                  return;
                }
                if (entry.attributes.KEYFORMAT === "com.apple.streamingkeydelivery") {
                  this.manifest.contentProtection = this.manifest.contentProtection || {};
                  this.manifest.contentProtection["com.apple.fps.1_0"] = {
                    attributes: entry.attributes
                  };
                  return;
                }
                if (entry.attributes.KEYFORMAT === "com.microsoft.playready") {
                  this.manifest.contentProtection = this.manifest.contentProtection || {};
                  this.manifest.contentProtection["com.microsoft.playready"] = {
                    uri: entry.attributes.URI
                  };
                  return;
                }
                if (entry.attributes.KEYFORMAT === widevineUuid) {
                  const VALID_METHODS = ["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"];
                  if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {
                    this.trigger("warn", {
                      message: "invalid key method provided for Widevine"
                    });
                    return;
                  }
                  if (entry.attributes.METHOD === "SAMPLE-AES-CENC") {
                    this.trigger("warn", {
                      message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"
                    });
                  }
                  if (entry.attributes.URI.substring(0, 23) !== "data:text/plain;base64,") {
                    this.trigger("warn", {
                      message: "invalid key URI provided for Widevine"
                    });
                    return;
                  }
                  if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === "0x")) {
                    this.trigger("warn", {
                      message: "invalid key ID provided for Widevine"
                    });
                    return;
                  }
                  this.manifest.contentProtection = this.manifest.contentProtection || {};
                  this.manifest.contentProtection["com.widevine.alpha"] = {
                    attributes: {
                      schemeIdUri: entry.attributes.KEYFORMAT,
                      // remove '0x' from the key id string
                      keyId: entry.attributes.KEYID.substring(2)
                    },
                    // decode the base64-encoded PSSH box
                    pssh: decodeB64ToUint8Array$1(entry.attributes.URI.split(",")[1])
                  };
                  return;
                }
                if (!entry.attributes.METHOD) {
                  this.trigger("warn", {
                    message: "defaulting key method to AES-128"
                  });
                }
                key = {
                  method: entry.attributes.METHOD || "AES-128",
                  uri: entry.attributes.URI
                };
                if (typeof entry.attributes.IV !== "undefined") {
                  key.iv = entry.attributes.IV;
                }
              },
              "media-sequence"() {
                if (!isFinite(entry.number)) {
                  this.trigger("warn", {
                    message: "ignoring invalid media sequence: " + entry.number
                  });
                  return;
                }
                this.manifest.mediaSequence = entry.number;
              },
              "discontinuity-sequence"() {
                if (!isFinite(entry.number)) {
                  this.trigger("warn", {
                    message: "ignoring invalid discontinuity sequence: " + entry.number
                  });
                  return;
                }
                this.manifest.discontinuitySequence = entry.number;
                currentTimeline = entry.number;
              },
              "playlist-type"() {
                if (!/VOD|EVENT/.test(entry.playlistType)) {
                  this.trigger("warn", {
                    message: "ignoring unknown playlist type: " + entry.playlist
                  });
                  return;
                }
                this.manifest.playlistType = entry.playlistType;
              },
              map() {
                currentMap = {};
                if (entry.uri) {
                  currentMap.uri = entry.uri;
                }
                if (entry.byterange) {
                  currentMap.byterange = entry.byterange;
                }
                if (key) {
                  currentMap.key = key;
                }
              },
              "stream-inf"() {
                this.manifest.playlists = uris;
                this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
                if (!entry.attributes) {
                  this.trigger("warn", {
                    message: "ignoring empty stream-inf attributes"
                  });
                  return;
                }
                if (!currentUri.attributes) {
                  currentUri.attributes = {};
                }
                _extends$1(currentUri.attributes, entry.attributes);
              },
              media() {
                this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
                if (!(entry.attributes && entry.attributes.TYPE && entry.attributes["GROUP-ID"] && entry.attributes.NAME)) {
                  this.trigger("warn", {
                    message: "ignoring incomplete or missing media group"
                  });
                  return;
                }
                const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];
                mediaGroupType[entry.attributes["GROUP-ID"]] = mediaGroupType[entry.attributes["GROUP-ID"]] || {};
                mediaGroup = mediaGroupType[entry.attributes["GROUP-ID"]];
                rendition = {
                  default: /yes/i.test(entry.attributes.DEFAULT)
                };
                if (rendition.default) {
                  rendition.autoselect = true;
                } else {
                  rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);
                }
                if (entry.attributes.LANGUAGE) {
                  rendition.language = entry.attributes.LANGUAGE;
                }
                if (entry.attributes.URI) {
                  rendition.uri = entry.attributes.URI;
                }
                if (entry.attributes["INSTREAM-ID"]) {
                  rendition.instreamId = entry.attributes["INSTREAM-ID"];
                }
                if (entry.attributes.CHARACTERISTICS) {
                  rendition.characteristics = entry.attributes.CHARACTERISTICS;
                }
                if (entry.attributes.FORCED) {
                  rendition.forced = /yes/i.test(entry.attributes.FORCED);
                }
                mediaGroup[entry.attributes.NAME] = rendition;
              },
              discontinuity() {
                currentTimeline += 1;
                currentUri.discontinuity = true;
                this.manifest.discontinuityStarts.push(uris.length);
              },
              "program-date-time"() {
                if (typeof this.manifest.dateTimeString === "undefined") {
                  this.manifest.dateTimeString = entry.dateTimeString;
                  this.manifest.dateTimeObject = entry.dateTimeObject;
                }
                currentUri.dateTimeString = entry.dateTimeString;
                currentUri.dateTimeObject = entry.dateTimeObject;
                const {
                  lastProgramDateTime
                } = this;
                this.lastProgramDateTime = new Date(entry.dateTimeString).getTime();
                if (lastProgramDateTime === null) {
                  this.manifest.segments.reduceRight((programDateTime, segment) => {
                    segment.programDateTime = programDateTime - segment.duration * 1e3;
                    return segment.programDateTime;
                  }, this.lastProgramDateTime);
                }
              },
              targetduration() {
                if (!isFinite(entry.duration) || entry.duration < 0) {
                  this.trigger("warn", {
                    message: "ignoring invalid target duration: " + entry.duration
                  });
                  return;
                }
                this.manifest.targetDuration = entry.duration;
                setHoldBack.call(this, this.manifest);
              },
              start() {
                if (!entry.attributes || isNaN(entry.attributes["TIME-OFFSET"])) {
                  this.trigger("warn", {
                    message: "ignoring start declaration without appropriate attribute list"
                  });
                  return;
                }
                this.manifest.start = {
                  timeOffset: entry.attributes["TIME-OFFSET"],
                  precise: entry.attributes.PRECISE
                };
              },
              "cue-out"() {
                currentUri.cueOut = entry.data;
              },
              "cue-out-cont"() {
                currentUri.cueOutCont = entry.data;
              },
              "cue-in"() {
                currentUri.cueIn = entry.data;
              },
              "skip"() {
                this.manifest.skip = camelCaseKeys(entry.attributes);
                this.warnOnMissingAttributes_("#EXT-X-SKIP", entry.attributes, ["SKIPPED-SEGMENTS"]);
              },
              "part"() {
                hasParts = true;
                const segmentIndex = this.manifest.segments.length;
                const part = camelCaseKeys(entry.attributes);
                currentUri.parts = currentUri.parts || [];
                currentUri.parts.push(part);
                if (part.byterange) {
                  if (!part.byterange.hasOwnProperty("offset")) {
                    part.byterange.offset = lastPartByterangeEnd;
                  }
                  lastPartByterangeEnd = part.byterange.offset + part.byterange.length;
                }
                const partIndex = currentUri.parts.length - 1;
                this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, ["URI", "DURATION"]);
                if (this.manifest.renditionReports) {
                  this.manifest.renditionReports.forEach((r, i) => {
                    if (!r.hasOwnProperty("lastPart")) {
                      this.trigger("warn", {
                        message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`
                      });
                    }
                  });
                }
              },
              "server-control"() {
                const attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);
                if (!attrs.hasOwnProperty("canBlockReload")) {
                  attrs.canBlockReload = false;
                  this.trigger("info", {
                    message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"
                  });
                }
                setHoldBack.call(this, this.manifest);
                if (attrs.canSkipDateranges && !attrs.hasOwnProperty("canSkipUntil")) {
                  this.trigger("warn", {
                    message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"
                  });
                }
              },
              "preload-hint"() {
                const segmentIndex = this.manifest.segments.length;
                const hint = camelCaseKeys(entry.attributes);
                const isPart = hint.type && hint.type === "PART";
                currentUri.preloadHints = currentUri.preloadHints || [];
                currentUri.preloadHints.push(hint);
                if (hint.byterange) {
                  if (!hint.byterange.hasOwnProperty("offset")) {
                    hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;
                    if (isPart) {
                      lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;
                    }
                  }
                }
                const index = currentUri.preloadHints.length - 1;
                this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, ["TYPE", "URI"]);
                if (!hint.type) {
                  return;
                }
                for (let i = 0; i < currentUri.preloadHints.length - 1; i++) {
                  const otherHint = currentUri.preloadHints[i];
                  if (!otherHint.type) {
                    continue;
                  }
                  if (otherHint.type === hint.type) {
                    this.trigger("warn", {
                      message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`
                    });
                  }
                }
              },
              "rendition-report"() {
                const report = camelCaseKeys(entry.attributes);
                this.manifest.renditionReports = this.manifest.renditionReports || [];
                this.manifest.renditionReports.push(report);
                const index = this.manifest.renditionReports.length - 1;
                const required = ["LAST-MSN", "URI"];
                if (hasParts) {
                  required.push("LAST-PART");
                }
                this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);
              },
              "part-inf"() {
                this.manifest.partInf = camelCaseKeys(entry.attributes);
                this.warnOnMissingAttributes_("#EXT-X-PART-INF", entry.attributes, ["PART-TARGET"]);
                if (this.manifest.partInf.partTarget) {
                  this.manifest.partTargetDuration = this.manifest.partInf.partTarget;
                }
                setHoldBack.call(this, this.manifest);
              },
              "daterange"() {
                this.manifest.dateRanges.push(camelCaseKeys(entry.attributes));
                const index = this.manifest.dateRanges.length - 1;
                this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${index}`, entry.attributes, ["ID", "START-DATE"]);
                const dateRange = this.manifest.dateRanges[index];
                if (dateRange.endDate && dateRange.startDate && new Date(dateRange.endDate) < new Date(dateRange.startDate)) {
                  this.trigger("warn", {
                    message: "EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE"
                  });
                }
                if (dateRange.duration && dateRange.duration < 0) {
                  this.trigger("warn", {
                    message: "EXT-X-DATERANGE DURATION must not be negative"
                  });
                }
                if (dateRange.plannedDuration && dateRange.plannedDuration < 0) {
                  this.trigger("warn", {
                    message: "EXT-X-DATERANGE PLANNED-DURATION must not be negative"
                  });
                }
                const endOnNextYes = !!dateRange.endOnNext;
                if (endOnNextYes && !dateRange.class) {
                  this.trigger("warn", {
                    message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute"
                  });
                }
                if (endOnNextYes && (dateRange.duration || dateRange.endDate)) {
                  this.trigger("warn", {
                    message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes"
                  });
                }
                if (dateRange.duration && dateRange.endDate) {
                  const startDate = dateRange.startDate;
                  const newDateInSeconds = startDate.getTime() + dateRange.duration * 1e3;
                  this.manifest.dateRanges[index].endDate = new Date(newDateInSeconds);
                }
                if (!dateRangeTags[dateRange.id]) {
                  dateRangeTags[dateRange.id] = dateRange;
                } else {
                  for (const attribute in dateRangeTags[dateRange.id]) {
                    if (!!dateRange[attribute] && JSON.stringify(dateRangeTags[dateRange.id][attribute]) !== JSON.stringify(dateRange[attribute])) {
                      this.trigger("warn", {
                        message: "EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values"
                      });
                      break;
                    }
                  }
                  const dateRangeWithSameId = this.manifest.dateRanges.findIndex((dateRangeToFind) => dateRangeToFind.id === dateRange.id);
                  this.manifest.dateRanges[dateRangeWithSameId] = _extends$1(this.manifest.dateRanges[dateRangeWithSameId], dateRange);
                  dateRangeTags[dateRange.id] = _extends$1(dateRangeTags[dateRange.id], dateRange);
                  this.manifest.dateRanges.pop();
                }
              },
              "independent-segments"() {
                this.manifest.independentSegments = true;
              },
              "content-steering"() {
                this.manifest.contentSteering = camelCaseKeys(entry.attributes);
                this.warnOnMissingAttributes_("#EXT-X-CONTENT-STEERING", entry.attributes, ["SERVER-URI"]);
              }
            }[entry.tagType] || noop2).call(self2);
          },
          uri() {
            currentUri.uri = entry.uri;
            uris.push(currentUri);
            if (this.manifest.targetDuration && !("duration" in currentUri)) {
              this.trigger("warn", {
                message: "defaulting segment duration to the target duration"
              });
              currentUri.duration = this.manifest.targetDuration;
            }
            if (key) {
              currentUri.key = key;
            }
            currentUri.timeline = currentTimeline;
            if (currentMap) {
              currentUri.map = currentMap;
            }
            lastPartByterangeEnd = 0;
            if (this.lastProgramDateTime !== null) {
              currentUri.programDateTime = this.lastProgramDateTime;
              this.lastProgramDateTime += currentUri.duration * 1e3;
            }
            currentUri = {};
          },
          comment() {
          },
          custom() {
            if (entry.segment) {
              currentUri.custom = currentUri.custom || {};
              currentUri.custom[entry.customType] = entry.data;
            } else {
              this.manifest.custom = this.manifest.custom || {};
              this.manifest.custom[entry.customType] = entry.data;
            }
          }
        })[entry.type].call(self2);
      });
    }
    warnOnMissingAttributes_(identifier, attributes, required) {
      const missing = [];
      required.forEach(function(key) {
        if (!attributes.hasOwnProperty(key)) {
          missing.push(key);
        }
      });
      if (missing.length) {
        this.trigger("warn", {
          message: `${identifier} lacks required attribute(s): ${missing.join(", ")}`
        });
      }
    }
    /**
     * Parse the input string and update the manifest object.
     *
     * @param {string} chunk a potentially incomplete portion of the manifest
     */
    push(chunk) {
      this.lineStream.push(chunk);
    }
    /**
     * Flush any remaining input. This can be handy if the last line of an M3U8
     * manifest did not contain a trailing newline but the file has been
     * completely received.
     */
    end() {
      this.lineStream.push("\n");
      if (this.manifest.dateRanges.length && this.lastProgramDateTime === null) {
        this.trigger("warn", {
          message: "A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag"
        });
      }
      this.lastProgramDateTime = null;
      this.trigger("end");
    }
    /**
     * Add an additional parser for non-standard tags
     *
     * @param {Object}   options              a map of options for the added parser
     * @param {RegExp}   options.expression   a regular expression to match the custom header
     * @param {string}   options.customType   the custom type to register to the output
     * @param {Function} [options.dataParser] function to parse the line into an object
     * @param {boolean}  [options.segment]    should tag data be attached to the segment object
     */
    addParser(options) {
      this.parseStream.addParser(options);
    }
    /**
     * Add a custom header mapper
     *
     * @param {Object}   options
     * @param {RegExp}   options.expression   a regular expression to match the custom header
     * @param {Function} options.map          function to translate tag into a different tag
     */
    addTagMapper(options) {
      this.parseStream.addTagMapper(options);
    }
  }
  var regexs = {
    // to determine mime types
    mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
    webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
    ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
    // to determine if a codec is audio or video
    video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
    audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
    text: /^(stpp.ttml.im1t)/,
    // mux.js support regex
    muxerVideo: /^(avc0?1)/,
    muxerAudio: /^(mp4a)/,
    // match nothing as muxer does not support text right now.
    // there cannot never be a character before the start of a string
    // so this matches nothing.
    muxerText: /a^/
  };
  var mediaTypes = ["video", "audio", "text"];
  var upperMediaTypes = ["Video", "Audio", "Text"];
  var translateLegacyCodec = function translateLegacyCodec2(codec) {
    if (!codec) {
      return codec;
    }
    return codec.replace(/avc1\.(\d+)\.(\d+)/i, function(orig, profile, avcLevel) {
      var profileHex = ("00" + Number(profile).toString(16)).slice(-2);
      var avcLevelHex = ("00" + Number(avcLevel).toString(16)).slice(-2);
      return "avc1." + profileHex + "00" + avcLevelHex;
    });
  };
  var parseCodecs = function parseCodecs2(codecString) {
    if (codecString === void 0) {
      codecString = "";
    }
    var codecs = codecString.split(",");
    var result = [];
    codecs.forEach(function(codec) {
      codec = codec.trim();
      var codecType;
      mediaTypes.forEach(function(name) {
        var match = regexs[name].exec(codec.toLowerCase());
        if (!match || match.length <= 1) {
          return;
        }
        codecType = name;
        var type = codec.substring(0, match[1].length);
        var details = codec.replace(type, "");
        result.push({
          type,
          details,
          mediaType: name
        });
      });
      if (!codecType) {
        result.push({
          type: codec,
          details: "",
          mediaType: "unknown"
        });
      }
    });
    return result;
  };
  var codecsFromDefault = function codecsFromDefault2(master, audioGroupId) {
    if (!master.mediaGroups.AUDIO || !audioGroupId) {
      return null;
    }
    var audioGroup = master.mediaGroups.AUDIO[audioGroupId];
    if (!audioGroup) {
      return null;
    }
    for (var name in audioGroup) {
      var audioType = audioGroup[name];
      if (audioType.default && audioType.playlists) {
        return parseCodecs(audioType.playlists[0].attributes.CODECS);
      }
    }
    return null;
  };
  var isAudioCodec = function isAudioCodec2(codec) {
    if (codec === void 0) {
      codec = "";
    }
    return regexs.audio.test(codec.trim().toLowerCase());
  };
  var isTextCodec = function isTextCodec2(codec) {
    if (codec === void 0) {
      codec = "";
    }
    return regexs.text.test(codec.trim().toLowerCase());
  };
  var getMimeForCodec = function getMimeForCodec2(codecString) {
    if (!codecString || typeof codecString !== "string") {
      return;
    }
    var codecs = codecString.toLowerCase().split(",").map(function(c) {
      return translateLegacyCodec(c.trim());
    });
    var type = "video";
    if (codecs.length === 1 && isAudioCodec(codecs[0])) {
      type = "audio";
    } else if (codecs.length === 1 && isTextCodec(codecs[0])) {
      type = "application";
    }
    var container = "mp4";
    if (codecs.every(function(c) {
      return regexs.mp4.test(c);
    })) {
      container = "mp4";
    } else if (codecs.every(function(c) {
      return regexs.webm.test(c);
    })) {
      container = "webm";
    } else if (codecs.every(function(c) {
      return regexs.ogg.test(c);
    })) {
      container = "ogg";
    }
    return type + "/" + container + ';codecs="' + codecString + '"';
  };
  var browserSupportsCodec = function browserSupportsCodec2(codecString) {
    if (codecString === void 0) {
      codecString = "";
    }
    return window.MediaSource && window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;
  };
  var muxerSupportsCodec = function muxerSupportsCodec2(codecString) {
    if (codecString === void 0) {
      codecString = "";
    }
    return codecString.toLowerCase().split(",").every(function(codec) {
      codec = codec.trim();
      for (var i = 0; i < upperMediaTypes.length; i++) {
        var type = upperMediaTypes[i];
        if (regexs["muxer" + type].test(codec)) {
          return true;
        }
      }
      return false;
    });
  };
  var DEFAULT_AUDIO_CODEC = "mp4a.40.2";
  var DEFAULT_VIDEO_CODEC = "avc1.4d400d";
  var MPEGURL_REGEX = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i;
  var DASH_REGEX = /^application\/dash\+xml/i;
  var simpleTypeFromSourceType = function simpleTypeFromSourceType2(type) {
    if (MPEGURL_REGEX.test(type)) {
      return "hls";
    }
    if (DASH_REGEX.test(type)) {
      return "dash";
    }
    if (type === "application/vnd.videojs.vhs+json") {
      return "vhs-json";
    }
    return null;
  };
  var countBits = function countBits2(x) {
    return x.toString(2).length;
  };
  var countBytes = function countBytes2(x) {
    return Math.ceil(countBits(x) / 8);
  };
  var isArrayBufferView = function isArrayBufferView2(obj) {
    if (ArrayBuffer.isView === "function") {
      return ArrayBuffer.isView(obj);
    }
    return obj && obj.buffer instanceof ArrayBuffer;
  };
  var isTypedArray = function isTypedArray2(obj) {
    return isArrayBufferView(obj);
  };
  var toUint8 = function toUint82(bytes) {
    if (bytes instanceof Uint8Array) {
      return bytes;
    }
    if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) {
      if (typeof bytes !== "number" || typeof bytes === "number" && bytes !== bytes) {
        bytes = 0;
      } else {
        bytes = [bytes];
      }
    }
    return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);
  };
  var BigInt = window.BigInt || Number;
  var BYTE_TABLE = [BigInt("0x1"), BigInt("0x100"), BigInt("0x10000"), BigInt("0x1000000"), BigInt("0x100000000"), BigInt("0x10000000000"), BigInt("0x1000000000000"), BigInt("0x100000000000000"), BigInt("0x10000000000000000")];
  (function() {
    var a = new Uint16Array([65484]);
    var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
    if (b[0] === 255) {
      return "big";
    }
    if (b[0] === 204) {
      return "little";
    }
    return "unknown";
  })();
  var bytesToNumber = function bytesToNumber2(bytes, _temp) {
    var _ref = _temp === void 0 ? {} : _temp, _ref$signed = _ref.signed, signed = _ref$signed === void 0 ? false : _ref$signed, _ref$le = _ref.le, le = _ref$le === void 0 ? false : _ref$le;
    bytes = toUint8(bytes);
    var fn = le ? "reduce" : "reduceRight";
    var obj = bytes[fn] ? bytes[fn] : Array.prototype[fn];
    var number = obj.call(bytes, function(total, byte, i) {
      var exponent = le ? i : Math.abs(i + 1 - bytes.length);
      return total + BigInt(byte) * BYTE_TABLE[exponent];
    }, BigInt(0));
    if (signed) {
      var max = BYTE_TABLE[bytes.length] / BigInt(2) - BigInt(1);
      number = BigInt(number);
      if (number > max) {
        number -= max;
        number -= max;
        number -= BigInt(2);
      }
    }
    return Number(number);
  };
  var numberToBytes = function numberToBytes2(number, _temp2) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$le = _ref2.le, le = _ref2$le === void 0 ? false : _ref2$le;
    if (typeof number !== "bigint" && typeof number !== "number" || typeof number === "number" && number !== number) {
      number = 0;
    }
    number = BigInt(number);
    var byteCount = countBytes(number);
    var bytes = new Uint8Array(new ArrayBuffer(byteCount));
    for (var i = 0; i < byteCount; i++) {
      var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);
      bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt(255));
      if (number < 0) {
        bytes[byteIndex] = Math.abs(~bytes[byteIndex]);
        bytes[byteIndex] -= i === 0 ? 1 : 2;
      }
    }
    return bytes;
  };
  var stringToBytes = function stringToBytes2(string, stringIsBytes) {
    if (typeof string !== "string" && string && typeof string.toString === "function") {
      string = string.toString();
    }
    if (typeof string !== "string") {
      return new Uint8Array();
    }
    if (!stringIsBytes) {
      string = unescape(encodeURIComponent(string));
    }
    var view = new Uint8Array(string.length);
    for (var i = 0; i < string.length; i++) {
      view[i] = string.charCodeAt(i);
    }
    return view;
  };
  var concatTypedArrays = function concatTypedArrays2() {
    for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {
      buffers[_key] = arguments[_key];
    }
    buffers = buffers.filter(function(b) {
      return b && (b.byteLength || b.length) && typeof b !== "string";
    });
    if (buffers.length <= 1) {
      return toUint8(buffers[0]);
    }
    var totalLen = buffers.reduce(function(total, buf, i) {
      return total + (buf.byteLength || buf.length);
    }, 0);
    var tempBuffer = new Uint8Array(totalLen);
    var offset = 0;
    buffers.forEach(function(buf) {
      buf = toUint8(buf);
      tempBuffer.set(buf, offset);
      offset += buf.byteLength;
    });
    return tempBuffer;
  };
  var bytesMatch = function bytesMatch2(a, b, _temp3) {
    var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$offset = _ref3.offset, offset = _ref3$offset === void 0 ? 0 : _ref3$offset, _ref3$mask = _ref3.mask, mask = _ref3$mask === void 0 ? [] : _ref3$mask;
    a = toUint8(a);
    b = toUint8(b);
    var fn = b.every ? b.every : Array.prototype.every;
    return b.length && a.length - offset >= b.length && // ie 11 doesn't support every on uin8
    fn.call(b, function(bByte, i) {
      var aByte = mask[i] ? mask[i] & a[offset + i] : a[offset + i];
      return bByte === aByte;
    });
  };
  var forEachMediaGroup$1 = function forEachMediaGroup2(master, groups, callback) {
    groups.forEach(function(mediaType) {
      for (var groupKey in master.mediaGroups[mediaType]) {
        for (var labelKey in master.mediaGroups[mediaType][groupKey]) {
          var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];
          callback(mediaProperties, mediaType, groupKey, labelKey);
        }
      }
    });
  };
  var atob2 = function atob3(s) {
    return window.atob ? window.atob(s) : Buffer.from(s, "base64").toString("binary");
  };
  function decodeB64ToUint8Array(b64Text) {
    var decodedString = atob2(b64Text);
    var array = new Uint8Array(decodedString.length);
    for (var i = 0; i < decodedString.length; i++) {
      array[i] = decodedString.charCodeAt(i);
    }
    return array;
  }
  function find$1(list, predicate, ac) {
    if (ac === void 0) {
      ac = Array.prototype;
    }
    if (list && typeof ac.find === "function") {
      return ac.find.call(list, predicate);
    }
    for (var i = 0; i < list.length; i++) {
      if (Object.prototype.hasOwnProperty.call(list, i)) {
        var item = list[i];
        if (predicate.call(void 0, item, i, list)) {
          return item;
        }
      }
    }
  }
  function freeze(object, oc) {
    if (oc === void 0) {
      oc = Object;
    }
    return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
  }
  function assign(target, source) {
    if (target === null || typeof target !== "object") {
      throw new TypeError("target is not an object");
    }
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
    return target;
  }
  var MIME_TYPE = freeze({
    /**
     * `text/html`, the only mime type that triggers treating an XML document as HTML.
     *
     * @see DOMParser.SupportedType.isHTML
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
     */
    HTML: "text/html",
    /**
     * Helper method to check a mime type if it indicates an HTML document
     *
     * @param {string} [value]
     * @returns {boolean}
     *
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
    isHTML: function(value) {
      return value === MIME_TYPE.HTML;
    },
    /**
     * `application/xml`, the standard mime type for XML documents.
     *
     * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
     * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_APPLICATION: "application/xml",
    /**
     * `text/html`, an alias for `application/xml`.
     *
     * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
     * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_TEXT: "text/xml",
    /**
     * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
     * but is parsed as an XML document.
     *
     * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
     * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
     */
    XML_XHTML_APPLICATION: "application/xhtml+xml",
    /**
     * `image/svg+xml`,
     *
     * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
     * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
     * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
     */
    XML_SVG_IMAGE: "image/svg+xml"
  });
  var NAMESPACE$3 = freeze({
    /**
     * The XHTML namespace.
     *
     * @see http://www.w3.org/1999/xhtml
     */
    HTML: "http://www.w3.org/1999/xhtml",
    /**
     * Checks if `uri` equals `NAMESPACE.HTML`.
     *
     * @param {string} [uri]
     *
     * @see NAMESPACE.HTML
     */
    isHTML: function(uri) {
      return uri === NAMESPACE$3.HTML;
    },
    /**
     * The SVG namespace.
     *
     * @see http://www.w3.org/2000/svg
     */
    SVG: "http://www.w3.org/2000/svg",
    /**
     * The `xml:` namespace.
     *
     * @see http://www.w3.org/XML/1998/namespace
     */
    XML: "http://www.w3.org/XML/1998/namespace",
    /**
     * The `xmlns:` namespace
     *
     * @see https://www.w3.org/2000/xmlns/
     */
    XMLNS: "http://www.w3.org/2000/xmlns/"
  });
  var assign_1 = assign;
  var find_1 = find$1;
  var freeze_1 = freeze;
  var MIME_TYPE_1 = MIME_TYPE;
  var NAMESPACE_1 = NAMESPACE$3;
  var conventions = {
    assign: assign_1,
    find: find_1,
    freeze: freeze_1,
    MIME_TYPE: MIME_TYPE_1,
    NAMESPACE: NAMESPACE_1
  };
  var find = conventions.find;
  var NAMESPACE$2 = conventions.NAMESPACE;
  function notEmptyString(input) {
    return input !== "";
  }
  function splitOnASCIIWhitespace(input) {
    return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
  }
  function orderedSetReducer(current, element) {
    if (!current.hasOwnProperty(element)) {
      current[element] = true;
    }
    return current;
  }
  function toOrderedSet(input) {
    if (!input)
      return [];
    var list = splitOnASCIIWhitespace(input);
    return Object.keys(list.reduce(orderedSetReducer, {}));
  }
  function arrayIncludes(list) {
    return function(element) {
      return list && list.indexOf(element) !== -1;
    };
  }
  function copy(src, dest) {
    for (var p in src) {
      if (Object.prototype.hasOwnProperty.call(src, p)) {
        dest[p] = src[p];
      }
    }
  }
  function _extends(Class, Super) {
    var pt = Class.prototype;
    if (!(pt instanceof Super)) {
      let t = function() {
      };
      t.prototype = Super.prototype;
      t = new t();
      copy(pt, t);
      Class.prototype = pt = t;
    }
    if (pt.constructor != Class) {
      if (typeof Class != "function") {
        console.error("unknown Class:" + Class);
      }
      pt.constructor = Class;
    }
  }
  var NodeType = {};
  var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
  var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
  var TEXT_NODE = NodeType.TEXT_NODE = 3;
  var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
  var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
  var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
  var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
  var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
  var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
  var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
  var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
  var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
  var ExceptionCode = {};
  var ExceptionMessage = {};
  ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
  ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
  var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
  ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
  ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
  ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
  ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
  var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
  ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
  var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
  ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
  ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
  ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
  ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
  ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
  function DOMException2(code, message) {
    if (message instanceof Error) {
      var error = message;
    } else {
      error = this;
      Error.call(this, ExceptionMessage[code]);
      this.message = ExceptionMessage[code];
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, DOMException2);
    }
    error.code = code;
    if (message)
      this.message = this.message + ": " + message;
    return error;
  }
  DOMException2.prototype = Error.prototype;
  copy(ExceptionCode, DOMException2);
  function NodeList() {
  }
  NodeList.prototype = {
    /**
     * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
     * @standard level1
     */
    length: 0,
    /**
     * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
     * @standard level1
     * @param index  unsigned long
     *   Index into the collection.
     * @return Node
     * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
     */
    item: function(index) {
      return index >= 0 && index < this.length ? this[index] : null;
    },
    toString: function(isHTML, nodeFilter) {
      for (var buf = [], i = 0; i < this.length; i++) {
        serializeToString(this[i], buf, isHTML, nodeFilter);
      }
      return buf.join("");
    },
    /**
     * @private
     * @param {function (Node):boolean} predicate
     * @returns {Node[]}
     */
    filter: function(predicate) {
      return Array.prototype.filter.call(this, predicate);
    },
    /**
     * @private
     * @param {Node} item
     * @returns {number}
     */
    indexOf: function(item) {
      return Array.prototype.indexOf.call(this, item);
    }
  };
  function LiveNodeList(node, refresh) {
    this._node = node;
    this._refresh = refresh;
    _updateLiveList(this);
  }
  function _updateLiveList(list) {
    var inc = list._node._inc || list._node.ownerDocument._inc;
    if (list._inc !== inc) {
      var ls = list._refresh(list._node);
      __set__(list, "length", ls.length);
      if (!list.$$length || ls.length < list.$$length) {
        for (var i = ls.length; i in list; i++) {
          if (Object.prototype.hasOwnProperty.call(list, i)) {
            delete list[i];
          }
        }
      }
      copy(ls, list);
      list._inc = inc;
    }
  }
  LiveNodeList.prototype.item = function(i) {
    _updateLiveList(this);
    return this[i] || null;
  };
  _extends(LiveNodeList, NodeList);
  function NamedNodeMap() {
  }
  function _findNodeIndex(list, node) {
    var i = list.length;
    while (i--) {
      if (list[i] === node) {
        return i;
      }
    }
  }
  function _addNamedNode(el, list, newAttr, oldAttr) {
    if (oldAttr) {
      list[_findNodeIndex(list, oldAttr)] = newAttr;
    } else {
      list[list.length++] = newAttr;
    }
    if (el) {
      newAttr.ownerElement = el;
      var doc = el.ownerDocument;
      if (doc) {
        oldAttr && _onRemoveAttribute(doc, el, oldAttr);
        _onAddAttribute(doc, el, newAttr);
      }
    }
  }
  function _removeNamedNode(el, list, attr) {
    var i = _findNodeIndex(list, attr);
    if (i >= 0) {
      var lastIndex = list.length - 1;
      while (i < lastIndex) {
        list[i] = list[++i];
      }
      list.length = lastIndex;
      if (el) {
        var doc = el.ownerDocument;
        if (doc) {
          _onRemoveAttribute(doc, el, attr);
          attr.ownerElement = null;
        }
      }
    } else {
      throw new DOMException2(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
    }
  }
  NamedNodeMap.prototype = {
    length: 0,
    item: NodeList.prototype.item,
    getNamedItem: function(key) {
      var i = this.length;
      while (i--) {
        var attr = this[i];
        if (attr.nodeName == key) {
          return attr;
        }
      }
    },
    setNamedItem: function(attr) {
      var el = attr.ownerElement;
      if (el && el != this._ownerElement) {
        throw new DOMException2(INUSE_ATTRIBUTE_ERR);
      }
      var oldAttr = this.getNamedItem(attr.nodeName);
      _addNamedNode(this._ownerElement, this, attr, oldAttr);
      return oldAttr;
    },
    /* returns Node */
    setNamedItemNS: function(attr) {
      var el = attr.ownerElement, oldAttr;
      if (el && el != this._ownerElement) {
        throw new DOMException2(INUSE_ATTRIBUTE_ERR);
      }
      oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
      _addNamedNode(this._ownerElement, this, attr, oldAttr);
      return oldAttr;
    },
    /* returns Node */
    removeNamedItem: function(key) {
      var attr = this.getNamedItem(key);
      _removeNamedNode(this._ownerElement, this, attr);
      return attr;
    },
    // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
    //for level2
    removeNamedItemNS: function(namespaceURI, localName) {
      var attr = this.getNamedItemNS(namespaceURI, localName);
      _removeNamedNode(this._ownerElement, this, attr);
      return attr;
    },
    getNamedItemNS: function(namespaceURI, localName) {
      var i = this.length;
      while (i--) {
        var node = this[i];
        if (node.localName == localName && node.namespaceURI == namespaceURI) {
          return node;
        }
      }
      return null;
    }
  };
  function DOMImplementation$1() {
  }
  DOMImplementation$1.prototype = {
    /**
     * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
     * The different implementations fairly diverged in what kind of features were reported.
     * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
     *
     * @deprecated It is deprecated and modern browsers return true in all cases.
     *
     * @param {string} feature
     * @param {string} [version]
     * @returns {boolean} always true
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
     */
    hasFeature: function(feature, version2) {
      return true;
    },
    /**
     * Creates an XML Document object of the specified type with its document element.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
     * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string|null} namespaceURI
     * @param {string} qualifiedName
     * @param {DocumentType=null} doctype
     * @returns {Document}
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocument: function(namespaceURI, qualifiedName, doctype) {
      var doc = new Document();
      doc.implementation = this;
      doc.childNodes = new NodeList();
      doc.doctype = doctype || null;
      if (doctype) {
        doc.appendChild(doctype);
      }
      if (qualifiedName) {
        var root = doc.createElementNS(namespaceURI, qualifiedName);
        doc.appendChild(root);
      }
      return doc;
    },
    /**
     * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
     *
     * __This behavior is slightly different from the in the specs__:
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string} qualifiedName
     * @param {string} [publicId]
     * @param {string} [systemId]
     * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
     * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocumentType: function(qualifiedName, publicId, systemId) {
      var node = new DocumentType();
      node.name = qualifiedName;
      node.nodeName = qualifiedName;
      node.publicId = publicId || "";
      node.systemId = systemId || "";
      return node;
    }
  };
  function Node() {
  }
  Node.prototype = {
    firstChild: null,
    lastChild: null,
    previousSibling: null,
    nextSibling: null,
    attributes: null,
    parentNode: null,
    childNodes: null,
    ownerDocument: null,
    nodeValue: null,
    namespaceURI: null,
    prefix: null,
    localName: null,
    // Modified in DOM Level 2:
    insertBefore: function(newChild, refChild) {
      return _insertBefore(this, newChild, refChild);
    },
    replaceChild: function(newChild, oldChild) {
      _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
      if (oldChild) {
        this.removeChild(oldChild);
      }
    },
    removeChild: function(oldChild) {
      return _removeChild(this, oldChild);
    },
    appendChild: function(newChild) {
      return this.insertBefore(newChild, null);
    },
    hasChildNodes: function() {
      return this.firstChild != null;
    },
    cloneNode: function(deep) {
      return cloneNode(this.ownerDocument || this, this, deep);
    },
    // Modified in DOM Level 2:
    normalize: function() {
      var child = this.firstChild;
      while (child) {
        var next = child.nextSibling;
        if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
          this.removeChild(next);
          child.appendData(next.data);
        } else {
          child.normalize();
          child = next;
        }
      }
    },
    // Introduced in DOM Level 2:
    isSupported: function(feature, version2) {
      return this.ownerDocument.implementation.hasFeature(feature, version2);
    },
    // Introduced in DOM Level 2:
    hasAttributes: function() {
      return this.attributes.length > 0;
    },
    /**
     * Look up the prefix associated to the given namespace URI, starting from this node.
     * **The default namespace declarations are ignored by this method.**
     * See Namespace Prefix Lookup for details on the algorithm used by this method.
     *
     * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
     *
     * @param {string | null} namespaceURI
     * @returns {string | null}
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
     * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
     * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
     * @see https://github.com/xmldom/xmldom/issues/322
     */
    lookupPrefix: function(namespaceURI) {
      var el = this;
      while (el) {
        var map = el._nsMap;
        if (map) {
          for (var n in map) {
            if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
              return n;
            }
          }
        }
        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI: function(prefix) {
      var el = this;
      while (el) {
        var map = el._nsMap;
        if (map) {
          if (Object.prototype.hasOwnProperty.call(map, prefix)) {
            return map[prefix];
          }
        }
        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace: function(namespaceURI) {
      var prefix = this.lookupPrefix(namespaceURI);
      return prefix == null;
    }
  };
  function _xmlEncoder(c) {
    return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
  }
  copy(NodeType, Node);
  copy(NodeType, Node.prototype);
  function _visitNode(node, callback) {
    if (callback(node)) {
      return true;
    }
    if (node = node.firstChild) {
      do {
        if (_visitNode(node, callback)) {
          return true;
        }
      } while (node = node.nextSibling);
    }
  }
  function Document() {
    this.ownerDocument = this;
  }
  function _onAddAttribute(doc, el, newAttr) {
    doc && doc._inc++;
    var ns = newAttr.namespaceURI;
    if (ns === NAMESPACE$2.XMLNS) {
      el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
    }
  }
  function _onRemoveAttribute(doc, el, newAttr, remove) {
    doc && doc._inc++;
    var ns = newAttr.namespaceURI;
    if (ns === NAMESPACE$2.XMLNS) {
      delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
    }
  }
  function _onUpdateChild(doc, el, newChild) {
    if (doc && doc._inc) {
      doc._inc++;
      var cs = el.childNodes;
      if (newChild) {
        cs[cs.length++] = newChild;
      } else {
        var child = el.firstChild;
        var i = 0;
        while (child) {
          cs[i++] = child;
          child = child.nextSibling;
        }
        cs.length = i;
        delete cs[cs.length];
      }
    }
  }
  function _removeChild(parentNode, child) {
    var previous = child.previousSibling;
    var next = child.nextSibling;
    if (previous) {
      previous.nextSibling = next;
    } else {
      parentNode.firstChild = next;
    }
    if (next) {
      next.previousSibling = previous;
    } else {
      parentNode.lastChild = previous;
    }
    child.parentNode = null;
    child.previousSibling = null;
    child.nextSibling = null;
    _onUpdateChild(parentNode.ownerDocument, parentNode);
    return child;
  }
  function hasValidParentNodeType(node) {
    return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
  }
  function hasInsertableNodeType(node) {
    return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
  }
  function isDocTypeNode(node) {
    return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
  }
  function isElementNode(node) {
    return node && node.nodeType === Node.ELEMENT_NODE;
  }
  function isTextNode(node) {
    return node && node.nodeType === Node.TEXT_NODE;
  }
  function isElementInsertionPossible(doc, child) {
    var parentChildNodes = doc.childNodes || [];
    if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
      return false;
    }
    var docTypeNode = find(parentChildNodes, isDocTypeNode);
    return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
  }
  function isElementReplacementPossible(doc, child) {
    var parentChildNodes = doc.childNodes || [];
    function hasElementChildThatIsNotChild(node) {
      return isElementNode(node) && node !== child;
    }
    if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
      return false;
    }
    var docTypeNode = find(parentChildNodes, isDocTypeNode);
    return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
  }
  function assertPreInsertionValidity1to5(parent, node, child) {
    if (!hasValidParentNodeType(parent)) {
      throw new DOMException2(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
    }
    if (child && child.parentNode !== parent) {
      throw new DOMException2(NOT_FOUND_ERR, "child not in parent");
    }
    if (
      // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
      !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
      // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
      // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
      // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
      isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
    ) {
      throw new DOMException2(HIERARCHY_REQUEST_ERR, "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType);
    }
  }
  function assertPreInsertionValidityInDocument(parent, node, child) {
    var parentChildNodes = parent.childNodes || [];
    var nodeChildNodes = node.childNodes || [];
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      var nodeChildElements = nodeChildNodes.filter(isElementNode);
      if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      }
      if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
      }
    }
    if (isElementNode(node)) {
      if (!isElementInsertionPossible(parent, child)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
      }
    }
    if (isDocTypeNode(node)) {
      if (find(parentChildNodes, isDocTypeNode)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      }
      var parentElementChild = find(parentChildNodes, isElementNode);
      if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
      }
      if (!child && parentElementChild) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
      }
    }
  }
  function assertPreReplacementValidityInDocument(parent, node, child) {
    var parentChildNodes = parent.childNodes || [];
    var nodeChildNodes = node.childNodes || [];
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      var nodeChildElements = nodeChildNodes.filter(isElementNode);
      if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      }
      if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
      }
    }
    if (isElementNode(node)) {
      if (!isElementReplacementPossible(parent, child)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
      }
    }
    if (isDocTypeNode(node)) {
      let hasDoctypeChildThatIsNotChild = function(node2) {
        return isDocTypeNode(node2) && node2 !== child;
      };
      if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      }
      var parentElementChild = find(parentChildNodes, isElementNode);
      if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
      }
    }
  }
  function _insertBefore(parent, node, child, _inDocumentAssertion) {
    assertPreInsertionValidity1to5(parent, node, child);
    if (parent.nodeType === Node.DOCUMENT_NODE) {
      (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
    }
    var cp = node.parentNode;
    if (cp) {
      cp.removeChild(node);
    }
    if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
      var newFirst = node.firstChild;
      if (newFirst == null) {
        return node;
      }
      var newLast = node.lastChild;
    } else {
      newFirst = newLast = node;
    }
    var pre = child ? child.previousSibling : parent.lastChild;
    newFirst.previousSibling = pre;
    newLast.nextSibling = child;
    if (pre) {
      pre.nextSibling = newFirst;
    } else {
      parent.firstChild = newFirst;
    }
    if (child == null) {
      parent.lastChild = newLast;
    } else {
      child.previousSibling = newLast;
    }
    do {
      newFirst.parentNode = parent;
    } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
    _onUpdateChild(parent.ownerDocument || parent, parent);
    if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
      node.firstChild = node.lastChild = null;
    }
    return node;
  }
  function _appendSingleChild(parentNode, newChild) {
    if (newChild.parentNode) {
      newChild.parentNode.removeChild(newChild);
    }
    newChild.parentNode = parentNode;
    newChild.previousSibling = parentNode.lastChild;
    newChild.nextSibling = null;
    if (newChild.previousSibling) {
      newChild.previousSibling.nextSibling = newChild;
    } else {
      parentNode.firstChild = newChild;
    }
    parentNode.lastChild = newChild;
    _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
    return newChild;
  }
  Document.prototype = {
    //implementation : null,
    nodeName: "#document",
    nodeType: DOCUMENT_NODE,
    /**
     * The DocumentType node of the document.
     *
     * @readonly
     * @type DocumentType
     */
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function(newChild, refChild) {
      if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
        var child = newChild.firstChild;
        while (child) {
          var next = child.nextSibling;
          this.insertBefore(child, refChild);
          child = next;
        }
        return newChild;
      }
      _insertBefore(this, newChild, refChild);
      newChild.ownerDocument = this;
      if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
        this.documentElement = newChild;
      }
      return newChild;
    },
    removeChild: function(oldChild) {
      if (this.documentElement == oldChild) {
        this.documentElement = null;
      }
      return _removeChild(this, oldChild);
    },
    replaceChild: function(newChild, oldChild) {
      _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
      newChild.ownerDocument = this;
      if (oldChild) {
        this.removeChild(oldChild);
      }
      if (isElementNode(newChild)) {
        this.documentElement = newChild;
      }
    },
    // Introduced in DOM Level 2:
    importNode: function(importedNode, deep) {
      return importNode(this, importedNode, deep);
    },
    // Introduced in DOM Level 2:
    getElementById: function(id) {
      var rtv = null;
      _visitNode(this.documentElement, function(node) {
        if (node.nodeType == ELEMENT_NODE) {
          if (node.getAttribute("id") == id) {
            rtv = node;
            return true;
          }
        }
      });
      return rtv;
    },
    /**
     * The `getElementsByClassName` method of `Document` interface returns an array-like object
     * of all child elements which have **all** of the given class name(s).
     *
     * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
     *
     *
     * Warning: This is a live LiveNodeList.
     * Changes in the DOM will reflect in the array as the changes occur.
     * If an element selected by this array no longer qualifies for the selector,
     * it will automatically be removed. Be aware of this for iteration purposes.
     *
     * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
     * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
     */
    getElementsByClassName: function(classNames) {
      var classNamesSet = toOrderedSet(classNames);
      return new LiveNodeList(this, function(base) {
        var ls = [];
        if (classNamesSet.length > 0) {
          _visitNode(base.documentElement, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE) {
              var nodeClassNames = node.getAttribute("class");
              if (nodeClassNames) {
                var matches = classNames === nodeClassNames;
                if (!matches) {
                  var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                  matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                }
                if (matches) {
                  ls.push(node);
                }
              }
            }
          });
        }
        return ls;
      });
    },
    //document factory method:
    createElement: function(tagName) {
      var node = new Element();
      node.ownerDocument = this;
      node.nodeName = tagName;
      node.tagName = tagName;
      node.localName = tagName;
      node.childNodes = new NodeList();
      var attrs = node.attributes = new NamedNodeMap();
      attrs._ownerElement = node;
      return node;
    },
    createDocumentFragment: function() {
      var node = new DocumentFragment();
      node.ownerDocument = this;
      node.childNodes = new NodeList();
      return node;
    },
    createTextNode: function(data) {
      var node = new Text();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createComment: function(data) {
      var node = new Comment();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createCDATASection: function(data) {
      var node = new CDATASection();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createProcessingInstruction: function(target, data) {
      var node = new ProcessingInstruction();
      node.ownerDocument = this;
      node.tagName = node.nodeName = node.target = target;
      node.nodeValue = node.data = data;
      return node;
    },
    createAttribute: function(name) {
      var node = new Attr();
      node.ownerDocument = this;
      node.name = name;
      node.nodeName = name;
      node.localName = name;
      node.specified = true;
      return node;
    },
    createEntityReference: function(name) {
      var node = new EntityReference();
      node.ownerDocument = this;
      node.nodeName = name;
      return node;
    },
    // Introduced in DOM Level 2:
    createElementNS: function(namespaceURI, qualifiedName) {
      var node = new Element();
      var pl = qualifiedName.split(":");
      var attrs = node.attributes = new NamedNodeMap();
      node.childNodes = new NodeList();
      node.ownerDocument = this;
      node.nodeName = qualifiedName;
      node.tagName = qualifiedName;
      node.namespaceURI = namespaceURI;
      if (pl.length == 2) {
        node.prefix = pl[0];
        node.localName = pl[1];
      } else {
        node.localName = qualifiedName;
      }
      attrs._ownerElement = node;
      return node;
    },
    // Introduced in DOM Level 2:
    createAttributeNS: function(namespaceURI, qualifiedName) {
      var node = new Attr();
      var pl = qualifiedName.split(":");
      node.ownerDocument = this;
      node.nodeName = qualifiedName;
      node.name = qualifiedName;
      node.namespaceURI = namespaceURI;
      node.specified = true;
      if (pl.length == 2) {
        node.prefix = pl[0];
        node.localName = pl[1];
      } else {
        node.localName = qualifiedName;
      }
      return node;
    }
  };
  _extends(Document, Node);
  function Element() {
    this._nsMap = {};
  }
  Element.prototype = {
    nodeType: ELEMENT_NODE,
    hasAttribute: function(name) {
      return this.getAttributeNode(name) != null;
    },
    getAttribute: function(name) {
      var attr = this.getAttributeNode(name);
      return attr && attr.value || "";
    },
    getAttributeNode: function(name) {
      return this.attributes.getNamedItem(name);
    },
    setAttribute: function(name, value) {
      var attr = this.ownerDocument.createAttribute(name);
      attr.value = attr.nodeValue = "" + value;
      this.setAttributeNode(attr);
    },
    removeAttribute: function(name) {
      var attr = this.getAttributeNode(name);
      attr && this.removeAttributeNode(attr);
    },
    //four real opeartion method
    appendChild: function(newChild) {
      if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
        return this.insertBefore(newChild, null);
      } else {
        return _appendSingleChild(this, newChild);
      }
    },
    setAttributeNode: function(newAttr) {
      return this.attributes.setNamedItem(newAttr);
    },
    setAttributeNodeNS: function(newAttr) {
      return this.attributes.setNamedItemNS(newAttr);
    },
    removeAttributeNode: function(oldAttr) {
      return this.attributes.removeNamedItem(oldAttr.nodeName);
    },
    //get real attribute name,and remove it by removeAttributeNode
    removeAttributeNS: function(namespaceURI, localName) {
      var old = this.getAttributeNodeNS(namespaceURI, localName);
      old && this.removeAttributeNode(old);
    },
    hasAttributeNS: function(namespaceURI, localName) {
      return this.getAttributeNodeNS(namespaceURI, localName) != null;
    },
    getAttributeNS: function(namespaceURI, localName) {
      var attr = this.getAttributeNodeNS(namespaceURI, localName);
      return attr && attr.value || "";
    },
    setAttributeNS: function(namespaceURI, qualifiedName, value) {
      var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
      attr.value = attr.nodeValue = "" + value;
      this.setAttributeNode(attr);
    },
    getAttributeNodeNS: function(namespaceURI, localName) {
      return this.attributes.getNamedItemNS(namespaceURI, localName);
    },
    getElementsByTagName: function(tagName) {
      return new LiveNodeList(this, function(base) {
        var ls = [];
        _visitNode(base, function(node) {
          if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
            ls.push(node);
          }
        });
        return ls;
      });
    },
    getElementsByTagNameNS: function(namespaceURI, localName) {
      return new LiveNodeList(this, function(base) {
        var ls = [];
        _visitNode(base, function(node) {
          if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
            ls.push(node);
          }
        });
        return ls;
      });
    }
  };
  Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
  Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
  _extends(Element, Node);
  function Attr() {
  }
  Attr.prototype.nodeType = ATTRIBUTE_NODE;
  _extends(Attr, Node);
  function CharacterData() {
  }
  CharacterData.prototype = {
    data: "",
    substringData: function(offset, count) {
      return this.data.substring(offset, offset + count);
    },
    appendData: function(text) {
      text = this.data + text;
      this.nodeValue = this.data = text;
      this.length = text.length;
    },
    insertData: function(offset, text) {
      this.replaceData(offset, 0, text);
    },
    appendChild: function(newChild) {
      throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
    },
    deleteData: function(offset, count) {
      this.replaceData(offset, count, "");
    },
    replaceData: function(offset, count, text) {
      var start = this.data.substring(0, offset);
      var end = this.data.substring(offset + count);
      text = start + text + end;
      this.nodeValue = this.data = text;
      this.length = text.length;
    }
  };
  _extends(CharacterData, Node);
  function Text() {
  }
  Text.prototype = {
    nodeName: "#text",
    nodeType: TEXT_NODE,
    splitText: function(offset) {
      var text = this.data;
      var newText = text.substring(offset);
      text = text.substring(0, offset);
      this.data = this.nodeValue = text;
      this.length = text.length;
      var newNode = this.ownerDocument.createTextNode(newText);
      if (this.parentNode) {
        this.parentNode.insertBefore(newNode, this.nextSibling);
      }
      return newNode;
    }
  };
  _extends(Text, CharacterData);
  function Comment() {
  }
  Comment.prototype = {
    nodeName: "#comment",
    nodeType: COMMENT_NODE
  };
  _extends(Comment, CharacterData);
  function CDATASection() {
  }
  CDATASection.prototype = {
    nodeName: "#cdata-section",
    nodeType: CDATA_SECTION_NODE
  };
  _extends(CDATASection, CharacterData);
  function DocumentType() {
  }
  DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
  _extends(DocumentType, Node);
  function Notation() {
  }
  Notation.prototype.nodeType = NOTATION_NODE;
  _extends(Notation, Node);
  function Entity() {
  }
  Entity.prototype.nodeType = ENTITY_NODE;
  _extends(Entity, Node);
  function EntityReference() {
  }
  EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
  _extends(EntityReference, Node);
  function DocumentFragment() {
  }
  DocumentFragment.prototype.nodeName = "#document-fragment";
  DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
  _extends(DocumentFragment, Node);
  function ProcessingInstruction() {
  }
  ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
  _extends(ProcessingInstruction, Node);
  function XMLSerializer() {
  }
  XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
    return nodeSerializeToString.call(node, isHtml, nodeFilter);
  };
  Node.prototype.toString = nodeSerializeToString;
  function nodeSerializeToString(isHtml, nodeFilter) {
    var buf = [];
    var refNode = this.nodeType == 9 && this.documentElement || this;
    var prefix = refNode.prefix;
    var uri = refNode.namespaceURI;
    if (uri && prefix == null) {
      var prefix = refNode.lookupPrefix(uri);
      if (prefix == null) {
        var visibleNamespaces = [
          {
            namespace: uri,
            prefix: null
          }
          //{namespace:uri,prefix:''}
        ];
      }
    }
    serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
    return buf.join("");
  }
  function needNamespaceDefine(node, isHTML, visibleNamespaces) {
    var prefix = node.prefix || "";
    var uri = node.namespaceURI;
    if (!uri) {
      return false;
    }
    if (prefix === "xml" && uri === NAMESPACE$2.XML || uri === NAMESPACE$2.XMLNS) {
      return false;
    }
    var i = visibleNamespaces.length;
    while (i--) {
      var ns = visibleNamespaces[i];
      if (ns.prefix === prefix) {
        return ns.namespace !== uri;
      }
    }
    return true;
  }
  function addSerializedAttribute(buf, qualifiedName, value) {
    buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
  }
  function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
    if (!visibleNamespaces) {
      visibleNamespaces = [];
    }
    if (nodeFilter) {
      node = nodeFilter(node);
      if (node) {
        if (typeof node == "string") {
          buf.push(node);
          return;
        }
      } else {
        return;
      }
    }
    switch (node.nodeType) {
      case ELEMENT_NODE:
        var attrs = node.attributes;
        var len = attrs.length;
        var child = node.firstChild;
        var nodeName = node.tagName;
        isHTML = NAMESPACE$2.isHTML(node.namespaceURI) || isHTML;
        var prefixedNodeName = nodeName;
        if (!isHTML && !node.prefix && node.namespaceURI) {
          var defaultNS;
          for (var ai = 0; ai < attrs.length; ai++) {
            if (attrs.item(ai).name === "xmlns") {
              defaultNS = attrs.item(ai).value;
              break;
            }
          }
          if (!defaultNS) {
            for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
              var namespace = visibleNamespaces[nsi];
              if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                defaultNS = namespace.namespace;
                break;
              }
            }
          }
          if (defaultNS !== node.namespaceURI) {
            for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
              var namespace = visibleNamespaces[nsi];
              if (namespace.namespace === node.namespaceURI) {
                if (namespace.prefix) {
                  prefixedNodeName = namespace.prefix + ":" + nodeName;
                }
                break;
              }
            }
          }
        }
        buf.push("<", prefixedNodeName);
        for (var i = 0; i < len; i++) {
          var attr = attrs.item(i);
          if (attr.prefix == "xmlns") {
            visibleNamespaces.push({
              prefix: attr.localName,
              namespace: attr.value
            });
          } else if (attr.nodeName == "xmlns") {
            visibleNamespaces.push({
              prefix: "",
              namespace: attr.value
            });
          }
        }
        for (var i = 0; i < len; i++) {
          var attr = attrs.item(i);
          if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
            var prefix = attr.prefix || "";
            var uri = attr.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({
              prefix,
              namespace: uri
            });
          }
          serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
        }
        if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
          var prefix = node.prefix || "";
          var uri = node.namespaceURI;
          addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
          visibleNamespaces.push({
            prefix,
            namespace: uri
          });
        }
        if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
          buf.push(">");
          if (isHTML && /^script$/i.test(nodeName)) {
            while (child) {
              if (child.data) {
                buf.push(child.data);
              } else {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
              }
              child = child.nextSibling;
            }
          } else {
            while (child) {
              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
              child = child.nextSibling;
            }
          }
          buf.push("</", prefixedNodeName, ">");
        } else {
          buf.push("/>");
        }
        return;
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        var child = node.firstChild;
        while (child) {
          serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
          child = child.nextSibling;
        }
        return;
      case ATTRIBUTE_NODE:
        return addSerializedAttribute(buf, node.name, node.value);
      case TEXT_NODE:
        return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));
      case CDATA_SECTION_NODE:
        return buf.push("<![CDATA[", node.data, "]]>");
      case COMMENT_NODE:
        return buf.push("<!--", node.data, "-->");
      case DOCUMENT_TYPE_NODE:
        var pubid = node.publicId;
        var sysid = node.systemId;
        buf.push("<!DOCTYPE ", node.name);
        if (pubid) {
          buf.push(" PUBLIC ", pubid);
          if (sysid && sysid != ".") {
            buf.push(" ", sysid);
          }
          buf.push(">");
        } else if (sysid && sysid != ".") {
          buf.push(" SYSTEM ", sysid, ">");
        } else {
          var sub = node.internalSubset;
          if (sub) {
            buf.push(" [", sub, "]");
          }
          buf.push(">");
        }
        return;
      case PROCESSING_INSTRUCTION_NODE:
        return buf.push("<?", node.target, " ", node.data, "?>");
      case ENTITY_REFERENCE_NODE:
        return buf.push("&", node.nodeName, ";");
      default:
        buf.push("??", node.nodeName);
    }
  }
  function importNode(doc, node, deep) {
    var node2;
    switch (node.nodeType) {
      case ELEMENT_NODE:
        node2 = node.cloneNode(false);
        node2.ownerDocument = doc;
      case DOCUMENT_FRAGMENT_NODE:
        break;
      case ATTRIBUTE_NODE:
        deep = true;
        break;
    }
    if (!node2) {
      node2 = node.cloneNode(false);
    }
    node2.ownerDocument = doc;
    node2.parentNode = null;
    if (deep) {
      var child = node.firstChild;
      while (child) {
        node2.appendChild(importNode(doc, child, deep));
        child = child.nextSibling;
      }
    }
    return node2;
  }
  function cloneNode(doc, node, deep) {
    var node2 = new node.constructor();
    for (var n in node) {
      if (Object.prototype.hasOwnProperty.call(node, n)) {
        var v = node[n];
        if (typeof v != "object") {
          if (v != node2[n]) {
            node2[n] = v;
          }
        }
      }
    }
    if (node.childNodes) {
      node2.childNodes = new NodeList();
    }
    node2.ownerDocument = doc;
    switch (node2.nodeType) {
      case ELEMENT_NODE:
        var attrs = node.attributes;
        var attrs2 = node2.attributes = new NamedNodeMap();
        var len = attrs.length;
        attrs2._ownerElement = node2;
        for (var i = 0; i < len; i++) {
          node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
        }
        break;
      case ATTRIBUTE_NODE:
        deep = true;
    }
    if (deep) {
      var child = node.firstChild;
      while (child) {
        node2.appendChild(cloneNode(doc, child, deep));
        child = child.nextSibling;
      }
    }
    return node2;
  }
  function __set__(object, key, value) {
    object[key] = value;
  }
  try {
    if (Object.defineProperty) {
      let getTextContent = function(node) {
        switch (node.nodeType) {
          case ELEMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            var buf = [];
            node = node.firstChild;
            while (node) {
              if (node.nodeType !== 7 && node.nodeType !== 8) {
                buf.push(getTextContent(node));
              }
              node = node.nextSibling;
            }
            return buf.join("");
          default:
            return node.nodeValue;
        }
      };
      Object.defineProperty(LiveNodeList.prototype, "length", {
        get: function() {
          _updateLiveList(this);
          return this.$$length;
        }
      });
      Object.defineProperty(Node.prototype, "textContent", {
        get: function() {
          return getTextContent(this);
        },
        set: function(data) {
          switch (this.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              while (this.firstChild) {
                this.removeChild(this.firstChild);
              }
              if (data || String(data)) {
                this.appendChild(this.ownerDocument.createTextNode(data));
              }
              break;
            default:
              this.data = data;
              this.value = data;
              this.nodeValue = data;
          }
        }
      });
      __set__ = function(object, key, value) {
        object["$$" + key] = value;
      };
    }
  } catch (e) {
  }
  var DocumentType_1 = DocumentType;
  var DOMException_1 = DOMException2;
  var DOMImplementation_1 = DOMImplementation$1;
  var Element_1 = Element;
  var Node_1 = Node;
  var NodeList_1 = NodeList;
  var XMLSerializer_1 = XMLSerializer;
  var dom = {
    DocumentType: DocumentType_1,
    DOMException: DOMException_1,
    DOMImplementation: DOMImplementation_1,
    Element: Element_1,
    Node: Node_1,
    NodeList: NodeList_1,
    XMLSerializer: XMLSerializer_1
  };
  var entities = createCommonjsModule(function(module2, exports2) {
    var freeze2 = conventions.freeze;
    exports2.XML_ENTITIES = freeze2({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports2.HTML_ENTITIES = freeze2({
      Aacute: "\xC1",
      aacute: "\xE1",
      Abreve: "\u0102",
      abreve: "\u0103",
      ac: "\u223E",
      acd: "\u223F",
      acE: "\u223E\u0333",
      Acirc: "\xC2",
      acirc: "\xE2",
      acute: "\xB4",
      Acy: "\u0410",
      acy: "\u0430",
      AElig: "\xC6",
      aelig: "\xE6",
      af: "\u2061",
      Afr: "\u{1D504}",
      afr: "\u{1D51E}",
      Agrave: "\xC0",
      agrave: "\xE0",
      alefsym: "\u2135",
      aleph: "\u2135",
      Alpha: "\u0391",
      alpha: "\u03B1",
      Amacr: "\u0100",
      amacr: "\u0101",
      amalg: "\u2A3F",
      AMP: "&",
      amp: "&",
      And: "\u2A53",
      and: "\u2227",
      andand: "\u2A55",
      andd: "\u2A5C",
      andslope: "\u2A58",
      andv: "\u2A5A",
      ang: "\u2220",
      ange: "\u29A4",
      angle: "\u2220",
      angmsd: "\u2221",
      angmsdaa: "\u29A8",
      angmsdab: "\u29A9",
      angmsdac: "\u29AA",
      angmsdad: "\u29AB",
      angmsdae: "\u29AC",
      angmsdaf: "\u29AD",
      angmsdag: "\u29AE",
      angmsdah: "\u29AF",
      angrt: "\u221F",
      angrtvb: "\u22BE",
      angrtvbd: "\u299D",
      angsph: "\u2222",
      angst: "\xC5",
      angzarr: "\u237C",
      Aogon: "\u0104",
      aogon: "\u0105",
      Aopf: "\u{1D538}",
      aopf: "\u{1D552}",
      ap: "\u2248",
      apacir: "\u2A6F",
      apE: "\u2A70",
      ape: "\u224A",
      apid: "\u224B",
      apos: "'",
      ApplyFunction: "\u2061",
      approx: "\u2248",
      approxeq: "\u224A",
      Aring: "\xC5",
      aring: "\xE5",
      Ascr: "\u{1D49C}",
      ascr: "\u{1D4B6}",
      Assign: "\u2254",
      ast: "*",
      asymp: "\u2248",
      asympeq: "\u224D",
      Atilde: "\xC3",
      atilde: "\xE3",
      Auml: "\xC4",
      auml: "\xE4",
      awconint: "\u2233",
      awint: "\u2A11",
      backcong: "\u224C",
      backepsilon: "\u03F6",
      backprime: "\u2035",
      backsim: "\u223D",
      backsimeq: "\u22CD",
      Backslash: "\u2216",
      Barv: "\u2AE7",
      barvee: "\u22BD",
      Barwed: "\u2306",
      barwed: "\u2305",
      barwedge: "\u2305",
      bbrk: "\u23B5",
      bbrktbrk: "\u23B6",
      bcong: "\u224C",
      Bcy: "\u0411",
      bcy: "\u0431",
      bdquo: "\u201E",
      becaus: "\u2235",
      Because: "\u2235",
      because: "\u2235",
      bemptyv: "\u29B0",
      bepsi: "\u03F6",
      bernou: "\u212C",
      Bernoullis: "\u212C",
      Beta: "\u0392",
      beta: "\u03B2",
      beth: "\u2136",
      between: "\u226C",
      Bfr: "\u{1D505}",
      bfr: "\u{1D51F}",
      bigcap: "\u22C2",
      bigcirc: "\u25EF",
      bigcup: "\u22C3",
      bigodot: "\u2A00",
      bigoplus: "\u2A01",
      bigotimes: "\u2A02",
      bigsqcup: "\u2A06",
      bigstar: "\u2605",
      bigtriangledown: "\u25BD",
      bigtriangleup: "\u25B3",
      biguplus: "\u2A04",
      bigvee: "\u22C1",
      bigwedge: "\u22C0",
      bkarow: "\u290D",
      blacklozenge: "\u29EB",
      blacksquare: "\u25AA",
      blacktriangle: "\u25B4",
      blacktriangledown: "\u25BE",
      blacktriangleleft: "\u25C2",
      blacktriangleright: "\u25B8",
      blank: "\u2423",
      blk12: "\u2592",
      blk14: "\u2591",
      blk34: "\u2593",
      block: "\u2588",
      bne: "=\u20E5",
      bnequiv: "\u2261\u20E5",
      bNot: "\u2AED",
      bnot: "\u2310",
      Bopf: "\u{1D539}",
      bopf: "\u{1D553}",
      bot: "\u22A5",
      bottom: "\u22A5",
      bowtie: "\u22C8",
      boxbox: "\u29C9",
      boxDL: "\u2557",
      boxDl: "\u2556",
      boxdL: "\u2555",
      boxdl: "\u2510",
      boxDR: "\u2554",
      boxDr: "\u2553",
      boxdR: "\u2552",
      boxdr: "\u250C",
      boxH: "\u2550",
      boxh: "\u2500",
      boxHD: "\u2566",
      boxHd: "\u2564",
      boxhD: "\u2565",
      boxhd: "\u252C",
      boxHU: "\u2569",
      boxHu: "\u2567",
      boxhU: "\u2568",
      boxhu: "\u2534",
      boxminus: "\u229F",
      boxplus: "\u229E",
      boxtimes: "\u22A0",
      boxUL: "\u255D",
      boxUl: "\u255C",
      boxuL: "\u255B",
      boxul: "\u2518",
      boxUR: "\u255A",
      boxUr: "\u2559",
      boxuR: "\u2558",
      boxur: "\u2514",
      boxV: "\u2551",
      boxv: "\u2502",
      boxVH: "\u256C",
      boxVh: "\u256B",
      boxvH: "\u256A",
      boxvh: "\u253C",
      boxVL: "\u2563",
      boxVl: "\u2562",
      boxvL: "\u2561",
      boxvl: "\u2524",
      boxVR: "\u2560",
      boxVr: "\u255F",
      boxvR: "\u255E",
      boxvr: "\u251C",
      bprime: "\u2035",
      Breve: "\u02D8",
      breve: "\u02D8",
      brvbar: "\xA6",
      Bscr: "\u212C",
      bscr: "\u{1D4B7}",
      bsemi: "\u204F",
      bsim: "\u223D",
      bsime: "\u22CD",
      bsol: "\\",
      bsolb: "\u29C5",
      bsolhsub: "\u27C8",
      bull: "\u2022",
      bullet: "\u2022",
      bump: "\u224E",
      bumpE: "\u2AAE",
      bumpe: "\u224F",
      Bumpeq: "\u224E",
      bumpeq: "\u224F",
      Cacute: "\u0106",
      cacute: "\u0107",
      Cap: "\u22D2",
      cap: "\u2229",
      capand: "\u2A44",
      capbrcup: "\u2A49",
      capcap: "\u2A4B",
      capcup: "\u2A47",
      capdot: "\u2A40",
      CapitalDifferentialD: "\u2145",
      caps: "\u2229\uFE00",
      caret: "\u2041",
      caron: "\u02C7",
      Cayleys: "\u212D",
      ccaps: "\u2A4D",
      Ccaron: "\u010C",
      ccaron: "\u010D",
      Ccedil: "\xC7",
      ccedil: "\xE7",
      Ccirc: "\u0108",
      ccirc: "\u0109",
      Cconint: "\u2230",
      ccups: "\u2A4C",
      ccupssm: "\u2A50",
      Cdot: "\u010A",
      cdot: "\u010B",
      cedil: "\xB8",
      Cedilla: "\xB8",
      cemptyv: "\u29B2",
      cent: "\xA2",
      CenterDot: "\xB7",
      centerdot: "\xB7",
      Cfr: "\u212D",
      cfr: "\u{1D520}",
      CHcy: "\u0427",
      chcy: "\u0447",
      check: "\u2713",
      checkmark: "\u2713",
      Chi: "\u03A7",
      chi: "\u03C7",
      cir: "\u25CB",
      circ: "\u02C6",
      circeq: "\u2257",
      circlearrowleft: "\u21BA",
      circlearrowright: "\u21BB",
      circledast: "\u229B",
      circledcirc: "\u229A",
      circleddash: "\u229D",
      CircleDot: "\u2299",
      circledR: "\xAE",
      circledS: "\u24C8",
      CircleMinus: "\u2296",
      CirclePlus: "\u2295",
      CircleTimes: "\u2297",
      cirE: "\u29C3",
      cire: "\u2257",
      cirfnint: "\u2A10",
      cirmid: "\u2AEF",
      cirscir: "\u29C2",
      ClockwiseContourIntegral: "\u2232",
      CloseCurlyDoubleQuote: "\u201D",
      CloseCurlyQuote: "\u2019",
      clubs: "\u2663",
      clubsuit: "\u2663",
      Colon: "\u2237",
      colon: ":",
      Colone: "\u2A74",
      colone: "\u2254",
      coloneq: "\u2254",
      comma: ",",
      commat: "@",
      comp: "\u2201",
      compfn: "\u2218",
      complement: "\u2201",
      complexes: "\u2102",
      cong: "\u2245",
      congdot: "\u2A6D",
      Congruent: "\u2261",
      Conint: "\u222F",
      conint: "\u222E",
      ContourIntegral: "\u222E",
      Copf: "\u2102",
      copf: "\u{1D554}",
      coprod: "\u2210",
      Coproduct: "\u2210",
      COPY: "\xA9",
      copy: "\xA9",
      copysr: "\u2117",
      CounterClockwiseContourIntegral: "\u2233",
      crarr: "\u21B5",
      Cross: "\u2A2F",
      cross: "\u2717",
      Cscr: "\u{1D49E}",
      cscr: "\u{1D4B8}",
      csub: "\u2ACF",
      csube: "\u2AD1",
      csup: "\u2AD0",
      csupe: "\u2AD2",
      ctdot: "\u22EF",
      cudarrl: "\u2938",
      cudarrr: "\u2935",
      cuepr: "\u22DE",
      cuesc: "\u22DF",
      cularr: "\u21B6",
      cularrp: "\u293D",
      Cup: "\u22D3",
      cup: "\u222A",
      cupbrcap: "\u2A48",
      CupCap: "\u224D",
      cupcap: "\u2A46",
      cupcup: "\u2A4A",
      cupdot: "\u228D",
      cupor: "\u2A45",
      cups: "\u222A\uFE00",
      curarr: "\u21B7",
      curarrm: "\u293C",
      curlyeqprec: "\u22DE",
      curlyeqsucc: "\u22DF",
      curlyvee: "\u22CE",
      curlywedge: "\u22CF",
      curren: "\xA4",
      curvearrowleft: "\u21B6",
      curvearrowright: "\u21B7",
      cuvee: "\u22CE",
      cuwed: "\u22CF",
      cwconint: "\u2232",
      cwint: "\u2231",
      cylcty: "\u232D",
      Dagger: "\u2021",
      dagger: "\u2020",
      daleth: "\u2138",
      Darr: "\u21A1",
      dArr: "\u21D3",
      darr: "\u2193",
      dash: "\u2010",
      Dashv: "\u2AE4",
      dashv: "\u22A3",
      dbkarow: "\u290F",
      dblac: "\u02DD",
      Dcaron: "\u010E",
      dcaron: "\u010F",
      Dcy: "\u0414",
      dcy: "\u0434",
      DD: "\u2145",
      dd: "\u2146",
      ddagger: "\u2021",
      ddarr: "\u21CA",
      DDotrahd: "\u2911",
      ddotseq: "\u2A77",
      deg: "\xB0",
      Del: "\u2207",
      Delta: "\u0394",
      delta: "\u03B4",
      demptyv: "\u29B1",
      dfisht: "\u297F",
      Dfr: "\u{1D507}",
      dfr: "\u{1D521}",
      dHar: "\u2965",
      dharl: "\u21C3",
      dharr: "\u21C2",
      DiacriticalAcute: "\xB4",
      DiacriticalDot: "\u02D9",
      DiacriticalDoubleAcute: "\u02DD",
      DiacriticalGrave: "`",
      DiacriticalTilde: "\u02DC",
      diam: "\u22C4",
      Diamond: "\u22C4",
      diamond: "\u22C4",
      diamondsuit: "\u2666",
      diams: "\u2666",
      die: "\xA8",
      DifferentialD: "\u2146",
      digamma: "\u03DD",
      disin: "\u22F2",
      div: "\xF7",
      divide: "\xF7",
      divideontimes: "\u22C7",
      divonx: "\u22C7",
      DJcy: "\u0402",
      djcy: "\u0452",
      dlcorn: "\u231E",
      dlcrop: "\u230D",
      dollar: "$",
      Dopf: "\u{1D53B}",
      dopf: "\u{1D555}",
      Dot: "\xA8",
      dot: "\u02D9",
      DotDot: "\u20DC",
      doteq: "\u2250",
      doteqdot: "\u2251",
      DotEqual: "\u2250",
      dotminus: "\u2238",
      dotplus: "\u2214",
      dotsquare: "\u22A1",
      doublebarwedge: "\u2306",
      DoubleContourIntegral: "\u222F",
      DoubleDot: "\xA8",
      DoubleDownArrow: "\u21D3",
      DoubleLeftArrow: "\u21D0",
      DoubleLeftRightArrow: "\u21D4",
      DoubleLeftTee: "\u2AE4",
      DoubleLongLeftArrow: "\u27F8",
      DoubleLongLeftRightArrow: "\u27FA",
      DoubleLongRightArrow: "\u27F9",
      DoubleRightArrow: "\u21D2",
      DoubleRightTee: "\u22A8",
      DoubleUpArrow: "\u21D1",
      DoubleUpDownArrow: "\u21D5",
      DoubleVerticalBar: "\u2225",
      DownArrow: "\u2193",
      Downarrow: "\u21D3",
      downarrow: "\u2193",
      DownArrowBar: "\u2913",
      DownArrowUpArrow: "\u21F5",
      DownBreve: "\u0311",
      downdownarrows: "\u21CA",
      downharpoonleft: "\u21C3",
      downharpoonright: "\u21C2",
      DownLeftRightVector: "\u2950",
      DownLeftTeeVector: "\u295E",
      DownLeftVector: "\u21BD",
      DownLeftVectorBar: "\u2956",
      DownRightTeeVector: "\u295F",
      DownRightVector: "\u21C1",
      DownRightVectorBar: "\u2957",
      DownTee: "\u22A4",
      DownTeeArrow: "\u21A7",
      drbkarow: "\u2910",
      drcorn: "\u231F",
      drcrop: "\u230C",
      Dscr: "\u{1D49F}",
      dscr: "\u{1D4B9}",
      DScy: "\u0405",
      dscy: "\u0455",
      dsol: "\u29F6",
      Dstrok: "\u0110",
      dstrok: "\u0111",
      dtdot: "\u22F1",
      dtri: "\u25BF",
      dtrif: "\u25BE",
      duarr: "\u21F5",
      duhar: "\u296F",
      dwangle: "\u29A6",
      DZcy: "\u040F",
      dzcy: "\u045F",
      dzigrarr: "\u27FF",
      Eacute: "\xC9",
      eacute: "\xE9",
      easter: "\u2A6E",
      Ecaron: "\u011A",
      ecaron: "\u011B",
      ecir: "\u2256",
      Ecirc: "\xCA",
      ecirc: "\xEA",
      ecolon: "\u2255",
      Ecy: "\u042D",
      ecy: "\u044D",
      eDDot: "\u2A77",
      Edot: "\u0116",
      eDot: "\u2251",
      edot: "\u0117",
      ee: "\u2147",
      efDot: "\u2252",
      Efr: "\u{1D508}",
      efr: "\u{1D522}",
      eg: "\u2A9A",
      Egrave: "\xC8",
      egrave: "\xE8",
      egs: "\u2A96",
      egsdot: "\u2A98",
      el: "\u2A99",
      Element: "\u2208",
      elinters: "\u23E7",
      ell: "\u2113",
      els: "\u2A95",
      elsdot: "\u2A97",
      Emacr: "\u0112",
      emacr: "\u0113",
      empty: "\u2205",
      emptyset: "\u2205",
      EmptySmallSquare: "\u25FB",
      emptyv: "\u2205",
      EmptyVerySmallSquare: "\u25AB",
      emsp: "\u2003",
      emsp13: "\u2004",
      emsp14: "\u2005",
      ENG: "\u014A",
      eng: "\u014B",
      ensp: "\u2002",
      Eogon: "\u0118",
      eogon: "\u0119",
      Eopf: "\u{1D53C}",
      eopf: "\u{1D556}",
      epar: "\u22D5",
      eparsl: "\u29E3",
      eplus: "\u2A71",
      epsi: "\u03B5",
      Epsilon: "\u0395",
      epsilon: "\u03B5",
      epsiv: "\u03F5",
      eqcirc: "\u2256",
      eqcolon: "\u2255",
      eqsim: "\u2242",
      eqslantgtr: "\u2A96",
      eqslantless: "\u2A95",
      Equal: "\u2A75",
      equals: "=",
      EqualTilde: "\u2242",
      equest: "\u225F",
      Equilibrium: "\u21CC",
      equiv: "\u2261",
      equivDD: "\u2A78",
      eqvparsl: "\u29E5",
      erarr: "\u2971",
      erDot: "\u2253",
      Escr: "\u2130",
      escr: "\u212F",
      esdot: "\u2250",
      Esim: "\u2A73",
      esim: "\u2242",
      Eta: "\u0397",
      eta: "\u03B7",
      ETH: "\xD0",
      eth: "\xF0",
      Euml: "\xCB",
      euml: "\xEB",
      euro: "\u20AC",
      excl: "!",
      exist: "\u2203",
      Exists: "\u2203",
      expectation: "\u2130",
      ExponentialE: "\u2147",
      exponentiale: "\u2147",
      fallingdotseq: "\u2252",
      Fcy: "\u0424",
      fcy: "\u0444",
      female: "\u2640",
      ffilig: "\uFB03",
      fflig: "\uFB00",
      ffllig: "\uFB04",
      Ffr: "\u{1D509}",
      ffr: "\u{1D523}",
      filig: "\uFB01",
      FilledSmallSquare: "\u25FC",
      FilledVerySmallSquare: "\u25AA",
      fjlig: "fj",
      flat: "\u266D",
      fllig: "\uFB02",
      fltns: "\u25B1",
      fnof: "\u0192",
      Fopf: "\u{1D53D}",
      fopf: "\u{1D557}",
      ForAll: "\u2200",
      forall: "\u2200",
      fork: "\u22D4",
      forkv: "\u2AD9",
      Fouriertrf: "\u2131",
      fpartint: "\u2A0D",
      frac12: "\xBD",
      frac13: "\u2153",
      frac14: "\xBC",
      frac15: "\u2155",
      frac16: "\u2159",
      frac18: "\u215B",
      frac23: "\u2154",
      frac25: "\u2156",
      frac34: "\xBE",
      frac35: "\u2157",
      frac38: "\u215C",
      frac45: "\u2158",
      frac56: "\u215A",
      frac58: "\u215D",
      frac78: "\u215E",
      frasl: "\u2044",
      frown: "\u2322",
      Fscr: "\u2131",
      fscr: "\u{1D4BB}",
      gacute: "\u01F5",
      Gamma: "\u0393",
      gamma: "\u03B3",
      Gammad: "\u03DC",
      gammad: "\u03DD",
      gap: "\u2A86",
      Gbreve: "\u011E",
      gbreve: "\u011F",
      Gcedil: "\u0122",
      Gcirc: "\u011C",
      gcirc: "\u011D",
      Gcy: "\u0413",
      gcy: "\u0433",
      Gdot: "\u0120",
      gdot: "\u0121",
      gE: "\u2267",
      ge: "\u2265",
      gEl: "\u2A8C",
      gel: "\u22DB",
      geq: "\u2265",
      geqq: "\u2267",
      geqslant: "\u2A7E",
      ges: "\u2A7E",
      gescc: "\u2AA9",
      gesdot: "\u2A80",
      gesdoto: "\u2A82",
      gesdotol: "\u2A84",
      gesl: "\u22DB\uFE00",
      gesles: "\u2A94",
      Gfr: "\u{1D50A}",
      gfr: "\u{1D524}",
      Gg: "\u22D9",
      gg: "\u226B",
      ggg: "\u22D9",
      gimel: "\u2137",
      GJcy: "\u0403",
      gjcy: "\u0453",
      gl: "\u2277",
      gla: "\u2AA5",
      glE: "\u2A92",
      glj: "\u2AA4",
      gnap: "\u2A8A",
      gnapprox: "\u2A8A",
      gnE: "\u2269",
      gne: "\u2A88",
      gneq: "\u2A88",
      gneqq: "\u2269",
      gnsim: "\u22E7",
      Gopf: "\u{1D53E}",
      gopf: "\u{1D558}",
      grave: "`",
      GreaterEqual: "\u2265",
      GreaterEqualLess: "\u22DB",
      GreaterFullEqual: "\u2267",
      GreaterGreater: "\u2AA2",
      GreaterLess: "\u2277",
      GreaterSlantEqual: "\u2A7E",
      GreaterTilde: "\u2273",
      Gscr: "\u{1D4A2}",
      gscr: "\u210A",
      gsim: "\u2273",
      gsime: "\u2A8E",
      gsiml: "\u2A90",
      Gt: "\u226B",
      GT: ">",
      gt: ">",
      gtcc: "\u2AA7",
      gtcir: "\u2A7A",
      gtdot: "\u22D7",
      gtlPar: "\u2995",
      gtquest: "\u2A7C",
      gtrapprox: "\u2A86",
      gtrarr: "\u2978",
      gtrdot: "\u22D7",
      gtreqless: "\u22DB",
      gtreqqless: "\u2A8C",
      gtrless: "\u2277",
      gtrsim: "\u2273",
      gvertneqq: "\u2269\uFE00",
      gvnE: "\u2269\uFE00",
      Hacek: "\u02C7",
      hairsp: "\u200A",
      half: "\xBD",
      hamilt: "\u210B",
      HARDcy: "\u042A",
      hardcy: "\u044A",
      hArr: "\u21D4",
      harr: "\u2194",
      harrcir: "\u2948",
      harrw: "\u21AD",
      Hat: "^",
      hbar: "\u210F",
      Hcirc: "\u0124",
      hcirc: "\u0125",
      hearts: "\u2665",
      heartsuit: "\u2665",
      hellip: "\u2026",
      hercon: "\u22B9",
      Hfr: "\u210C",
      hfr: "\u{1D525}",
      HilbertSpace: "\u210B",
      hksearow: "\u2925",
      hkswarow: "\u2926",
      hoarr: "\u21FF",
      homtht: "\u223B",
      hookleftarrow: "\u21A9",
      hookrightarrow: "\u21AA",
      Hopf: "\u210D",
      hopf: "\u{1D559}",
      horbar: "\u2015",
      HorizontalLine: "\u2500",
      Hscr: "\u210B",
      hscr: "\u{1D4BD}",
      hslash: "\u210F",
      Hstrok: "\u0126",
      hstrok: "\u0127",
      HumpDownHump: "\u224E",
      HumpEqual: "\u224F",
      hybull: "\u2043",
      hyphen: "\u2010",
      Iacute: "\xCD",
      iacute: "\xED",
      ic: "\u2063",
      Icirc: "\xCE",
      icirc: "\xEE",
      Icy: "\u0418",
      icy: "\u0438",
      Idot: "\u0130",
      IEcy: "\u0415",
      iecy: "\u0435",
      iexcl: "\xA1",
      iff: "\u21D4",
      Ifr: "\u2111",
      ifr: "\u{1D526}",
      Igrave: "\xCC",
      igrave: "\xEC",
      ii: "\u2148",
      iiiint: "\u2A0C",
      iiint: "\u222D",
      iinfin: "\u29DC",
      iiota: "\u2129",
      IJlig: "\u0132",
      ijlig: "\u0133",
      Im: "\u2111",
      Imacr: "\u012A",
      imacr: "\u012B",
      image: "\u2111",
      ImaginaryI: "\u2148",
      imagline: "\u2110",
      imagpart: "\u2111",
      imath: "\u0131",
      imof: "\u22B7",
      imped: "\u01B5",
      Implies: "\u21D2",
      in: "\u2208",
      incare: "\u2105",
      infin: "\u221E",
      infintie: "\u29DD",
      inodot: "\u0131",
      Int: "\u222C",
      int: "\u222B",
      intcal: "\u22BA",
      integers: "\u2124",
      Integral: "\u222B",
      intercal: "\u22BA",
      Intersection: "\u22C2",
      intlarhk: "\u2A17",
      intprod: "\u2A3C",
      InvisibleComma: "\u2063",
      InvisibleTimes: "\u2062",
      IOcy: "\u0401",
      iocy: "\u0451",
      Iogon: "\u012E",
      iogon: "\u012F",
      Iopf: "\u{1D540}",
      iopf: "\u{1D55A}",
      Iota: "\u0399",
      iota: "\u03B9",
      iprod: "\u2A3C",
      iquest: "\xBF",
      Iscr: "\u2110",
      iscr: "\u{1D4BE}",
      isin: "\u2208",
      isindot: "\u22F5",
      isinE: "\u22F9",
      isins: "\u22F4",
      isinsv: "\u22F3",
      isinv: "\u2208",
      it: "\u2062",
      Itilde: "\u0128",
      itilde: "\u0129",
      Iukcy: "\u0406",
      iukcy: "\u0456",
      Iuml: "\xCF",
      iuml: "\xEF",
      Jcirc: "\u0134",
      jcirc: "\u0135",
      Jcy: "\u0419",
      jcy: "\u0439",
      Jfr: "\u{1D50D}",
      jfr: "\u{1D527}",
      jmath: "\u0237",
      Jopf: "\u{1D541}",
      jopf: "\u{1D55B}",
      Jscr: "\u{1D4A5}",
      jscr: "\u{1D4BF}",
      Jsercy: "\u0408",
      jsercy: "\u0458",
      Jukcy: "\u0404",
      jukcy: "\u0454",
      Kappa: "\u039A",
      kappa: "\u03BA",
      kappav: "\u03F0",
      Kcedil: "\u0136",
      kcedil: "\u0137",
      Kcy: "\u041A",
      kcy: "\u043A",
      Kfr: "\u{1D50E}",
      kfr: "\u{1D528}",
      kgreen: "\u0138",
      KHcy: "\u0425",
      khcy: "\u0445",
      KJcy: "\u040C",
      kjcy: "\u045C",
      Kopf: "\u{1D542}",
      kopf: "\u{1D55C}",
      Kscr: "\u{1D4A6}",
      kscr: "\u{1D4C0}",
      lAarr: "\u21DA",
      Lacute: "\u0139",
      lacute: "\u013A",
      laemptyv: "\u29B4",
      lagran: "\u2112",
      Lambda: "\u039B",
      lambda: "\u03BB",
      Lang: "\u27EA",
      lang: "\u27E8",
      langd: "\u2991",
      langle: "\u27E8",
      lap: "\u2A85",
      Laplacetrf: "\u2112",
      laquo: "\xAB",
      Larr: "\u219E",
      lArr: "\u21D0",
      larr: "\u2190",
      larrb: "\u21E4",
      larrbfs: "\u291F",
      larrfs: "\u291D",
      larrhk: "\u21A9",
      larrlp: "\u21AB",
      larrpl: "\u2939",
      larrsim: "\u2973",
      larrtl: "\u21A2",
      lat: "\u2AAB",
      lAtail: "\u291B",
      latail: "\u2919",
      late: "\u2AAD",
      lates: "\u2AAD\uFE00",
      lBarr: "\u290E",
      lbarr: "\u290C",
      lbbrk: "\u2772",
      lbrace: "{",
      lbrack: "[",
      lbrke: "\u298B",
      lbrksld: "\u298F",
      lbrkslu: "\u298D",
      Lcaron: "\u013D",
      lcaron: "\u013E",
      Lcedil: "\u013B",
      lcedil: "\u013C",
      lceil: "\u2308",
      lcub: "{",
      Lcy: "\u041B",
      lcy: "\u043B",
      ldca: "\u2936",
      ldquo: "\u201C",
      ldquor: "\u201E",
      ldrdhar: "\u2967",
      ldrushar: "\u294B",
      ldsh: "\u21B2",
      lE: "\u2266",
      le: "\u2264",
      LeftAngleBracket: "\u27E8",
      LeftArrow: "\u2190",
      Leftarrow: "\u21D0",
      leftarrow: "\u2190",
      LeftArrowBar: "\u21E4",
      LeftArrowRightArrow: "\u21C6",
      leftarrowtail: "\u21A2",
      LeftCeiling: "\u2308",
      LeftDoubleBracket: "\u27E6",
      LeftDownTeeVector: "\u2961",
      LeftDownVector: "\u21C3",
      LeftDownVectorBar: "\u2959",
      LeftFloor: "\u230A",
      leftharpoondown: "\u21BD",
      leftharpoonup: "\u21BC",
      leftleftarrows: "\u21C7",
      LeftRightArrow: "\u2194",
      Leftrightarrow: "\u21D4",
      leftrightarrow: "\u2194",
      leftrightarrows: "\u21C6",
      leftrightharpoons: "\u21CB",
      leftrightsquigarrow: "\u21AD",
      LeftRightVector: "\u294E",
      LeftTee: "\u22A3",
      LeftTeeArrow: "\u21A4",
      LeftTeeVector: "\u295A",
      leftthreetimes: "\u22CB",
      LeftTriangle: "\u22B2",
      LeftTriangleBar: "\u29CF",
      LeftTriangleEqual: "\u22B4",
      LeftUpDownVector: "\u2951",
      LeftUpTeeVector: "\u2960",
      LeftUpVector: "\u21BF",
      LeftUpVectorBar: "\u2958",
      LeftVector: "\u21BC",
      LeftVectorBar: "\u2952",
      lEg: "\u2A8B",
      leg: "\u22DA",
      leq: "\u2264",
      leqq: "\u2266",
      leqslant: "\u2A7D",
      les: "\u2A7D",
      lescc: "\u2AA8",
      lesdot: "\u2A7F",
      lesdoto: "\u2A81",
      lesdotor: "\u2A83",
      lesg: "\u22DA\uFE00",
      lesges: "\u2A93",
      lessapprox: "\u2A85",
      lessdot: "\u22D6",
      lesseqgtr: "\u22DA",
      lesseqqgtr: "\u2A8B",
      LessEqualGreater: "\u22DA",
      LessFullEqual: "\u2266",
      LessGreater: "\u2276",
      lessgtr: "\u2276",
      LessLess: "\u2AA1",
      lesssim: "\u2272",
      LessSlantEqual: "\u2A7D",
      LessTilde: "\u2272",
      lfisht: "\u297C",
      lfloor: "\u230A",
      Lfr: "\u{1D50F}",
      lfr: "\u{1D529}",
      lg: "\u2276",
      lgE: "\u2A91",
      lHar: "\u2962",
      lhard: "\u21BD",
      lharu: "\u21BC",
      lharul: "\u296A",
      lhblk: "\u2584",
      LJcy: "\u0409",
      ljcy: "\u0459",
      Ll: "\u22D8",
      ll: "\u226A",
      llarr: "\u21C7",
      llcorner: "\u231E",
      Lleftarrow: "\u21DA",
      llhard: "\u296B",
      lltri: "\u25FA",
      Lmidot: "\u013F",
      lmidot: "\u0140",
      lmoust: "\u23B0",
      lmoustache: "\u23B0",
      lnap: "\u2A89",
      lnapprox: "\u2A89",
      lnE: "\u2268",
      lne: "\u2A87",
      lneq: "\u2A87",
      lneqq: "\u2268",
      lnsim: "\u22E6",
      loang: "\u27EC",
      loarr: "\u21FD",
      lobrk: "\u27E6",
      LongLeftArrow: "\u27F5",
      Longleftarrow: "\u27F8",
      longleftarrow: "\u27F5",
      LongLeftRightArrow: "\u27F7",
      Longleftrightarrow: "\u27FA",
      longleftrightarrow: "\u27F7",
      longmapsto: "\u27FC",
      LongRightArrow: "\u27F6",
      Longrightarrow: "\u27F9",
      longrightarrow: "\u27F6",
      looparrowleft: "\u21AB",
      looparrowright: "\u21AC",
      lopar: "\u2985",
      Lopf: "\u{1D543}",
      lopf: "\u{1D55D}",
      loplus: "\u2A2D",
      lotimes: "\u2A34",
      lowast: "\u2217",
      lowbar: "_",
      LowerLeftArrow: "\u2199",
      LowerRightArrow: "\u2198",
      loz: "\u25CA",
      lozenge: "\u25CA",
      lozf: "\u29EB",
      lpar: "(",
      lparlt: "\u2993",
      lrarr: "\u21C6",
      lrcorner: "\u231F",
      lrhar: "\u21CB",
      lrhard: "\u296D",
      lrm: "\u200E",
      lrtri: "\u22BF",
      lsaquo: "\u2039",
      Lscr: "\u2112",
      lscr: "\u{1D4C1}",
      Lsh: "\u21B0",
      lsh: "\u21B0",
      lsim: "\u2272",
      lsime: "\u2A8D",
      lsimg: "\u2A8F",
      lsqb: "[",
      lsquo: "\u2018",
      lsquor: "\u201A",
      Lstrok: "\u0141",
      lstrok: "\u0142",
      Lt: "\u226A",
      LT: "<",
      lt: "<",
      ltcc: "\u2AA6",
      ltcir: "\u2A79",
      ltdot: "\u22D6",
      lthree: "\u22CB",
      ltimes: "\u22C9",
      ltlarr: "\u2976",
      ltquest: "\u2A7B",
      ltri: "\u25C3",
      ltrie: "\u22B4",
      ltrif: "\u25C2",
      ltrPar: "\u2996",
      lurdshar: "\u294A",
      luruhar: "\u2966",
      lvertneqq: "\u2268\uFE00",
      lvnE: "\u2268\uFE00",
      macr: "\xAF",
      male: "\u2642",
      malt: "\u2720",
      maltese: "\u2720",
      Map: "\u2905",
      map: "\u21A6",
      mapsto: "\u21A6",
      mapstodown: "\u21A7",
      mapstoleft: "\u21A4",
      mapstoup: "\u21A5",
      marker: "\u25AE",
      mcomma: "\u2A29",
      Mcy: "\u041C",
      mcy: "\u043C",
      mdash: "\u2014",
      mDDot: "\u223A",
      measuredangle: "\u2221",
      MediumSpace: "\u205F",
      Mellintrf: "\u2133",
      Mfr: "\u{1D510}",
      mfr: "\u{1D52A}",
      mho: "\u2127",
      micro: "\xB5",
      mid: "\u2223",
      midast: "*",
      midcir: "\u2AF0",
      middot: "\xB7",
      minus: "\u2212",
      minusb: "\u229F",
      minusd: "\u2238",
      minusdu: "\u2A2A",
      MinusPlus: "\u2213",
      mlcp: "\u2ADB",
      mldr: "\u2026",
      mnplus: "\u2213",
      models: "\u22A7",
      Mopf: "\u{1D544}",
      mopf: "\u{1D55E}",
      mp: "\u2213",
      Mscr: "\u2133",
      mscr: "\u{1D4C2}",
      mstpos: "\u223E",
      Mu: "\u039C",
      mu: "\u03BC",
      multimap: "\u22B8",
      mumap: "\u22B8",
      nabla: "\u2207",
      Nacute: "\u0143",
      nacute: "\u0144",
      nang: "\u2220\u20D2",
      nap: "\u2249",
      napE: "\u2A70\u0338",
      napid: "\u224B\u0338",
      napos: "\u0149",
      napprox: "\u2249",
      natur: "\u266E",
      natural: "\u266E",
      naturals: "\u2115",
      nbsp: "\xA0",
      nbump: "\u224E\u0338",
      nbumpe: "\u224F\u0338",
      ncap: "\u2A43",
      Ncaron: "\u0147",
      ncaron: "\u0148",
      Ncedil: "\u0145",
      ncedil: "\u0146",
      ncong: "\u2247",
      ncongdot: "\u2A6D\u0338",
      ncup: "\u2A42",
      Ncy: "\u041D",
      ncy: "\u043D",
      ndash: "\u2013",
      ne: "\u2260",
      nearhk: "\u2924",
      neArr: "\u21D7",
      nearr: "\u2197",
      nearrow: "\u2197",
      nedot: "\u2250\u0338",
      NegativeMediumSpace: "\u200B",
      NegativeThickSpace: "\u200B",
      NegativeThinSpace: "\u200B",
      NegativeVeryThinSpace: "\u200B",
      nequiv: "\u2262",
      nesear: "\u2928",
      nesim: "\u2242\u0338",
      NestedGreaterGreater: "\u226B",
      NestedLessLess: "\u226A",
      NewLine: "\n",
      nexist: "\u2204",
      nexists: "\u2204",
      Nfr: "\u{1D511}",
      nfr: "\u{1D52B}",
      ngE: "\u2267\u0338",
      nge: "\u2271",
      ngeq: "\u2271",
      ngeqq: "\u2267\u0338",
      ngeqslant: "\u2A7E\u0338",
      nges: "\u2A7E\u0338",
      nGg: "\u22D9\u0338",
      ngsim: "\u2275",
      nGt: "\u226B\u20D2",
      ngt: "\u226F",
      ngtr: "\u226F",
      nGtv: "\u226B\u0338",
      nhArr: "\u21CE",
      nharr: "\u21AE",
      nhpar: "\u2AF2",
      ni: "\u220B",
      nis: "\u22FC",
      nisd: "\u22FA",
      niv: "\u220B",
      NJcy: "\u040A",
      njcy: "\u045A",
      nlArr: "\u21CD",
      nlarr: "\u219A",
      nldr: "\u2025",
      nlE: "\u2266\u0338",
      nle: "\u2270",
      nLeftarrow: "\u21CD",
      nleftarrow: "\u219A",
      nLeftrightarrow: "\u21CE",
      nleftrightarrow: "\u21AE",
      nleq: "\u2270",
      nleqq: "\u2266\u0338",
      nleqslant: "\u2A7D\u0338",
      nles: "\u2A7D\u0338",
      nless: "\u226E",
      nLl: "\u22D8\u0338",
      nlsim: "\u2274",
      nLt: "\u226A\u20D2",
      nlt: "\u226E",
      nltri: "\u22EA",
      nltrie: "\u22EC",
      nLtv: "\u226A\u0338",
      nmid: "\u2224",
      NoBreak: "\u2060",
      NonBreakingSpace: "\xA0",
      Nopf: "\u2115",
      nopf: "\u{1D55F}",
      Not: "\u2AEC",
      not: "\xAC",
      NotCongruent: "\u2262",
      NotCupCap: "\u226D",
      NotDoubleVerticalBar: "\u2226",
      NotElement: "\u2209",
      NotEqual: "\u2260",
      NotEqualTilde: "\u2242\u0338",
      NotExists: "\u2204",
      NotGreater: "\u226F",
      NotGreaterEqual: "\u2271",
      NotGreaterFullEqual: "\u2267\u0338",
      NotGreaterGreater: "\u226B\u0338",
      NotGreaterLess: "\u2279",
      NotGreaterSlantEqual: "\u2A7E\u0338",
      NotGreaterTilde: "\u2275",
      NotHumpDownHump: "\u224E\u0338",
      NotHumpEqual: "\u224F\u0338",
      notin: "\u2209",
      notindot: "\u22F5\u0338",
      notinE: "\u22F9\u0338",
      notinva: "\u2209",
      notinvb: "\u22F7",
      notinvc: "\u22F6",
      NotLeftTriangle: "\u22EA",
      NotLeftTriangleBar: "\u29CF\u0338",
      NotLeftTriangleEqual: "\u22EC",
      NotLess: "\u226E",
      NotLessEqual: "\u2270",
      NotLessGreater: "\u2278",
      NotLessLess: "\u226A\u0338",
      NotLessSlantEqual: "\u2A7D\u0338",
      NotLessTilde: "\u2274",
      NotNestedGreaterGreater: "\u2AA2\u0338",
      NotNestedLessLess: "\u2AA1\u0338",
      notni: "\u220C",
      notniva: "\u220C",
      notnivb: "\u22FE",
      notnivc: "\u22FD",
      NotPrecedes: "\u2280",
      NotPrecedesEqual: "\u2AAF\u0338",
      NotPrecedesSlantEqual: "\u22E0",
      NotReverseElement: "\u220C",
      NotRightTriangle: "\u22EB",
      NotRightTriangleBar: "\u29D0\u0338",
      NotRightTriangleEqual: "\u22ED",
      NotSquareSubset: "\u228F\u0338",
      NotSquareSubsetEqual: "\u22E2",
      NotSquareSuperset: "\u2290\u0338",
      NotSquareSupersetEqual: "\u22E3",
      NotSubset: "\u2282\u20D2",
      NotSubsetEqual: "\u2288",
      NotSucceeds: "\u2281",
      NotSucceedsEqual: "\u2AB0\u0338",
      NotSucceedsSlantEqual: "\u22E1",
      NotSucceedsTilde: "\u227F\u0338",
      NotSuperset: "\u2283\u20D2",
      NotSupersetEqual: "\u2289",
      NotTilde: "\u2241",
      NotTildeEqual: "\u2244",
      NotTildeFullEqual: "\u2247",
      NotTildeTilde: "\u2249",
      NotVerticalBar: "\u2224",
      npar: "\u2226",
      nparallel: "\u2226",
      nparsl: "\u2AFD\u20E5",
      npart: "\u2202\u0338",
      npolint: "\u2A14",
      npr: "\u2280",
      nprcue: "\u22E0",
      npre: "\u2AAF\u0338",
      nprec: "\u2280",
      npreceq: "\u2AAF\u0338",
      nrArr: "\u21CF",
      nrarr: "\u219B",
      nrarrc: "\u2933\u0338",
      nrarrw: "\u219D\u0338",
      nRightarrow: "\u21CF",
      nrightarrow: "\u219B",
      nrtri: "\u22EB",
      nrtrie: "\u22ED",
      nsc: "\u2281",
      nsccue: "\u22E1",
      nsce: "\u2AB0\u0338",
      Nscr: "\u{1D4A9}",
      nscr: "\u{1D4C3}",
      nshortmid: "\u2224",
      nshortparallel: "\u2226",
      nsim: "\u2241",
      nsime: "\u2244",
      nsimeq: "\u2244",
      nsmid: "\u2224",
      nspar: "\u2226",
      nsqsube: "\u22E2",
      nsqsupe: "\u22E3",
      nsub: "\u2284",
      nsubE: "\u2AC5\u0338",
      nsube: "\u2288",
      nsubset: "\u2282\u20D2",
      nsubseteq: "\u2288",
      nsubseteqq: "\u2AC5\u0338",
      nsucc: "\u2281",
      nsucceq: "\u2AB0\u0338",
      nsup: "\u2285",
      nsupE: "\u2AC6\u0338",
      nsupe: "\u2289",
      nsupset: "\u2283\u20D2",
      nsupseteq: "\u2289",
      nsupseteqq: "\u2AC6\u0338",
      ntgl: "\u2279",
      Ntilde: "\xD1",
      ntilde: "\xF1",
      ntlg: "\u2278",
      ntriangleleft: "\u22EA",
      ntrianglelefteq: "\u22EC",
      ntriangleright: "\u22EB",
      ntrianglerighteq: "\u22ED",
      Nu: "\u039D",
      nu: "\u03BD",
      num: "#",
      numero: "\u2116",
      numsp: "\u2007",
      nvap: "\u224D\u20D2",
      nVDash: "\u22AF",
      nVdash: "\u22AE",
      nvDash: "\u22AD",
      nvdash: "\u22AC",
      nvge: "\u2265\u20D2",
      nvgt: ">\u20D2",
      nvHarr: "\u2904",
      nvinfin: "\u29DE",
      nvlArr: "\u2902",
      nvle: "\u2264\u20D2",
      nvlt: "<\u20D2",
      nvltrie: "\u22B4\u20D2",
      nvrArr: "\u2903",
      nvrtrie: "\u22B5\u20D2",
      nvsim: "\u223C\u20D2",
      nwarhk: "\u2923",
      nwArr: "\u21D6",
      nwarr: "\u2196",
      nwarrow: "\u2196",
      nwnear: "\u2927",
      Oacute: "\xD3",
      oacute: "\xF3",
      oast: "\u229B",
      ocir: "\u229A",
      Ocirc: "\xD4",
      ocirc: "\xF4",
      Ocy: "\u041E",
      ocy: "\u043E",
      odash: "\u229D",
      Odblac: "\u0150",
      odblac: "\u0151",
      odiv: "\u2A38",
      odot: "\u2299",
      odsold: "\u29BC",
      OElig: "\u0152",
      oelig: "\u0153",
      ofcir: "\u29BF",
      Ofr: "\u{1D512}",
      ofr: "\u{1D52C}",
      ogon: "\u02DB",
      Ograve: "\xD2",
      ograve: "\xF2",
      ogt: "\u29C1",
      ohbar: "\u29B5",
      ohm: "\u03A9",
      oint: "\u222E",
      olarr: "\u21BA",
      olcir: "\u29BE",
      olcross: "\u29BB",
      oline: "\u203E",
      olt: "\u29C0",
      Omacr: "\u014C",
      omacr: "\u014D",
      Omega: "\u03A9",
      omega: "\u03C9",
      Omicron: "\u039F",
      omicron: "\u03BF",
      omid: "\u29B6",
      ominus: "\u2296",
      Oopf: "\u{1D546}",
      oopf: "\u{1D560}",
      opar: "\u29B7",
      OpenCurlyDoubleQuote: "\u201C",
      OpenCurlyQuote: "\u2018",
      operp: "\u29B9",
      oplus: "\u2295",
      Or: "\u2A54",
      or: "\u2228",
      orarr: "\u21BB",
      ord: "\u2A5D",
      order: "\u2134",
      orderof: "\u2134",
      ordf: "\xAA",
      ordm: "\xBA",
      origof: "\u22B6",
      oror: "\u2A56",
      orslope: "\u2A57",
      orv: "\u2A5B",
      oS: "\u24C8",
      Oscr: "\u{1D4AA}",
      oscr: "\u2134",
      Oslash: "\xD8",
      oslash: "\xF8",
      osol: "\u2298",
      Otilde: "\xD5",
      otilde: "\xF5",
      Otimes: "\u2A37",
      otimes: "\u2297",
      otimesas: "\u2A36",
      Ouml: "\xD6",
      ouml: "\xF6",
      ovbar: "\u233D",
      OverBar: "\u203E",
      OverBrace: "\u23DE",
      OverBracket: "\u23B4",
      OverParenthesis: "\u23DC",
      par: "\u2225",
      para: "\xB6",
      parallel: "\u2225",
      parsim: "\u2AF3",
      parsl: "\u2AFD",
      part: "\u2202",
      PartialD: "\u2202",
      Pcy: "\u041F",
      pcy: "\u043F",
      percnt: "%",
      period: ".",
      permil: "\u2030",
      perp: "\u22A5",
      pertenk: "\u2031",
      Pfr: "\u{1D513}",
      pfr: "\u{1D52D}",
      Phi: "\u03A6",
      phi: "\u03C6",
      phiv: "\u03D5",
      phmmat: "\u2133",
      phone: "\u260E",
      Pi: "\u03A0",
      pi: "\u03C0",
      pitchfork: "\u22D4",
      piv: "\u03D6",
      planck: "\u210F",
      planckh: "\u210E",
      plankv: "\u210F",
      plus: "+",
      plusacir: "\u2A23",
      plusb: "\u229E",
      pluscir: "\u2A22",
      plusdo: "\u2214",
      plusdu: "\u2A25",
      pluse: "\u2A72",
      PlusMinus: "\xB1",
      plusmn: "\xB1",
      plussim: "\u2A26",
      plustwo: "\u2A27",
      pm: "\xB1",
      Poincareplane: "\u210C",
      pointint: "\u2A15",
      Popf: "\u2119",
      popf: "\u{1D561}",
      pound: "\xA3",
      Pr: "\u2ABB",
      pr: "\u227A",
      prap: "\u2AB7",
      prcue: "\u227C",
      prE: "\u2AB3",
      pre: "\u2AAF",
      prec: "\u227A",
      precapprox: "\u2AB7",
      preccurlyeq: "\u227C",
      Precedes: "\u227A",
      PrecedesEqual: "\u2AAF",
      PrecedesSlantEqual: "\u227C",
      PrecedesTilde: "\u227E",
      preceq: "\u2AAF",
      precnapprox: "\u2AB9",
      precneqq: "\u2AB5",
      precnsim: "\u22E8",
      precsim: "\u227E",
      Prime: "\u2033",
      prime: "\u2032",
      primes: "\u2119",
      prnap: "\u2AB9",
      prnE: "\u2AB5",
      prnsim: "\u22E8",
      prod: "\u220F",
      Product: "\u220F",
      profalar: "\u232E",
      profline: "\u2312",
      profsurf: "\u2313",
      prop: "\u221D",
      Proportion: "\u2237",
      Proportional: "\u221D",
      propto: "\u221D",
      prsim: "\u227E",
      prurel: "\u22B0",
      Pscr: "\u{1D4AB}",
      pscr: "\u{1D4C5}",
      Psi: "\u03A8",
      psi: "\u03C8",
      puncsp: "\u2008",
      Qfr: "\u{1D514}",
      qfr: "\u{1D52E}",
      qint: "\u2A0C",
      Qopf: "\u211A",
      qopf: "\u{1D562}",
      qprime: "\u2057",
      Qscr: "\u{1D4AC}",
      qscr: "\u{1D4C6}",
      quaternions: "\u210D",
      quatint: "\u2A16",
      quest: "?",
      questeq: "\u225F",
      QUOT: '"',
      quot: '"',
      rAarr: "\u21DB",
      race: "\u223D\u0331",
      Racute: "\u0154",
      racute: "\u0155",
      radic: "\u221A",
      raemptyv: "\u29B3",
      Rang: "\u27EB",
      rang: "\u27E9",
      rangd: "\u2992",
      range: "\u29A5",
      rangle: "\u27E9",
      raquo: "\xBB",
      Rarr: "\u21A0",
      rArr: "\u21D2",
      rarr: "\u2192",
      rarrap: "\u2975",
      rarrb: "\u21E5",
      rarrbfs: "\u2920",
      rarrc: "\u2933",
      rarrfs: "\u291E",
      rarrhk: "\u21AA",
      rarrlp: "\u21AC",
      rarrpl: "\u2945",
      rarrsim: "\u2974",
      Rarrtl: "\u2916",
      rarrtl: "\u21A3",
      rarrw: "\u219D",
      rAtail: "\u291C",
      ratail: "\u291A",
      ratio: "\u2236",
      rationals: "\u211A",
      RBarr: "\u2910",
      rBarr: "\u290F",
      rbarr: "\u290D",
      rbbrk: "\u2773",
      rbrace: "}",
      rbrack: "]",
      rbrke: "\u298C",
      rbrksld: "\u298E",
      rbrkslu: "\u2990",
      Rcaron: "\u0158",
      rcaron: "\u0159",
      Rcedil: "\u0156",
      rcedil: "\u0157",
      rceil: "\u2309",
      rcub: "}",
      Rcy: "\u0420",
      rcy: "\u0440",
      rdca: "\u2937",
      rdldhar: "\u2969",
      rdquo: "\u201D",
      rdquor: "\u201D",
      rdsh: "\u21B3",
      Re: "\u211C",
      real: "\u211C",
      realine: "\u211B",
      realpart: "\u211C",
      reals: "\u211D",
      rect: "\u25AD",
      REG: "\xAE",
      reg: "\xAE",
      ReverseElement: "\u220B",
      ReverseEquilibrium: "\u21CB",
      ReverseUpEquilibrium: "\u296F",
      rfisht: "\u297D",
      rfloor: "\u230B",
      Rfr: "\u211C",
      rfr: "\u{1D52F}",
      rHar: "\u2964",
      rhard: "\u21C1",
      rharu: "\u21C0",
      rharul: "\u296C",
      Rho: "\u03A1",
      rho: "\u03C1",
      rhov: "\u03F1",
      RightAngleBracket: "\u27E9",
      RightArrow: "\u2192",
      Rightarrow: "\u21D2",
      rightarrow: "\u2192",
      RightArrowBar: "\u21E5",
      RightArrowLeftArrow: "\u21C4",
      rightarrowtail: "\u21A3",
      RightCeiling: "\u2309",
      RightDoubleBracket: "\u27E7",
      RightDownTeeVector: "\u295D",
      RightDownVector: "\u21C2",
      RightDownVectorBar: "\u2955",
      RightFloor: "\u230B",
      rightharpoondown: "\u21C1",
      rightharpoonup: "\u21C0",
      rightleftarrows: "\u21C4",
      rightleftharpoons: "\u21CC",
      rightrightarrows: "\u21C9",
      rightsquigarrow: "\u219D",
      RightTee: "\u22A2",
      RightTeeArrow: "\u21A6",
      RightTeeVector: "\u295B",
      rightthreetimes: "\u22CC",
      RightTriangle: "\u22B3",
      RightTriangleBar: "\u29D0",
      RightTriangleEqual: "\u22B5",
      RightUpDownVector: "\u294F",
      RightUpTeeVector: "\u295C",
      RightUpVector: "\u21BE",
      RightUpVectorBar: "\u2954",
      RightVector: "\u21C0",
      RightVectorBar: "\u2953",
      ring: "\u02DA",
      risingdotseq: "\u2253",
      rlarr: "\u21C4",
      rlhar: "\u21CC",
      rlm: "\u200F",
      rmoust: "\u23B1",
      rmoustache: "\u23B1",
      rnmid: "\u2AEE",
      roang: "\u27ED",
      roarr: "\u21FE",
      robrk: "\u27E7",
      ropar: "\u2986",
      Ropf: "\u211D",
      ropf: "\u{1D563}",
      roplus: "\u2A2E",
      rotimes: "\u2A35",
      RoundImplies: "\u2970",
      rpar: ")",
      rpargt: "\u2994",
      rppolint: "\u2A12",
      rrarr: "\u21C9",
      Rrightarrow: "\u21DB",
      rsaquo: "\u203A",
      Rscr: "\u211B",
      rscr: "\u{1D4C7}",
      Rsh: "\u21B1",
      rsh: "\u21B1",
      rsqb: "]",
      rsquo: "\u2019",
      rsquor: "\u2019",
      rthree: "\u22CC",
      rtimes: "\u22CA",
      rtri: "\u25B9",
      rtrie: "\u22B5",
      rtrif: "\u25B8",
      rtriltri: "\u29CE",
      RuleDelayed: "\u29F4",
      ruluhar: "\u2968",
      rx: "\u211E",
      Sacute: "\u015A",
      sacute: "\u015B",
      sbquo: "\u201A",
      Sc: "\u2ABC",
      sc: "\u227B",
      scap: "\u2AB8",
      Scaron: "\u0160",
      scaron: "\u0161",
      sccue: "\u227D",
      scE: "\u2AB4",
      sce: "\u2AB0",
      Scedil: "\u015E",
      scedil: "\u015F",
      Scirc: "\u015C",
      scirc: "\u015D",
      scnap: "\u2ABA",
      scnE: "\u2AB6",
      scnsim: "\u22E9",
      scpolint: "\u2A13",
      scsim: "\u227F",
      Scy: "\u0421",
      scy: "\u0441",
      sdot: "\u22C5",
      sdotb: "\u22A1",
      sdote: "\u2A66",
      searhk: "\u2925",
      seArr: "\u21D8",
      searr: "\u2198",
      searrow: "\u2198",
      sect: "\xA7",
      semi: ";",
      seswar: "\u2929",
      setminus: "\u2216",
      setmn: "\u2216",
      sext: "\u2736",
      Sfr: "\u{1D516}",
      sfr: "\u{1D530}",
      sfrown: "\u2322",
      sharp: "\u266F",
      SHCHcy: "\u0429",
      shchcy: "\u0449",
      SHcy: "\u0428",
      shcy: "\u0448",
      ShortDownArrow: "\u2193",
      ShortLeftArrow: "\u2190",
      shortmid: "\u2223",
      shortparallel: "\u2225",
      ShortRightArrow: "\u2192",
      ShortUpArrow: "\u2191",
      shy: "\xAD",
      Sigma: "\u03A3",
      sigma: "\u03C3",
      sigmaf: "\u03C2",
      sigmav: "\u03C2",
      sim: "\u223C",
      simdot: "\u2A6A",
      sime: "\u2243",
      simeq: "\u2243",
      simg: "\u2A9E",
      simgE: "\u2AA0",
      siml: "\u2A9D",
      simlE: "\u2A9F",
      simne: "\u2246",
      simplus: "\u2A24",
      simrarr: "\u2972",
      slarr: "\u2190",
      SmallCircle: "\u2218",
      smallsetminus: "\u2216",
      smashp: "\u2A33",
      smeparsl: "\u29E4",
      smid: "\u2223",
      smile: "\u2323",
      smt: "\u2AAA",
      smte: "\u2AAC",
      smtes: "\u2AAC\uFE00",
      SOFTcy: "\u042C",
      softcy: "\u044C",
      sol: "/",
      solb: "\u29C4",
      solbar: "\u233F",
      Sopf: "\u{1D54A}",
      sopf: "\u{1D564}",
      spades: "\u2660",
      spadesuit: "\u2660",
      spar: "\u2225",
      sqcap: "\u2293",
      sqcaps: "\u2293\uFE00",
      sqcup: "\u2294",
      sqcups: "\u2294\uFE00",
      Sqrt: "\u221A",
      sqsub: "\u228F",
      sqsube: "\u2291",
      sqsubset: "\u228F",
      sqsubseteq: "\u2291",
      sqsup: "\u2290",
      sqsupe: "\u2292",
      sqsupset: "\u2290",
      sqsupseteq: "\u2292",
      squ: "\u25A1",
      Square: "\u25A1",
      square: "\u25A1",
      SquareIntersection: "\u2293",
      SquareSubset: "\u228F",
      SquareSubsetEqual: "\u2291",
      SquareSuperset: "\u2290",
      SquareSupersetEqual: "\u2292",
      SquareUnion: "\u2294",
      squarf: "\u25AA",
      squf: "\u25AA",
      srarr: "\u2192",
      Sscr: "\u{1D4AE}",
      sscr: "\u{1D4C8}",
      ssetmn: "\u2216",
      ssmile: "\u2323",
      sstarf: "\u22C6",
      Star: "\u22C6",
      star: "\u2606",
      starf: "\u2605",
      straightepsilon: "\u03F5",
      straightphi: "\u03D5",
      strns: "\xAF",
      Sub: "\u22D0",
      sub: "\u2282",
      subdot: "\u2ABD",
      subE: "\u2AC5",
      sube: "\u2286",
      subedot: "\u2AC3",
      submult: "\u2AC1",
      subnE: "\u2ACB",
      subne: "\u228A",
      subplus: "\u2ABF",
      subrarr: "\u2979",
      Subset: "\u22D0",
      subset: "\u2282",
      subseteq: "\u2286",
      subseteqq: "\u2AC5",
      SubsetEqual: "\u2286",
      subsetneq: "\u228A",
      subsetneqq: "\u2ACB",
      subsim: "\u2AC7",
      subsub: "\u2AD5",
      subsup: "\u2AD3",
      succ: "\u227B",
      succapprox: "\u2AB8",
      succcurlyeq: "\u227D",
      Succeeds: "\u227B",
      SucceedsEqual: "\u2AB0",
      SucceedsSlantEqual: "\u227D",
      SucceedsTilde: "\u227F",
      succeq: "\u2AB0",
      succnapprox: "\u2ABA",
      succneqq: "\u2AB6",
      succnsim: "\u22E9",
      succsim: "\u227F",
      SuchThat: "\u220B",
      Sum: "\u2211",
      sum: "\u2211",
      sung: "\u266A",
      Sup: "\u22D1",
      sup: "\u2283",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      supdot: "\u2ABE",
      supdsub: "\u2AD8",
      supE: "\u2AC6",
      supe: "\u2287",
      supedot: "\u2AC4",
      Superset: "\u2283",
      SupersetEqual: "\u2287",
      suphsol: "\u27C9",
      suphsub: "\u2AD7",
      suplarr: "\u297B",
      supmult: "\u2AC2",
      supnE: "\u2ACC",
      supne: "\u228B",
      supplus: "\u2AC0",
      Supset: "\u22D1",
      supset: "\u2283",
      supseteq: "\u2287",
      supseteqq: "\u2AC6",
      supsetneq: "\u228B",
      supsetneqq: "\u2ACC",
      supsim: "\u2AC8",
      supsub: "\u2AD4",
      supsup: "\u2AD6",
      swarhk: "\u2926",
      swArr: "\u21D9",
      swarr: "\u2199",
      swarrow: "\u2199",
      swnwar: "\u292A",
      szlig: "\xDF",
      Tab: "	",
      target: "\u2316",
      Tau: "\u03A4",
      tau: "\u03C4",
      tbrk: "\u23B4",
      Tcaron: "\u0164",
      tcaron: "\u0165",
      Tcedil: "\u0162",
      tcedil: "\u0163",
      Tcy: "\u0422",
      tcy: "\u0442",
      tdot: "\u20DB",
      telrec: "\u2315",
      Tfr: "\u{1D517}",
      tfr: "\u{1D531}",
      there4: "\u2234",
      Therefore: "\u2234",
      therefore: "\u2234",
      Theta: "\u0398",
      theta: "\u03B8",
      thetasym: "\u03D1",
      thetav: "\u03D1",
      thickapprox: "\u2248",
      thicksim: "\u223C",
      ThickSpace: "\u205F\u200A",
      thinsp: "\u2009",
      ThinSpace: "\u2009",
      thkap: "\u2248",
      thksim: "\u223C",
      THORN: "\xDE",
      thorn: "\xFE",
      Tilde: "\u223C",
      tilde: "\u02DC",
      TildeEqual: "\u2243",
      TildeFullEqual: "\u2245",
      TildeTilde: "\u2248",
      times: "\xD7",
      timesb: "\u22A0",
      timesbar: "\u2A31",
      timesd: "\u2A30",
      tint: "\u222D",
      toea: "\u2928",
      top: "\u22A4",
      topbot: "\u2336",
      topcir: "\u2AF1",
      Topf: "\u{1D54B}",
      topf: "\u{1D565}",
      topfork: "\u2ADA",
      tosa: "\u2929",
      tprime: "\u2034",
      TRADE: "\u2122",
      trade: "\u2122",
      triangle: "\u25B5",
      triangledown: "\u25BF",
      triangleleft: "\u25C3",
      trianglelefteq: "\u22B4",
      triangleq: "\u225C",
      triangleright: "\u25B9",
      trianglerighteq: "\u22B5",
      tridot: "\u25EC",
      trie: "\u225C",
      triminus: "\u2A3A",
      TripleDot: "\u20DB",
      triplus: "\u2A39",
      trisb: "\u29CD",
      tritime: "\u2A3B",
      trpezium: "\u23E2",
      Tscr: "\u{1D4AF}",
      tscr: "\u{1D4C9}",
      TScy: "\u0426",
      tscy: "\u0446",
      TSHcy: "\u040B",
      tshcy: "\u045B",
      Tstrok: "\u0166",
      tstrok: "\u0167",
      twixt: "\u226C",
      twoheadleftarrow: "\u219E",
      twoheadrightarrow: "\u21A0",
      Uacute: "\xDA",
      uacute: "\xFA",
      Uarr: "\u219F",
      uArr: "\u21D1",
      uarr: "\u2191",
      Uarrocir: "\u2949",
      Ubrcy: "\u040E",
      ubrcy: "\u045E",
      Ubreve: "\u016C",
      ubreve: "\u016D",
      Ucirc: "\xDB",
      ucirc: "\xFB",
      Ucy: "\u0423",
      ucy: "\u0443",
      udarr: "\u21C5",
      Udblac: "\u0170",
      udblac: "\u0171",
      udhar: "\u296E",
      ufisht: "\u297E",
      Ufr: "\u{1D518}",
      ufr: "\u{1D532}",
      Ugrave: "\xD9",
      ugrave: "\xF9",
      uHar: "\u2963",
      uharl: "\u21BF",
      uharr: "\u21BE",
      uhblk: "\u2580",
      ulcorn: "\u231C",
      ulcorner: "\u231C",
      ulcrop: "\u230F",
      ultri: "\u25F8",
      Umacr: "\u016A",
      umacr: "\u016B",
      uml: "\xA8",
      UnderBar: "_",
      UnderBrace: "\u23DF",
      UnderBracket: "\u23B5",
      UnderParenthesis: "\u23DD",
      Union: "\u22C3",
      UnionPlus: "\u228E",
      Uogon: "\u0172",
      uogon: "\u0173",
      Uopf: "\u{1D54C}",
      uopf: "\u{1D566}",
      UpArrow: "\u2191",
      Uparrow: "\u21D1",
      uparrow: "\u2191",
      UpArrowBar: "\u2912",
      UpArrowDownArrow: "\u21C5",
      UpDownArrow: "\u2195",
      Updownarrow: "\u21D5",
      updownarrow: "\u2195",
      UpEquilibrium: "\u296E",
      upharpoonleft: "\u21BF",
      upharpoonright: "\u21BE",
      uplus: "\u228E",
      UpperLeftArrow: "\u2196",
      UpperRightArrow: "\u2197",
      Upsi: "\u03D2",
      upsi: "\u03C5",
      upsih: "\u03D2",
      Upsilon: "\u03A5",
      upsilon: "\u03C5",
      UpTee: "\u22A5",
      UpTeeArrow: "\u21A5",
      upuparrows: "\u21C8",
      urcorn: "\u231D",
      urcorner: "\u231D",
      urcrop: "\u230E",
      Uring: "\u016E",
      uring: "\u016F",
      urtri: "\u25F9",
      Uscr: "\u{1D4B0}",
      uscr: "\u{1D4CA}",
      utdot: "\u22F0",
      Utilde: "\u0168",
      utilde: "\u0169",
      utri: "\u25B5",
      utrif: "\u25B4",
      uuarr: "\u21C8",
      Uuml: "\xDC",
      uuml: "\xFC",
      uwangle: "\u29A7",
      vangrt: "\u299C",
      varepsilon: "\u03F5",
      varkappa: "\u03F0",
      varnothing: "\u2205",
      varphi: "\u03D5",
      varpi: "\u03D6",
      varpropto: "\u221D",
      vArr: "\u21D5",
      varr: "\u2195",
      varrho: "\u03F1",
      varsigma: "\u03C2",
      varsubsetneq: "\u228A\uFE00",
      varsubsetneqq: "\u2ACB\uFE00",
      varsupsetneq: "\u228B\uFE00",
      varsupsetneqq: "\u2ACC\uFE00",
      vartheta: "\u03D1",
      vartriangleleft: "\u22B2",
      vartriangleright: "\u22B3",
      Vbar: "\u2AEB",
      vBar: "\u2AE8",
      vBarv: "\u2AE9",
      Vcy: "\u0412",
      vcy: "\u0432",
      VDash: "\u22AB",
      Vdash: "\u22A9",
      vDash: "\u22A8",
      vdash: "\u22A2",
      Vdashl: "\u2AE6",
      Vee: "\u22C1",
      vee: "\u2228",
      veebar: "\u22BB",
      veeeq: "\u225A",
      vellip: "\u22EE",
      Verbar: "\u2016",
      verbar: "|",
      Vert: "\u2016",
      vert: "|",
      VerticalBar: "\u2223",
      VerticalLine: "|",
      VerticalSeparator: "\u2758",
      VerticalTilde: "\u2240",
      VeryThinSpace: "\u200A",
      Vfr: "\u{1D519}",
      vfr: "\u{1D533}",
      vltri: "\u22B2",
      vnsub: "\u2282\u20D2",
      vnsup: "\u2283\u20D2",
      Vopf: "\u{1D54D}",
      vopf: "\u{1D567}",
      vprop: "\u221D",
      vrtri: "\u22B3",
      Vscr: "\u{1D4B1}",
      vscr: "\u{1D4CB}",
      vsubnE: "\u2ACB\uFE00",
      vsubne: "\u228A\uFE00",
      vsupnE: "\u2ACC\uFE00",
      vsupne: "\u228B\uFE00",
      Vvdash: "\u22AA",
      vzigzag: "\u299A",
      Wcirc: "\u0174",
      wcirc: "\u0175",
      wedbar: "\u2A5F",
      Wedge: "\u22C0",
      wedge: "\u2227",
      wedgeq: "\u2259",
      weierp: "\u2118",
      Wfr: "\u{1D51A}",
      wfr: "\u{1D534}",
      Wopf: "\u{1D54E}",
      wopf: "\u{1D568}",
      wp: "\u2118",
      wr: "\u2240",
      wreath: "\u2240",
      Wscr: "\u{1D4B2}",
      wscr: "\u{1D4CC}",
      xcap: "\u22C2",
      xcirc: "\u25EF",
      xcup: "\u22C3",
      xdtri: "\u25BD",
      Xfr: "\u{1D51B}",
      xfr: "\u{1D535}",
      xhArr: "\u27FA",
      xharr: "\u27F7",
      Xi: "\u039E",
      xi: "\u03BE",
      xlArr: "\u27F8",
      xlarr: "\u27F5",
      xmap: "\u27FC",
      xnis: "\u22FB",
      xodot: "\u2A00",
      Xopf: "\u{1D54F}",
      xopf: "\u{1D569}",
      xoplus: "\u2A01",
      xotime: "\u2A02",
      xrArr: "\u27F9",
      xrarr: "\u27F6",
      Xscr: "\u{1D4B3}",
      xscr: "\u{1D4CD}",
      xsqcup: "\u2A06",
      xuplus: "\u2A04",
      xutri: "\u25B3",
      xvee: "\u22C1",
      xwedge: "\u22C0",
      Yacute: "\xDD",
      yacute: "\xFD",
      YAcy: "\u042F",
      yacy: "\u044F",
      Ycirc: "\u0176",
      ycirc: "\u0177",
      Ycy: "\u042B",
      ycy: "\u044B",
      yen: "\xA5",
      Yfr: "\u{1D51C}",
      yfr: "\u{1D536}",
      YIcy: "\u0407",
      yicy: "\u0457",
      Yopf: "\u{1D550}",
      yopf: "\u{1D56A}",
      Yscr: "\u{1D4B4}",
      yscr: "\u{1D4CE}",
      YUcy: "\u042E",
      yucy: "\u044E",
      Yuml: "\u0178",
      yuml: "\xFF",
      Zacute: "\u0179",
      zacute: "\u017A",
      Zcaron: "\u017D",
      zcaron: "\u017E",
      Zcy: "\u0417",
      zcy: "\u0437",
      Zdot: "\u017B",
      zdot: "\u017C",
      zeetrf: "\u2128",
      ZeroWidthSpace: "\u200B",
      Zeta: "\u0396",
      zeta: "\u03B6",
      Zfr: "\u2128",
      zfr: "\u{1D537}",
      ZHcy: "\u0416",
      zhcy: "\u0436",
      zigrarr: "\u21DD",
      Zopf: "\u2124",
      zopf: "\u{1D56B}",
      Zscr: "\u{1D4B5}",
      zscr: "\u{1D4CF}",
      zwj: "\u200D",
      zwnj: "\u200C"
    });
    exports2.entityMap = exports2.HTML_ENTITIES;
  });
  entities.XML_ENTITIES;
  entities.HTML_ENTITIES;
  entities.entityMap;
  var NAMESPACE$1 = conventions.NAMESPACE;
  var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
  var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
  var S_TAG = 0;
  var S_ATTR = 1;
  var S_ATTR_SPACE = 2;
  var S_EQ = 3;
  var S_ATTR_NOQUOT_VALUE = 4;
  var S_ATTR_END = 5;
  var S_TAG_SPACE = 6;
  var S_TAG_CLOSE = 7;
  function ParseError$1(message, locator) {
    this.message = message;
    this.locator = locator;
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, ParseError$1);
  }
  ParseError$1.prototype = new Error();
  ParseError$1.prototype.name = ParseError$1.name;
  function XMLReader$1() {
  }
  XMLReader$1.prototype = {
    parse: function(source, defaultNSMap, entityMap) {
      var domBuilder = this.domBuilder;
      domBuilder.startDocument();
      _copy(defaultNSMap, defaultNSMap = {});
      parse$1(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
      domBuilder.endDocument();
    }
  };
  function parse$1(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
    function fixedFromCharCode(code) {
      if (code > 65535) {
        code -= 65536;
        var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      } else {
        return String.fromCharCode(code);
      }
    }
    function entityReplacer(a2) {
      var k = a2.slice(1, -1);
      if (Object.hasOwnProperty.call(entityMap, k)) {
        return entityMap[k];
      } else if (k.charAt(0) === "#") {
        return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
      } else {
        errorHandler.error("entity not found:" + a2);
        return a2;
      }
    }
    function appendText(end2) {
      if (end2 > start) {
        var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
        locator && position2(start);
        domBuilder.characters(xt, 0, end2 - start);
        start = end2;
      }
    }
    function position2(p, m) {
      while (p >= lineEnd && (m = linePattern.exec(source))) {
        lineStart = m.index;
        lineEnd = lineStart + m[0].length;
        locator.lineNumber++;
      }
      locator.columnNumber = p - lineStart + 1;
    }
    var lineStart = 0;
    var lineEnd = 0;
    var linePattern = /.*(?:\r\n?|\n)|.*$/g;
    var locator = domBuilder.locator;
    var parseStack = [{
      currentNSMap: defaultNSMapCopy
    }];
    var closeMap = {};
    var start = 0;
    while (true) {
      try {
        var tagStart = source.indexOf("<", start);
        if (tagStart < 0) {
          if (!source.substr(start).match(/^\s*$/)) {
            var doc = domBuilder.doc;
            var text = doc.createTextNode(source.substr(start));
            doc.appendChild(text);
            domBuilder.currentElement = text;
          }
          return;
        }
        if (tagStart > start) {
          appendText(tagStart);
        }
        switch (source.charAt(tagStart + 1)) {
          case "/":
            var end = source.indexOf(">", tagStart + 3);
            var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
            var config = parseStack.pop();
            if (end < 0) {
              tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
              errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
              end = tagStart + 1 + tagName.length;
            } else if (tagName.match(/\s</)) {
              tagName = tagName.replace(/[\s<].*/, "");
              errorHandler.error("end tag name: " + tagName + " maybe not complete");
              end = tagStart + 1 + tagName.length;
            }
            var localNSMap = config.localNSMap;
            var endMatch = config.tagName == tagName;
            var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
            if (endIgnoreCaseMach) {
              domBuilder.endElement(config.uri, config.localName, tagName);
              if (localNSMap) {
                for (var prefix in localNSMap) {
                  if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                    domBuilder.endPrefixMapping(prefix);
                  }
                }
              }
              if (!endMatch) {
                errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
              }
            } else {
              parseStack.push(config);
            }
            end++;
            break;
          case "?":
            locator && position2(tagStart);
            end = parseInstruction(source, tagStart, domBuilder);
            break;
          case "!":
            locator && position2(tagStart);
            end = parseDCC(source, tagStart, domBuilder, errorHandler);
            break;
          default:
            locator && position2(tagStart);
            var el = new ElementAttributes();
            var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
            var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
            var len = el.length;
            if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
              el.closed = true;
              if (!entityMap.nbsp) {
                errorHandler.warning("unclosed xml attribute");
              }
            }
            if (locator && len) {
              var locator2 = copyLocator(locator, {});
              for (var i = 0; i < len; i++) {
                var a = el[i];
                position2(a.offset);
                a.locator = copyLocator(locator, {});
              }
              domBuilder.locator = locator2;
              if (appendElement$1(el, domBuilder, currentNSMap)) {
                parseStack.push(el);
              }
              domBuilder.locator = locator;
            } else {
              if (appendElement$1(el, domBuilder, currentNSMap)) {
                parseStack.push(el);
              }
            }
            if (NAMESPACE$1.isHTML(el.uri) && !el.closed) {
              end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
            } else {
              end++;
            }
        }
      } catch (e) {
        if (e instanceof ParseError$1) {
          throw e;
        }
        errorHandler.error("element parse error: " + e);
        end = -1;
      }
      if (end > start) {
        start = end;
      } else {
        appendText(Math.max(tagStart, start) + 1);
      }
    }
  }
  function copyLocator(f, t) {
    t.lineNumber = f.lineNumber;
    t.columnNumber = f.columnNumber;
    return t;
  }
  function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
    function addAttribute(qname, value2, startIndex) {
      if (el.attributeNames.hasOwnProperty(qname)) {
        errorHandler.fatalError("Attribute " + qname + " redefined");
      }
      el.addValue(
        qname,
        // @see https://www.w3.org/TR/xml/#AVNormalize
        // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
        // - recursive replacement of (DTD) entity references
        // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
        value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
        startIndex
      );
    }
    var attrName;
    var value;
    var p = ++start;
    var s = S_TAG;
    while (true) {
      var c = source.charAt(p);
      switch (c) {
        case "=":
          if (s === S_ATTR) {
            attrName = source.slice(start, p);
            s = S_EQ;
          } else if (s === S_ATTR_SPACE) {
            s = S_EQ;
          } else {
            throw new Error("attribute equal must after attrName");
          }
          break;
        case "'":
        case '"':
          if (s === S_EQ || s === S_ATTR) {
            if (s === S_ATTR) {
              errorHandler.warning('attribute value must after "="');
              attrName = source.slice(start, p);
            }
            start = p + 1;
            p = source.indexOf(c, start);
            if (p > 0) {
              value = source.slice(start, p);
              addAttribute(attrName, value, start - 1);
              s = S_ATTR_END;
            } else {
              throw new Error("attribute value no end '" + c + "' match");
            }
          } else if (s == S_ATTR_NOQUOT_VALUE) {
            value = source.slice(start, p);
            addAttribute(attrName, value, start);
            errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
            start = p + 1;
            s = S_ATTR_END;
          } else {
            throw new Error('attribute value must after "="');
          }
          break;
        case "/":
          switch (s) {
            case S_TAG:
              el.setTagName(source.slice(start, p));
            case S_ATTR_END:
            case S_TAG_SPACE:
            case S_TAG_CLOSE:
              s = S_TAG_CLOSE;
              el.closed = true;
            case S_ATTR_NOQUOT_VALUE:
            case S_ATTR:
              break;
            case S_ATTR_SPACE:
              el.closed = true;
              break;
            default:
              throw new Error("attribute invalid close char('/')");
          }
          break;
        case "":
          errorHandler.error("unexpected end of input");
          if (s == S_TAG) {
            el.setTagName(source.slice(start, p));
          }
          return p;
        case ">":
          switch (s) {
            case S_TAG:
              el.setTagName(source.slice(start, p));
            case S_ATTR_END:
            case S_TAG_SPACE:
            case S_TAG_CLOSE:
              break;
            case S_ATTR_NOQUOT_VALUE:
            case S_ATTR:
              value = source.slice(start, p);
              if (value.slice(-1) === "/") {
                el.closed = true;
                value = value.slice(0, -1);
              }
            case S_ATTR_SPACE:
              if (s === S_ATTR_SPACE) {
                value = attrName;
              }
              if (s == S_ATTR_NOQUOT_VALUE) {
                errorHandler.warning('attribute "' + value + '" missed quot(")!');
                addAttribute(attrName, value, start);
              } else {
                if (!NAMESPACE$1.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                  errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                }
                addAttribute(value, value, start);
              }
              break;
            case S_EQ:
              throw new Error("attribute value missed!!");
          }
          return p;
        case "\x80":
          c = " ";
        default:
          if (c <= " ") {
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
                s = S_TAG_SPACE;
                break;
              case S_ATTR:
                attrName = source.slice(start, p);
                s = S_ATTR_SPACE;
                break;
              case S_ATTR_NOQUOT_VALUE:
                var value = source.slice(start, p);
                errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                addAttribute(attrName, value, start);
              case S_ATTR_END:
                s = S_TAG_SPACE;
                break;
            }
          } else {
            switch (s) {
              case S_ATTR_SPACE:
                el.tagName;
                if (!NAMESPACE$1.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                  errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                }
                addAttribute(attrName, attrName, start);
                start = p;
                s = S_ATTR;
                break;
              case S_ATTR_END:
                errorHandler.warning('attribute space is required"' + attrName + '"!!');
              case S_TAG_SPACE:
                s = S_ATTR;
                start = p;
                break;
              case S_EQ:
                s = S_ATTR_NOQUOT_VALUE;
                start = p;
                break;
              case S_TAG_CLOSE:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
          }
      }
      p++;
    }
  }
  function appendElement$1(el, domBuilder, currentNSMap) {
    var tagName = el.tagName;
    var localNSMap = null;
    var i = el.length;
    while (i--) {
      var a = el[i];
      var qName = a.qName;
      var value = a.value;
      var nsp = qName.indexOf(":");
      if (nsp > 0) {
        var prefix = a.prefix = qName.slice(0, nsp);
        var localName = qName.slice(nsp + 1);
        var nsPrefix = prefix === "xmlns" && localName;
      } else {
        localName = qName;
        prefix = null;
        nsPrefix = qName === "xmlns" && "";
      }
      a.localName = localName;
      if (nsPrefix !== false) {
        if (localNSMap == null) {
          localNSMap = {};
          _copy(currentNSMap, currentNSMap = {});
        }
        currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
        a.uri = NAMESPACE$1.XMLNS;
        domBuilder.startPrefixMapping(nsPrefix, value);
      }
    }
    var i = el.length;
    while (i--) {
      a = el[i];
      var prefix = a.prefix;
      if (prefix) {
        if (prefix === "xml") {
          a.uri = NAMESPACE$1.XML;
        }
        if (prefix !== "xmlns") {
          a.uri = currentNSMap[prefix || ""];
        }
      }
    }
    var nsp = tagName.indexOf(":");
    if (nsp > 0) {
      prefix = el.prefix = tagName.slice(0, nsp);
      localName = el.localName = tagName.slice(nsp + 1);
    } else {
      prefix = null;
      localName = el.localName = tagName;
    }
    var ns = el.uri = currentNSMap[prefix || ""];
    domBuilder.startElement(ns, localName, tagName, el);
    if (el.closed) {
      domBuilder.endElement(ns, localName, tagName);
      if (localNSMap) {
        for (prefix in localNSMap) {
          if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
            domBuilder.endPrefixMapping(prefix);
          }
        }
      }
    } else {
      el.currentNSMap = currentNSMap;
      el.localNSMap = localNSMap;
      return true;
    }
  }
  function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
    if (/^(?:script|textarea)$/i.test(tagName)) {
      var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
      var text = source.substring(elStartEnd + 1, elEndStart);
      if (/[&<]/.test(text)) {
        if (/^script$/i.test(tagName)) {
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
        text = text.replace(/&#?\w+;/g, entityReplacer);
        domBuilder.characters(text, 0, text.length);
        return elEndStart;
      }
    }
    return elStartEnd + 1;
  }
  function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
    var pos = closeMap[tagName];
    if (pos == null) {
      pos = source.lastIndexOf("</" + tagName + ">");
      if (pos < elStartEnd) {
        pos = source.lastIndexOf("</" + tagName);
      }
      closeMap[tagName] = pos;
    }
    return pos < elStartEnd;
  }
  function _copy(source, target) {
    for (var n in source) {
      if (Object.prototype.hasOwnProperty.call(source, n)) {
        target[n] = source[n];
      }
    }
  }
  function parseDCC(source, start, domBuilder, errorHandler) {
    var next = source.charAt(start + 2);
    switch (next) {
      case "-":
        if (source.charAt(start + 3) === "-") {
          var end = source.indexOf("-->", start + 4);
          if (end > start) {
            domBuilder.comment(source, start + 4, end - start - 4);
            return end + 3;
          } else {
            errorHandler.error("Unclosed comment");
            return -1;
          }
        } else {
          return -1;
        }
      default:
        if (source.substr(start + 3, 6) == "CDATA[") {
          var end = source.indexOf("]]>", start + 9);
          domBuilder.startCDATA();
          domBuilder.characters(source, start + 9, end - start - 9);
          domBuilder.endCDATA();
          return end + 3;
        }
        var matchs = split(source, start);
        var len = matchs.length;
        if (len > 1 && /!doctype/i.test(matchs[0][0])) {
          var name = matchs[1][0];
          var pubid = false;
          var sysid = false;
          if (len > 3) {
            if (/^public$/i.test(matchs[2][0])) {
              pubid = matchs[3][0];
              sysid = len > 4 && matchs[4][0];
            } else if (/^system$/i.test(matchs[2][0])) {
              sysid = matchs[3][0];
            }
          }
          var lastMatch = matchs[len - 1];
          domBuilder.startDTD(name, pubid, sysid);
          domBuilder.endDTD();
          return lastMatch.index + lastMatch[0].length;
        }
    }
    return -1;
  }
  function parseInstruction(source, start, domBuilder) {
    var end = source.indexOf("?>", start);
    if (end) {
      var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
      if (match) {
        match[0].length;
        domBuilder.processingInstruction(match[1], match[2]);
        return end + 2;
      } else {
        return -1;
      }
    }
    return -1;
  }
  function ElementAttributes() {
    this.attributeNames = {};
  }
  ElementAttributes.prototype = {
    setTagName: function(tagName) {
      if (!tagNamePattern.test(tagName)) {
        throw new Error("invalid tagName:" + tagName);
      }
      this.tagName = tagName;
    },
    addValue: function(qName, value, offset) {
      if (!tagNamePattern.test(qName)) {
        throw new Error("invalid attribute:" + qName);
      }
      this.attributeNames[qName] = this.length;
      this[this.length++] = {
        qName,
        value,
        offset
      };
    },
    length: 0,
    getLocalName: function(i) {
      return this[i].localName;
    },
    getLocator: function(i) {
      return this[i].locator;
    },
    getQName: function(i) {
      return this[i].qName;
    },
    getURI: function(i) {
      return this[i].uri;
    },
    getValue: function(i) {
      return this[i].value;
    }
    //	,getIndex:function(uri, localName)){
    //		if(localName){
    //
    //		}else{
    //			var qName = uri
    //		}
    //	},
    //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
    //	getType:function(uri,localName){}
    //	getType:function(i){},
  };
  function split(source, start) {
    var match;
    var buf = [];
    var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
    reg.lastIndex = start;
    reg.exec(source);
    while (match = reg.exec(source)) {
      buf.push(match);
      if (match[1])
        return buf;
    }
  }
  var XMLReader_1 = XMLReader$1;
  var ParseError_1 = ParseError$1;
  var sax = {
    XMLReader: XMLReader_1,
    ParseError: ParseError_1
  };
  var DOMImplementation = dom.DOMImplementation;
  var NAMESPACE = conventions.NAMESPACE;
  var ParseError = sax.ParseError;
  var XMLReader = sax.XMLReader;
  function normalizeLineEndings(input) {
    return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
  }
  function DOMParser$1(options) {
    this.options = options || {
      locator: {}
    };
  }
  DOMParser$1.prototype.parseFromString = function(source, mimeType) {
    var options = this.options;
    var sax2 = new XMLReader();
    var domBuilder = options.domBuilder || new DOMHandler();
    var errorHandler = options.errorHandler;
    var locator = options.locator;
    var defaultNSMap = options.xmlns || {};
    var isHTML = /\/x?html?$/.test(mimeType);
    var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
    if (locator) {
      domBuilder.setDocumentLocator(locator);
    }
    sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
    sax2.domBuilder = options.domBuilder || domBuilder;
    if (isHTML) {
      defaultNSMap[""] = NAMESPACE.HTML;
    }
    defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
    var normalize = options.normalizeLineEndings || normalizeLineEndings;
    if (source && typeof source === "string") {
      sax2.parse(normalize(source), defaultNSMap, entityMap);
    } else {
      sax2.errorHandler.error("invalid doc source");
    }
    return domBuilder.doc;
  };
  function buildErrorHandler(errorImpl, domBuilder, locator) {
    if (!errorImpl) {
      if (domBuilder instanceof DOMHandler) {
        return domBuilder;
      }
      errorImpl = domBuilder;
    }
    var errorHandler = {};
    var isCallback = errorImpl instanceof Function;
    locator = locator || {};
    function build(key) {
      var fn = errorImpl[key];
      if (!fn && isCallback) {
        fn = errorImpl.length == 2 ? function(msg) {
          errorImpl(key, msg);
        } : errorImpl;
      }
      errorHandler[key] = fn && function(msg) {
        fn("[xmldom " + key + "]	" + msg + _locator(locator));
      } || function() {
      };
    }
    build("warning");
    build("error");
    build("fatalError");
    return errorHandler;
  }
  function DOMHandler() {
    this.cdata = false;
  }
  function position(locator, node) {
    node.lineNumber = locator.lineNumber;
    node.columnNumber = locator.columnNumber;
  }
  DOMHandler.prototype = {
    startDocument: function() {
      this.doc = new DOMImplementation().createDocument(null, null, null);
      if (this.locator) {
        this.doc.documentURI = this.locator.systemId;
      }
    },
    startElement: function(namespaceURI, localName, qName, attrs) {
      var doc = this.doc;
      var el = doc.createElementNS(namespaceURI, qName || localName);
      var len = attrs.length;
      appendElement(this, el);
      this.currentElement = el;
      this.locator && position(this.locator, el);
      for (var i = 0; i < len; i++) {
        var namespaceURI = attrs.getURI(i);
        var value = attrs.getValue(i);
        var qName = attrs.getQName(i);
        var attr = doc.createAttributeNS(namespaceURI, qName);
        this.locator && position(attrs.getLocator(i), attr);
        attr.value = attr.nodeValue = value;
        el.setAttributeNode(attr);
      }
    },
    endElement: function(namespaceURI, localName, qName) {
      var current = this.currentElement;
      current.tagName;
      this.currentElement = current.parentNode;
    },
    startPrefixMapping: function(prefix, uri) {
    },
    endPrefixMapping: function(prefix) {
    },
    processingInstruction: function(target, data) {
      var ins = this.doc.createProcessingInstruction(target, data);
      this.locator && position(this.locator, ins);
      appendElement(this, ins);
    },
    ignorableWhitespace: function(ch, start, length) {
    },
    characters: function(chars, start, length) {
      chars = _toString.apply(this, arguments);
      if (chars) {
        if (this.cdata) {
          var charNode = this.doc.createCDATASection(chars);
        } else {
          var charNode = this.doc.createTextNode(chars);
        }
        if (this.currentElement) {
          this.currentElement.appendChild(charNode);
        } else if (/^\s*$/.test(chars)) {
          this.doc.appendChild(charNode);
        }
        this.locator && position(this.locator, charNode);
      }
    },
    skippedEntity: function(name) {
    },
    endDocument: function() {
      this.doc.normalize();
    },
    setDocumentLocator: function(locator) {
      if (this.locator = locator) {
        locator.lineNumber = 0;
      }
    },
    //LexicalHandler
    comment: function(chars, start, length) {
      chars = _toString.apply(this, arguments);
      var comm = this.doc.createComment(chars);
      this.locator && position(this.locator, comm);
      appendElement(this, comm);
    },
    startCDATA: function() {
      this.cdata = true;
    },
    endCDATA: function() {
      this.cdata = false;
    },
    startDTD: function(name, publicId, systemId) {
      var impl = this.doc.implementation;
      if (impl && impl.createDocumentType) {
        var dt = impl.createDocumentType(name, publicId, systemId);
        this.locator && position(this.locator, dt);
        appendElement(this, dt);
        this.doc.doctype = dt;
      }
    },
    /**
     * @see org.xml.sax.ErrorHandler
     * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
     */
    warning: function(error) {
      console.warn("[xmldom warning]	" + error, _locator(this.locator));
    },
    error: function(error) {
      console.error("[xmldom error]	" + error, _locator(this.locator));
    },
    fatalError: function(error) {
      throw new ParseError(error, this.locator);
    }
  };
  function _locator(l) {
    if (l) {
      return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
    }
  }
  function _toString(chars, start, length) {
    if (typeof chars == "string") {
      return chars.substr(start, length);
    } else {
      if (chars.length >= start + length || start) {
        return new java.lang.String(chars, start, length) + "";
      }
      return chars;
    }
  }
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
    DOMHandler.prototype[key] = function() {
      return null;
    };
  });
  function appendElement(hander, node) {
    if (!hander.currentElement) {
      hander.doc.appendChild(node);
    } else {
      hander.currentElement.appendChild(node);
    }
  }
  var __DOMHandler = DOMHandler;
  var normalizeLineEndings_1 = normalizeLineEndings;
  var DOMParser_1 = DOMParser$1;
  var domParser = {
    __DOMHandler,
    normalizeLineEndings: normalizeLineEndings_1,
    DOMParser: DOMParser_1
  };
  var DOMParser2 = domParser.DOMParser;
  /*! @name mpd-parser @version 1.3.0 @license Apache-2.0 */
  const isObject = (obj) => {
    return !!obj && typeof obj === "object";
  };
  const merge$1 = (...objects) => {
    return objects.reduce((result, source) => {
      if (typeof source !== "object") {
        return result;
      }
      Object.keys(source).forEach((key) => {
        if (Array.isArray(result[key]) && Array.isArray(source[key])) {
          result[key] = result[key].concat(source[key]);
        } else if (isObject(result[key]) && isObject(source[key])) {
          result[key] = merge$1(result[key], source[key]);
        } else {
          result[key] = source[key];
        }
      });
      return result;
    }, {});
  };
  const values = (o) => Object.keys(o).map((k) => o[k]);
  const range = (start, end) => {
    const result = [];
    for (let i = start; i < end; i++) {
      result.push(i);
    }
    return result;
  };
  const flatten = (lists) => lists.reduce((x, y) => x.concat(y), []);
  const from = (list) => {
    if (!list.length) {
      return [];
    }
    const result = [];
    for (let i = 0; i < list.length; i++) {
      result.push(list[i]);
    }
    return result;
  };
  const findIndexes = (l, key) => l.reduce((a, e, i) => {
    if (e[key]) {
      a.push(i);
    }
    return a;
  }, []);
  const union = (lists, keyFunction) => {
    return values(lists.reduce((acc, list) => {
      list.forEach((el) => {
        acc[keyFunction(el)] = el;
      });
      return acc;
    }, {}));
  };
  var errors = {
    INVALID_NUMBER_OF_PERIOD: "INVALID_NUMBER_OF_PERIOD",
    INVALID_NUMBER_OF_CONTENT_STEERING: "INVALID_NUMBER_OF_CONTENT_STEERING",
    DASH_EMPTY_MANIFEST: "DASH_EMPTY_MANIFEST",
    DASH_INVALID_XML: "DASH_INVALID_XML",
    NO_BASE_URL: "NO_BASE_URL",
    MISSING_SEGMENT_INFORMATION: "MISSING_SEGMENT_INFORMATION",
    SEGMENT_TIME_UNSPECIFIED: "SEGMENT_TIME_UNSPECIFIED",
    UNSUPPORTED_UTC_TIMING_SCHEME: "UNSUPPORTED_UTC_TIMING_SCHEME"
  };
  const urlTypeToSegment = ({
    baseUrl = "",
    source = "",
    range: range2 = "",
    indexRange = ""
  }) => {
    const segment = {
      uri: source,
      resolvedUri: resolveUrl$1(baseUrl || "", source)
    };
    if (range2 || indexRange) {
      const rangeStr = range2 ? range2 : indexRange;
      const ranges = rangeStr.split("-");
      let startRange = window.BigInt ? window.BigInt(ranges[0]) : parseInt(ranges[0], 10);
      let endRange = window.BigInt ? window.BigInt(ranges[1]) : parseInt(ranges[1], 10);
      if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === "bigint") {
        startRange = Number(startRange);
      }
      if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === "bigint") {
        endRange = Number(endRange);
      }
      let length;
      if (typeof endRange === "bigint" || typeof startRange === "bigint") {
        length = window.BigInt(endRange) - window.BigInt(startRange) + window.BigInt(1);
      } else {
        length = endRange - startRange + 1;
      }
      if (typeof length === "bigint" && length < Number.MAX_SAFE_INTEGER) {
        length = Number(length);
      }
      segment.byterange = {
        length,
        offset: startRange
      };
    }
    return segment;
  };
  const byteRangeToString = (byterange) => {
    let endRange;
    if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") {
      endRange = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);
    } else {
      endRange = byterange.offset + byterange.length - 1;
    }
    return `${byterange.offset}-${endRange}`;
  };
  const parseEndNumber = (endNumber) => {
    if (endNumber && typeof endNumber !== "number") {
      endNumber = parseInt(endNumber, 10);
    }
    if (isNaN(endNumber)) {
      return null;
    }
    return endNumber;
  };
  const segmentRange = {
    /**
     * Returns the entire range of available segments for a static MPD
     *
     * @param {Object} attributes
     *        Inheritied MPD attributes
     * @return {{ start: number, end: number }}
     *         The start and end numbers for available segments
     */
    static(attributes) {
      const {
        duration: duration2,
        timescale = 1,
        sourceDuration,
        periodDuration
      } = attributes;
      const endNumber = parseEndNumber(attributes.endNumber);
      const segmentDuration = duration2 / timescale;
      if (typeof endNumber === "number") {
        return {
          start: 0,
          end: endNumber
        };
      }
      if (typeof periodDuration === "number") {
        return {
          start: 0,
          end: periodDuration / segmentDuration
        };
      }
      return {
        start: 0,
        end: sourceDuration / segmentDuration
      };
    },
    /**
     * Returns the current live window range of available segments for a dynamic MPD
     *
     * @param {Object} attributes
     *        Inheritied MPD attributes
     * @return {{ start: number, end: number }}
     *         The start and end numbers for available segments
     */
    dynamic(attributes) {
      const {
        NOW,
        clientOffset,
        availabilityStartTime,
        timescale = 1,
        duration: duration2,
        periodStart = 0,
        minimumUpdatePeriod = 0,
        timeShiftBufferDepth = Infinity
      } = attributes;
      const endNumber = parseEndNumber(attributes.endNumber);
      const now = (NOW + clientOffset) / 1e3;
      const periodStartWC = availabilityStartTime + periodStart;
      const periodEndWC = now + minimumUpdatePeriod;
      const periodDuration = periodEndWC - periodStartWC;
      const segmentCount = Math.ceil(periodDuration * timescale / duration2);
      const availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration2);
      const availableEnd = Math.floor((now - periodStartWC) * timescale / duration2);
      return {
        start: Math.max(0, availableStart),
        end: typeof endNumber === "number" ? endNumber : Math.min(segmentCount, availableEnd)
      };
    }
  };
  const toSegments = (attributes) => (number) => {
    const {
      duration: duration2,
      timescale = 1,
      periodStart,
      startNumber = 1
    } = attributes;
    return {
      number: startNumber + number,
      duration: duration2 / timescale,
      timeline: periodStart,
      time: number * duration2
    };
  };
  const parseByDuration = (attributes) => {
    const {
      type,
      duration: duration2,
      timescale = 1,
      periodDuration,
      sourceDuration
    } = attributes;
    const {
      start,
      end
    } = segmentRange[type](attributes);
    const segments = range(start, end).map(toSegments(attributes));
    if (type === "static") {
      const index = segments.length - 1;
      const sectionDuration = typeof periodDuration === "number" ? periodDuration : sourceDuration;
      segments[index].duration = sectionDuration - duration2 / timescale * index;
    }
    return segments;
  };
  const segmentsFromBase = (attributes) => {
    const {
      baseUrl,
      initialization = {},
      sourceDuration,
      indexRange = "",
      periodStart,
      presentationTime,
      number = 0,
      duration: duration2
    } = attributes;
    if (!baseUrl) {
      throw new Error(errors.NO_BASE_URL);
    }
    const initSegment = urlTypeToSegment({
      baseUrl,
      source: initialization.sourceURL,
      range: initialization.range
    });
    const segment = urlTypeToSegment({
      baseUrl,
      source: baseUrl,
      indexRange
    });
    segment.map = initSegment;
    if (duration2) {
      const segmentTimeInfo = parseByDuration(attributes);
      if (segmentTimeInfo.length) {
        segment.duration = segmentTimeInfo[0].duration;
        segment.timeline = segmentTimeInfo[0].timeline;
      }
    } else if (sourceDuration) {
      segment.duration = sourceDuration;
      segment.timeline = periodStart;
    }
    segment.presentationTime = presentationTime || periodStart;
    segment.number = number;
    return [segment];
  };
  const addSidxSegmentsToPlaylist$1 = (playlist, sidx, baseUrl) => {
    const initSegment = playlist.sidx.map ? playlist.sidx.map : null;
    const sourceDuration = playlist.sidx.duration;
    const timeline = playlist.timeline || 0;
    const sidxByteRange = playlist.sidx.byterange;
    const sidxEnd = sidxByteRange.offset + sidxByteRange.length;
    const timescale = sidx.timescale;
    const mediaReferences = sidx.references.filter((r) => r.referenceType !== 1);
    const segments = [];
    const type = playlist.endList ? "static" : "dynamic";
    const periodStart = playlist.sidx.timeline;
    let presentationTime = periodStart;
    let number = playlist.mediaSequence || 0;
    let startIndex;
    if (typeof sidx.firstOffset === "bigint") {
      startIndex = window.BigInt(sidxEnd) + sidx.firstOffset;
    } else {
      startIndex = sidxEnd + sidx.firstOffset;
    }
    for (let i = 0; i < mediaReferences.length; i++) {
      const reference = sidx.references[i];
      const size = reference.referencedSize;
      const duration2 = reference.subsegmentDuration;
      let endIndex;
      if (typeof startIndex === "bigint") {
        endIndex = startIndex + window.BigInt(size) - window.BigInt(1);
      } else {
        endIndex = startIndex + size - 1;
      }
      const indexRange = `${startIndex}-${endIndex}`;
      const attributes = {
        baseUrl,
        timescale,
        timeline,
        periodStart,
        presentationTime,
        number,
        duration: duration2,
        sourceDuration,
        indexRange,
        type
      };
      const segment = segmentsFromBase(attributes)[0];
      if (initSegment) {
        segment.map = initSegment;
      }
      segments.push(segment);
      if (typeof startIndex === "bigint") {
        startIndex += window.BigInt(size);
      } else {
        startIndex += size;
      }
      presentationTime += duration2 / timescale;
      number++;
    }
    playlist.segments = segments;
    return playlist;
  };
  const SUPPORTED_MEDIA_TYPES = ["AUDIO", "SUBTITLES"];
  const TIME_FUDGE = 1 / 60;
  const getUniqueTimelineStarts = (timelineStarts) => {
    return union(timelineStarts, ({
      timeline
    }) => timeline).sort((a, b) => a.timeline > b.timeline ? 1 : -1);
  };
  const findPlaylistWithName = (playlists, name) => {
    for (let i = 0; i < playlists.length; i++) {
      if (playlists[i].attributes.NAME === name) {
        return playlists[i];
      }
    }
    return null;
  };
  const getMediaGroupPlaylists = (manifest) => {
    let mediaGroupPlaylists = [];
    forEachMediaGroup$1(manifest, SUPPORTED_MEDIA_TYPES, (properties, type, group, label) => {
      mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);
    });
    return mediaGroupPlaylists;
  };
  const updateMediaSequenceForPlaylist = ({
    playlist,
    mediaSequence
  }) => {
    playlist.mediaSequence = mediaSequence;
    playlist.segments.forEach((segment, index) => {
      segment.number = playlist.mediaSequence + index;
    });
  };
  const updateSequenceNumbers = ({
    oldPlaylists,
    newPlaylists,
    timelineStarts
  }) => {
    newPlaylists.forEach((playlist) => {
      playlist.discontinuitySequence = timelineStarts.findIndex(function({
        timeline
      }) {
        return timeline === playlist.timeline;
      });
      const oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);
      if (!oldPlaylist) {
        return;
      }
      if (playlist.sidx) {
        return;
      }
      const firstNewSegment = playlist.segments[0];
      const oldMatchingSegmentIndex = oldPlaylist.segments.findIndex(function(oldSegment) {
        return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;
      });
      if (oldMatchingSegmentIndex === -1) {
        updateMediaSequenceForPlaylist({
          playlist,
          mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length
        });
        playlist.segments[0].discontinuity = true;
        playlist.discontinuityStarts.unshift(0);
        if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {
          playlist.discontinuitySequence--;
        }
        return;
      }
      const oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];
      if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {
        firstNewSegment.discontinuity = true;
        playlist.discontinuityStarts.unshift(0);
        playlist.discontinuitySequence--;
      }
      updateMediaSequenceForPlaylist({
        playlist,
        mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number
      });
    });
  };
  const positionManifestOnTimeline = ({
    oldManifest,
    newManifest
  }) => {
    const oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));
    const newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest));
    newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);
    updateSequenceNumbers({
      oldPlaylists,
      newPlaylists,
      timelineStarts: newManifest.timelineStarts
    });
    return newManifest;
  };
  const generateSidxKey = (sidx) => sidx && sidx.uri + "-" + byteRangeToString(sidx.byterange);
  const mergeDiscontiguousPlaylists = (playlists) => {
    const playlistsByBaseUrl = playlists.reduce(function(acc, cur) {
      if (!acc[cur.attributes.baseUrl]) {
        acc[cur.attributes.baseUrl] = [];
      }
      acc[cur.attributes.baseUrl].push(cur);
      return acc;
    }, {});
    let allPlaylists = [];
    Object.values(playlistsByBaseUrl).forEach((playlistGroup) => {
      const mergedPlaylists = values(playlistGroup.reduce((acc, playlist) => {
        const name = playlist.attributes.id + (playlist.attributes.lang || "");
        if (!acc[name]) {
          acc[name] = playlist;
          acc[name].attributes.timelineStarts = [];
        } else {
          if (playlist.segments) {
            if (playlist.segments[0]) {
              playlist.segments[0].discontinuity = true;
            }
            acc[name].segments.push(...playlist.segments);
          }
          if (playlist.attributes.contentProtection) {
            acc[name].attributes.contentProtection = playlist.attributes.contentProtection;
          }
        }
        acc[name].attributes.timelineStarts.push({
          // Although they represent the same number, it's important to have both to make it
          // compatible with HLS potentially having a similar attribute.
          start: playlist.attributes.periodStart,
          timeline: playlist.attributes.periodStart
        });
        return acc;
      }, {}));
      allPlaylists = allPlaylists.concat(mergedPlaylists);
    });
    return allPlaylists.map((playlist) => {
      playlist.discontinuityStarts = findIndexes(playlist.segments || [], "discontinuity");
      return playlist;
    });
  };
  const addSidxSegmentsToPlaylist = (playlist, sidxMapping) => {
    const sidxKey = generateSidxKey(playlist.sidx);
    const sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;
    if (sidxMatch) {
      addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);
    }
    return playlist;
  };
  const addSidxSegmentsToPlaylists = (playlists, sidxMapping = {}) => {
    if (!Object.keys(sidxMapping).length) {
      return playlists;
    }
    for (const i in playlists) {
      playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);
    }
    return playlists;
  };
  const formatAudioPlaylist = ({
    attributes,
    segments,
    sidx,
    mediaSequence,
    discontinuitySequence,
    discontinuityStarts
  }, isAudioOnly2) => {
    const playlist = {
      attributes: {
        NAME: attributes.id,
        BANDWIDTH: attributes.bandwidth,
        CODECS: attributes.codecs,
        ["PROGRAM-ID"]: 1
      },
      uri: "",
      endList: attributes.type === "static",
      timeline: attributes.periodStart,
      resolvedUri: attributes.baseUrl || "",
      targetDuration: attributes.duration,
      discontinuitySequence,
      discontinuityStarts,
      timelineStarts: attributes.timelineStarts,
      mediaSequence,
      segments
    };
    if (attributes.contentProtection) {
      playlist.contentProtection = attributes.contentProtection;
    }
    if (attributes.serviceLocation) {
      playlist.attributes.serviceLocation = attributes.serviceLocation;
    }
    if (sidx) {
      playlist.sidx = sidx;
    }
    if (isAudioOnly2) {
      playlist.attributes.AUDIO = "audio";
      playlist.attributes.SUBTITLES = "subs";
    }
    return playlist;
  };
  const formatVttPlaylist = ({
    attributes,
    segments,
    mediaSequence,
    discontinuityStarts,
    discontinuitySequence
  }) => {
    if (typeof segments === "undefined") {
      segments = [{
        uri: attributes.baseUrl,
        timeline: attributes.periodStart,
        resolvedUri: attributes.baseUrl || "",
        duration: attributes.sourceDuration,
        number: 0
      }];
      attributes.duration = attributes.sourceDuration;
    }
    const m3u8Attributes = {
      NAME: attributes.id,
      BANDWIDTH: attributes.bandwidth,
      ["PROGRAM-ID"]: 1
    };
    if (attributes.codecs) {
      m3u8Attributes.CODECS = attributes.codecs;
    }
    const vttPlaylist = {
      attributes: m3u8Attributes,
      uri: "",
      endList: attributes.type === "static",
      timeline: attributes.periodStart,
      resolvedUri: attributes.baseUrl || "",
      targetDuration: attributes.duration,
      timelineStarts: attributes.timelineStarts,
      discontinuityStarts,
      discontinuitySequence,
      mediaSequence,
      segments
    };
    if (attributes.serviceLocation) {
      vttPlaylist.attributes.serviceLocation = attributes.serviceLocation;
    }
    return vttPlaylist;
  };
  const organizeAudioPlaylists = (playlists, sidxMapping = {}, isAudioOnly2 = false) => {
    let mainPlaylist;
    const formattedPlaylists = playlists.reduce((a, playlist) => {
      const role = playlist.attributes.role && playlist.attributes.role.value || "";
      const language = playlist.attributes.lang || "";
      let label = playlist.attributes.label || "main";
      if (language && !playlist.attributes.label) {
        const roleLabel = role ? ` (${role})` : "";
        label = `${playlist.attributes.lang}${roleLabel}`;
      }
      if (!a[label]) {
        a[label] = {
          language,
          autoselect: true,
          default: role === "main",
          playlists: [],
          uri: ""
        };
      }
      const formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly2), sidxMapping);
      a[label].playlists.push(formatted);
      if (typeof mainPlaylist === "undefined" && role === "main") {
        mainPlaylist = playlist;
        mainPlaylist.default = true;
      }
      return a;
    }, {});
    if (!mainPlaylist) {
      const firstLabel = Object.keys(formattedPlaylists)[0];
      formattedPlaylists[firstLabel].default = true;
    }
    return formattedPlaylists;
  };
  const organizeVttPlaylists = (playlists, sidxMapping = {}) => {
    return playlists.reduce((a, playlist) => {
      const label = playlist.attributes.label || playlist.attributes.lang || "text";
      if (!a[label]) {
        a[label] = {
          language: label,
          default: false,
          autoselect: false,
          playlists: [],
          uri: ""
        };
      }
      a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));
      return a;
    }, {});
  };
  const organizeCaptionServices = (captionServices) => captionServices.reduce((svcObj, svc) => {
    if (!svc) {
      return svcObj;
    }
    svc.forEach((service) => {
      const {
        channel,
        language
      } = service;
      svcObj[language] = {
        autoselect: false,
        default: false,
        instreamId: channel,
        language
      };
      if (service.hasOwnProperty("aspectRatio")) {
        svcObj[language].aspectRatio = service.aspectRatio;
      }
      if (service.hasOwnProperty("easyReader")) {
        svcObj[language].easyReader = service.easyReader;
      }
      if (service.hasOwnProperty("3D")) {
        svcObj[language]["3D"] = service["3D"];
      }
    });
    return svcObj;
  }, {});
  const formatVideoPlaylist = ({
    attributes,
    segments,
    sidx,
    discontinuityStarts
  }) => {
    const playlist = {
      attributes: {
        NAME: attributes.id,
        AUDIO: "audio",
        SUBTITLES: "subs",
        RESOLUTION: {
          width: attributes.width,
          height: attributes.height
        },
        CODECS: attributes.codecs,
        BANDWIDTH: attributes.bandwidth,
        ["PROGRAM-ID"]: 1
      },
      uri: "",
      endList: attributes.type === "static",
      timeline: attributes.periodStart,
      resolvedUri: attributes.baseUrl || "",
      targetDuration: attributes.duration,
      discontinuityStarts,
      timelineStarts: attributes.timelineStarts,
      segments
    };
    if (attributes.frameRate) {
      playlist.attributes["FRAME-RATE"] = attributes.frameRate;
    }
    if (attributes.contentProtection) {
      playlist.contentProtection = attributes.contentProtection;
    }
    if (attributes.serviceLocation) {
      playlist.attributes.serviceLocation = attributes.serviceLocation;
    }
    if (sidx) {
      playlist.sidx = sidx;
    }
    return playlist;
  };
  const videoOnly = ({
    attributes
  }) => attributes.mimeType === "video/mp4" || attributes.mimeType === "video/webm" || attributes.contentType === "video";
  const audioOnly = ({
    attributes
  }) => attributes.mimeType === "audio/mp4" || attributes.mimeType === "audio/webm" || attributes.contentType === "audio";
  const vttOnly = ({
    attributes
  }) => attributes.mimeType === "text/vtt" || attributes.contentType === "text";
  const addMediaSequenceValues = (playlists, timelineStarts) => {
    playlists.forEach((playlist) => {
      playlist.mediaSequence = 0;
      playlist.discontinuitySequence = timelineStarts.findIndex(function({
        timeline
      }) {
        return timeline === playlist.timeline;
      });
      if (!playlist.segments) {
        return;
      }
      playlist.segments.forEach((segment, index) => {
        segment.number = index;
      });
    });
  };
  const flattenMediaGroupPlaylists = (mediaGroupObject) => {
    if (!mediaGroupObject) {
      return [];
    }
    return Object.keys(mediaGroupObject).reduce((acc, label) => {
      const labelContents = mediaGroupObject[label];
      return acc.concat(labelContents.playlists);
    }, []);
  };
  const toM3u8 = ({
    dashPlaylists,
    locations,
    contentSteering,
    sidxMapping = {},
    previousManifest,
    eventStream
  }) => {
    if (!dashPlaylists.length) {
      return {};
    }
    const {
      sourceDuration: duration2,
      type,
      suggestedPresentationDelay,
      minimumUpdatePeriod
    } = dashPlaylists[0].attributes;
    const videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);
    const audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));
    const vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));
    const captions = dashPlaylists.map((playlist) => playlist.attributes.captionServices).filter(Boolean);
    const manifest = {
      allowCache: true,
      discontinuityStarts: [],
      segments: [],
      endList: true,
      mediaGroups: {
        AUDIO: {},
        VIDEO: {},
        ["CLOSED-CAPTIONS"]: {},
        SUBTITLES: {}
      },
      uri: "",
      duration: duration2,
      playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)
    };
    if (minimumUpdatePeriod >= 0) {
      manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1e3;
    }
    if (locations) {
      manifest.locations = locations;
    }
    if (contentSteering) {
      manifest.contentSteering = contentSteering;
    }
    if (type === "dynamic") {
      manifest.suggestedPresentationDelay = suggestedPresentationDelay;
    }
    if (eventStream && eventStream.length > 0) {
      manifest.eventStream = eventStream;
    }
    const isAudioOnly2 = manifest.playlists.length === 0;
    const organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly2) : null;
    const organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;
    const formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));
    const playlistTimelineStarts = formattedPlaylists.map(({
      timelineStarts
    }) => timelineStarts);
    manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);
    addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);
    if (organizedAudioGroup) {
      manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;
    }
    if (organizedVttGroup) {
      manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;
    }
    if (captions.length) {
      manifest.mediaGroups["CLOSED-CAPTIONS"].cc = organizeCaptionServices(captions);
    }
    if (previousManifest) {
      return positionManifestOnTimeline({
        oldManifest: previousManifest,
        newManifest: manifest
      });
    }
    return manifest;
  };
  const getLiveRValue = (attributes, time, duration2) => {
    const {
      NOW,
      clientOffset,
      availabilityStartTime,
      timescale = 1,
      periodStart = 0,
      minimumUpdatePeriod = 0
    } = attributes;
    const now = (NOW + clientOffset) / 1e3;
    const periodStartWC = availabilityStartTime + periodStart;
    const periodEndWC = now + minimumUpdatePeriod;
    const periodDuration = periodEndWC - periodStartWC;
    return Math.ceil((periodDuration * timescale - time) / duration2);
  };
  const parseByTimeline = (attributes, segmentTimeline) => {
    const {
      type,
      minimumUpdatePeriod = 0,
      media = "",
      sourceDuration,
      timescale = 1,
      startNumber = 1,
      periodStart: timeline
    } = attributes;
    const segments = [];
    let time = -1;
    for (let sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {
      const S = segmentTimeline[sIndex];
      const duration2 = S.d;
      const repeat = S.r || 0;
      const segmentTime = S.t || 0;
      if (time < 0) {
        time = segmentTime;
      }
      if (segmentTime && segmentTime > time) {
        time = segmentTime;
      }
      let count;
      if (repeat < 0) {
        const nextS = sIndex + 1;
        if (nextS === segmentTimeline.length) {
          if (type === "dynamic" && minimumUpdatePeriod > 0 && media.indexOf("$Number$") > 0) {
            count = getLiveRValue(attributes, time, duration2);
          } else {
            count = (sourceDuration * timescale - time) / duration2;
          }
        } else {
          count = (segmentTimeline[nextS].t - time) / duration2;
        }
      } else {
        count = repeat + 1;
      }
      const end = startNumber + segments.length + count;
      let number = startNumber + segments.length;
      while (number < end) {
        segments.push({
          number,
          duration: duration2 / timescale,
          time,
          timeline
        });
        time += duration2;
        number++;
      }
    }
    return segments;
  };
  const identifierPattern = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g;
  const identifierReplacement = (values2) => (match, identifier, format, width) => {
    if (match === "$$") {
      return "$";
    }
    if (typeof values2[identifier] === "undefined") {
      return match;
    }
    const value = "" + values2[identifier];
    if (identifier === "RepresentationID") {
      return value;
    }
    if (!format) {
      width = 1;
    } else {
      width = parseInt(width, 10);
    }
    if (value.length >= width) {
      return value;
    }
    return `${new Array(width - value.length + 1).join("0")}${value}`;
  };
  const constructTemplateUrl = (url, values2) => url.replace(identifierPattern, identifierReplacement(values2));
  const parseTemplateInfo = (attributes, segmentTimeline) => {
    if (!attributes.duration && !segmentTimeline) {
      return [{
        number: attributes.startNumber || 1,
        duration: attributes.sourceDuration,
        time: 0,
        timeline: attributes.periodStart
      }];
    }
    if (attributes.duration) {
      return parseByDuration(attributes);
    }
    return parseByTimeline(attributes, segmentTimeline);
  };
  const segmentsFromTemplate = (attributes, segmentTimeline) => {
    const templateValues = {
      RepresentationID: attributes.id,
      Bandwidth: attributes.bandwidth || 0
    };
    const {
      initialization = {
        sourceURL: "",
        range: ""
      }
    } = attributes;
    const mapSegment = urlTypeToSegment({
      baseUrl: attributes.baseUrl,
      source: constructTemplateUrl(initialization.sourceURL, templateValues),
      range: initialization.range
    });
    const segments = parseTemplateInfo(attributes, segmentTimeline);
    return segments.map((segment) => {
      templateValues.Number = segment.number;
      templateValues.Time = segment.time;
      const uri = constructTemplateUrl(attributes.media || "", templateValues);
      const timescale = attributes.timescale || 1;
      const presentationTimeOffset = attributes.presentationTimeOffset || 0;
      const presentationTime = (
        // Even if the @t attribute is not specified for the segment, segment.time is
        // calculated in mpd-parser prior to this, so it's assumed to be available.
        attributes.periodStart + (segment.time - presentationTimeOffset) / timescale
      );
      const map = {
        uri,
        timeline: segment.timeline,
        duration: segment.duration,
        resolvedUri: resolveUrl$1(attributes.baseUrl || "", uri),
        map: mapSegment,
        number: segment.number,
        presentationTime
      };
      return map;
    });
  };
  const SegmentURLToSegmentObject = (attributes, segmentUrl) => {
    const {
      baseUrl,
      initialization = {}
    } = attributes;
    const initSegment = urlTypeToSegment({
      baseUrl,
      source: initialization.sourceURL,
      range: initialization.range
    });
    const segment = urlTypeToSegment({
      baseUrl,
      source: segmentUrl.media,
      range: segmentUrl.mediaRange
    });
    segment.map = initSegment;
    return segment;
  };
  const segmentsFromList = (attributes, segmentTimeline) => {
    const {
      duration: duration2,
      segmentUrls = [],
      periodStart
    } = attributes;
    if (!duration2 && !segmentTimeline || duration2 && segmentTimeline) {
      throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);
    }
    const segmentUrlMap = segmentUrls.map((segmentUrlObject) => SegmentURLToSegmentObject(attributes, segmentUrlObject));
    let segmentTimeInfo;
    if (duration2) {
      segmentTimeInfo = parseByDuration(attributes);
    }
    if (segmentTimeline) {
      segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);
    }
    const segments = segmentTimeInfo.map((segmentTime, index) => {
      if (segmentUrlMap[index]) {
        const segment = segmentUrlMap[index];
        const timescale = attributes.timescale || 1;
        const presentationTimeOffset = attributes.presentationTimeOffset || 0;
        segment.timeline = segmentTime.timeline;
        segment.duration = segmentTime.duration;
        segment.number = segmentTime.number;
        segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;
        return segment;
      }
    }).filter((segment) => segment);
    return segments;
  };
  const generateSegments = ({
    attributes,
    segmentInfo
  }) => {
    let segmentAttributes;
    let segmentsFn;
    if (segmentInfo.template) {
      segmentsFn = segmentsFromTemplate;
      segmentAttributes = merge$1(attributes, segmentInfo.template);
    } else if (segmentInfo.base) {
      segmentsFn = segmentsFromBase;
      segmentAttributes = merge$1(attributes, segmentInfo.base);
    } else if (segmentInfo.list) {
      segmentsFn = segmentsFromList;
      segmentAttributes = merge$1(attributes, segmentInfo.list);
    }
    const segmentsInfo = {
      attributes
    };
    if (!segmentsFn) {
      return segmentsInfo;
    }
    const segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline);
    if (segmentAttributes.duration) {
      const {
        duration: duration2,
        timescale = 1
      } = segmentAttributes;
      segmentAttributes.duration = duration2 / timescale;
    } else if (segments.length) {
      segmentAttributes.duration = segments.reduce((max, segment) => {
        return Math.max(max, Math.ceil(segment.duration));
      }, 0);
    } else {
      segmentAttributes.duration = 0;
    }
    segmentsInfo.attributes = segmentAttributes;
    segmentsInfo.segments = segments;
    if (segmentInfo.base && segmentAttributes.indexRange) {
      segmentsInfo.sidx = segments[0];
      segmentsInfo.segments = [];
    }
    return segmentsInfo;
  };
  const toPlaylists = (representations) => representations.map(generateSegments);
  const findChildren = (element, name) => from(element.childNodes).filter(({
    tagName
  }) => tagName === name);
  const getContent = (element) => element.textContent.trim();
  const parseDivisionValue = (value) => {
    return parseFloat(value.split("/").reduce((prev, current) => prev / current));
  };
  const parseDuration = (str) => {
    const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
    const SECONDS_IN_MONTH = 30 * 24 * 60 * 60;
    const SECONDS_IN_DAY = 24 * 60 * 60;
    const SECONDS_IN_HOUR = 60 * 60;
    const SECONDS_IN_MIN = 60;
    const durationRegex = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/;
    const match = durationRegex.exec(str);
    if (!match) {
      return 0;
    }
    const [year, month, day, hour, minute, second] = match.slice(1);
    return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);
  };
  const parseDate = (str) => {
    const dateRegex = /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/;
    if (dateRegex.test(str)) {
      str += "Z";
    }
    return Date.parse(str);
  };
  const parsers = {
    /**
     * Specifies the duration of the entire Media Presentation. Format is a duration string
     * as specified in ISO 8601
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The duration in seconds
     */
    mediaPresentationDuration(value) {
      return parseDuration(value);
    },
    /**
     * Specifies the Segment availability start time for all Segments referred to in this
     * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability
     * time. Format is a date string as specified in ISO 8601
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The date as seconds from unix epoch
     */
    availabilityStartTime(value) {
      return parseDate(value) / 1e3;
    },
    /**
     * Specifies the smallest period between potential changes to the MPD. Format is a
     * duration string as specified in ISO 8601
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The duration in seconds
     */
    minimumUpdatePeriod(value) {
      return parseDuration(value);
    },
    /**
     * Specifies the suggested presentation delay. Format is a
     * duration string as specified in ISO 8601
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The duration in seconds
     */
    suggestedPresentationDelay(value) {
      return parseDuration(value);
    },
    /**
     * specifices the type of mpd. Can be either "static" or "dynamic"
     *
     * @param {string} value
     *        value of attribute as a string
     *
     * @return {string}
     *         The type as a string
     */
    type(value) {
      return value;
    },
    /**
     * Specifies the duration of the smallest time shifting buffer for any Representation
     * in the MPD. Format is a duration string as specified in ISO 8601
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The duration in seconds
     */
    timeShiftBufferDepth(value) {
      return parseDuration(value);
    },
    /**
     * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.
     * Format is a duration string as specified in ISO 8601
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The duration in seconds
     */
    start(value) {
      return parseDuration(value);
    },
    /**
     * Specifies the width of the visual presentation
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The parsed width
     */
    width(value) {
      return parseInt(value, 10);
    },
    /**
     * Specifies the height of the visual presentation
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The parsed height
     */
    height(value) {
      return parseInt(value, 10);
    },
    /**
     * Specifies the bitrate of the representation
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The parsed bandwidth
     */
    bandwidth(value) {
      return parseInt(value, 10);
    },
    /**
     * Specifies the frame rate of the representation
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The parsed frame rate
     */
    frameRate(value) {
      return parseDivisionValue(value);
    },
    /**
     * Specifies the number of the first Media Segment in this Representation in the Period
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The parsed number
     */
    startNumber(value) {
      return parseInt(value, 10);
    },
    /**
     * Specifies the timescale in units per seconds
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The parsed timescale
     */
    timescale(value) {
      return parseInt(value, 10);
    },
    /**
     * Specifies the presentationTimeOffset.
     *
     * @param {string} value
     *        value of the attribute as a string
     *
     * @return {number}
     *         The parsed presentationTimeOffset
     */
    presentationTimeOffset(value) {
      return parseInt(value, 10);
    },
    /**
     * Specifies the constant approximate Segment duration
     * NOTE: The <Period> element also contains an @duration attribute. This duration
     *       specifies the duration of the Period. This attribute is currently not
     *       supported by the rest of the parser, however we still check for it to prevent
     *       errors.
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The parsed duration
     */
    duration(value) {
      const parsedValue = parseInt(value, 10);
      if (isNaN(parsedValue)) {
        return parseDuration(value);
      }
      return parsedValue;
    },
    /**
     * Specifies the Segment duration, in units of the value of the @timescale.
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The parsed duration
     */
    d(value) {
      return parseInt(value, 10);
    },
    /**
     * Specifies the MPD start time, in @timescale units, the first Segment in the series
     * starts relative to the beginning of the Period
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The parsed time
     */
    t(value) {
      return parseInt(value, 10);
    },
    /**
     * Specifies the repeat count of the number of following contiguous Segments with the
     * same duration expressed by the value of @d
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {number}
     *         The parsed number
     */
    r(value) {
      return parseInt(value, 10);
    },
    /**
     * Specifies the presentationTime.
     *
     * @param {string} value
     *        value of the attribute as a string
     *
     * @return {number}
     *         The parsed presentationTime
     */
    presentationTime(value) {
      return parseInt(value, 10);
    },
    /**
     * Default parser for all other attributes. Acts as a no-op and just returns the value
     * as a string
     *
     * @param {string} value
     *        value of attribute as a string
     * @return {string}
     *         Unparsed value
     */
    DEFAULT(value) {
      return value;
    }
  };
  const parseAttributes = (el) => {
    if (!(el && el.attributes)) {
      return {};
    }
    return from(el.attributes).reduce((a, e) => {
      const parseFn = parsers[e.name] || parsers.DEFAULT;
      a[e.name] = parseFn(e.value);
      return a;
    }, {});
  };
  const keySystemsMap = {
    "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
    "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
    "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
    "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime",
    // ISO_IEC 23009-1_2022 5.8.5.2.2 The mp4 Protection Scheme
    "urn:mpeg:dash:mp4protection:2011": "mp4protection"
  };
  const buildBaseUrls = (references, baseUrlElements) => {
    if (!baseUrlElements.length) {
      return references;
    }
    return flatten(references.map(function(reference) {
      return baseUrlElements.map(function(baseUrlElement) {
        const initialBaseUrl = getContent(baseUrlElement);
        const resolvedBaseUrl = resolveUrl$1(reference.baseUrl, initialBaseUrl);
        const finalBaseUrl = merge$1(parseAttributes(baseUrlElement), {
          baseUrl: resolvedBaseUrl
        });
        if (resolvedBaseUrl !== initialBaseUrl && !finalBaseUrl.serviceLocation && reference.serviceLocation) {
          finalBaseUrl.serviceLocation = reference.serviceLocation;
        }
        return finalBaseUrl;
      });
    }));
  };
  const getSegmentInformation = (adaptationSet) => {
    const segmentTemplate = findChildren(adaptationSet, "SegmentTemplate")[0];
    const segmentList = findChildren(adaptationSet, "SegmentList")[0];
    const segmentUrls = segmentList && findChildren(segmentList, "SegmentURL").map((s) => merge$1({
      tag: "SegmentURL"
    }, parseAttributes(s)));
    const segmentBase = findChildren(adaptationSet, "SegmentBase")[0];
    const segmentTimelineParentNode = segmentList || segmentTemplate;
    const segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, "SegmentTimeline")[0];
    const segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;
    const segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, "Initialization")[0];
    const template = segmentTemplate && parseAttributes(segmentTemplate);
    if (template && segmentInitialization) {
      template.initialization = segmentInitialization && parseAttributes(segmentInitialization);
    } else if (template && template.initialization) {
      template.initialization = {
        sourceURL: template.initialization
      };
    }
    const segmentInfo = {
      template,
      segmentTimeline: segmentTimeline && findChildren(segmentTimeline, "S").map((s) => parseAttributes(s)),
      list: segmentList && merge$1(parseAttributes(segmentList), {
        segmentUrls,
        initialization: parseAttributes(segmentInitialization)
      }),
      base: segmentBase && merge$1(parseAttributes(segmentBase), {
        initialization: parseAttributes(segmentInitialization)
      })
    };
    Object.keys(segmentInfo).forEach((key) => {
      if (!segmentInfo[key]) {
        delete segmentInfo[key];
      }
    });
    return segmentInfo;
  };
  const inheritBaseUrls = (adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) => (representation) => {
    const repBaseUrlElements = findChildren(representation, "BaseURL");
    const repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);
    const attributes = merge$1(adaptationSetAttributes, parseAttributes(representation));
    const representationSegmentInfo = getSegmentInformation(representation);
    return repBaseUrls.map((baseUrl) => {
      return {
        segmentInfo: merge$1(adaptationSetSegmentInfo, representationSegmentInfo),
        attributes: merge$1(attributes, baseUrl)
      };
    });
  };
  const generateKeySystemInformation = (contentProtectionNodes) => {
    return contentProtectionNodes.reduce((acc, node) => {
      const attributes = parseAttributes(node);
      if (attributes.schemeIdUri) {
        attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();
      }
      const keySystem = keySystemsMap[attributes.schemeIdUri];
      if (keySystem) {
        acc[keySystem] = {
          attributes
        };
        const psshNode = findChildren(node, "cenc:pssh")[0];
        if (psshNode) {
          const pssh = getContent(psshNode);
          acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);
        }
      }
      return acc;
    }, {});
  };
  const parseCaptionServiceMetadata = (service) => {
    if (service.schemeIdUri === "urn:scte:dash:cc:cea-608:2015") {
      const values2 = typeof service.value !== "string" ? [] : service.value.split(";");
      return values2.map((value) => {
        let channel;
        let language;
        language = value;
        if (/^CC\d=/.test(value)) {
          [channel, language] = value.split("=");
        } else if (/^CC\d$/.test(value)) {
          channel = value;
        }
        return {
          channel,
          language
        };
      });
    } else if (service.schemeIdUri === "urn:scte:dash:cc:cea-708:2015") {
      const values2 = typeof service.value !== "string" ? [] : service.value.split(";");
      return values2.map((value) => {
        const flags = {
          // service or channel number 1-63
          "channel": void 0,
          // language is a 3ALPHA per ISO 639.2/B
          // field is required
          "language": void 0,
          // BIT 1/0 or ?
          // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown
          "aspectRatio": 1,
          // BIT 1/0
          // easy reader flag indicated the text is tailed to the needs of beginning readers
          // default 0, or off
          "easyReader": 0,
          // BIT 1/0
          // If 3d metadata is present (CEA-708.1) then 1
          // default 0
          "3D": 0
        };
        if (/=/.test(value)) {
          const [channel, opts = ""] = value.split("=");
          flags.channel = channel;
          flags.language = value;
          opts.split(",").forEach((opt) => {
            const [name, val] = opt.split(":");
            if (name === "lang") {
              flags.language = val;
            } else if (name === "er") {
              flags.easyReader = Number(val);
            } else if (name === "war") {
              flags.aspectRatio = Number(val);
            } else if (name === "3D") {
              flags["3D"] = Number(val);
            }
          });
        } else {
          flags.language = value;
        }
        if (flags.channel) {
          flags.channel = "SERVICE" + flags.channel;
        }
        return flags;
      });
    }
  };
  const toEventStream = (period) => {
    return flatten(findChildren(period.node, "EventStream").map((eventStream) => {
      const eventStreamAttributes = parseAttributes(eventStream);
      const schemeIdUri = eventStreamAttributes.schemeIdUri;
      return findChildren(eventStream, "Event").map((event) => {
        const eventAttributes = parseAttributes(event);
        const presentationTime = eventAttributes.presentationTime || 0;
        const timescale = eventStreamAttributes.timescale || 1;
        const duration2 = eventAttributes.duration || 0;
        const start = presentationTime / timescale + period.attributes.start;
        return {
          schemeIdUri,
          value: eventStreamAttributes.value,
          id: eventAttributes.id,
          start,
          end: start + duration2 / timescale,
          messageData: getContent(event) || eventAttributes.messageData,
          contentEncoding: eventStreamAttributes.contentEncoding,
          presentationTimeOffset: eventStreamAttributes.presentationTimeOffset || 0
        };
      });
    }));
  };
  const toRepresentations = (periodAttributes, periodBaseUrls, periodSegmentInfo) => (adaptationSet) => {
    const adaptationSetAttributes = parseAttributes(adaptationSet);
    const adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, "BaseURL"));
    const role = findChildren(adaptationSet, "Role")[0];
    const roleAttributes = {
      role: parseAttributes(role)
    };
    let attrs = merge$1(periodAttributes, adaptationSetAttributes, roleAttributes);
    const accessibility = findChildren(adaptationSet, "Accessibility")[0];
    const captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));
    if (captionServices) {
      attrs = merge$1(attrs, {
        captionServices
      });
    }
    const label = findChildren(adaptationSet, "Label")[0];
    if (label && label.childNodes.length) {
      const labelVal = label.childNodes[0].nodeValue.trim();
      attrs = merge$1(attrs, {
        label: labelVal
      });
    }
    const contentProtection = generateKeySystemInformation(findChildren(adaptationSet, "ContentProtection"));
    if (Object.keys(contentProtection).length) {
      attrs = merge$1(attrs, {
        contentProtection
      });
    }
    const segmentInfo = getSegmentInformation(adaptationSet);
    const representations = findChildren(adaptationSet, "Representation");
    const adaptationSetSegmentInfo = merge$1(periodSegmentInfo, segmentInfo);
    return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));
  };
  const toAdaptationSets = (mpdAttributes, mpdBaseUrls) => (period, index) => {
    const periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, "BaseURL"));
    const periodAttributes = merge$1(mpdAttributes, {
      periodStart: period.attributes.start
    });
    if (typeof period.attributes.duration === "number") {
      periodAttributes.periodDuration = period.attributes.duration;
    }
    const adaptationSets = findChildren(period.node, "AdaptationSet");
    const periodSegmentInfo = getSegmentInformation(period.node);
    return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));
  };
  const generateContentSteeringInformation = (contentSteeringNodes, eventHandler) => {
    if (contentSteeringNodes.length > 1) {
      eventHandler({
        type: "warn",
        message: "The MPD manifest should contain no more than one ContentSteering tag"
      });
    }
    if (!contentSteeringNodes.length) {
      return null;
    }
    const infoFromContentSteeringTag = merge$1({
      serverURL: getContent(contentSteeringNodes[0])
    }, parseAttributes(contentSteeringNodes[0]));
    infoFromContentSteeringTag.queryBeforeStart = infoFromContentSteeringTag.queryBeforeStart === "true";
    return infoFromContentSteeringTag;
  };
  const getPeriodStart = ({
    attributes,
    priorPeriodAttributes,
    mpdType
  }) => {
    if (typeof attributes.start === "number") {
      return attributes.start;
    }
    if (priorPeriodAttributes && typeof priorPeriodAttributes.start === "number" && typeof priorPeriodAttributes.duration === "number") {
      return priorPeriodAttributes.start + priorPeriodAttributes.duration;
    }
    if (!priorPeriodAttributes && mpdType === "static") {
      return 0;
    }
    return null;
  };
  const inheritAttributes = (mpd, options = {}) => {
    const {
      manifestUri = "",
      NOW = Date.now(),
      clientOffset = 0,
      // TODO: For now, we are expecting an eventHandler callback function
      // to be passed into the mpd parser as an option.
      // In the future, we should enable stream parsing by using the Stream class from vhs-utils.
      // This will support new features including a standardized event handler.
      // See the m3u8 parser for examples of how stream parsing is currently used for HLS parsing.
      // https://github.com/videojs/vhs-utils/blob/88d6e10c631e57a5af02c5a62bc7376cd456b4f5/src/stream.js#L9
      eventHandler = function() {
      }
    } = options;
    const periodNodes = findChildren(mpd, "Period");
    if (!periodNodes.length) {
      throw new Error(errors.INVALID_NUMBER_OF_PERIOD);
    }
    const locations = findChildren(mpd, "Location");
    const mpdAttributes = parseAttributes(mpd);
    const mpdBaseUrls = buildBaseUrls([{
      baseUrl: manifestUri
    }], findChildren(mpd, "BaseURL"));
    const contentSteeringNodes = findChildren(mpd, "ContentSteering");
    mpdAttributes.type = mpdAttributes.type || "static";
    mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;
    mpdAttributes.NOW = NOW;
    mpdAttributes.clientOffset = clientOffset;
    if (locations.length) {
      mpdAttributes.locations = locations.map(getContent);
    }
    const periods = [];
    periodNodes.forEach((node, index) => {
      const attributes = parseAttributes(node);
      const priorPeriod = periods[index - 1];
      attributes.start = getPeriodStart({
        attributes,
        priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,
        mpdType: mpdAttributes.type
      });
      periods.push({
        node,
        attributes
      });
    });
    return {
      locations: mpdAttributes.locations,
      contentSteeringInfo: generateContentSteeringInformation(contentSteeringNodes, eventHandler),
      // TODO: There are occurences where this `representationInfo` array contains undesired
      // duplicates. This generally occurs when there are multiple BaseURL nodes that are
      // direct children of the MPD node. When we attempt to resolve URLs from a combination of the
      // parent BaseURL and a child BaseURL, and the value does not resolve,
      // we end up returning the child BaseURL multiple times.
      // We need to determine a way to remove these duplicates in a safe way.
      // See: https://github.com/videojs/mpd-parser/pull/17#discussion_r162750527
      representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls))),
      eventStream: flatten(periods.map(toEventStream))
    };
  };
  const stringToMpdXml = (manifestString) => {
    if (manifestString === "") {
      throw new Error(errors.DASH_EMPTY_MANIFEST);
    }
    const parser = new DOMParser2();
    let xml;
    let mpd;
    try {
      xml = parser.parseFromString(manifestString, "application/xml");
      mpd = xml && xml.documentElement.tagName === "MPD" ? xml.documentElement : null;
    } catch (e) {
    }
    if (!mpd || mpd && mpd.getElementsByTagName("parsererror").length > 0) {
      throw new Error(errors.DASH_INVALID_XML);
    }
    return mpd;
  };
  const parseUTCTimingScheme = (mpd) => {
    const UTCTimingNode = findChildren(mpd, "UTCTiming")[0];
    if (!UTCTimingNode) {
      return null;
    }
    const attributes = parseAttributes(UTCTimingNode);
    switch (attributes.schemeIdUri) {
      case "urn:mpeg:dash:utc:http-head:2014":
      case "urn:mpeg:dash:utc:http-head:2012":
        attributes.method = "HEAD";
        break;
      case "urn:mpeg:dash:utc:http-xsdate:2014":
      case "urn:mpeg:dash:utc:http-iso:2014":
      case "urn:mpeg:dash:utc:http-xsdate:2012":
      case "urn:mpeg:dash:utc:http-iso:2012":
        attributes.method = "GET";
        break;
      case "urn:mpeg:dash:utc:direct:2014":
      case "urn:mpeg:dash:utc:direct:2012":
        attributes.method = "DIRECT";
        attributes.value = Date.parse(attributes.value);
        break;
      case "urn:mpeg:dash:utc:http-ntp:2014":
      case "urn:mpeg:dash:utc:ntp:2014":
      case "urn:mpeg:dash:utc:sntp:2014":
      default:
        throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);
    }
    return attributes;
  };
  const parse = (manifestString, options = {}) => {
    const parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);
    const playlists = toPlaylists(parsedManifestInfo.representationInfo);
    return toM3u8({
      dashPlaylists: playlists,
      locations: parsedManifestInfo.locations,
      contentSteering: parsedManifestInfo.contentSteeringInfo,
      sidxMapping: options.sidxMapping,
      previousManifest: options.previousManifest,
      eventStream: parsedManifestInfo.eventStream
    });
  };
  const parseUTCTiming = (manifestString) => parseUTCTimingScheme(stringToMpdXml(manifestString));
  var MAX_UINT32 = Math.pow(2, 32);
  var getUint64$1 = function(uint8) {
    var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
    var value;
    if (dv.getBigUint64) {
      value = dv.getBigUint64(0);
      if (value < Number.MAX_SAFE_INTEGER) {
        return Number(value);
      }
      return value;
    }
    return dv.getUint32(0) * MAX_UINT32 + dv.getUint32(4);
  };
  var numbers = {
    getUint64: getUint64$1,
    MAX_UINT32
  };
  var getUint64 = numbers.getUint64;
  var parseSidx = function(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      references: [],
      referenceId: view.getUint32(4),
      timescale: view.getUint32(8)
    }, i = 12;
    if (result.version === 0) {
      result.earliestPresentationTime = view.getUint32(i);
      result.firstOffset = view.getUint32(i + 4);
      i += 8;
    } else {
      result.earliestPresentationTime = getUint64(data.subarray(i));
      result.firstOffset = getUint64(data.subarray(i + 8));
      i += 16;
    }
    i += 2;
    var referenceCount = view.getUint16(i);
    i += 2;
    for (; referenceCount > 0; i += 12, referenceCount--) {
      result.references.push({
        referenceType: (data[i] & 128) >>> 7,
        referencedSize: view.getUint32(i) & 2147483647,
        subsegmentDuration: view.getUint32(i + 4),
        startsWithSap: !!(data[i + 8] & 128),
        sapType: (data[i + 8] & 112) >>> 4,
        sapDeltaTime: view.getUint32(i + 8) & 268435455
      });
    }
    return result;
  };
  var parseSidx_1 = parseSidx;
  var ID3 = toUint8([73, 68, 51]);
  var getId3Size = function getId3Size2(bytes, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    bytes = toUint8(bytes);
    var flags = bytes[offset + 5];
    var returnSize = bytes[offset + 6] << 21 | bytes[offset + 7] << 14 | bytes[offset + 8] << 7 | bytes[offset + 9];
    var footerPresent = (flags & 16) >> 4;
    if (footerPresent) {
      return returnSize + 20;
    }
    return returnSize + 10;
  };
  var getId3Offset = function getId3Offset2(bytes, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    bytes = toUint8(bytes);
    if (bytes.length - offset < 10 || !bytesMatch(bytes, ID3, {
      offset
    })) {
      return offset;
    }
    offset += getId3Size(bytes, offset);
    return getId3Offset2(bytes, offset);
  };
  var normalizePath$1 = function normalizePath2(path) {
    if (typeof path === "string") {
      return stringToBytes(path);
    }
    if (typeof path === "number") {
      return path;
    }
    return path;
  };
  var normalizePaths$1 = function normalizePaths2(paths) {
    if (!Array.isArray(paths)) {
      return [normalizePath$1(paths)];
    }
    return paths.map(function(p) {
      return normalizePath$1(p);
    });
  };
  var findBox = function findBox2(bytes, paths, complete) {
    if (complete === void 0) {
      complete = false;
    }
    paths = normalizePaths$1(paths);
    bytes = toUint8(bytes);
    var results = [];
    if (!paths.length) {
      return results;
    }
    var i = 0;
    while (i < bytes.length) {
      var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;
      var type = bytes.subarray(i + 4, i + 8);
      if (size === 0) {
        break;
      }
      var end = i + size;
      if (end > bytes.length) {
        if (complete) {
          break;
        }
        end = bytes.length;
      }
      var data = bytes.subarray(i + 8, end);
      if (bytesMatch(type, paths[0])) {
        if (paths.length === 1) {
          results.push(data);
        } else {
          results.push.apply(results, findBox2(data, paths.slice(1), complete));
        }
      }
      i = end;
    }
    return results;
  };
  var EBML_TAGS = {
    EBML: toUint8([26, 69, 223, 163]),
    DocType: toUint8([66, 130]),
    Segment: toUint8([24, 83, 128, 103]),
    SegmentInfo: toUint8([21, 73, 169, 102]),
    Tracks: toUint8([22, 84, 174, 107]),
    Track: toUint8([174]),
    TrackNumber: toUint8([215]),
    DefaultDuration: toUint8([35, 227, 131]),
    TrackEntry: toUint8([174]),
    TrackType: toUint8([131]),
    FlagDefault: toUint8([136]),
    CodecID: toUint8([134]),
    CodecPrivate: toUint8([99, 162]),
    VideoTrack: toUint8([224]),
    AudioTrack: toUint8([225]),
    // Not used yet, but will be used for live webm/mkv
    // see https://www.matroska.org/technical/basics.html#block-structure
    // see https://www.matroska.org/technical/basics.html#simpleblock-structure
    Cluster: toUint8([31, 67, 182, 117]),
    Timestamp: toUint8([231]),
    TimestampScale: toUint8([42, 215, 177]),
    BlockGroup: toUint8([160]),
    BlockDuration: toUint8([155]),
    Block: toUint8([161]),
    SimpleBlock: toUint8([163])
  };
  var LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];
  var getLength = function getLength2(byte) {
    var len = 1;
    for (var i = 0; i < LENGTH_TABLE.length; i++) {
      if (byte & LENGTH_TABLE[i]) {
        break;
      }
      len++;
    }
    return len;
  };
  var getvint = function getvint2(bytes, offset, removeLength, signed) {
    if (removeLength === void 0) {
      removeLength = true;
    }
    if (signed === void 0) {
      signed = false;
    }
    var length = getLength(bytes[offset]);
    var valueBytes = bytes.subarray(offset, offset + length);
    if (removeLength) {
      valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);
      valueBytes[0] ^= LENGTH_TABLE[length - 1];
    }
    return {
      length,
      value: bytesToNumber(valueBytes, {
        signed
      }),
      bytes: valueBytes
    };
  };
  var normalizePath = function normalizePath2(path) {
    if (typeof path === "string") {
      return path.match(/.{1,2}/g).map(function(p) {
        return normalizePath2(p);
      });
    }
    if (typeof path === "number") {
      return numberToBytes(path);
    }
    return path;
  };
  var normalizePaths = function normalizePaths2(paths) {
    if (!Array.isArray(paths)) {
      return [normalizePath(paths)];
    }
    return paths.map(function(p) {
      return normalizePath(p);
    });
  };
  var getInfinityDataSize = function getInfinityDataSize2(id, bytes, offset) {
    if (offset >= bytes.length) {
      return bytes.length;
    }
    var innerid = getvint(bytes, offset, false);
    if (bytesMatch(id.bytes, innerid.bytes)) {
      return offset;
    }
    var dataHeader = getvint(bytes, offset + innerid.length);
    return getInfinityDataSize2(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);
  };
  var findEbml = function findEbml2(bytes, paths) {
    paths = normalizePaths(paths);
    bytes = toUint8(bytes);
    var results = [];
    if (!paths.length) {
      return results;
    }
    var i = 0;
    while (i < bytes.length) {
      var id = getvint(bytes, i, false);
      var dataHeader = getvint(bytes, i + id.length);
      var dataStart = i + id.length + dataHeader.length;
      if (dataHeader.value === 127) {
        dataHeader.value = getInfinityDataSize(id, bytes, dataStart);
        if (dataHeader.value !== bytes.length) {
          dataHeader.value -= dataStart;
        }
      }
      var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;
      var data = bytes.subarray(dataStart, dataEnd);
      if (bytesMatch(paths[0], id.bytes)) {
        if (paths.length === 1) {
          results.push(data);
        } else {
          results = results.concat(findEbml2(data, paths.slice(1)));
        }
      }
      var totalLength = id.length + dataHeader.length + data.length;
      i += totalLength;
    }
    return results;
  };
  var NAL_TYPE_ONE = toUint8([0, 0, 0, 1]);
  var NAL_TYPE_TWO = toUint8([0, 0, 1]);
  var EMULATION_PREVENTION = toUint8([0, 0, 3]);
  var discardEmulationPreventionBytes = function discardEmulationPreventionBytes2(bytes) {
    var positions = [];
    var i = 1;
    while (i < bytes.length - 2) {
      if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {
        positions.push(i + 2);
        i++;
      }
      i++;
    }
    if (positions.length === 0) {
      return bytes;
    }
    var newLength = bytes.length - positions.length;
    var newData = new Uint8Array(newLength);
    var sourceIndex = 0;
    for (i = 0; i < newLength; sourceIndex++, i++) {
      if (sourceIndex === positions[0]) {
        sourceIndex++;
        positions.shift();
      }
      newData[i] = bytes[sourceIndex];
    }
    return newData;
  };
  var findNal = function findNal2(bytes, dataType, types, nalLimit) {
    if (nalLimit === void 0) {
      nalLimit = Infinity;
    }
    bytes = toUint8(bytes);
    types = [].concat(types);
    var i = 0;
    var nalStart;
    var nalsFound = 0;
    while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {
      var nalOffset = void 0;
      if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {
        nalOffset = 4;
      } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {
        nalOffset = 3;
      }
      if (!nalOffset) {
        i++;
        continue;
      }
      nalsFound++;
      if (nalStart) {
        return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));
      }
      var nalType = void 0;
      if (dataType === "h264") {
        nalType = bytes[i + nalOffset] & 31;
      } else if (dataType === "h265") {
        nalType = bytes[i + nalOffset] >> 1 & 63;
      }
      if (types.indexOf(nalType) !== -1) {
        nalStart = i + nalOffset;
      }
      i += nalOffset + (dataType === "h264" ? 1 : 2);
    }
    return bytes.subarray(0, 0);
  };
  var findH264Nal = function findH264Nal2(bytes, type, nalLimit) {
    return findNal(bytes, "h264", type, nalLimit);
  };
  var findH265Nal = function findH265Nal2(bytes, type, nalLimit) {
    return findNal(bytes, "h265", type, nalLimit);
  };
  var CONSTANTS = {
    // "webm" string literal in hex
    "webm": toUint8([119, 101, 98, 109]),
    // "matroska" string literal in hex
    "matroska": toUint8([109, 97, 116, 114, 111, 115, 107, 97]),
    // "fLaC" string literal in hex
    "flac": toUint8([102, 76, 97, 67]),
    // "OggS" string literal in hex
    "ogg": toUint8([79, 103, 103, 83]),
    // ac-3 sync byte, also works for ec-3 as that is simply a codec
    // of ac-3
    "ac3": toUint8([11, 119]),
    // "RIFF" string literal in hex used for wav and avi
    "riff": toUint8([82, 73, 70, 70]),
    // "AVI" string literal in hex
    "avi": toUint8([65, 86, 73]),
    // "WAVE" string literal in hex
    "wav": toUint8([87, 65, 86, 69]),
    // "ftyp3g" string literal in hex
    "3gp": toUint8([102, 116, 121, 112, 51, 103]),
    // "ftyp" string literal in hex
    "mp4": toUint8([102, 116, 121, 112]),
    // "styp" string literal in hex
    "fmp4": toUint8([115, 116, 121, 112]),
    // "ftypqt" string literal in hex
    "mov": toUint8([102, 116, 121, 112, 113, 116]),
    // moov string literal in hex
    "moov": toUint8([109, 111, 111, 118]),
    // moof string literal in hex
    "moof": toUint8([109, 111, 111, 102])
  };
  var _isLikely = {
    aac: function aac(bytes) {
      var offset = getId3Offset(bytes);
      return bytesMatch(bytes, [255, 16], {
        offset,
        mask: [255, 22]
      });
    },
    mp3: function mp3(bytes) {
      var offset = getId3Offset(bytes);
      return bytesMatch(bytes, [255, 2], {
        offset,
        mask: [255, 6]
      });
    },
    webm: function webm(bytes) {
      var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0];
      return bytesMatch(docType, CONSTANTS.webm);
    },
    mkv: function mkv(bytes) {
      var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0];
      return bytesMatch(docType, CONSTANTS.matroska);
    },
    mp4: function mp4(bytes) {
      if (_isLikely["3gp"](bytes) || _isLikely.mov(bytes)) {
        return false;
      }
      if (bytesMatch(bytes, CONSTANTS.mp4, {
        offset: 4
      }) || bytesMatch(bytes, CONSTANTS.fmp4, {
        offset: 4
      })) {
        return true;
      }
      if (bytesMatch(bytes, CONSTANTS.moof, {
        offset: 4
      }) || bytesMatch(bytes, CONSTANTS.moov, {
        offset: 4
      })) {
        return true;
      }
    },
    mov: function mov(bytes) {
      return bytesMatch(bytes, CONSTANTS.mov, {
        offset: 4
      });
    },
    "3gp": function gp(bytes) {
      return bytesMatch(bytes, CONSTANTS["3gp"], {
        offset: 4
      });
    },
    ac3: function ac3(bytes) {
      var offset = getId3Offset(bytes);
      return bytesMatch(bytes, CONSTANTS.ac3, {
        offset
      });
    },
    ts: function ts(bytes) {
      if (bytes.length < 189 && bytes.length >= 1) {
        return bytes[0] === 71;
      }
      var i = 0;
      while (i + 188 < bytes.length && i < 188) {
        if (bytes[i] === 71 && bytes[i + 188] === 71) {
          return true;
        }
        i += 1;
      }
      return false;
    },
    flac: function flac(bytes) {
      var offset = getId3Offset(bytes);
      return bytesMatch(bytes, CONSTANTS.flac, {
        offset
      });
    },
    ogg: function ogg(bytes) {
      return bytesMatch(bytes, CONSTANTS.ogg);
    },
    avi: function avi(bytes) {
      return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {
        offset: 8
      });
    },
    wav: function wav(bytes) {
      return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {
        offset: 8
      });
    },
    "h264": function h264(bytes) {
      return findH264Nal(bytes, 7, 3).length;
    },
    "h265": function h265(bytes) {
      return findH265Nal(bytes, [32, 33], 3).length;
    }
  };
  var isLikelyTypes = Object.keys(_isLikely).filter(function(t) {
    return t !== "ts" && t !== "h264" && t !== "h265";
  }).concat(["ts", "h264", "h265"]);
  isLikelyTypes.forEach(function(type) {
    var isLikelyFn = _isLikely[type];
    _isLikely[type] = function(bytes) {
      return isLikelyFn(toUint8(bytes));
    };
  });
  var isLikely = _isLikely;
  var detectContainerForBytes = function detectContainerForBytes2(bytes) {
    bytes = toUint8(bytes);
    for (var i = 0; i < isLikelyTypes.length; i++) {
      var type = isLikelyTypes[i];
      if (isLikely[type](bytes)) {
        return type;
      }
    }
    return "";
  };
  var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment2(bytes) {
    return findBox(bytes, ["moof"]).length > 0;
  };
  var ONE_SECOND_IN_TS = 9e4, secondsToVideoTs, secondsToAudioTs, videoTsToSeconds, audioTsToSeconds, audioTsToVideoTs, videoTsToAudioTs, metadataTsToSeconds;
  secondsToVideoTs = function(seconds) {
    return seconds * ONE_SECOND_IN_TS;
  };
  secondsToAudioTs = function(seconds, sampleRate) {
    return seconds * sampleRate;
  };
  videoTsToSeconds = function(timestamp) {
    return timestamp / ONE_SECOND_IN_TS;
  };
  audioTsToSeconds = function(timestamp, sampleRate) {
    return timestamp / sampleRate;
  };
  audioTsToVideoTs = function(timestamp, sampleRate) {
    return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
  };
  videoTsToAudioTs = function(timestamp, sampleRate) {
    return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
  };
  metadataTsToSeconds = function(timestamp, timelineStartPts, keepOriginalTimestamps) {
    return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
  };
  var clock = {
    ONE_SECOND_IN_TS,
    secondsToVideoTs,
    secondsToAudioTs,
    videoTsToSeconds,
    audioTsToSeconds,
    audioTsToVideoTs,
    videoTsToAudioTs,
    metadataTsToSeconds
  };
  var clock_1 = clock.ONE_SECOND_IN_TS;
  /*! @name @videojs/http-streaming @version 3.9.1 @license Apache-2.0 */
  const resolveUrl = resolveUrl$1;
  const resolveManifestRedirect = (url, req) => {
    if (req && req.responseURL && url !== req.responseURL) {
      return req.responseURL;
    }
    return url;
  };
  const logger = (source) => {
    if (videojs.log.debug) {
      return videojs.log.debug.bind(videojs, "VHS:", `${source} >`);
    }
    return function() {
    };
  };
  function merge(...args) {
    const context = videojs.obj || videojs;
    const fn = context.merge || context.mergeOptions;
    return fn.apply(context, args);
  }
  function createTimeRanges(...args) {
    const context = videojs.time || videojs;
    const fn = context.createTimeRanges || context.createTimeRanges;
    return fn.apply(context, args);
  }
  const TIME_FUDGE_FACTOR = 1 / 30;
  const SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;
  const filterRanges = function(timeRanges, predicate) {
    const results = [];
    let i;
    if (timeRanges && timeRanges.length) {
      for (i = 0; i < timeRanges.length; i++) {
        if (predicate(timeRanges.start(i), timeRanges.end(i))) {
          results.push([timeRanges.start(i), timeRanges.end(i)]);
        }
      }
    }
    return createTimeRanges(results);
  };
  const findRange = function(buffered, time) {
    return filterRanges(buffered, function(start, end) {
      return start - SAFE_TIME_DELTA <= time && end + SAFE_TIME_DELTA >= time;
    });
  };
  const findNextRange = function(timeRanges, time) {
    return filterRanges(timeRanges, function(start) {
      return start - TIME_FUDGE_FACTOR >= time;
    });
  };
  const findGaps = function(buffered) {
    if (buffered.length < 2) {
      return createTimeRanges();
    }
    const ranges = [];
    for (let i = 1; i < buffered.length; i++) {
      const start = buffered.end(i - 1);
      const end = buffered.start(i);
      ranges.push([start, end]);
    }
    return createTimeRanges(ranges);
  };
  const bufferIntersection = function(bufferA, bufferB) {
    let start = null;
    let end = null;
    let arity = 0;
    const extents = [];
    const ranges = [];
    if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {
      return createTimeRanges();
    }
    let count = bufferA.length;
    while (count--) {
      extents.push({
        time: bufferA.start(count),
        type: "start"
      });
      extents.push({
        time: bufferA.end(count),
        type: "end"
      });
    }
    count = bufferB.length;
    while (count--) {
      extents.push({
        time: bufferB.start(count),
        type: "start"
      });
      extents.push({
        time: bufferB.end(count),
        type: "end"
      });
    }
    extents.sort(function(a, b) {
      return a.time - b.time;
    });
    for (count = 0; count < extents.length; count++) {
      if (extents[count].type === "start") {
        arity++;
        if (arity === 2) {
          start = extents[count].time;
        }
      } else if (extents[count].type === "end") {
        arity--;
        if (arity === 1) {
          end = extents[count].time;
        }
      }
      if (start !== null && end !== null) {
        ranges.push([start, end]);
        start = null;
        end = null;
      }
    }
    return createTimeRanges(ranges);
  };
  const printableRange = (range2) => {
    const strArr = [];
    if (!range2 || !range2.length) {
      return "";
    }
    for (let i = 0; i < range2.length; i++) {
      strArr.push(range2.start(i) + " => " + range2.end(i));
    }
    return strArr.join(", ");
  };
  const timeUntilRebuffer = function(buffered, currentTime, playbackRate = 1) {
    const bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;
    return (bufferedEnd - currentTime) / playbackRate;
  };
  const timeRangesToArray = (timeRanges) => {
    const timeRangesList = [];
    for (let i = 0; i < timeRanges.length; i++) {
      timeRangesList.push({
        start: timeRanges.start(i),
        end: timeRanges.end(i)
      });
    }
    return timeRangesList;
  };
  const isRangeDifferent = function(a, b) {
    if (a === b) {
      return false;
    }
    if (!a && b || !b && a) {
      return true;
    }
    if (a.length !== b.length) {
      return true;
    }
    for (let i = 0; i < a.length; i++) {
      if (a.start(i) !== b.start(i) || a.end(i) !== b.end(i)) {
        return true;
      }
    }
    return false;
  };
  const lastBufferedEnd = function(a) {
    if (!a || !a.length || !a.end) {
      return;
    }
    return a.end(a.length - 1);
  };
  const timeAheadOf = function(range2, startTime) {
    let time = 0;
    if (!range2 || !range2.length) {
      return time;
    }
    for (let i = 0; i < range2.length; i++) {
      const start = range2.start(i);
      const end = range2.end(i);
      if (startTime > end) {
        continue;
      }
      if (startTime > start && startTime <= end) {
        time += end - startTime;
        continue;
      }
      time += end - start;
    }
    return time;
  };
  const segmentDurationWithParts = (playlist, segment) => {
    if (!segment.preload) {
      return segment.duration;
    }
    let result = 0;
    (segment.parts || []).forEach(function(p) {
      result += p.duration;
    });
    (segment.preloadHints || []).forEach(function(p) {
      if (p.type === "PART") {
        result += playlist.partTargetDuration;
      }
    });
    return result;
  };
  const getPartsAndSegments = (playlist) => (playlist.segments || []).reduce((acc, segment, si) => {
    if (segment.parts) {
      segment.parts.forEach(function(part, pi) {
        acc.push({
          duration: part.duration,
          segmentIndex: si,
          partIndex: pi,
          part,
          segment
        });
      });
    } else {
      acc.push({
        duration: segment.duration,
        segmentIndex: si,
        partIndex: null,
        segment,
        part: null
      });
    }
    return acc;
  }, []);
  const getLastParts = (media) => {
    const lastSegment = media.segments && media.segments.length && media.segments[media.segments.length - 1];
    return lastSegment && lastSegment.parts || [];
  };
  const getKnownPartCount = ({
    preloadSegment
  }) => {
    if (!preloadSegment) {
      return;
    }
    const {
      parts,
      preloadHints
    } = preloadSegment;
    let partCount = (preloadHints || []).reduce((count, hint) => count + (hint.type === "PART" ? 1 : 0), 0);
    partCount += parts && parts.length ? parts.length : 0;
    return partCount;
  };
  const liveEdgeDelay = (main, media) => {
    if (media.endList) {
      return 0;
    }
    if (main && main.suggestedPresentationDelay) {
      return main.suggestedPresentationDelay;
    }
    const hasParts = getLastParts(media).length > 0;
    if (hasParts && media.serverControl && media.serverControl.partHoldBack) {
      return media.serverControl.partHoldBack;
    } else if (hasParts && media.partTargetDuration) {
      return media.partTargetDuration * 3;
    } else if (media.serverControl && media.serverControl.holdBack) {
      return media.serverControl.holdBack;
    } else if (media.targetDuration) {
      return media.targetDuration * 3;
    }
    return 0;
  };
  const backwardDuration = function(playlist, endSequence) {
    let result = 0;
    let i = endSequence - playlist.mediaSequence;
    let segment = playlist.segments[i];
    if (segment) {
      if (typeof segment.start !== "undefined") {
        return {
          result: segment.start,
          precise: true
        };
      }
      if (typeof segment.end !== "undefined") {
        return {
          result: segment.end - segment.duration,
          precise: true
        };
      }
    }
    while (i--) {
      segment = playlist.segments[i];
      if (typeof segment.end !== "undefined") {
        return {
          result: result + segment.end,
          precise: true
        };
      }
      result += segmentDurationWithParts(playlist, segment);
      if (typeof segment.start !== "undefined") {
        return {
          result: result + segment.start,
          precise: true
        };
      }
    }
    return {
      result,
      precise: false
    };
  };
  const forwardDuration = function(playlist, endSequence) {
    let result = 0;
    let segment;
    let i = endSequence - playlist.mediaSequence;
    for (; i < playlist.segments.length; i++) {
      segment = playlist.segments[i];
      if (typeof segment.start !== "undefined") {
        return {
          result: segment.start - result,
          precise: true
        };
      }
      result += segmentDurationWithParts(playlist, segment);
      if (typeof segment.end !== "undefined") {
        return {
          result: segment.end - result,
          precise: true
        };
      }
    }
    return {
      result: -1,
      precise: false
    };
  };
  const intervalDuration = function(playlist, endSequence, expired) {
    if (typeof endSequence === "undefined") {
      endSequence = playlist.mediaSequence + playlist.segments.length;
    }
    if (endSequence < playlist.mediaSequence) {
      return 0;
    }
    const backward = backwardDuration(playlist, endSequence);
    if (backward.precise) {
      return backward.result;
    }
    const forward = forwardDuration(playlist, endSequence);
    if (forward.precise) {
      return forward.result;
    }
    return backward.result + expired;
  };
  const duration = function(playlist, endSequence, expired) {
    if (!playlist) {
      return 0;
    }
    if (typeof expired !== "number") {
      expired = 0;
    }
    if (typeof endSequence === "undefined") {
      if (playlist.totalDuration) {
        return playlist.totalDuration;
      }
      if (!playlist.endList) {
        return window.Infinity;
      }
    }
    return intervalDuration(playlist, endSequence, expired);
  };
  const sumDurations = function({
    defaultDuration,
    durationList,
    startIndex,
    endIndex
  }) {
    let durations = 0;
    if (startIndex > endIndex) {
      [startIndex, endIndex] = [endIndex, startIndex];
    }
    if (startIndex < 0) {
      for (let i = startIndex; i < Math.min(0, endIndex); i++) {
        durations += defaultDuration;
      }
      startIndex = 0;
    }
    for (let i = startIndex; i < endIndex; i++) {
      durations += durationList[i].duration;
    }
    return durations;
  };
  const playlistEnd = function(playlist, expired, useSafeLiveEnd, liveEdgePadding) {
    if (!playlist || !playlist.segments) {
      return null;
    }
    if (playlist.endList) {
      return duration(playlist);
    }
    if (expired === null) {
      return null;
    }
    expired = expired || 0;
    let lastSegmentEndTime = intervalDuration(playlist, playlist.mediaSequence + playlist.segments.length, expired);
    if (useSafeLiveEnd) {
      liveEdgePadding = typeof liveEdgePadding === "number" ? liveEdgePadding : liveEdgeDelay(null, playlist);
      lastSegmentEndTime -= liveEdgePadding;
    }
    return Math.max(0, lastSegmentEndTime);
  };
  const seekable = function(playlist, expired, liveEdgePadding) {
    const useSafeLiveEnd = true;
    const seekableStart = expired || 0;
    let seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding);
    if (seekableEnd === null) {
      return createTimeRanges();
    }
    if (seekableEnd < seekableStart) {
      seekableEnd = seekableStart;
    }
    return createTimeRanges(seekableStart, seekableEnd);
  };
  const getMediaInfoForTime = function({
    playlist,
    currentTime,
    startingSegmentIndex,
    startingPartIndex,
    startTime,
    exactManifestTimings
  }) {
    let time = currentTime - startTime;
    const partsAndSegments = getPartsAndSegments(playlist);
    let startIndex = 0;
    for (let i = 0; i < partsAndSegments.length; i++) {
      const partAndSegment = partsAndSegments[i];
      if (startingSegmentIndex !== partAndSegment.segmentIndex) {
        continue;
      }
      if (typeof startingPartIndex === "number" && typeof partAndSegment.partIndex === "number" && startingPartIndex !== partAndSegment.partIndex) {
        continue;
      }
      startIndex = i;
      break;
    }
    if (time < 0) {
      if (startIndex > 0) {
        for (let i = startIndex - 1; i >= 0; i--) {
          const partAndSegment = partsAndSegments[i];
          time += partAndSegment.duration;
          if (exactManifestTimings) {
            if (time < 0) {
              continue;
            }
          } else if (time + TIME_FUDGE_FACTOR <= 0) {
            continue;
          }
          return {
            partIndex: partAndSegment.partIndex,
            segmentIndex: partAndSegment.segmentIndex,
            startTime: startTime - sumDurations({
              defaultDuration: playlist.targetDuration,
              durationList: partsAndSegments,
              startIndex,
              endIndex: i
            })
          };
        }
      }
      return {
        partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
        segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
        startTime: currentTime
      };
    }
    if (startIndex < 0) {
      for (let i = startIndex; i < 0; i++) {
        time -= playlist.targetDuration;
        if (time < 0) {
          return {
            partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
            segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
            startTime: currentTime
          };
        }
      }
      startIndex = 0;
    }
    for (let i = startIndex; i < partsAndSegments.length; i++) {
      const partAndSegment = partsAndSegments[i];
      time -= partAndSegment.duration;
      const canUseFudgeFactor = partAndSegment.duration > TIME_FUDGE_FACTOR;
      const isExactlyAtTheEnd = time === 0;
      const isExtremelyCloseToTheEnd = canUseFudgeFactor && time + TIME_FUDGE_FACTOR >= 0;
      if (isExactlyAtTheEnd || isExtremelyCloseToTheEnd) {
        if (i !== partsAndSegments.length - 1) {
          continue;
        }
      }
      if (exactManifestTimings) {
        if (time > 0) {
          continue;
        }
      } else if (time - TIME_FUDGE_FACTOR >= 0) {
        continue;
      }
      return {
        partIndex: partAndSegment.partIndex,
        segmentIndex: partAndSegment.segmentIndex,
        startTime: startTime + sumDurations({
          defaultDuration: playlist.targetDuration,
          durationList: partsAndSegments,
          startIndex,
          endIndex: i
        })
      };
    }
    return {
      segmentIndex: partsAndSegments[partsAndSegments.length - 1].segmentIndex,
      partIndex: partsAndSegments[partsAndSegments.length - 1].partIndex,
      startTime: currentTime
    };
  };
  const isExcluded = function(playlist) {
    return playlist.excludeUntil && playlist.excludeUntil > Date.now();
  };
  const isIncompatible = function(playlist) {
    return playlist.excludeUntil && playlist.excludeUntil === Infinity;
  };
  const isEnabled = function(playlist) {
    const excluded = isExcluded(playlist);
    return !playlist.disabled && !excluded;
  };
  const isDisabled = function(playlist) {
    return playlist.disabled;
  };
  const isAes = function(media) {
    for (let i = 0; i < media.segments.length; i++) {
      if (media.segments[i].key) {
        return true;
      }
    }
    return false;
  };
  const hasAttribute = function(attr, playlist) {
    return playlist.attributes && playlist.attributes[attr];
  };
  const estimateSegmentRequestTime = function(segmentDuration, bandwidth, playlist, bytesReceived = 0) {
    if (!hasAttribute("BANDWIDTH", playlist)) {
      return NaN;
    }
    const size = segmentDuration * playlist.attributes.BANDWIDTH;
    return (size - bytesReceived * 8) / bandwidth;
  };
  const isLowestEnabledRendition = (main, media) => {
    if (main.playlists.length === 1) {
      return true;
    }
    const currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;
    return main.playlists.filter((playlist) => {
      if (!isEnabled(playlist)) {
        return false;
      }
      return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;
    }).length === 0;
  };
  const playlistMatch = (a, b) => {
    if (!a && !b || !a && b || a && !b) {
      return false;
    }
    if (a === b) {
      return true;
    }
    if (a.id && b.id && a.id === b.id) {
      return true;
    }
    if (a.resolvedUri && b.resolvedUri && a.resolvedUri === b.resolvedUri) {
      return true;
    }
    if (a.uri && b.uri && a.uri === b.uri) {
      return true;
    }
    return false;
  };
  const someAudioVariant = function(main, callback) {
    const AUDIO = main && main.mediaGroups && main.mediaGroups.AUDIO || {};
    let found = false;
    for (const groupName in AUDIO) {
      for (const label in AUDIO[groupName]) {
        found = callback(AUDIO[groupName][label]);
        if (found) {
          break;
        }
      }
      if (found) {
        break;
      }
    }
    return !!found;
  };
  const isAudioOnly = (main) => {
    if (!main || !main.playlists || !main.playlists.length) {
      const found = someAudioVariant(main, (variant) => variant.playlists && variant.playlists.length || variant.uri);
      return found;
    }
    for (let i = 0; i < main.playlists.length; i++) {
      const playlist = main.playlists[i];
      const CODECS = playlist.attributes && playlist.attributes.CODECS;
      if (CODECS && CODECS.split(",").every((c) => isAudioCodec(c))) {
        continue;
      }
      const found = someAudioVariant(main, (variant) => playlistMatch(playlist, variant));
      if (found) {
        continue;
      }
      return false;
    }
    return true;
  };
  var Playlist = {
    liveEdgeDelay,
    duration,
    seekable,
    getMediaInfoForTime,
    isEnabled,
    isDisabled,
    isExcluded,
    isIncompatible,
    playlistEnd,
    isAes,
    hasAttribute,
    estimateSegmentRequestTime,
    isLowestEnabledRendition,
    isAudioOnly,
    playlistMatch,
    segmentDurationWithParts
  };
  const {
    log
  } = videojs;
  const createPlaylistID = (index, uri) => {
    return `${index}-${uri}`;
  };
  const groupID = (type, group, label) => {
    return `placeholder-uri-${type}-${group}-${label}`;
  };
  const parseManifest = ({
    onwarn,
    oninfo,
    manifestString,
    customTagParsers = [],
    customTagMappers = [],
    llhls
  }) => {
    const parser = new Parser();
    if (onwarn) {
      parser.on("warn", onwarn);
    }
    if (oninfo) {
      parser.on("info", oninfo);
    }
    customTagParsers.forEach((customParser) => parser.addParser(customParser));
    customTagMappers.forEach((mapper) => parser.addTagMapper(mapper));
    parser.push(manifestString);
    parser.end();
    const manifest = parser.manifest;
    if (!llhls) {
      ["preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration"].forEach(function(k) {
        if (manifest.hasOwnProperty(k)) {
          delete manifest[k];
        }
      });
      if (manifest.segments) {
        manifest.segments.forEach(function(segment) {
          ["parts", "preloadHints"].forEach(function(k) {
            if (segment.hasOwnProperty(k)) {
              delete segment[k];
            }
          });
        });
      }
    }
    if (!manifest.targetDuration) {
      let targetDuration = 10;
      if (manifest.segments && manifest.segments.length) {
        targetDuration = manifest.segments.reduce((acc, s) => Math.max(acc, s.duration), 0);
      }
      if (onwarn) {
        onwarn({
          message: `manifest has no targetDuration defaulting to ${targetDuration}`
        });
      }
      manifest.targetDuration = targetDuration;
    }
    const parts = getLastParts(manifest);
    if (parts.length && !manifest.partTargetDuration) {
      const partTargetDuration = parts.reduce((acc, p) => Math.max(acc, p.duration), 0);
      if (onwarn) {
        onwarn({
          message: `manifest has no partTargetDuration defaulting to ${partTargetDuration}`
        });
        log.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.");
      }
      manifest.partTargetDuration = partTargetDuration;
    }
    return manifest;
  };
  const forEachMediaGroup = (main, callback) => {
    if (!main.mediaGroups) {
      return;
    }
    ["AUDIO", "SUBTITLES"].forEach((mediaType) => {
      if (!main.mediaGroups[mediaType]) {
        return;
      }
      for (const groupKey in main.mediaGroups[mediaType]) {
        for (const labelKey in main.mediaGroups[mediaType][groupKey]) {
          const mediaProperties = main.mediaGroups[mediaType][groupKey][labelKey];
          callback(mediaProperties, mediaType, groupKey, labelKey);
        }
      }
    });
  };
  const setupMediaPlaylist = ({
    playlist,
    uri,
    id
  }) => {
    playlist.id = id;
    playlist.playlistErrors_ = 0;
    if (uri) {
      playlist.uri = uri;
    }
    playlist.attributes = playlist.attributes || {};
  };
  const setupMediaPlaylists = (main) => {
    let i = main.playlists.length;
    while (i--) {
      const playlist = main.playlists[i];
      setupMediaPlaylist({
        playlist,
        id: createPlaylistID(i, playlist.uri)
      });
      playlist.resolvedUri = resolveUrl(main.uri, playlist.uri);
      main.playlists[playlist.id] = playlist;
      main.playlists[playlist.uri] = playlist;
      if (!playlist.attributes.BANDWIDTH) {
        log.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.");
      }
    }
  };
  const resolveMediaGroupUris = (main) => {
    forEachMediaGroup(main, (properties) => {
      if (properties.uri) {
        properties.resolvedUri = resolveUrl(main.uri, properties.uri);
      }
    });
  };
  const mainForMedia = (media, uri) => {
    const id = createPlaylistID(0, uri);
    const main = {
      mediaGroups: {
        "AUDIO": {},
        "VIDEO": {},
        "CLOSED-CAPTIONS": {},
        "SUBTITLES": {}
      },
      uri: window.location.href,
      resolvedUri: window.location.href,
      playlists: [{
        uri,
        id,
        resolvedUri: uri,
        // m3u8-parser does not attach an attributes property to media playlists so make
        // sure that the property is attached to avoid undefined reference errors
        attributes: {}
      }]
    };
    main.playlists[id] = main.playlists[0];
    main.playlists[uri] = main.playlists[0];
    return main;
  };
  const addPropertiesToMain = (main, uri, createGroupID = groupID) => {
    main.uri = uri;
    for (let i = 0; i < main.playlists.length; i++) {
      if (!main.playlists[i].uri) {
        const phonyUri = `placeholder-uri-${i}`;
        main.playlists[i].uri = phonyUri;
      }
    }
    const audioOnlyMain = isAudioOnly(main);
    forEachMediaGroup(main, (properties, mediaType, groupKey, labelKey) => {
      if (!properties.playlists || !properties.playlists.length) {
        if (audioOnlyMain && mediaType === "AUDIO" && !properties.uri) {
          for (let i = 0; i < main.playlists.length; i++) {
            const p = main.playlists[i];
            if (p.attributes && p.attributes.AUDIO && p.attributes.AUDIO === groupKey) {
              return;
            }
          }
        }
        properties.playlists = [_extends$1({}, properties)];
      }
      properties.playlists.forEach(function(p, i) {
        const groupId = createGroupID(mediaType, groupKey, labelKey, p);
        const id = createPlaylistID(i, groupId);
        if (p.uri) {
          p.resolvedUri = p.resolvedUri || resolveUrl(main.uri, p.uri);
        } else {
          p.uri = i === 0 ? groupId : id;
          p.resolvedUri = p.uri;
        }
        p.id = p.id || id;
        p.attributes = p.attributes || {};
        main.playlists[p.id] = p;
        main.playlists[p.uri] = p;
      });
    });
    setupMediaPlaylists(main);
    resolveMediaGroupUris(main);
  };
  class DateRangesStorage {
    constructor() {
      this.offset_ = null;
      this.pendingDateRanges_ = /* @__PURE__ */ new Map();
      this.processedDateRanges_ = /* @__PURE__ */ new Map();
    }
    setOffset(segments = []) {
      if (this.offset_ !== null) {
        return;
      }
      if (!segments.length) {
        return;
      }
      const [firstSegment] = segments;
      if (firstSegment.programDateTime === void 0) {
        return;
      }
      this.offset_ = firstSegment.programDateTime / 1e3;
    }
    setPendingDateRanges(dateRanges = []) {
      if (!dateRanges.length) {
        return;
      }
      const [dateRange] = dateRanges;
      const startTime = dateRange.startDate.getTime();
      this.trimProcessedDateRanges_(startTime);
      this.pendingDateRanges_ = dateRanges.reduce((map, pendingDateRange) => {
        map.set(pendingDateRange.id, pendingDateRange);
        return map;
      }, /* @__PURE__ */ new Map());
    }
    processDateRange(dateRange) {
      this.pendingDateRanges_.delete(dateRange.id);
      this.processedDateRanges_.set(dateRange.id, dateRange);
    }
    getDateRangesToProcess() {
      if (this.offset_ === null) {
        return [];
      }
      const dateRangeClasses = {};
      const dateRangesToProcess = [];
      this.pendingDateRanges_.forEach((dateRange, id) => {
        if (this.processedDateRanges_.has(id)) {
          return;
        }
        dateRange.startTime = dateRange.startDate.getTime() / 1e3 - this.offset_;
        dateRange.processDateRange = () => this.processDateRange(dateRange);
        dateRangesToProcess.push(dateRange);
        if (!dateRange.class) {
          return;
        }
        if (dateRangeClasses[dateRange.class]) {
          const length = dateRangeClasses[dateRange.class].push(dateRange);
          dateRange.classListIndex = length - 1;
        } else {
          dateRangeClasses[dateRange.class] = [dateRange];
          dateRange.classListIndex = 0;
        }
      });
      for (const dateRange of dateRangesToProcess) {
        const classList = dateRangeClasses[dateRange.class] || [];
        if (dateRange.endDate) {
          dateRange.endTime = dateRange.endDate.getTime() / 1e3 - this.offset_;
        } else if (dateRange.endOnNext && classList[dateRange.classListIndex + 1]) {
          dateRange.endTime = classList[dateRange.classListIndex + 1].startTime;
        } else if (dateRange.duration) {
          dateRange.endTime = dateRange.startTime + dateRange.duration;
        } else if (dateRange.plannedDuration) {
          dateRange.endTime = dateRange.startTime + dateRange.plannedDuration;
        } else {
          dateRange.endTime = dateRange.startTime;
        }
      }
      return dateRangesToProcess;
    }
    trimProcessedDateRanges_(startTime) {
      const copy2 = new Map(this.processedDateRanges_);
      copy2.forEach((dateRange, id) => {
        if (dateRange.startDate.getTime() < startTime) {
          this.processedDateRanges_.delete(id);
        }
      });
    }
  }
  const {
    EventTarget: EventTarget$1
  } = videojs;
  const addLLHLSQueryDirectives = (uri, media) => {
    if (media.endList || !media.serverControl) {
      return uri;
    }
    const parameters = {};
    if (media.serverControl.canBlockReload) {
      const {
        preloadSegment
      } = media;
      let nextMSN = media.mediaSequence + media.segments.length;
      if (preloadSegment) {
        const parts = preloadSegment.parts || [];
        const nextPart = getKnownPartCount(media) - 1;
        if (nextPart > -1 && nextPart !== parts.length - 1) {
          parameters._HLS_part = nextPart;
        }
        if (nextPart > -1 || parts.length) {
          nextMSN--;
        }
      }
      parameters._HLS_msn = nextMSN;
    }
    if (media.serverControl && media.serverControl.canSkipUntil) {
      parameters._HLS_skip = media.serverControl.canSkipDateranges ? "v2" : "YES";
    }
    if (Object.keys(parameters).length) {
      const parsedUri = new window.URL(uri);
      ["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach(function(name) {
        if (!parameters.hasOwnProperty(name)) {
          return;
        }
        parsedUri.searchParams.set(name, parameters[name]);
      });
      uri = parsedUri.toString();
    }
    return uri;
  };
  const updateSegment = (a, b) => {
    if (!a) {
      return b;
    }
    const result = merge(a, b);
    if (a.preloadHints && !b.preloadHints) {
      delete result.preloadHints;
    }
    if (a.parts && !b.parts) {
      delete result.parts;
    } else if (a.parts && b.parts) {
      for (let i = 0; i < b.parts.length; i++) {
        if (a.parts && a.parts[i]) {
          result.parts[i] = merge(a.parts[i], b.parts[i]);
        }
      }
    }
    if (!a.skipped && b.skipped) {
      result.skipped = false;
    }
    if (a.preload && !b.preload) {
      result.preload = false;
    }
    return result;
  };
  const updateSegments = (original, update, offset) => {
    const oldSegments = original.slice();
    const newSegments = update.slice();
    offset = offset || 0;
    const result = [];
    let currentMap;
    for (let newIndex = 0; newIndex < newSegments.length; newIndex++) {
      const oldSegment = oldSegments[newIndex + offset];
      const newSegment = newSegments[newIndex];
      if (oldSegment) {
        currentMap = oldSegment.map || currentMap;
        result.push(updateSegment(oldSegment, newSegment));
      } else {
        if (currentMap && !newSegment.map) {
          newSegment.map = currentMap;
        }
        result.push(newSegment);
      }
    }
    return result;
  };
  const resolveSegmentUris = (segment, baseUri) => {
    if (!segment.resolvedUri && segment.uri) {
      segment.resolvedUri = resolveUrl(baseUri, segment.uri);
    }
    if (segment.key && !segment.key.resolvedUri) {
      segment.key.resolvedUri = resolveUrl(baseUri, segment.key.uri);
    }
    if (segment.map && !segment.map.resolvedUri) {
      segment.map.resolvedUri = resolveUrl(baseUri, segment.map.uri);
    }
    if (segment.map && segment.map.key && !segment.map.key.resolvedUri) {
      segment.map.key.resolvedUri = resolveUrl(baseUri, segment.map.key.uri);
    }
    if (segment.parts && segment.parts.length) {
      segment.parts.forEach((p) => {
        if (p.resolvedUri) {
          return;
        }
        p.resolvedUri = resolveUrl(baseUri, p.uri);
      });
    }
    if (segment.preloadHints && segment.preloadHints.length) {
      segment.preloadHints.forEach((p) => {
        if (p.resolvedUri) {
          return;
        }
        p.resolvedUri = resolveUrl(baseUri, p.uri);
      });
    }
  };
  const getAllSegments = function(media) {
    const segments = media.segments || [];
    const preloadSegment = media.preloadSegment;
    if (preloadSegment && preloadSegment.parts && preloadSegment.parts.length) {
      if (preloadSegment.preloadHints) {
        for (let i = 0; i < preloadSegment.preloadHints.length; i++) {
          if (preloadSegment.preloadHints[i].type === "MAP") {
            return segments;
          }
        }
      }
      preloadSegment.duration = media.targetDuration;
      preloadSegment.preload = true;
      segments.push(preloadSegment);
    }
    return segments;
  };
  const isPlaylistUnchanged = (a, b) => a === b || a.segments && b.segments && a.segments.length === b.segments.length && a.endList === b.endList && a.mediaSequence === b.mediaSequence && a.preloadSegment === b.preloadSegment;
  const updateMain$1 = (main, newMedia, unchangedCheck = isPlaylistUnchanged) => {
    const result = merge(main, {});
    const oldMedia = result.playlists[newMedia.id];
    if (!oldMedia) {
      return null;
    }
    if (unchangedCheck(oldMedia, newMedia)) {
      return null;
    }
    newMedia.segments = getAllSegments(newMedia);
    const mergedPlaylist = merge(oldMedia, newMedia);
    if (mergedPlaylist.preloadSegment && !newMedia.preloadSegment) {
      delete mergedPlaylist.preloadSegment;
    }
    if (oldMedia.segments) {
      if (newMedia.skip) {
        newMedia.segments = newMedia.segments || [];
        for (let i = 0; i < newMedia.skip.skippedSegments; i++) {
          newMedia.segments.unshift({
            skipped: true
          });
        }
      }
      mergedPlaylist.segments = updateSegments(oldMedia.segments, newMedia.segments, newMedia.mediaSequence - oldMedia.mediaSequence);
    }
    mergedPlaylist.segments.forEach((segment) => {
      resolveSegmentUris(segment, mergedPlaylist.resolvedUri);
    });
    for (let i = 0; i < result.playlists.length; i++) {
      if (result.playlists[i].id === newMedia.id) {
        result.playlists[i] = mergedPlaylist;
      }
    }
    result.playlists[newMedia.id] = mergedPlaylist;
    result.playlists[newMedia.uri] = mergedPlaylist;
    forEachMediaGroup(main, (properties, mediaType, groupKey, labelKey) => {
      if (!properties.playlists) {
        return;
      }
      for (let i = 0; i < properties.playlists.length; i++) {
        if (newMedia.id === properties.playlists[i].id) {
          properties.playlists[i] = mergedPlaylist;
        }
      }
    });
    return result;
  };
  const refreshDelay = (media, update) => {
    const segments = media.segments || [];
    const lastSegment = segments[segments.length - 1];
    const lastPart = lastSegment && lastSegment.parts && lastSegment.parts[lastSegment.parts.length - 1];
    const lastDuration = lastPart && lastPart.duration || lastSegment && lastSegment.duration;
    if (update && lastDuration) {
      return lastDuration * 1e3;
    }
    return (media.partTargetDuration || media.targetDuration || 10) * 500;
  };
  class PlaylistLoader extends EventTarget$1 {
    constructor(src, vhs, options = {}) {
      super();
      if (!src) {
        throw new Error("A non-empty playlist URL or object is required");
      }
      this.logger_ = logger("PlaylistLoader");
      const {
        withCredentials = false
      } = options;
      this.src = src;
      this.vhs_ = vhs;
      this.withCredentials = withCredentials;
      this.addDateRangesToTextTrack_ = options.addDateRangesToTextTrack;
      const vhsOptions = vhs.options_;
      this.customTagParsers = vhsOptions && vhsOptions.customTagParsers || [];
      this.customTagMappers = vhsOptions && vhsOptions.customTagMappers || [];
      this.llhls = vhsOptions && vhsOptions.llhls;
      this.dateRangesStorage_ = new DateRangesStorage();
      this.state = "HAVE_NOTHING";
      this.handleMediaupdatetimeout_ = this.handleMediaupdatetimeout_.bind(this);
      this.on("mediaupdatetimeout", this.handleMediaupdatetimeout_);
      this.on("loadedplaylist", this.handleLoadedPlaylist_.bind(this));
    }
    handleLoadedPlaylist_() {
      const mediaPlaylist = this.media();
      if (!mediaPlaylist) {
        return;
      }
      this.dateRangesStorage_.setOffset(mediaPlaylist.segments);
      this.dateRangesStorage_.setPendingDateRanges(mediaPlaylist.dateRanges);
      const availableDateRanges = this.dateRangesStorage_.getDateRangesToProcess();
      if (!availableDateRanges.length || !this.addDateRangesToTextTrack_) {
        return;
      }
      this.addDateRangesToTextTrack_(availableDateRanges);
    }
    handleMediaupdatetimeout_() {
      if (this.state !== "HAVE_METADATA") {
        return;
      }
      const media = this.media();
      let uri = resolveUrl(this.main.uri, media.uri);
      if (this.llhls) {
        uri = addLLHLSQueryDirectives(uri, media);
      }
      this.state = "HAVE_CURRENT_METADATA";
      this.request = this.vhs_.xhr({
        uri,
        withCredentials: this.withCredentials
      }, (error, req) => {
        if (!this.request) {
          return;
        }
        if (error) {
          return this.playlistRequestError(this.request, this.media(), "HAVE_METADATA");
        }
        this.haveMetadata({
          playlistString: this.request.responseText,
          url: this.media().uri,
          id: this.media().id
        });
      });
    }
    playlistRequestError(xhr, playlist, startingState) {
      const {
        uri,
        id
      } = playlist;
      this.request = null;
      if (startingState) {
        this.state = startingState;
      }
      this.error = {
        playlist: this.main.playlists[id],
        status: xhr.status,
        message: `HLS playlist request error at URL: ${uri}.`,
        responseText: xhr.responseText,
        code: xhr.status >= 500 ? 4 : 2
      };
      this.trigger("error");
    }
    parseManifest_({
      url,
      manifestString
    }) {
      return parseManifest({
        onwarn: ({
          message
        }) => this.logger_(`m3u8-parser warn for ${url}: ${message}`),
        oninfo: ({
          message
        }) => this.logger_(`m3u8-parser info for ${url}: ${message}`),
        manifestString,
        customTagParsers: this.customTagParsers,
        customTagMappers: this.customTagMappers,
        llhls: this.llhls
      });
    }
    /**
     * Update the playlist loader's state in response to a new or updated playlist.
     *
     * @param {string} [playlistString]
     *        Playlist string (if playlistObject is not provided)
     * @param {Object} [playlistObject]
     *        Playlist object (if playlistString is not provided)
     * @param {string} url
     *        URL of playlist
     * @param {string} id
     *        ID to use for playlist
     */
    haveMetadata({
      playlistString,
      playlistObject,
      url,
      id
    }) {
      this.request = null;
      this.state = "HAVE_METADATA";
      const playlist = playlistObject || this.parseManifest_({
        url,
        manifestString: playlistString
      });
      playlist.lastRequest = Date.now();
      setupMediaPlaylist({
        playlist,
        uri: url,
        id
      });
      const update = updateMain$1(this.main, playlist);
      this.targetDuration = playlist.partTargetDuration || playlist.targetDuration;
      this.pendingMedia_ = null;
      if (update) {
        this.main = update;
        this.media_ = this.main.playlists[id];
      } else {
        this.trigger("playlistunchanged");
      }
      this.updateMediaUpdateTimeout_(refreshDelay(this.media(), !!update));
      this.trigger("loadedplaylist");
    }
    /**
      * Abort any outstanding work and clean up.
      */
    dispose() {
      this.trigger("dispose");
      this.stopRequest();
      window.clearTimeout(this.mediaUpdateTimeout);
      window.clearTimeout(this.finalRenditionTimeout);
      this.dateRangesStorage_ = new DateRangesStorage();
      this.off();
    }
    stopRequest() {
      if (this.request) {
        const oldRequest = this.request;
        this.request = null;
        oldRequest.onreadystatechange = null;
        oldRequest.abort();
      }
    }
    /**
      * When called without any arguments, returns the currently
      * active media playlist. When called with a single argument,
      * triggers the playlist loader to asynchronously switch to the
      * specified media playlist. Calling this method while the
      * loader is in the HAVE_NOTHING causes an error to be emitted
      * but otherwise has no effect.
      *
      * @param {Object=} playlist the parsed media playlist
      * object to switch to
      * @param {boolean=} shouldDelay whether we should delay the request by half target duration
      *
      * @return {Playlist} the current loaded media
      */
    media(playlist, shouldDelay) {
      if (!playlist) {
        return this.media_;
      }
      if (this.state === "HAVE_NOTHING") {
        throw new Error("Cannot switch media playlist from " + this.state);
      }
      if (typeof playlist === "string") {
        if (!this.main.playlists[playlist]) {
          throw new Error("Unknown playlist URI: " + playlist);
        }
        playlist = this.main.playlists[playlist];
      }
      window.clearTimeout(this.finalRenditionTimeout);
      if (shouldDelay) {
        const delay = (playlist.partTargetDuration || playlist.targetDuration) / 2 * 1e3 || 5 * 1e3;
        this.finalRenditionTimeout = window.setTimeout(this.media.bind(this, playlist, false), delay);
        return;
      }
      const startingState = this.state;
      const mediaChange = !this.media_ || playlist.id !== this.media_.id;
      const mainPlaylistRef = this.main.playlists[playlist.id];
      if (mainPlaylistRef && mainPlaylistRef.endList || // handle the case of a playlist object (e.g., if using vhs-json with a resolved
      // media playlist or, for the case of demuxed audio, a resolved audio media group)
      playlist.endList && playlist.segments.length) {
        if (this.request) {
          this.request.onreadystatechange = null;
          this.request.abort();
          this.request = null;
        }
        this.state = "HAVE_METADATA";
        this.media_ = playlist;
        if (mediaChange) {
          this.trigger("mediachanging");
          if (startingState === "HAVE_MAIN_MANIFEST") {
            this.trigger("loadedmetadata");
          } else {
            this.trigger("mediachange");
          }
        }
        return;
      }
      this.updateMediaUpdateTimeout_(refreshDelay(playlist, true));
      if (!mediaChange) {
        return;
      }
      this.state = "SWITCHING_MEDIA";
      if (this.request) {
        if (playlist.resolvedUri === this.request.url) {
          return;
        }
        this.request.onreadystatechange = null;
        this.request.abort();
        this.request = null;
      }
      if (this.media_) {
        this.trigger("mediachanging");
      }
      this.pendingMedia_ = playlist;
      this.request = this.vhs_.xhr({
        uri: playlist.resolvedUri,
        withCredentials: this.withCredentials
      }, (error, req) => {
        if (!this.request) {
          return;
        }
        playlist.lastRequest = Date.now();
        playlist.resolvedUri = resolveManifestRedirect(playlist.resolvedUri, req);
        if (error) {
          return this.playlistRequestError(this.request, playlist, startingState);
        }
        this.haveMetadata({
          playlistString: req.responseText,
          url: playlist.uri,
          id: playlist.id
        });
        if (startingState === "HAVE_MAIN_MANIFEST") {
          this.trigger("loadedmetadata");
        } else {
          this.trigger("mediachange");
        }
      });
    }
    /**
     * pause loading of the playlist
     */
    pause() {
      if (this.mediaUpdateTimeout) {
        window.clearTimeout(this.mediaUpdateTimeout);
        this.mediaUpdateTimeout = null;
      }
      this.stopRequest();
      if (this.state === "HAVE_NOTHING") {
        this.started = false;
      }
      if (this.state === "SWITCHING_MEDIA") {
        if (this.media_) {
          this.state = "HAVE_METADATA";
        } else {
          this.state = "HAVE_MAIN_MANIFEST";
        }
      } else if (this.state === "HAVE_CURRENT_METADATA") {
        this.state = "HAVE_METADATA";
      }
    }
    /**
     * start loading of the playlist
     */
    load(shouldDelay) {
      if (this.mediaUpdateTimeout) {
        window.clearTimeout(this.mediaUpdateTimeout);
        this.mediaUpdateTimeout = null;
      }
      const media = this.media();
      if (shouldDelay) {
        const delay = media ? (media.partTargetDuration || media.targetDuration) / 2 * 1e3 : 5 * 1e3;
        this.mediaUpdateTimeout = window.setTimeout(() => {
          this.mediaUpdateTimeout = null;
          this.load();
        }, delay);
        return;
      }
      if (!this.started) {
        this.start();
        return;
      }
      if (media && !media.endList) {
        this.trigger("mediaupdatetimeout");
      } else {
        this.trigger("loadedplaylist");
      }
    }
    updateMediaUpdateTimeout_(delay) {
      if (this.mediaUpdateTimeout) {
        window.clearTimeout(this.mediaUpdateTimeout);
        this.mediaUpdateTimeout = null;
      }
      if (!this.media() || this.media().endList) {
        return;
      }
      this.mediaUpdateTimeout = window.setTimeout(() => {
        this.mediaUpdateTimeout = null;
        this.trigger("mediaupdatetimeout");
        this.updateMediaUpdateTimeout_(delay);
      }, delay);
    }
    /**
     * start loading of the playlist
     */
    start() {
      this.started = true;
      if (typeof this.src === "object") {
        if (!this.src.uri) {
          this.src.uri = window.location.href;
        }
        this.src.resolvedUri = this.src.uri;
        setTimeout(() => {
          this.setupInitialPlaylist(this.src);
        }, 0);
        return;
      }
      this.request = this.vhs_.xhr({
        uri: this.src,
        withCredentials: this.withCredentials
      }, (error, req) => {
        if (!this.request) {
          return;
        }
        this.request = null;
        if (error) {
          this.error = {
            status: req.status,
            message: `HLS playlist request error at URL: ${this.src}.`,
            responseText: req.responseText,
            // MEDIA_ERR_NETWORK
            code: 2
          };
          if (this.state === "HAVE_NOTHING") {
            this.started = false;
          }
          return this.trigger("error");
        }
        this.src = resolveManifestRedirect(this.src, req);
        const manifest = this.parseManifest_({
          manifestString: req.responseText,
          url: this.src
        });
        this.setupInitialPlaylist(manifest);
      });
    }
    srcUri() {
      return typeof this.src === "string" ? this.src : this.src.uri;
    }
    /**
     * Given a manifest object that's either a main or media playlist, trigger the proper
     * events and set the state of the playlist loader.
     *
     * If the manifest object represents a main playlist, `loadedplaylist` will be
     * triggered to allow listeners to select a playlist. If none is selected, the loader
     * will default to the first one in the playlists array.
     *
     * If the manifest object represents a media playlist, `loadedplaylist` will be
     * triggered followed by `loadedmetadata`, as the only available playlist is loaded.
     *
     * In the case of a media playlist, a main playlist object wrapper with one playlist
     * will be created so that all logic can handle playlists in the same fashion (as an
     * assumed manifest object schema).
     *
     * @param {Object} manifest
     *        The parsed manifest object
     */
    setupInitialPlaylist(manifest) {
      this.state = "HAVE_MAIN_MANIFEST";
      if (manifest.playlists) {
        this.main = manifest;
        addPropertiesToMain(this.main, this.srcUri());
        manifest.playlists.forEach((playlist) => {
          playlist.segments = getAllSegments(playlist);
          playlist.segments.forEach((segment) => {
            resolveSegmentUris(segment, playlist.resolvedUri);
          });
        });
        this.trigger("loadedplaylist");
        if (!this.request) {
          this.media(this.main.playlists[0]);
        }
        return;
      }
      const uri = this.srcUri() || window.location.href;
      this.main = mainForMedia(manifest, uri);
      this.haveMetadata({
        playlistObject: manifest,
        url: uri,
        id: this.main.playlists[0].id
      });
      this.trigger("loadedmetadata");
    }
    /**
     * Updates or deletes a preexisting pathway clone.
     * Ensures that all playlists related to the old pathway clone are
     * either updated or deleted.
     *
     * @param {Object} clone On update, the pathway clone object for the newly updated pathway clone.
     *        On delete, the old pathway clone object to be deleted.
     * @param {boolean} isUpdate True if the pathway is to be updated,
     *        false if it is meant to be deleted.
     */
    updateOrDeleteClone(clone, isUpdate) {
      const main = this.main;
      const pathway = clone.ID;
      let i = main.playlists.length;
      while (i--) {
        const p = main.playlists[i];
        if (p.attributes["PATHWAY-ID"] === pathway) {
          const oldPlaylistUri = p.resolvedUri;
          const oldPlaylistId = p.id;
          if (isUpdate) {
            const newPlaylistUri = this.createCloneURI_(p.resolvedUri, clone);
            const newPlaylistId = createPlaylistID(pathway, newPlaylistUri);
            const attributes = this.createCloneAttributes_(pathway, p.attributes);
            const updatedPlaylist = this.createClonePlaylist_(p, newPlaylistId, clone, attributes);
            main.playlists[i] = updatedPlaylist;
            main.playlists[newPlaylistId] = updatedPlaylist;
            main.playlists[newPlaylistUri] = updatedPlaylist;
          } else {
            main.playlists.splice(i, 1);
          }
          delete main.playlists[oldPlaylistId];
          delete main.playlists[oldPlaylistUri];
        }
      }
      this.updateOrDeleteCloneMedia(clone, isUpdate);
    }
    /**
     * Updates or deletes media data based on the pathway clone object.
     * Due to the complexity of the media groups and playlists, in all cases
     * we remove all of the old media groups and playlists.
     * On updates, we then create new media groups and playlists based on the
     * new pathway clone object.
     *
     * @param {Object} clone The pathway clone object for the newly updated pathway clone.
     * @param {boolean} isUpdate True if the pathway is to be updated,
     *        false if it is meant to be deleted.
     */
    updateOrDeleteCloneMedia(clone, isUpdate) {
      const main = this.main;
      const id = clone.ID;
      ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((mediaType) => {
        if (!main.mediaGroups[mediaType] || !main.mediaGroups[mediaType][id]) {
          return;
        }
        for (const groupKey in main.mediaGroups[mediaType]) {
          if (groupKey === id) {
            for (const labelKey in main.mediaGroups[mediaType][groupKey]) {
              const oldMedia = main.mediaGroups[mediaType][groupKey][labelKey];
              oldMedia.playlists.forEach((p, i) => {
                const oldMediaPlaylist = main.playlists[p.id];
                const oldPlaylistId = oldMediaPlaylist.id;
                const oldPlaylistUri = oldMediaPlaylist.resolvedUri;
                delete main.playlists[oldPlaylistId];
                delete main.playlists[oldPlaylistUri];
              });
            }
            delete main.mediaGroups[mediaType][groupKey];
          }
        }
      });
      if (isUpdate) {
        this.createClonedMediaGroups_(clone);
      }
    }
    /**
     * Given a pathway clone object, clones all necessary playlists.
     *
     * @param {Object} clone The pathway clone object.
     * @param {Object} basePlaylist The original playlist to clone from.
     */
    addClonePathway(clone, basePlaylist = {}) {
      const main = this.main;
      const index = main.playlists.length;
      const uri = this.createCloneURI_(basePlaylist.resolvedUri, clone);
      const playlistId = createPlaylistID(clone.ID, uri);
      const attributes = this.createCloneAttributes_(clone.ID, basePlaylist.attributes);
      const playlist = this.createClonePlaylist_(basePlaylist, playlistId, clone, attributes);
      main.playlists[index] = playlist;
      main.playlists[playlistId] = playlist;
      main.playlists[uri] = playlist;
      this.createClonedMediaGroups_(clone);
    }
    /**
     * Given a pathway clone object we create clones of all media.
     * In this function, all necessary information and updated playlists
     * are added to the `mediaGroup` object.
     * Playlists are also added to the `playlists` array so the media groups
     * will be properly linked.
     *
     * @param {Object} clone The pathway clone object.
     */
    createClonedMediaGroups_(clone) {
      const id = clone.ID;
      const baseID = clone["BASE-ID"];
      const main = this.main;
      ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((mediaType) => {
        if (!main.mediaGroups[mediaType] || main.mediaGroups[mediaType][id]) {
          return;
        }
        for (const groupKey in main.mediaGroups[mediaType]) {
          if (groupKey === baseID) {
            main.mediaGroups[mediaType][id] = {};
          } else {
            continue;
          }
          for (const labelKey in main.mediaGroups[mediaType][groupKey]) {
            const oldMedia = main.mediaGroups[mediaType][groupKey][labelKey];
            main.mediaGroups[mediaType][id][labelKey] = _extends$1({}, oldMedia);
            const newMedia = main.mediaGroups[mediaType][id][labelKey];
            const newUri = this.createCloneURI_(oldMedia.resolvedUri, clone);
            newMedia.resolvedUri = newUri;
            newMedia.uri = newUri;
            newMedia.playlists = [];
            oldMedia.playlists.forEach((p, i) => {
              const oldMediaPlaylist = main.playlists[p.id];
              const group = groupID(mediaType, id, labelKey);
              const newPlaylistID = createPlaylistID(id, group);
              if (oldMediaPlaylist && !main.playlists[newPlaylistID]) {
                const newMediaPlaylist = this.createClonePlaylist_(oldMediaPlaylist, newPlaylistID, clone);
                const newPlaylistUri = newMediaPlaylist.resolvedUri;
                main.playlists[newPlaylistID] = newMediaPlaylist;
                main.playlists[newPlaylistUri] = newMediaPlaylist;
              }
              newMedia.playlists[i] = this.createClonePlaylist_(p, newPlaylistID, clone);
            });
          }
        }
      });
    }
    /**
     * Using the original playlist to be cloned, and the pathway clone object
     * information, we create a new playlist.
     *
     * @param {Object} basePlaylist  The original playlist to be cloned from.
     * @param {string} id The desired id of the newly cloned playlist.
     * @param {Object} clone The pathway clone object.
     * @param {Object} attributes An optional object to populate the `attributes` property in the playlist.
     *
     * @return {Object} The combined cloned playlist.
     */
    createClonePlaylist_(basePlaylist, id, clone, attributes) {
      const uri = this.createCloneURI_(basePlaylist.resolvedUri, clone);
      const newProps = {
        resolvedUri: uri,
        uri,
        id
      };
      if (basePlaylist.segments) {
        newProps.segments = [];
      }
      if (attributes) {
        newProps.attributes = attributes;
      }
      return merge(basePlaylist, newProps);
    }
    /**
     * Generates an updated URI for a cloned pathway based on the original
     * pathway's URI and the paramaters from the pathway clone object in the
     * content steering server response.
     *
     * @param {string} baseUri URI to be updated in the cloned pathway.
     * @param {Object} clone The pathway clone object.
     *
     * @return {string} The updated URI for the cloned pathway.
     */
    createCloneURI_(baseURI, clone) {
      const uri = new URL(baseURI);
      uri.hostname = clone["URI-REPLACEMENT"].HOST;
      const params = clone["URI-REPLACEMENT"].PARAMS;
      for (const key of Object.keys(params)) {
        uri.searchParams.set(key, params[key]);
      }
      return uri.href;
    }
    /**
     * Helper function to create the attributes needed for the new clone.
     * This mainly adds the necessary media attributes.
     *
     * @param {string} id The pathway clone object ID.
     * @param {Object} oldAttributes The old attributes to compare to.
     * @return {Object} The new attributes to add to the playlist.
     */
    createCloneAttributes_(id, oldAttributes) {
      const attributes = {
        ["PATHWAY-ID"]: id
      };
      ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((mediaType) => {
        if (oldAttributes[mediaType]) {
          attributes[mediaType] = id;
        }
      });
      return attributes;
    }
    /**
     * Returns the key ID set from a playlist
     *
     * @param {playlist} playlist to fetch the key ID set from.
     * @return a Set of 32 digit hex strings that represent the unique keyIds for that playlist.
     */
    getKeyIdSet(playlist) {
      if (playlist.contentProtection) {
        const keyIds = /* @__PURE__ */ new Set();
        for (const keysystem in playlist.contentProtection) {
          const keyId = playlist.contentProtection[keysystem].attributes.keyId;
          if (keyId) {
            keyIds.add(keyId.toLowerCase());
          }
        }
        return keyIds;
      }
    }
  }
  const {
    xhr: videojsXHR
  } = videojs;
  const callbackWrapper = function(request, error, response, callback) {
    const reqResponse = request.responseType === "arraybuffer" ? request.response : request.responseText;
    if (!error && reqResponse) {
      request.responseTime = Date.now();
      request.roundTripTime = request.responseTime - request.requestTime;
      request.bytesReceived = reqResponse.byteLength || reqResponse.length;
      if (!request.bandwidth) {
        request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1e3);
      }
    }
    if (response.headers) {
      request.responseHeaders = response.headers;
    }
    if (error && error.code === "ETIMEDOUT") {
      request.timedout = true;
    }
    if (!error && !request.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {
      error = new Error("XHR Failed with a response of: " + (request && (reqResponse || request.responseText)));
    }
    callback(error, request);
  };
  const callAllRequestHooks = (requestSet, options) => {
    if (!requestSet || !requestSet.size) {
      return;
    }
    let newOptions = options;
    requestSet.forEach((requestCallback) => {
      newOptions = requestCallback(newOptions);
    });
    return newOptions;
  };
  const callAllResponseHooks = (responseSet, request, error, response) => {
    if (!responseSet || !responseSet.size) {
      return;
    }
    responseSet.forEach((responseCallback) => {
      responseCallback(request, error, response);
    });
  };
  const xhrFactory = function() {
    const xhr = function XhrFunction(options, callback) {
      options = merge({
        timeout: 45e3
      }, options);
      const beforeRequest = XhrFunction.beforeRequest || videojs.Vhs.xhr.beforeRequest;
      const _requestCallbackSet = XhrFunction._requestCallbackSet || videojs.Vhs.xhr._requestCallbackSet || /* @__PURE__ */ new Set();
      const _responseCallbackSet = XhrFunction._responseCallbackSet || videojs.Vhs.xhr._responseCallbackSet;
      if (beforeRequest && typeof beforeRequest === "function") {
        videojs.log.warn("beforeRequest is deprecated, use onRequest instead.");
        _requestCallbackSet.add(beforeRequest);
      }
      const xhrMethod = videojs.Vhs.xhr.original === true ? videojsXHR : videojs.Vhs.xhr;
      const beforeRequestOptions = callAllRequestHooks(_requestCallbackSet, options);
      _requestCallbackSet.delete(beforeRequest);
      const request = xhrMethod(beforeRequestOptions || options, function(error, response) {
        callAllResponseHooks(_responseCallbackSet, request, error, response);
        return callbackWrapper(request, error, response, callback);
      });
      const originalAbort = request.abort;
      request.abort = function() {
        request.aborted = true;
        return originalAbort.apply(request, arguments);
      };
      request.uri = options.uri;
      request.requestTime = Date.now();
      return request;
    };
    xhr.original = true;
    return xhr;
  };
  const byterangeStr = function(byterange) {
    let byterangeEnd;
    const byterangeStart = byterange.offset;
    if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") {
      byterangeEnd = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);
    } else {
      byterangeEnd = byterange.offset + byterange.length - 1;
    }
    return "bytes=" + byterangeStart + "-" + byterangeEnd;
  };
  const segmentXhrHeaders = function(segment) {
    const headers = {};
    if (segment.byterange) {
      headers.Range = byterangeStr(segment.byterange);
    }
    return headers;
  };
  const textRange = function(range2, i) {
    return range2.start(i) + "-" + range2.end(i);
  };
  const formatHexString = function(e, i) {
    const value = e.toString(16);
    return "00".substring(0, 2 - value.length) + value + (i % 2 ? " " : "");
  };
  const formatAsciiString = function(e) {
    if (e >= 32 && e < 126) {
      return String.fromCharCode(e);
    }
    return ".";
  };
  const createTransferableMessage = function(message) {
    const transferable = {};
    Object.keys(message).forEach((key) => {
      const value = message[key];
      if (isArrayBufferView(value)) {
        transferable[key] = {
          bytes: value.buffer,
          byteOffset: value.byteOffset,
          byteLength: value.byteLength
        };
      } else {
        transferable[key] = value;
      }
    });
    return transferable;
  };
  const initSegmentId = function(initSegment) {
    const byterange = initSegment.byterange || {
      length: Infinity,
      offset: 0
    };
    return [byterange.length, byterange.offset, initSegment.resolvedUri].join(",");
  };
  const segmentKeyId = function(key) {
    return key.resolvedUri;
  };
  const hexDump = (data) => {
    const bytes = Array.prototype.slice.call(data);
    const step = 16;
    let result = "";
    let hex;
    let ascii;
    for (let j = 0; j < bytes.length / step; j++) {
      hex = bytes.slice(j * step, j * step + step).map(formatHexString).join("");
      ascii = bytes.slice(j * step, j * step + step).map(formatAsciiString).join("");
      result += hex + " " + ascii + "\n";
    }
    return result;
  };
  const tagDump = ({
    bytes
  }) => hexDump(bytes);
  const textRanges = (ranges) => {
    let result = "";
    let i;
    for (i = 0; i < ranges.length; i++) {
      result += textRange(ranges, i) + " ";
    }
    return result;
  };
  var utils = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    createTransferableMessage,
    initSegmentId,
    segmentKeyId,
    hexDump,
    tagDump,
    textRanges
  });
  const SEGMENT_END_FUDGE_PERCENT = 0.25;
  const playerTimeToProgramTime = (playerTime, segment) => {
    if (!segment.dateTimeObject) {
      return null;
    }
    const transmuxerPrependedSeconds = segment.videoTimingInfo.transmuxerPrependedSeconds;
    const transmuxedStart = segment.videoTimingInfo.transmuxedPresentationStart;
    const startOfSegment = transmuxedStart + transmuxerPrependedSeconds;
    const offsetFromSegmentStart = playerTime - startOfSegment;
    return new Date(segment.dateTimeObject.getTime() + offsetFromSegmentStart * 1e3);
  };
  const originalSegmentVideoDuration = (videoTimingInfo) => {
    return videoTimingInfo.transmuxedPresentationEnd - videoTimingInfo.transmuxedPresentationStart - videoTimingInfo.transmuxerPrependedSeconds;
  };
  const findSegmentForProgramTime = (programTime, playlist) => {
    let dateTimeObject;
    try {
      dateTimeObject = new Date(programTime);
    } catch (e) {
      return null;
    }
    if (!playlist || !playlist.segments || playlist.segments.length === 0) {
      return null;
    }
    let segment = playlist.segments[0];
    if (dateTimeObject < new Date(segment.dateTimeObject)) {
      return null;
    }
    for (let i = 0; i < playlist.segments.length - 1; i++) {
      segment = playlist.segments[i];
      const nextSegmentStart = new Date(playlist.segments[i + 1].dateTimeObject);
      if (dateTimeObject < nextSegmentStart) {
        break;
      }
    }
    const lastSegment = playlist.segments[playlist.segments.length - 1];
    const lastSegmentStart = lastSegment.dateTimeObject;
    const lastSegmentDuration = lastSegment.videoTimingInfo ? originalSegmentVideoDuration(lastSegment.videoTimingInfo) : lastSegment.duration + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT;
    const lastSegmentEnd = new Date(lastSegmentStart.getTime() + lastSegmentDuration * 1e3);
    if (dateTimeObject > lastSegmentEnd) {
      return null;
    }
    if (dateTimeObject > new Date(lastSegmentStart)) {
      segment = lastSegment;
    }
    return {
      segment,
      estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : Playlist.duration(playlist, playlist.mediaSequence + playlist.segments.indexOf(segment)),
      // Although, given that all segments have accurate date time objects, the segment
      // selected should be accurate, unless the video has been transmuxed at some point
      // (determined by the presence of the videoTimingInfo object), the segment's "player
      // time" (the start time in the player) can't be considered accurate.
      type: segment.videoTimingInfo ? "accurate" : "estimate"
    };
  };
  const findSegmentForPlayerTime = (time, playlist) => {
    if (!playlist || !playlist.segments || playlist.segments.length === 0) {
      return null;
    }
    let segmentEnd = 0;
    let segment;
    for (let i = 0; i < playlist.segments.length; i++) {
      segment = playlist.segments[i];
      segmentEnd = segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationEnd : segmentEnd + segment.duration;
      if (time <= segmentEnd) {
        break;
      }
    }
    const lastSegment = playlist.segments[playlist.segments.length - 1];
    if (lastSegment.videoTimingInfo && lastSegment.videoTimingInfo.transmuxedPresentationEnd < time) {
      return null;
    }
    if (time > segmentEnd) {
      if (time > segmentEnd + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT) {
        return null;
      }
      segment = lastSegment;
    }
    return {
      segment,
      estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : segmentEnd - segment.duration,
      // Because videoTimingInfo is only set after transmux, it is the only way to get
      // accurate timing values.
      type: segment.videoTimingInfo ? "accurate" : "estimate"
    };
  };
  const getOffsetFromTimestamp = (comparisonTimeStamp, programTime) => {
    let segmentDateTime;
    let programDateTime;
    try {
      segmentDateTime = new Date(comparisonTimeStamp);
      programDateTime = new Date(programTime);
    } catch (e) {
    }
    const segmentTimeEpoch = segmentDateTime.getTime();
    const programTimeEpoch = programDateTime.getTime();
    return (programTimeEpoch - segmentTimeEpoch) / 1e3;
  };
  const verifyProgramDateTimeTags = (playlist) => {
    if (!playlist.segments || playlist.segments.length === 0) {
      return false;
    }
    for (let i = 0; i < playlist.segments.length; i++) {
      const segment = playlist.segments[i];
      if (!segment.dateTimeObject) {
        return false;
      }
    }
    return true;
  };
  const getProgramTime = ({
    playlist,
    time = void 0,
    callback
  }) => {
    if (!callback) {
      throw new Error("getProgramTime: callback must be provided");
    }
    if (!playlist || time === void 0) {
      return callback({
        message: "getProgramTime: playlist and time must be provided"
      });
    }
    const matchedSegment = findSegmentForPlayerTime(time, playlist);
    if (!matchedSegment) {
      return callback({
        message: "valid programTime was not found"
      });
    }
    if (matchedSegment.type === "estimate") {
      return callback({
        message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again",
        seekTime: matchedSegment.estimatedStart
      });
    }
    const programTimeObject = {
      mediaSeconds: time
    };
    const programTime = playerTimeToProgramTime(time, matchedSegment.segment);
    if (programTime) {
      programTimeObject.programDateTime = programTime.toISOString();
    }
    return callback(null, programTimeObject);
  };
  const seekToProgramTime = ({
    programTime,
    playlist,
    retryCount = 2,
    seekTo,
    pauseAfterSeek = true,
    tech,
    callback
  }) => {
    if (!callback) {
      throw new Error("seekToProgramTime: callback must be provided");
    }
    if (typeof programTime === "undefined" || !playlist || !seekTo) {
      return callback({
        message: "seekToProgramTime: programTime, seekTo and playlist must be provided"
      });
    }
    if (!playlist.endList && !tech.hasStarted_) {
      return callback({
        message: "player must be playing a live stream to start buffering"
      });
    }
    if (!verifyProgramDateTimeTags(playlist)) {
      return callback({
        message: "programDateTime tags must be provided in the manifest " + playlist.resolvedUri
      });
    }
    const matchedSegment = findSegmentForProgramTime(programTime, playlist);
    if (!matchedSegment) {
      return callback({
        message: `${programTime} was not found in the stream`
      });
    }
    const segment = matchedSegment.segment;
    const mediaOffset = getOffsetFromTimestamp(segment.dateTimeObject, programTime);
    if (matchedSegment.type === "estimate") {
      if (retryCount === 0) {
        return callback({
          message: `${programTime} is not buffered yet. Try again`
        });
      }
      seekTo(matchedSegment.estimatedStart + mediaOffset);
      tech.one("seeked", () => {
        seekToProgramTime({
          programTime,
          playlist,
          retryCount: retryCount - 1,
          seekTo,
          pauseAfterSeek,
          tech,
          callback
        });
      });
      return;
    }
    const seekToTime = segment.start + mediaOffset;
    const seekedCallback = () => {
      return callback(null, tech.currentTime());
    };
    tech.one("seeked", seekedCallback);
    if (pauseAfterSeek) {
      tech.pause();
    }
    seekTo(seekToTime);
  };
  const callbackOnCompleted = (request, cb) => {
    if (request.readyState === 4) {
      return cb();
    }
    return;
  };
  const containerRequest = (uri, xhr, cb) => {
    let bytes = [];
    let id3Offset;
    let finished = false;
    const endRequestAndCallback = function(err, req, type, _bytes) {
      req.abort();
      finished = true;
      return cb(err, req, type, _bytes);
    };
    const progressListener = function(error, request2) {
      if (finished) {
        return;
      }
      if (error) {
        return endRequestAndCallback(error, request2, "", bytes);
      }
      const newPart = request2.responseText.substring(bytes && bytes.byteLength || 0, request2.responseText.length);
      bytes = concatTypedArrays(bytes, stringToBytes(newPart, true));
      id3Offset = id3Offset || getId3Offset(bytes);
      if (bytes.length < 10 || id3Offset && bytes.length < id3Offset + 2) {
        return callbackOnCompleted(request2, () => endRequestAndCallback(error, request2, "", bytes));
      }
      const type = detectContainerForBytes(bytes);
      if (type === "ts" && bytes.length < 188) {
        return callbackOnCompleted(request2, () => endRequestAndCallback(error, request2, "", bytes));
      }
      if (!type && bytes.length < 376) {
        return callbackOnCompleted(request2, () => endRequestAndCallback(error, request2, "", bytes));
      }
      return endRequestAndCallback(null, request2, type, bytes);
    };
    const options = {
      uri,
      beforeSend(request2) {
        request2.overrideMimeType("text/plain; charset=x-user-defined");
        request2.addEventListener("progress", function({
          total,
          loaded
        }) {
          return callbackWrapper(request2, null, {
            statusCode: request2.status
          }, progressListener);
        });
      }
    };
    const request = xhr(options, function(error, response) {
      return callbackWrapper(request, error, response, progressListener);
    });
    return request;
  };
  const {
    EventTarget
  } = videojs;
  const dashPlaylistUnchanged = function(a, b) {
    if (!isPlaylistUnchanged(a, b)) {
      return false;
    }
    if (a.sidx && b.sidx && (a.sidx.offset !== b.sidx.offset || a.sidx.length !== b.sidx.length)) {
      return false;
    } else if (!a.sidx && b.sidx || a.sidx && !b.sidx) {
      return false;
    }
    if (a.segments && !b.segments || !a.segments && b.segments) {
      return false;
    }
    if (!a.segments && !b.segments) {
      return true;
    }
    for (let i = 0; i < a.segments.length; i++) {
      const aSegment = a.segments[i];
      const bSegment = b.segments[i];
      if (aSegment.uri !== bSegment.uri) {
        return false;
      }
      if (!aSegment.byterange && !bSegment.byterange) {
        continue;
      }
      const aByterange = aSegment.byterange;
      const bByterange = bSegment.byterange;
      if (aByterange && !bByterange || !aByterange && bByterange) {
        return false;
      }
      if (aByterange.offset !== bByterange.offset || aByterange.length !== bByterange.length) {
        return false;
      }
    }
    return true;
  };
  const dashGroupId = (type, group, label, playlist) => {
    const playlistId = playlist.attributes.NAME || label;
    return `placeholder-uri-${type}-${group}-${playlistId}`;
  };
  const parseMainXml = ({
    mainXml,
    srcUrl,
    clientOffset,
    sidxMapping,
    previousManifest
  }) => {
    const manifest = parse(mainXml, {
      manifestUri: srcUrl,
      clientOffset,
      sidxMapping,
      previousManifest
    });
    addPropertiesToMain(manifest, srcUrl, dashGroupId);
    return manifest;
  };
  const removeOldMediaGroupLabels = (update, newMain) => {
    forEachMediaGroup(update, (properties, type, group, label) => {
      if (!(label in newMain.mediaGroups[type][group])) {
        delete update.mediaGroups[type][group][label];
      }
    });
  };
  const updateMain = (oldMain, newMain, sidxMapping) => {
    let noChanges = true;
    let update = merge(oldMain, {
      // These are top level properties that can be updated
      duration: newMain.duration,
      minimumUpdatePeriod: newMain.minimumUpdatePeriod,
      timelineStarts: newMain.timelineStarts
    });
    for (let i = 0; i < newMain.playlists.length; i++) {
      const playlist = newMain.playlists[i];
      if (playlist.sidx) {
        const sidxKey = generateSidxKey(playlist.sidx);
        if (sidxMapping && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx) {
          addSidxSegmentsToPlaylist$1(playlist, sidxMapping[sidxKey].sidx, playlist.sidx.resolvedUri);
        }
      }
      const playlistUpdate = updateMain$1(update, playlist, dashPlaylistUnchanged);
      if (playlistUpdate) {
        update = playlistUpdate;
        noChanges = false;
      }
    }
    forEachMediaGroup(newMain, (properties, type, group, label) => {
      if (properties.playlists && properties.playlists.length) {
        const id = properties.playlists[0].id;
        const playlistUpdate = updateMain$1(update, properties.playlists[0], dashPlaylistUnchanged);
        if (playlistUpdate) {
          update = playlistUpdate;
          if (!(label in update.mediaGroups[type][group])) {
            update.mediaGroups[type][group][label] = properties;
          }
          update.mediaGroups[type][group][label].playlists[0] = update.playlists[id];
          noChanges = false;
        }
      }
    });
    removeOldMediaGroupLabels(update, newMain);
    if (newMain.minimumUpdatePeriod !== oldMain.minimumUpdatePeriod) {
      noChanges = false;
    }
    if (noChanges) {
      return null;
    }
    return update;
  };
  const equivalentSidx = (a, b) => {
    const neitherMap = Boolean(!a.map && !b.map);
    const equivalentMap = neitherMap || Boolean(a.map && b.map && a.map.byterange.offset === b.map.byterange.offset && a.map.byterange.length === b.map.byterange.length);
    return equivalentMap && a.uri === b.uri && a.byterange.offset === b.byterange.offset && a.byterange.length === b.byterange.length;
  };
  const compareSidxEntry = (playlists, oldSidxMapping) => {
    const newSidxMapping = {};
    for (const id in playlists) {
      const playlist = playlists[id];
      const currentSidxInfo = playlist.sidx;
      if (currentSidxInfo) {
        const key = generateSidxKey(currentSidxInfo);
        if (!oldSidxMapping[key]) {
          break;
        }
        const savedSidxInfo = oldSidxMapping[key].sidxInfo;
        if (equivalentSidx(savedSidxInfo, currentSidxInfo)) {
          newSidxMapping[key] = oldSidxMapping[key];
        }
      }
    }
    return newSidxMapping;
  };
  const filterChangedSidxMappings = (main, oldSidxMapping) => {
    const videoSidx = compareSidxEntry(main.playlists, oldSidxMapping);
    let mediaGroupSidx = videoSidx;
    forEachMediaGroup(main, (properties, mediaType, groupKey, labelKey) => {
      if (properties.playlists && properties.playlists.length) {
        const playlists = properties.playlists;
        mediaGroupSidx = merge(mediaGroupSidx, compareSidxEntry(playlists, oldSidxMapping));
      }
    });
    return mediaGroupSidx;
  };
  class DashPlaylistLoader extends EventTarget {
    // DashPlaylistLoader must accept either a src url or a playlist because subsequent
    // playlist loader setups from media groups will expect to be able to pass a playlist
    // (since there aren't external URLs to media playlists with DASH)
    constructor(srcUrlOrPlaylist, vhs, options = {}, mainPlaylistLoader) {
      super();
      this.mainPlaylistLoader_ = mainPlaylistLoader || this;
      if (!mainPlaylistLoader) {
        this.isMain_ = true;
      }
      const {
        withCredentials = false
      } = options;
      this.vhs_ = vhs;
      this.withCredentials = withCredentials;
      this.addMetadataToTextTrack = options.addMetadataToTextTrack;
      if (!srcUrlOrPlaylist) {
        throw new Error("A non-empty playlist URL or object is required");
      }
      this.on("minimumUpdatePeriod", () => {
        this.refreshXml_();
      });
      this.on("mediaupdatetimeout", () => {
        this.refreshMedia_(this.media().id);
      });
      this.state = "HAVE_NOTHING";
      this.loadedPlaylists_ = {};
      this.logger_ = logger("DashPlaylistLoader");
      if (this.isMain_) {
        this.mainPlaylistLoader_.srcUrl = srcUrlOrPlaylist;
        this.mainPlaylistLoader_.sidxMapping_ = {};
      } else {
        this.childPlaylist_ = srcUrlOrPlaylist;
      }
    }
    requestErrored_(err, request, startingState) {
      if (!this.request) {
        return true;
      }
      this.request = null;
      if (err) {
        this.error = typeof err === "object" && !(err instanceof Error) ? err : {
          status: request.status,
          message: "DASH request error at URL: " + request.uri,
          response: request.response,
          // MEDIA_ERR_NETWORK
          code: 2
        };
        if (startingState) {
          this.state = startingState;
        }
        this.trigger("error");
        return true;
      }
    }
    /**
     * Verify that the container of the sidx segment can be parsed
     * and if it can, get and parse that segment.
     */
    addSidxSegments_(playlist, startingState, cb) {
      const sidxKey = playlist.sidx && generateSidxKey(playlist.sidx);
      if (!playlist.sidx || !sidxKey || this.mainPlaylistLoader_.sidxMapping_[sidxKey]) {
        this.mediaRequest_ = window.setTimeout(() => cb(false), 0);
        return;
      }
      const uri = resolveManifestRedirect(playlist.sidx.resolvedUri);
      const fin = (err, request) => {
        if (this.requestErrored_(err, request, startingState)) {
          return;
        }
        const sidxMapping = this.mainPlaylistLoader_.sidxMapping_;
        let sidx;
        try {
          sidx = parseSidx_1(toUint8(request.response).subarray(8));
        } catch (e) {
          this.requestErrored_(e, request, startingState);
          return;
        }
        sidxMapping[sidxKey] = {
          sidxInfo: playlist.sidx,
          sidx
        };
        addSidxSegmentsToPlaylist$1(playlist, sidx, playlist.sidx.resolvedUri);
        return cb(true);
      };
      this.request = containerRequest(uri, this.vhs_.xhr, (err, request, container, bytes) => {
        if (err) {
          return fin(err, request);
        }
        if (!container || container !== "mp4") {
          return fin({
            status: request.status,
            message: `Unsupported ${container || "unknown"} container type for sidx segment at URL: ${uri}`,
            // response is just bytes in this case
            // but we really don't want to return that.
            response: "",
            playlist,
            internal: true,
            playlistExclusionDuration: Infinity,
            // MEDIA_ERR_NETWORK
            code: 2
          }, request);
        }
        const {
          offset,
          length
        } = playlist.sidx.byterange;
        if (bytes.length >= length + offset) {
          return fin(err, {
            response: bytes.subarray(offset, offset + length),
            status: request.status,
            uri: request.uri
          });
        }
        this.request = this.vhs_.xhr({
          uri,
          responseType: "arraybuffer",
          headers: segmentXhrHeaders({
            byterange: playlist.sidx.byterange
          })
        }, fin);
      });
    }
    dispose() {
      this.trigger("dispose");
      this.stopRequest();
      this.loadedPlaylists_ = {};
      window.clearTimeout(this.minimumUpdatePeriodTimeout_);
      window.clearTimeout(this.mediaRequest_);
      window.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
      this.mediaRequest_ = null;
      this.minimumUpdatePeriodTimeout_ = null;
      if (this.mainPlaylistLoader_.createMupOnMedia_) {
        this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_);
        this.mainPlaylistLoader_.createMupOnMedia_ = null;
      }
      this.off();
    }
    hasPendingRequest() {
      return this.request || this.mediaRequest_;
    }
    stopRequest() {
      if (this.request) {
        const oldRequest = this.request;
        this.request = null;
        oldRequest.onreadystatechange = null;
        oldRequest.abort();
      }
    }
    media(playlist) {
      if (!playlist) {
        return this.media_;
      }
      if (this.state === "HAVE_NOTHING") {
        throw new Error("Cannot switch media playlist from " + this.state);
      }
      const startingState = this.state;
      if (typeof playlist === "string") {
        if (!this.mainPlaylistLoader_.main.playlists[playlist]) {
          throw new Error("Unknown playlist URI: " + playlist);
        }
        playlist = this.mainPlaylistLoader_.main.playlists[playlist];
      }
      const mediaChange = !this.media_ || playlist.id !== this.media_.id;
      if (mediaChange && this.loadedPlaylists_[playlist.id] && this.loadedPlaylists_[playlist.id].endList) {
        this.state = "HAVE_METADATA";
        this.media_ = playlist;
        if (mediaChange) {
          this.trigger("mediachanging");
          this.trigger("mediachange");
        }
        return;
      }
      if (!mediaChange) {
        return;
      }
      if (this.media_) {
        this.trigger("mediachanging");
      }
      this.addSidxSegments_(playlist, startingState, (sidxChanged) => {
        this.haveMetadata({
          startingState,
          playlist
        });
      });
    }
    haveMetadata({
      startingState,
      playlist
    }) {
      this.state = "HAVE_METADATA";
      this.loadedPlaylists_[playlist.id] = playlist;
      this.mediaRequest_ = null;
      this.refreshMedia_(playlist.id);
      if (startingState === "HAVE_MAIN_MANIFEST") {
        this.trigger("loadedmetadata");
      } else {
        this.trigger("mediachange");
      }
    }
    pause() {
      if (this.mainPlaylistLoader_.createMupOnMedia_) {
        this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_);
        this.mainPlaylistLoader_.createMupOnMedia_ = null;
      }
      this.stopRequest();
      window.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
      if (this.isMain_) {
        window.clearTimeout(this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_);
        this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_ = null;
      }
      if (this.state === "HAVE_NOTHING") {
        this.started = false;
      }
    }
    load(isFinalRendition) {
      window.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
      const media = this.media();
      if (isFinalRendition) {
        const delay = media ? media.targetDuration / 2 * 1e3 : 5 * 1e3;
        this.mediaUpdateTimeout = window.setTimeout(() => this.load(), delay);
        return;
      }
      if (!this.started) {
        this.start();
        return;
      }
      if (media && !media.endList) {
        if (this.isMain_ && !this.minimumUpdatePeriodTimeout_) {
          this.trigger("minimumUpdatePeriod");
          this.updateMinimumUpdatePeriodTimeout_();
        }
        this.trigger("mediaupdatetimeout");
      } else {
        this.trigger("loadedplaylist");
      }
    }
    start() {
      this.started = true;
      if (!this.isMain_) {
        this.mediaRequest_ = window.setTimeout(() => this.haveMain_(), 0);
        return;
      }
      this.requestMain_((req, mainChanged) => {
        this.haveMain_();
        if (!this.hasPendingRequest() && !this.media_) {
          this.media(this.mainPlaylistLoader_.main.playlists[0]);
        }
      });
    }
    requestMain_(cb) {
      this.request = this.vhs_.xhr({
        uri: this.mainPlaylistLoader_.srcUrl,
        withCredentials: this.withCredentials
      }, (error, req) => {
        if (this.requestErrored_(error, req)) {
          if (this.state === "HAVE_NOTHING") {
            this.started = false;
          }
          return;
        }
        const mainChanged = req.responseText !== this.mainPlaylistLoader_.mainXml_;
        this.mainPlaylistLoader_.mainXml_ = req.responseText;
        if (req.responseHeaders && req.responseHeaders.date) {
          this.mainLoaded_ = Date.parse(req.responseHeaders.date);
        } else {
          this.mainLoaded_ = Date.now();
        }
        this.mainPlaylistLoader_.srcUrl = resolveManifestRedirect(this.mainPlaylistLoader_.srcUrl, req);
        if (mainChanged) {
          this.handleMain_();
          this.syncClientServerClock_(() => {
            return cb(req, mainChanged);
          });
          return;
        }
        return cb(req, mainChanged);
      });
    }
    /**
     * Parses the main xml for UTCTiming node to sync the client clock to the server
     * clock. If the UTCTiming node requires a HEAD or GET request, that request is made.
     *
     * @param {Function} done
     *        Function to call when clock sync has completed
     */
    syncClientServerClock_(done) {
      const utcTiming = parseUTCTiming(this.mainPlaylistLoader_.mainXml_);
      if (utcTiming === null) {
        this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now();
        return done();
      }
      if (utcTiming.method === "DIRECT") {
        this.mainPlaylistLoader_.clientOffset_ = utcTiming.value - Date.now();
        return done();
      }
      this.request = this.vhs_.xhr({
        uri: resolveUrl(this.mainPlaylistLoader_.srcUrl, utcTiming.value),
        method: utcTiming.method,
        withCredentials: this.withCredentials
      }, (error, req) => {
        if (!this.request) {
          return;
        }
        if (error) {
          this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now();
          return done();
        }
        let serverTime;
        if (utcTiming.method === "HEAD") {
          if (!req.responseHeaders || !req.responseHeaders.date) {
            serverTime = this.mainLoaded_;
          } else {
            serverTime = Date.parse(req.responseHeaders.date);
          }
        } else {
          serverTime = Date.parse(req.responseText);
        }
        this.mainPlaylistLoader_.clientOffset_ = serverTime - Date.now();
        done();
      });
    }
    haveMain_() {
      this.state = "HAVE_MAIN_MANIFEST";
      if (this.isMain_) {
        this.trigger("loadedplaylist");
      } else if (!this.media_) {
        this.media(this.childPlaylist_);
      }
    }
    handleMain_() {
      this.mediaRequest_ = null;
      const oldMain = this.mainPlaylistLoader_.main;
      let newMain = parseMainXml({
        mainXml: this.mainPlaylistLoader_.mainXml_,
        srcUrl: this.mainPlaylistLoader_.srcUrl,
        clientOffset: this.mainPlaylistLoader_.clientOffset_,
        sidxMapping: this.mainPlaylistLoader_.sidxMapping_,
        previousManifest: oldMain
      });
      if (oldMain) {
        newMain = updateMain(oldMain, newMain, this.mainPlaylistLoader_.sidxMapping_);
      }
      this.mainPlaylistLoader_.main = newMain ? newMain : oldMain;
      const location2 = this.mainPlaylistLoader_.main.locations && this.mainPlaylistLoader_.main.locations[0];
      if (location2 && location2 !== this.mainPlaylistLoader_.srcUrl) {
        this.mainPlaylistLoader_.srcUrl = location2;
      }
      if (!oldMain || newMain && newMain.minimumUpdatePeriod !== oldMain.minimumUpdatePeriod) {
        this.updateMinimumUpdatePeriodTimeout_();
      }
      this.addEventStreamToMetadataTrack_(newMain);
      return Boolean(newMain);
    }
    updateMinimumUpdatePeriodTimeout_() {
      const mpl = this.mainPlaylistLoader_;
      if (mpl.createMupOnMedia_) {
        mpl.off("loadedmetadata", mpl.createMupOnMedia_);
        mpl.createMupOnMedia_ = null;
      }
      if (mpl.minimumUpdatePeriodTimeout_) {
        window.clearTimeout(mpl.minimumUpdatePeriodTimeout_);
        mpl.minimumUpdatePeriodTimeout_ = null;
      }
      let mup = mpl.main && mpl.main.minimumUpdatePeriod;
      if (mup === 0) {
        if (mpl.media()) {
          mup = mpl.media().targetDuration * 1e3;
        } else {
          mpl.createMupOnMedia_ = mpl.updateMinimumUpdatePeriodTimeout_;
          mpl.one("loadedmetadata", mpl.createMupOnMedia_);
        }
      }
      if (typeof mup !== "number" || mup <= 0) {
        if (mup < 0) {
          this.logger_(`found invalid minimumUpdatePeriod of ${mup}, not setting a timeout`);
        }
        return;
      }
      this.createMUPTimeout_(mup);
    }
    createMUPTimeout_(mup) {
      const mpl = this.mainPlaylistLoader_;
      mpl.minimumUpdatePeriodTimeout_ = window.setTimeout(() => {
        mpl.minimumUpdatePeriodTimeout_ = null;
        mpl.trigger("minimumUpdatePeriod");
        mpl.createMUPTimeout_(mup);
      }, mup);
    }
    /**
     * Sends request to refresh the main xml and updates the parsed main manifest
     */
    refreshXml_() {
      this.requestMain_((req, mainChanged) => {
        if (!mainChanged) {
          return;
        }
        if (this.media_) {
          this.media_ = this.mainPlaylistLoader_.main.playlists[this.media_.id];
        }
        this.mainPlaylistLoader_.sidxMapping_ = filterChangedSidxMappings(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.sidxMapping_);
        this.addSidxSegments_(this.media(), this.state, (sidxChanged) => {
          this.refreshMedia_(this.media().id);
        });
      });
    }
    /**
     * Refreshes the media playlist by re-parsing the main xml and updating playlist
     * references. If this is an alternate loader, the updated parsed manifest is retrieved
     * from the main loader.
     */
    refreshMedia_(mediaID) {
      if (!mediaID) {
        throw new Error("refreshMedia_ must take a media id");
      }
      if (this.media_ && this.isMain_) {
        this.handleMain_();
      }
      const playlists = this.mainPlaylistLoader_.main.playlists;
      const mediaChanged = !this.media_ || this.media_ !== playlists[mediaID];
      if (mediaChanged) {
        this.media_ = playlists[mediaID];
      } else {
        this.trigger("playlistunchanged");
      }
      if (!this.mediaUpdateTimeout) {
        const createMediaUpdateTimeout = () => {
          if (this.media().endList) {
            return;
          }
          this.mediaUpdateTimeout = window.setTimeout(() => {
            this.trigger("mediaupdatetimeout");
            createMediaUpdateTimeout();
          }, refreshDelay(this.media(), Boolean(mediaChanged)));
        };
        createMediaUpdateTimeout();
      }
      this.trigger("loadedplaylist");
    }
    /**
     * Takes eventstream data from a parsed DASH manifest and adds it to the metadata text track.
     *
     * @param {manifest} newMain the newly parsed manifest
     */
    addEventStreamToMetadataTrack_(newMain) {
      if (newMain && this.mainPlaylistLoader_.main.eventStream) {
        const metadataArray = this.mainPlaylistLoader_.main.eventStream.map((eventStreamNode) => {
          return {
            cueTime: eventStreamNode.start,
            frames: [{
              data: eventStreamNode.messageData
            }]
          };
        });
        this.addMetadataToTextTrack("EventStream", metadataArray, this.mainPlaylistLoader_.main.duration);
      }
    }
    /**
     * Returns the key ID set from a playlist
     *
     * @param {playlist} playlist to fetch the key ID set from.
     * @return a Set of 32 digit hex strings that represent the unique keyIds for that playlist.
     */
    getKeyIdSet(playlist) {
      if (playlist.contentProtection) {
        const keyIds = /* @__PURE__ */ new Set();
        for (const keysystem in playlist.contentProtection) {
          const defaultKID = playlist.contentProtection[keysystem].attributes["cenc:default_KID"];
          if (defaultKID) {
            keyIds.add(defaultKID.replace(/-/g, "").toLowerCase());
          }
        }
        return keyIds;
      }
    }
  }
  var Config = {
    GOAL_BUFFER_LENGTH: 30,
    MAX_GOAL_BUFFER_LENGTH: 60,
    BACK_BUFFER_LENGTH: 30,
    GOAL_BUFFER_LENGTH_RATE: 1,
    // 0.5 MB/s
    INITIAL_BANDWIDTH: 4194304,
    // A fudge factor to apply to advertised playlist bitrates to account for
    // temporary flucations in client bandwidth
    BANDWIDTH_VARIANCE: 1.2,
    // How much of the buffer must be filled before we consider upswitching
    BUFFER_LOW_WATER_LINE: 0,
    MAX_BUFFER_LOW_WATER_LINE: 30,
    // TODO: Remove this when experimentalBufferBasedABR is removed
    EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
    BUFFER_LOW_WATER_LINE_RATE: 1,
    // If the buffer is greater than the high water line, we won't switch down
    BUFFER_HIGH_WATER_LINE: 30
  };
  const stringToArrayBuffer = (string) => {
    const view = new Uint8Array(new ArrayBuffer(string.length));
    for (let i = 0; i < string.length; i++) {
      view[i] = string.charCodeAt(i);
    }
    return view.buffer;
  };
  const browserWorkerPolyFill = function(workerObj) {
    workerObj.on = workerObj.addEventListener;
    workerObj.off = workerObj.removeEventListener;
    return workerObj;
  };
  const createObjectURL = function(str) {
    try {
      return URL.createObjectURL(new Blob([str], {
        type: "application/javascript"
      }));
    } catch (e) {
      const blob = new BlobBuilder();
      blob.append(str);
      return URL.createObjectURL(blob.getBlob());
    }
  };
  const factory = function(code) {
    return function() {
      const objectUrl = createObjectURL(code);
      const worker = browserWorkerPolyFill(new Worker(objectUrl));
      worker.objURL = objectUrl;
      const terminate = worker.terminate;
      worker.on = worker.addEventListener;
      worker.off = worker.removeEventListener;
      worker.terminate = function() {
        URL.revokeObjectURL(objectUrl);
        return terminate.call(this);
      };
      return worker;
    };
  };
  const transform = function(code) {
    return `var browserWorkerPolyFill = ${browserWorkerPolyFill.toString()};
browserWorkerPolyFill(self);
` + code;
  };
  const getWorkerString = function(fn) {
    return fn.toString().replace(/^function.+?{/, "").slice(0, -1);
  };
  const workerCode$1 = transform(getWorkerString(function() {
    var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var Stream$8 = function() {
      this.init = function() {
        var listeners = {};
        this.on = function(type2, listener) {
          if (!listeners[type2]) {
            listeners[type2] = [];
          }
          listeners[type2] = listeners[type2].concat(listener);
        };
        this.off = function(type2, listener) {
          var index;
          if (!listeners[type2]) {
            return false;
          }
          index = listeners[type2].indexOf(listener);
          listeners[type2] = listeners[type2].slice();
          listeners[type2].splice(index, 1);
          return index > -1;
        };
        this.trigger = function(type2) {
          var callbacks, i, length, args;
          callbacks = listeners[type2];
          if (!callbacks) {
            return;
          }
          if (arguments.length === 2) {
            length = callbacks.length;
            for (i = 0; i < length; ++i) {
              callbacks[i].call(this, arguments[1]);
            }
          } else {
            args = [];
            i = arguments.length;
            for (i = 1; i < arguments.length; ++i) {
              args.push(arguments[i]);
            }
            length = callbacks.length;
            for (i = 0; i < length; ++i) {
              callbacks[i].apply(this, args);
            }
          }
        };
        this.dispose = function() {
          listeners = {};
        };
      };
    };
    Stream$8.prototype.pipe = function(destination) {
      this.on("data", function(data) {
        destination.push(data);
      });
      this.on("done", function(flushSource) {
        destination.flush(flushSource);
      });
      this.on("partialdone", function(flushSource) {
        destination.partialFlush(flushSource);
      });
      this.on("endedtimeline", function(flushSource) {
        destination.endTimeline(flushSource);
      });
      this.on("reset", function(flushSource) {
        destination.reset(flushSource);
      });
      return destination;
    };
    Stream$8.prototype.push = function(data) {
      this.trigger("data", data);
    };
    Stream$8.prototype.flush = function(flushSource) {
      this.trigger("done", flushSource);
    };
    Stream$8.prototype.partialFlush = function(flushSource) {
      this.trigger("partialdone", flushSource);
    };
    Stream$8.prototype.endTimeline = function(flushSource) {
      this.trigger("endedtimeline", flushSource);
    };
    Stream$8.prototype.reset = function(flushSource) {
      this.trigger("reset", flushSource);
    };
    var stream = Stream$8;
    var MAX_UINT32$1 = Math.pow(2, 32);
    var getUint64$3 = function(uint8) {
      var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
      var value;
      if (dv.getBigUint64) {
        value = dv.getBigUint64(0);
        if (value < Number.MAX_SAFE_INTEGER) {
          return Number(value);
        }
        return value;
      }
      return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);
    };
    var numbers2 = {
      getUint64: getUint64$3,
      MAX_UINT32: MAX_UINT32$1
    };
    var MAX_UINT322 = numbers2.MAX_UINT32;
    var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;
    (function() {
      var i;
      types = {
        avc1: [],
        // codingname
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        // codingname
        mvex: [],
        mvhd: [],
        pasp: [],
        sdtp: [],
        smhd: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        styp: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: []
      };
      if (typeof Uint8Array === "undefined") {
        return;
      }
      for (i in types) {
        if (types.hasOwnProperty(i)) {
          types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
        }
      }
      MAJOR_BRAND = new Uint8Array(["i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0)]);
      AVC1_BRAND = new Uint8Array(["a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0)]);
      MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);
      VIDEO_HDLR = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0,
        // pre_defined
        118,
        105,
        100,
        101,
        // handler_type: 'vide'
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        86,
        105,
        100,
        101,
        111,
        72,
        97,
        110,
        100,
        108,
        101,
        114,
        0
        // name: 'VideoHandler'
      ]);
      AUDIO_HDLR = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0,
        // pre_defined
        115,
        111,
        117,
        110,
        // handler_type: 'soun'
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        83,
        111,
        117,
        110,
        100,
        72,
        97,
        110,
        100,
        108,
        101,
        114,
        0
        // name: 'SoundHandler'
      ]);
      HDLR_TYPES = {
        video: VIDEO_HDLR,
        audio: AUDIO_HDLR
      };
      DREF = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        1,
        // entry_count
        0,
        0,
        0,
        12,
        // entry_size
        117,
        114,
        108,
        32,
        // 'url' type
        0,
        // version 0
        0,
        0,
        1
        // entry_flags
      ]);
      SMHD = new Uint8Array([
        0,
        // version
        0,
        0,
        0,
        // flags
        0,
        0,
        // balance, 0 means centered
        0,
        0
        // reserved
      ]);
      STCO = new Uint8Array([
        0,
        // version
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0
        // entry_count
      ]);
      STSC = STCO;
      STSZ = new Uint8Array([
        0,
        // version
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0,
        // sample_size
        0,
        0,
        0,
        0
        // sample_count
      ]);
      STTS = STCO;
      VMHD = new Uint8Array([
        0,
        // version
        0,
        0,
        1,
        // flags
        0,
        0,
        // graphicsmode
        0,
        0,
        0,
        0,
        0,
        0
        // opcolor
      ]);
    })();
    box = function(type2) {
      var payload = [], size = 0, i, result, view;
      for (i = 1; i < arguments.length; i++) {
        payload.push(arguments[i]);
      }
      i = payload.length;
      while (i--) {
        size += payload[i].byteLength;
      }
      result = new Uint8Array(size + 8);
      view = new DataView(result.buffer, result.byteOffset, result.byteLength);
      view.setUint32(0, result.byteLength);
      result.set(type2, 4);
      for (i = 0, size = 8; i < payload.length; i++) {
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    };
    dinf = function() {
      return box(types.dinf, box(types.dref, DREF));
    };
    esds = function(track) {
      return box(types.esds, new Uint8Array([
        0,
        // version
        0,
        0,
        0,
        // flags
        // ES_Descriptor
        3,
        // tag, ES_DescrTag
        25,
        // length
        0,
        0,
        // ES_ID
        0,
        // streamDependenceFlag, URL_flag, reserved, streamPriority
        // DecoderConfigDescriptor
        4,
        // tag, DecoderConfigDescrTag
        17,
        // length
        64,
        // object type
        21,
        // streamType
        0,
        6,
        0,
        // bufferSizeDB
        0,
        0,
        218,
        192,
        // maxBitrate
        0,
        0,
        218,
        192,
        // avgBitrate
        // DecoderSpecificInfo
        5,
        // tag, DecoderSpecificInfoTag
        2,
        // length
        // ISO/IEC 14496-3, AudioSpecificConfig
        // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35
        track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1,
        track.samplingfrequencyindex << 7 | track.channelcount << 3,
        6,
        1,
        2
        // GASpecificConfig
      ]));
    };
    ftyp = function() {
      return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);
    };
    hdlr = function(type2) {
      return box(types.hdlr, HDLR_TYPES[type2]);
    };
    mdat = function(data) {
      return box(types.mdat, data);
    };
    mdhd = function(track) {
      var result = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        2,
        // creation_time
        0,
        0,
        0,
        3,
        // modification_time
        0,
        1,
        95,
        144,
        // timescale, 90,000 "ticks" per second
        track.duration >>> 24 & 255,
        track.duration >>> 16 & 255,
        track.duration >>> 8 & 255,
        track.duration & 255,
        // duration
        85,
        196,
        // 'und' language (undetermined)
        0,
        0
      ]);
      if (track.samplerate) {
        result[12] = track.samplerate >>> 24 & 255;
        result[13] = track.samplerate >>> 16 & 255;
        result[14] = track.samplerate >>> 8 & 255;
        result[15] = track.samplerate & 255;
      }
      return box(types.mdhd, result);
    };
    mdia = function(track) {
      return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));
    };
    mfhd = function(sequenceNumber) {
      return box(types.mfhd, new Uint8Array([
        0,
        0,
        0,
        0,
        // flags
        (sequenceNumber & 4278190080) >> 24,
        (sequenceNumber & 16711680) >> 16,
        (sequenceNumber & 65280) >> 8,
        sequenceNumber & 255
        // sequence_number
      ]));
    };
    minf = function(track) {
      return box(types.minf, track.type === "video" ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));
    };
    moof = function(sequenceNumber, tracks) {
      var trackFragments = [], i = tracks.length;
      while (i--) {
        trackFragments[i] = traf(tracks[i]);
      }
      return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));
    };
    moov = function(tracks) {
      var i = tracks.length, boxes = [];
      while (i--) {
        boxes[i] = trak(tracks[i]);
      }
      return box.apply(null, [types.moov, mvhd(4294967295)].concat(boxes).concat(mvex(tracks)));
    };
    mvex = function(tracks) {
      var i = tracks.length, boxes = [];
      while (i--) {
        boxes[i] = trex(tracks[i]);
      }
      return box.apply(null, [types.mvex].concat(boxes));
    };
    mvhd = function(duration2) {
      var bytes = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        1,
        // creation_time
        0,
        0,
        0,
        2,
        // modification_time
        0,
        1,
        95,
        144,
        // timescale, 90,000 "ticks" per second
        (duration2 & 4278190080) >> 24,
        (duration2 & 16711680) >> 16,
        (duration2 & 65280) >> 8,
        duration2 & 255,
        // duration
        0,
        1,
        0,
        0,
        // 1.0 rate
        1,
        0,
        // 1.0 volume
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        // transformation: unity matrix
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        255,
        255,
        255,
        255
        // next_track_ID
      ]);
      return box(types.mvhd, bytes);
    };
    sdtp = function(track) {
      var samples = track.samples || [], bytes = new Uint8Array(4 + samples.length), flags, i;
      for (i = 0; i < samples.length; i++) {
        flags = samples[i].flags;
        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }
      return box(types.sdtp, bytes);
    };
    stbl = function(track) {
      return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));
    };
    (function() {
      var videoSample, audioSample;
      stsd = function(track) {
        return box(types.stsd, new Uint8Array([
          0,
          // version 0
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          1
        ]), track.type === "video" ? videoSample(track) : audioSample(track));
      };
      videoSample = function(track) {
        var sps = track.sps || [], pps = track.pps || [], sequenceParameterSets = [], pictureParameterSets = [], i, avc1Box;
        for (i = 0; i < sps.length; i++) {
          sequenceParameterSets.push((sps[i].byteLength & 65280) >>> 8);
          sequenceParameterSets.push(sps[i].byteLength & 255);
          sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i]));
        }
        for (i = 0; i < pps.length; i++) {
          pictureParameterSets.push((pps[i].byteLength & 65280) >>> 8);
          pictureParameterSets.push(pps[i].byteLength & 255);
          pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));
        }
        avc1Box = [types.avc1, new Uint8Array([
          0,
          0,
          0,
          0,
          0,
          0,
          // reserved
          0,
          1,
          // data_reference_index
          0,
          0,
          // pre_defined
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          // pre_defined
          (track.width & 65280) >> 8,
          track.width & 255,
          // width
          (track.height & 65280) >> 8,
          track.height & 255,
          // height
          0,
          72,
          0,
          0,
          // horizresolution
          0,
          72,
          0,
          0,
          // vertresolution
          0,
          0,
          0,
          0,
          // reserved
          0,
          1,
          // frame_count
          19,
          118,
          105,
          100,
          101,
          111,
          106,
          115,
          45,
          99,
          111,
          110,
          116,
          114,
          105,
          98,
          45,
          104,
          108,
          115,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          // compressorname
          0,
          24,
          // depth = 24
          17,
          17
          // pre_defined = -1
        ]), box(types.avcC, new Uint8Array([
          1,
          // configurationVersion
          track.profileIdc,
          // AVCProfileIndication
          track.profileCompatibility,
          // profile_compatibility
          track.levelIdc,
          // AVCLevelIndication
          255
          // lengthSizeMinusOne, hard-coded to 4 bytes
        ].concat(
          [sps.length],
          // numOfSequenceParameterSets
          sequenceParameterSets,
          // "SPS"
          [pps.length],
          // numOfPictureParameterSets
          pictureParameterSets
          // "PPS"
        ))), box(types.btrt, new Uint8Array([
          0,
          28,
          156,
          128,
          // bufferSizeDB
          0,
          45,
          198,
          192,
          // maxBitrate
          0,
          45,
          198,
          192
          // avgBitrate
        ]))];
        if (track.sarRatio) {
          var hSpacing = track.sarRatio[0], vSpacing = track.sarRatio[1];
          avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 4278190080) >> 24, (hSpacing & 16711680) >> 16, (hSpacing & 65280) >> 8, hSpacing & 255, (vSpacing & 4278190080) >> 24, (vSpacing & 16711680) >> 16, (vSpacing & 65280) >> 8, vSpacing & 255])));
        }
        return box.apply(null, avc1Box);
      };
      audioSample = function(track) {
        return box(types.mp4a, new Uint8Array([
          // SampleEntry, ISO/IEC 14496-12
          0,
          0,
          0,
          0,
          0,
          0,
          // reserved
          0,
          1,
          // data_reference_index
          // AudioSampleEntry, ISO/IEC 14496-12
          0,
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          // reserved
          (track.channelcount & 65280) >> 8,
          track.channelcount & 255,
          // channelcount
          (track.samplesize & 65280) >> 8,
          track.samplesize & 255,
          // samplesize
          0,
          0,
          // pre_defined
          0,
          0,
          // reserved
          (track.samplerate & 65280) >> 8,
          track.samplerate & 255,
          0,
          0
          // samplerate, 16.16
          // MP4AudioSampleEntry, ISO/IEC 14496-14
        ]), esds(track));
      };
    })();
    tkhd = function(track) {
      var result = new Uint8Array([
        0,
        // version 0
        0,
        0,
        7,
        // flags
        0,
        0,
        0,
        0,
        // creation_time
        0,
        0,
        0,
        0,
        // modification_time
        (track.id & 4278190080) >> 24,
        (track.id & 16711680) >> 16,
        (track.id & 65280) >> 8,
        track.id & 255,
        // track_ID
        0,
        0,
        0,
        0,
        // reserved
        (track.duration & 4278190080) >> 24,
        (track.duration & 16711680) >> 16,
        (track.duration & 65280) >> 8,
        track.duration & 255,
        // duration
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        // layer
        0,
        0,
        // alternate_group
        1,
        0,
        // non-audio track volume
        0,
        0,
        // reserved
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        // transformation: unity matrix
        (track.width & 65280) >> 8,
        track.width & 255,
        0,
        0,
        // width
        (track.height & 65280) >> 8,
        track.height & 255,
        0,
        0
        // height
      ]);
      return box(types.tkhd, result);
    };
    traf = function(track) {
      var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;
      trackFragmentHeader = box(types.tfhd, new Uint8Array([
        0,
        // version 0
        0,
        0,
        58,
        // flags
        (track.id & 4278190080) >> 24,
        (track.id & 16711680) >> 16,
        (track.id & 65280) >> 8,
        track.id & 255,
        // track_ID
        0,
        0,
        0,
        1,
        // sample_description_index
        0,
        0,
        0,
        0,
        // default_sample_duration
        0,
        0,
        0,
        0,
        // default_sample_size
        0,
        0,
        0,
        0
        // default_sample_flags
      ]));
      upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT322);
      lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT322);
      trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([
        1,
        // version 1
        0,
        0,
        0,
        // flags
        // baseMediaDecodeTime
        upperWordBaseMediaDecodeTime >>> 24 & 255,
        upperWordBaseMediaDecodeTime >>> 16 & 255,
        upperWordBaseMediaDecodeTime >>> 8 & 255,
        upperWordBaseMediaDecodeTime & 255,
        lowerWordBaseMediaDecodeTime >>> 24 & 255,
        lowerWordBaseMediaDecodeTime >>> 16 & 255,
        lowerWordBaseMediaDecodeTime >>> 8 & 255,
        lowerWordBaseMediaDecodeTime & 255
      ]));
      dataOffset = 32 + // tfhd
      20 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8;
      if (track.type === "audio") {
        trackFragmentRun = trun$1(track, dataOffset);
        return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);
      }
      sampleDependencyTable = sdtp(track);
      trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);
      return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);
    };
    trak = function(track) {
      track.duration = track.duration || 4294967295;
      return box(types.trak, tkhd(track), mdia(track));
    };
    trex = function(track) {
      var result = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        (track.id & 4278190080) >> 24,
        (track.id & 16711680) >> 16,
        (track.id & 65280) >> 8,
        track.id & 255,
        // track_ID
        0,
        0,
        0,
        1,
        // default_sample_description_index
        0,
        0,
        0,
        0,
        // default_sample_duration
        0,
        0,
        0,
        0,
        // default_sample_size
        0,
        1,
        0,
        1
        // default_sample_flags
      ]);
      if (track.type !== "video") {
        result[result.length - 1] = 0;
      }
      return box(types.trex, result);
    };
    (function() {
      var audioTrun, videoTrun, trunHeader;
      trunHeader = function(samples, offset) {
        var durationPresent = 0, sizePresent = 0, flagsPresent = 0, compositionTimeOffset = 0;
        if (samples.length) {
          if (samples[0].duration !== void 0) {
            durationPresent = 1;
          }
          if (samples[0].size !== void 0) {
            sizePresent = 2;
          }
          if (samples[0].flags !== void 0) {
            flagsPresent = 4;
          }
          if (samples[0].compositionTimeOffset !== void 0) {
            compositionTimeOffset = 8;
          }
        }
        return [
          0,
          // version 0
          0,
          durationPresent | sizePresent | flagsPresent | compositionTimeOffset,
          1,
          // flags
          (samples.length & 4278190080) >>> 24,
          (samples.length & 16711680) >>> 16,
          (samples.length & 65280) >>> 8,
          samples.length & 255,
          // sample_count
          (offset & 4278190080) >>> 24,
          (offset & 16711680) >>> 16,
          (offset & 65280) >>> 8,
          offset & 255
          // data_offset
        ];
      };
      videoTrun = function(track, offset) {
        var bytesOffest, bytes, header, samples, sample, i;
        samples = track.samples || [];
        offset += 8 + 12 + 16 * samples.length;
        header = trunHeader(samples, offset);
        bytes = new Uint8Array(header.length + samples.length * 16);
        bytes.set(header);
        bytesOffest = header.length;
        for (i = 0; i < samples.length; i++) {
          sample = samples[i];
          bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
          bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
          bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
          bytes[bytesOffest++] = sample.duration & 255;
          bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
          bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
          bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
          bytes[bytesOffest++] = sample.size & 255;
          bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;
          bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;
          bytes[bytesOffest++] = sample.flags.degradationPriority & 240 << 8;
          bytes[bytesOffest++] = sample.flags.degradationPriority & 15;
          bytes[bytesOffest++] = (sample.compositionTimeOffset & 4278190080) >>> 24;
          bytes[bytesOffest++] = (sample.compositionTimeOffset & 16711680) >>> 16;
          bytes[bytesOffest++] = (sample.compositionTimeOffset & 65280) >>> 8;
          bytes[bytesOffest++] = sample.compositionTimeOffset & 255;
        }
        return box(types.trun, bytes);
      };
      audioTrun = function(track, offset) {
        var bytes, bytesOffest, header, samples, sample, i;
        samples = track.samples || [];
        offset += 8 + 12 + 8 * samples.length;
        header = trunHeader(samples, offset);
        bytes = new Uint8Array(header.length + samples.length * 8);
        bytes.set(header);
        bytesOffest = header.length;
        for (i = 0; i < samples.length; i++) {
          sample = samples[i];
          bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
          bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
          bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
          bytes[bytesOffest++] = sample.duration & 255;
          bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
          bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
          bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
          bytes[bytesOffest++] = sample.size & 255;
        }
        return box(types.trun, bytes);
      };
      trun$1 = function(track, offset) {
        if (track.type === "audio") {
          return audioTrun(track, offset);
        }
        return videoTrun(track, offset);
      };
    })();
    var mp4Generator = {
      ftyp,
      mdat,
      moof,
      moov,
      initSegment: function(tracks) {
        var fileType = ftyp(), movie = moov(tracks), result;
        result = new Uint8Array(fileType.byteLength + movie.byteLength);
        result.set(fileType);
        result.set(movie, fileType.byteLength);
        return result;
      }
    };
    var groupNalsIntoFrames = function(nalUnits) {
      var i, currentNal, currentFrame = [], frames = [];
      frames.byteLength = 0;
      frames.nalCount = 0;
      frames.duration = 0;
      currentFrame.byteLength = 0;
      for (i = 0; i < nalUnits.length; i++) {
        currentNal = nalUnits[i];
        if (currentNal.nalUnitType === "access_unit_delimiter_rbsp") {
          if (currentFrame.length) {
            currentFrame.duration = currentNal.dts - currentFrame.dts;
            frames.byteLength += currentFrame.byteLength;
            frames.nalCount += currentFrame.length;
            frames.duration += currentFrame.duration;
            frames.push(currentFrame);
          }
          currentFrame = [currentNal];
          currentFrame.byteLength = currentNal.data.byteLength;
          currentFrame.pts = currentNal.pts;
          currentFrame.dts = currentNal.dts;
        } else {
          if (currentNal.nalUnitType === "slice_layer_without_partitioning_rbsp_idr") {
            currentFrame.keyFrame = true;
          }
          currentFrame.duration = currentNal.dts - currentFrame.dts;
          currentFrame.byteLength += currentNal.data.byteLength;
          currentFrame.push(currentNal);
        }
      }
      if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {
        currentFrame.duration = frames[frames.length - 1].duration;
      }
      frames.byteLength += currentFrame.byteLength;
      frames.nalCount += currentFrame.length;
      frames.duration += currentFrame.duration;
      frames.push(currentFrame);
      return frames;
    };
    var groupFramesIntoGops = function(frames) {
      var i, currentFrame, currentGop = [], gops = [];
      currentGop.byteLength = 0;
      currentGop.nalCount = 0;
      currentGop.duration = 0;
      currentGop.pts = frames[0].pts;
      currentGop.dts = frames[0].dts;
      gops.byteLength = 0;
      gops.nalCount = 0;
      gops.duration = 0;
      gops.pts = frames[0].pts;
      gops.dts = frames[0].dts;
      for (i = 0; i < frames.length; i++) {
        currentFrame = frames[i];
        if (currentFrame.keyFrame) {
          if (currentGop.length) {
            gops.push(currentGop);
            gops.byteLength += currentGop.byteLength;
            gops.nalCount += currentGop.nalCount;
            gops.duration += currentGop.duration;
          }
          currentGop = [currentFrame];
          currentGop.nalCount = currentFrame.length;
          currentGop.byteLength = currentFrame.byteLength;
          currentGop.pts = currentFrame.pts;
          currentGop.dts = currentFrame.dts;
          currentGop.duration = currentFrame.duration;
        } else {
          currentGop.duration += currentFrame.duration;
          currentGop.nalCount += currentFrame.length;
          currentGop.byteLength += currentFrame.byteLength;
          currentGop.push(currentFrame);
        }
      }
      if (gops.length && currentGop.duration <= 0) {
        currentGop.duration = gops[gops.length - 1].duration;
      }
      gops.byteLength += currentGop.byteLength;
      gops.nalCount += currentGop.nalCount;
      gops.duration += currentGop.duration;
      gops.push(currentGop);
      return gops;
    };
    var extendFirstKeyFrame = function(gops) {
      var currentGop;
      if (!gops[0][0].keyFrame && gops.length > 1) {
        currentGop = gops.shift();
        gops.byteLength -= currentGop.byteLength;
        gops.nalCount -= currentGop.nalCount;
        gops[0][0].dts = currentGop.dts;
        gops[0][0].pts = currentGop.pts;
        gops[0][0].duration += currentGop.duration;
      }
      return gops;
    };
    var createDefaultSample = function() {
      return {
        size: 0,
        flags: {
          isLeading: 0,
          dependsOn: 1,
          isDependedOn: 0,
          hasRedundancy: 0,
          degradationPriority: 0,
          isNonSyncSample: 1
        }
      };
    };
    var sampleForFrame = function(frame, dataOffset) {
      var sample = createDefaultSample();
      sample.dataOffset = dataOffset;
      sample.compositionTimeOffset = frame.pts - frame.dts;
      sample.duration = frame.duration;
      sample.size = 4 * frame.length;
      sample.size += frame.byteLength;
      if (frame.keyFrame) {
        sample.flags.dependsOn = 2;
        sample.flags.isNonSyncSample = 0;
      }
      return sample;
    };
    var generateSampleTable$1 = function(gops, baseDataOffset) {
      var h, i, sample, currentGop, currentFrame, dataOffset = baseDataOffset || 0, samples = [];
      for (h = 0; h < gops.length; h++) {
        currentGop = gops[h];
        for (i = 0; i < currentGop.length; i++) {
          currentFrame = currentGop[i];
          sample = sampleForFrame(currentFrame, dataOffset);
          dataOffset += sample.size;
          samples.push(sample);
        }
      }
      return samples;
    };
    var concatenateNalData = function(gops) {
      var h, i, j, currentGop, currentFrame, currentNal, dataOffset = 0, nalsByteLength = gops.byteLength, numberOfNals = gops.nalCount, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
      for (h = 0; h < gops.length; h++) {
        currentGop = gops[h];
        for (i = 0; i < currentGop.length; i++) {
          currentFrame = currentGop[i];
          for (j = 0; j < currentFrame.length; j++) {
            currentNal = currentFrame[j];
            view.setUint32(dataOffset, currentNal.data.byteLength);
            dataOffset += 4;
            data.set(currentNal.data, dataOffset);
            dataOffset += currentNal.data.byteLength;
          }
        }
      }
      return data;
    };
    var generateSampleTableForFrame = function(frame, baseDataOffset) {
      var sample, dataOffset = baseDataOffset || 0, samples = [];
      sample = sampleForFrame(frame, dataOffset);
      samples.push(sample);
      return samples;
    };
    var concatenateNalDataForFrame = function(frame) {
      var i, currentNal, dataOffset = 0, nalsByteLength = frame.byteLength, numberOfNals = frame.length, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
      for (i = 0; i < frame.length; i++) {
        currentNal = frame[i];
        view.setUint32(dataOffset, currentNal.data.byteLength);
        dataOffset += 4;
        data.set(currentNal.data, dataOffset);
        dataOffset += currentNal.data.byteLength;
      }
      return data;
    };
    var frameUtils$1 = {
      groupNalsIntoFrames,
      groupFramesIntoGops,
      extendFirstKeyFrame,
      generateSampleTable: generateSampleTable$1,
      concatenateNalData,
      generateSampleTableForFrame,
      concatenateNalDataForFrame
    };
    var highPrefix = [33, 16, 5, 32, 164, 27];
    var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];
    var zeroFill = function(count) {
      var a = [];
      while (count--) {
        a.push(0);
      }
      return a;
    };
    var makeTable = function(metaTable) {
      return Object.keys(metaTable).reduce(function(obj, key) {
        obj[key] = new Uint8Array(metaTable[key].reduce(function(arr, part) {
          return arr.concat(part);
        }, []));
        return obj;
      }, {});
    };
    var silence;
    var silence_1 = function() {
      if (!silence) {
        var coneOfSilence2 = {
          96e3: [highPrefix, [227, 64], zeroFill(154), [56]],
          88200: [highPrefix, [231], zeroFill(170), [56]],
          64e3: [highPrefix, [248, 192], zeroFill(240), [56]],
          48e3: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],
          44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],
          32e3: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],
          24e3: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],
          16e3: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],
          12e3: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],
          11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],
          8e3: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]
        };
        silence = makeTable(coneOfSilence2);
      }
      return silence;
    };
    var ONE_SECOND_IN_TS$4 = 9e4, secondsToVideoTs2, secondsToAudioTs2, videoTsToSeconds2, audioTsToSeconds2, audioTsToVideoTs2, videoTsToAudioTs2, metadataTsToSeconds2;
    secondsToVideoTs2 = function(seconds) {
      return seconds * ONE_SECOND_IN_TS$4;
    };
    secondsToAudioTs2 = function(seconds, sampleRate) {
      return seconds * sampleRate;
    };
    videoTsToSeconds2 = function(timestamp) {
      return timestamp / ONE_SECOND_IN_TS$4;
    };
    audioTsToSeconds2 = function(timestamp, sampleRate) {
      return timestamp / sampleRate;
    };
    audioTsToVideoTs2 = function(timestamp, sampleRate) {
      return secondsToVideoTs2(audioTsToSeconds2(timestamp, sampleRate));
    };
    videoTsToAudioTs2 = function(timestamp, sampleRate) {
      return secondsToAudioTs2(videoTsToSeconds2(timestamp), sampleRate);
    };
    metadataTsToSeconds2 = function(timestamp, timelineStartPts, keepOriginalTimestamps) {
      return videoTsToSeconds2(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
    };
    var clock$2 = {
      ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$4,
      secondsToVideoTs: secondsToVideoTs2,
      secondsToAudioTs: secondsToAudioTs2,
      videoTsToSeconds: videoTsToSeconds2,
      audioTsToSeconds: audioTsToSeconds2,
      audioTsToVideoTs: audioTsToVideoTs2,
      videoTsToAudioTs: videoTsToAudioTs2,
      metadataTsToSeconds: metadataTsToSeconds2
    };
    var coneOfSilence = silence_1;
    var clock$1 = clock$2;
    var sumFrameByteLengths = function(array) {
      var i, currentObj, sum = 0;
      for (i = 0; i < array.length; i++) {
        currentObj = array[i];
        sum += currentObj.data.byteLength;
      }
      return sum;
    };
    var prefixWithSilence = function(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {
      var baseMediaDecodeTimeTs, frameDuration = 0, audioGapDuration = 0, audioFillFrameCount = 0, audioFillDuration = 0, silentFrame, i, firstFrame;
      if (!frames.length) {
        return;
      }
      baseMediaDecodeTimeTs = clock$1.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);
      frameDuration = Math.ceil(clock$1.ONE_SECOND_IN_TS / (track.samplerate / 1024));
      if (audioAppendStartTs && videoBaseMediaDecodeTime) {
        audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);
        audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);
        audioFillDuration = audioFillFrameCount * frameDuration;
      }
      if (audioFillFrameCount < 1 || audioFillDuration > clock$1.ONE_SECOND_IN_TS / 2) {
        return;
      }
      silentFrame = coneOfSilence()[track.samplerate];
      if (!silentFrame) {
        silentFrame = frames[0].data;
      }
      for (i = 0; i < audioFillFrameCount; i++) {
        firstFrame = frames[0];
        frames.splice(0, 0, {
          data: silentFrame,
          dts: firstFrame.dts - frameDuration,
          pts: firstFrame.pts - frameDuration
        });
      }
      track.baseMediaDecodeTime -= Math.floor(clock$1.videoTsToAudioTs(audioFillDuration, track.samplerate));
      return audioFillDuration;
    };
    var trimAdtsFramesByEarliestDts = function(adtsFrames, track, earliestAllowedDts) {
      if (track.minSegmentDts >= earliestAllowedDts) {
        return adtsFrames;
      }
      track.minSegmentDts = Infinity;
      return adtsFrames.filter(function(currentFrame) {
        if (currentFrame.dts >= earliestAllowedDts) {
          track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);
          track.minSegmentPts = track.minSegmentDts;
          return true;
        }
        return false;
      });
    };
    var generateSampleTable = function(frames) {
      var i, currentFrame, samples = [];
      for (i = 0; i < frames.length; i++) {
        currentFrame = frames[i];
        samples.push({
          size: currentFrame.data.byteLength,
          duration: 1024
          // For AAC audio, all samples contain 1024 samples
        });
      }
      return samples;
    };
    var concatenateFrameData = function(frames) {
      var i, currentFrame, dataOffset = 0, data = new Uint8Array(sumFrameByteLengths(frames));
      for (i = 0; i < frames.length; i++) {
        currentFrame = frames[i];
        data.set(currentFrame.data, dataOffset);
        dataOffset += currentFrame.data.byteLength;
      }
      return data;
    };
    var audioFrameUtils$1 = {
      prefixWithSilence,
      trimAdtsFramesByEarliestDts,
      generateSampleTable,
      concatenateFrameData
    };
    var ONE_SECOND_IN_TS$3 = clock$2.ONE_SECOND_IN_TS;
    var collectDtsInfo = function(track, data) {
      if (typeof data.pts === "number") {
        if (track.timelineStartInfo.pts === void 0) {
          track.timelineStartInfo.pts = data.pts;
        }
        if (track.minSegmentPts === void 0) {
          track.minSegmentPts = data.pts;
        } else {
          track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);
        }
        if (track.maxSegmentPts === void 0) {
          track.maxSegmentPts = data.pts;
        } else {
          track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);
        }
      }
      if (typeof data.dts === "number") {
        if (track.timelineStartInfo.dts === void 0) {
          track.timelineStartInfo.dts = data.dts;
        }
        if (track.minSegmentDts === void 0) {
          track.minSegmentDts = data.dts;
        } else {
          track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);
        }
        if (track.maxSegmentDts === void 0) {
          track.maxSegmentDts = data.dts;
        } else {
          track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);
        }
      }
    };
    var clearDtsInfo = function(track) {
      delete track.minSegmentDts;
      delete track.maxSegmentDts;
      delete track.minSegmentPts;
      delete track.maxSegmentPts;
    };
    var calculateTrackBaseMediaDecodeTime = function(track, keepOriginalTimestamps) {
      var baseMediaDecodeTime, scale, minSegmentDts = track.minSegmentDts;
      if (!keepOriginalTimestamps) {
        minSegmentDts -= track.timelineStartInfo.dts;
      }
      baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;
      baseMediaDecodeTime += minSegmentDts;
      baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);
      if (track.type === "audio") {
        scale = track.samplerate / ONE_SECOND_IN_TS$3;
        baseMediaDecodeTime *= scale;
        baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);
      }
      return baseMediaDecodeTime;
    };
    var trackDecodeInfo$1 = {
      clearDtsInfo,
      calculateTrackBaseMediaDecodeTime,
      collectDtsInfo
    };
    var USER_DATA_REGISTERED_ITU_T_T35 = 4, RBSP_TRAILING_BITS = 128;
    var parseSei = function(bytes) {
      var i = 0, result = {
        payloadType: -1,
        payloadSize: 0
      }, payloadType = 0, payloadSize = 0;
      while (i < bytes.byteLength) {
        if (bytes[i] === RBSP_TRAILING_BITS) {
          break;
        }
        while (bytes[i] === 255) {
          payloadType += 255;
          i++;
        }
        payloadType += bytes[i++];
        while (bytes[i] === 255) {
          payloadSize += 255;
          i++;
        }
        payloadSize += bytes[i++];
        if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {
          var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);
          if (userIdentifier === "GA94") {
            result.payloadType = payloadType;
            result.payloadSize = payloadSize;
            result.payload = bytes.subarray(i, i + payloadSize);
            break;
          } else {
            result.payload = void 0;
          }
        }
        i += payloadSize;
        payloadType = 0;
        payloadSize = 0;
      }
      return result;
    };
    var parseUserData = function(sei) {
      if (sei.payload[0] !== 181) {
        return null;
      }
      if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {
        return null;
      }
      if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== "GA94") {
        return null;
      }
      if (sei.payload[7] !== 3) {
        return null;
      }
      return sei.payload.subarray(8, sei.payload.length - 1);
    };
    var parseCaptionPackets = function(pts, userData) {
      var results = [], i, count, offset, data;
      if (!(userData[0] & 64)) {
        return results;
      }
      count = userData[0] & 31;
      for (i = 0; i < count; i++) {
        offset = i * 3;
        data = {
          type: userData[offset + 2] & 3,
          pts
        };
        if (userData[offset + 2] & 4) {
          data.ccData = userData[offset + 3] << 8 | userData[offset + 4];
          results.push(data);
        }
      }
      return results;
    };
    var discardEmulationPreventionBytes$1 = function(data) {
      var length = data.byteLength, emulationPreventionBytesPositions = [], i = 1, newLength, newData;
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
          emulationPreventionBytesPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }
      if (emulationPreventionBytesPositions.length === 0) {
        return data;
      }
      newLength = length - emulationPreventionBytesPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;
      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === emulationPreventionBytesPositions[0]) {
          sourceIndex++;
          emulationPreventionBytesPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    };
    var captionPacketParser = {
      parseSei,
      parseUserData,
      parseCaptionPackets,
      discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,
      USER_DATA_REGISTERED_ITU_T_T35
    };
    var Stream$7 = stream;
    var cea708Parser = captionPacketParser;
    var CaptionStream$2 = function(options) {
      options = options || {};
      CaptionStream$2.prototype.init.call(this);
      this.parse708captions_ = typeof options.parse708captions === "boolean" ? options.parse708captions : true;
      this.captionPackets_ = [];
      this.ccStreams_ = [
        new Cea608Stream(0, 0),
        // eslint-disable-line no-use-before-define
        new Cea608Stream(0, 1),
        // eslint-disable-line no-use-before-define
        new Cea608Stream(1, 0),
        // eslint-disable-line no-use-before-define
        new Cea608Stream(1, 1)
        // eslint-disable-line no-use-before-define
      ];
      if (this.parse708captions_) {
        this.cc708Stream_ = new Cea708Stream({
          captionServices: options.captionServices
        });
      }
      this.reset();
      this.ccStreams_.forEach(function(cc) {
        cc.on("data", this.trigger.bind(this, "data"));
        cc.on("partialdone", this.trigger.bind(this, "partialdone"));
        cc.on("done", this.trigger.bind(this, "done"));
      }, this);
      if (this.parse708captions_) {
        this.cc708Stream_.on("data", this.trigger.bind(this, "data"));
        this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone"));
        this.cc708Stream_.on("done", this.trigger.bind(this, "done"));
      }
    };
    CaptionStream$2.prototype = new Stream$7();
    CaptionStream$2.prototype.push = function(event) {
      var sei, userData, newCaptionPackets;
      if (event.nalUnitType !== "sei_rbsp") {
        return;
      }
      sei = cea708Parser.parseSei(event.escapedRBSP);
      if (!sei.payload) {
        return;
      }
      if (sei.payloadType !== cea708Parser.USER_DATA_REGISTERED_ITU_T_T35) {
        return;
      }
      userData = cea708Parser.parseUserData(sei);
      if (!userData) {
        return;
      }
      if (event.dts < this.latestDts_) {
        this.ignoreNextEqualDts_ = true;
        return;
      } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {
        this.numSameDts_--;
        if (!this.numSameDts_) {
          this.ignoreNextEqualDts_ = false;
        }
        return;
      }
      newCaptionPackets = cea708Parser.parseCaptionPackets(event.pts, userData);
      this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);
      if (this.latestDts_ !== event.dts) {
        this.numSameDts_ = 0;
      }
      this.numSameDts_++;
      this.latestDts_ = event.dts;
    };
    CaptionStream$2.prototype.flushCCStreams = function(flushType) {
      this.ccStreams_.forEach(function(cc) {
        return flushType === "flush" ? cc.flush() : cc.partialFlush();
      }, this);
    };
    CaptionStream$2.prototype.flushStream = function(flushType) {
      if (!this.captionPackets_.length) {
        this.flushCCStreams(flushType);
        return;
      }
      this.captionPackets_.forEach(function(elem, idx) {
        elem.presortIndex = idx;
      });
      this.captionPackets_.sort(function(a, b) {
        if (a.pts === b.pts) {
          return a.presortIndex - b.presortIndex;
        }
        return a.pts - b.pts;
      });
      this.captionPackets_.forEach(function(packet) {
        if (packet.type < 2) {
          this.dispatchCea608Packet(packet);
        } else {
          this.dispatchCea708Packet(packet);
        }
      }, this);
      this.captionPackets_.length = 0;
      this.flushCCStreams(flushType);
    };
    CaptionStream$2.prototype.flush = function() {
      return this.flushStream("flush");
    };
    CaptionStream$2.prototype.partialFlush = function() {
      return this.flushStream("partialFlush");
    };
    CaptionStream$2.prototype.reset = function() {
      this.latestDts_ = null;
      this.ignoreNextEqualDts_ = false;
      this.numSameDts_ = 0;
      this.activeCea608Channel_ = [null, null];
      this.ccStreams_.forEach(function(ccStream) {
        ccStream.reset();
      });
    };
    CaptionStream$2.prototype.dispatchCea608Packet = function(packet) {
      if (this.setsTextOrXDSActive(packet)) {
        this.activeCea608Channel_[packet.type] = null;
      } else if (this.setsChannel1Active(packet)) {
        this.activeCea608Channel_[packet.type] = 0;
      } else if (this.setsChannel2Active(packet)) {
        this.activeCea608Channel_[packet.type] = 1;
      }
      if (this.activeCea608Channel_[packet.type] === null) {
        return;
      }
      this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);
    };
    CaptionStream$2.prototype.setsChannel1Active = function(packet) {
      return (packet.ccData & 30720) === 4096;
    };
    CaptionStream$2.prototype.setsChannel2Active = function(packet) {
      return (packet.ccData & 30720) === 6144;
    };
    CaptionStream$2.prototype.setsTextOrXDSActive = function(packet) {
      return (packet.ccData & 28928) === 256 || (packet.ccData & 30974) === 4138 || (packet.ccData & 30974) === 6186;
    };
    CaptionStream$2.prototype.dispatchCea708Packet = function(packet) {
      if (this.parse708captions_) {
        this.cc708Stream_.push(packet);
      }
    };
    var CHARACTER_TRANSLATION_708 = {
      127: 9834,
      // ♪
      4128: 32,
      // Transparent Space
      4129: 160,
      // Nob-breaking Transparent Space
      4133: 8230,
      // …
      4138: 352,
      // Š
      4140: 338,
      // Œ
      4144: 9608,
      // █
      4145: 8216,
      // ‘
      4146: 8217,
      // ’
      4147: 8220,
      // “
      4148: 8221,
      // ”
      4149: 8226,
      // •
      4153: 8482,
      // ™
      4154: 353,
      // š
      4156: 339,
      // œ
      4157: 8480,
      // ℠
      4159: 376,
      // Ÿ
      4214: 8539,
      // ⅛
      4215: 8540,
      // ⅜
      4216: 8541,
      // ⅝
      4217: 8542,
      // ⅞
      4218: 9168,
      // ⏐
      4219: 9124,
      // ⎤
      4220: 9123,
      // ⎣
      4221: 9135,
      // ⎯
      4222: 9126,
      // ⎦
      4223: 9121,
      // ⎡
      4256: 12600
      // ㄸ (CC char)
    };
    var get708CharFromCode = function(code) {
      var newCode = CHARACTER_TRANSLATION_708[code] || code;
      if (code & 4096 && code === newCode) {
        return "";
      }
      return String.fromCharCode(newCode);
    };
    var within708TextBlock = function(b) {
      return 32 <= b && b <= 127 || 160 <= b && b <= 255;
    };
    var Cea708Window = function(windowNum) {
      this.windowNum = windowNum;
      this.reset();
    };
    Cea708Window.prototype.reset = function() {
      this.clearText();
      this.pendingNewLine = false;
      this.winAttr = {};
      this.penAttr = {};
      this.penLoc = {};
      this.penColor = {};
      this.visible = 0;
      this.rowLock = 0;
      this.columnLock = 0;
      this.priority = 0;
      this.relativePositioning = 0;
      this.anchorVertical = 0;
      this.anchorHorizontal = 0;
      this.anchorPoint = 0;
      this.rowCount = 1;
      this.virtualRowCount = this.rowCount + 1;
      this.columnCount = 41;
      this.windowStyle = 0;
      this.penStyle = 0;
    };
    Cea708Window.prototype.getText = function() {
      return this.rows.join("\n");
    };
    Cea708Window.prototype.clearText = function() {
      this.rows = [""];
      this.rowIdx = 0;
    };
    Cea708Window.prototype.newLine = function(pts) {
      if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === "function") {
        this.beforeRowOverflow(pts);
      }
      if (this.rows.length > 0) {
        this.rows.push("");
        this.rowIdx++;
      }
      while (this.rows.length > this.virtualRowCount) {
        this.rows.shift();
        this.rowIdx--;
      }
    };
    Cea708Window.prototype.isEmpty = function() {
      if (this.rows.length === 0) {
        return true;
      } else if (this.rows.length === 1) {
        return this.rows[0] === "";
      }
      return false;
    };
    Cea708Window.prototype.addText = function(text) {
      this.rows[this.rowIdx] += text;
    };
    Cea708Window.prototype.backspace = function() {
      if (!this.isEmpty()) {
        var row = this.rows[this.rowIdx];
        this.rows[this.rowIdx] = row.substr(0, row.length - 1);
      }
    };
    var Cea708Service = function(serviceNum, encoding, stream2) {
      this.serviceNum = serviceNum;
      this.text = "";
      this.currentWindow = new Cea708Window(-1);
      this.windows = [];
      this.stream = stream2;
      if (typeof encoding === "string") {
        this.createTextDecoder(encoding);
      }
    };
    Cea708Service.prototype.init = function(pts, beforeRowOverflow) {
      this.startPts = pts;
      for (var win3 = 0; win3 < 8; win3++) {
        this.windows[win3] = new Cea708Window(win3);
        if (typeof beforeRowOverflow === "function") {
          this.windows[win3].beforeRowOverflow = beforeRowOverflow;
        }
      }
    };
    Cea708Service.prototype.setCurrentWindow = function(windowNum) {
      this.currentWindow = this.windows[windowNum];
    };
    Cea708Service.prototype.createTextDecoder = function(encoding) {
      if (typeof TextDecoder === "undefined") {
        this.stream.trigger("log", {
          level: "warn",
          message: "The `encoding` option is unsupported without TextDecoder support"
        });
      } else {
        try {
          this.textDecoder_ = new TextDecoder(encoding);
        } catch (error) {
          this.stream.trigger("log", {
            level: "warn",
            message: "TextDecoder could not be created with " + encoding + " encoding. " + error
          });
        }
      }
    };
    var Cea708Stream = function(options) {
      options = options || {};
      Cea708Stream.prototype.init.call(this);
      var self2 = this;
      var captionServices = options.captionServices || {};
      var captionServiceEncodings = {};
      var serviceProps;
      Object.keys(captionServices).forEach((serviceName) => {
        serviceProps = captionServices[serviceName];
        if (/^SERVICE/.test(serviceName)) {
          captionServiceEncodings[serviceName] = serviceProps.encoding;
        }
      });
      this.serviceEncodings = captionServiceEncodings;
      this.current708Packet = null;
      this.services = {};
      this.push = function(packet) {
        if (packet.type === 3) {
          self2.new708Packet();
          self2.add708Bytes(packet);
        } else {
          if (self2.current708Packet === null) {
            self2.new708Packet();
          }
          self2.add708Bytes(packet);
        }
      };
    };
    Cea708Stream.prototype = new Stream$7();
    Cea708Stream.prototype.new708Packet = function() {
      if (this.current708Packet !== null) {
        this.push708Packet();
      }
      this.current708Packet = {
        data: [],
        ptsVals: []
      };
    };
    Cea708Stream.prototype.add708Bytes = function(packet) {
      var data = packet.ccData;
      var byte0 = data >>> 8;
      var byte1 = data & 255;
      this.current708Packet.ptsVals.push(packet.pts);
      this.current708Packet.data.push(byte0);
      this.current708Packet.data.push(byte1);
    };
    Cea708Stream.prototype.push708Packet = function() {
      var packet708 = this.current708Packet;
      var packetData = packet708.data;
      var serviceNum = null;
      var blockSize = null;
      var i = 0;
      var b = packetData[i++];
      packet708.seq = b >> 6;
      packet708.sizeCode = b & 63;
      for (; i < packetData.length; i++) {
        b = packetData[i++];
        serviceNum = b >> 5;
        blockSize = b & 31;
        if (serviceNum === 7 && blockSize > 0) {
          b = packetData[i++];
          serviceNum = b;
        }
        this.pushServiceBlock(serviceNum, i, blockSize);
        if (blockSize > 0) {
          i += blockSize - 1;
        }
      }
    };
    Cea708Stream.prototype.pushServiceBlock = function(serviceNum, start, size) {
      var b;
      var i = start;
      var packetData = this.current708Packet.data;
      var service = this.services[serviceNum];
      if (!service) {
        service = this.initService(serviceNum, i);
      }
      for (; i < start + size && i < packetData.length; i++) {
        b = packetData[i];
        if (within708TextBlock(b)) {
          i = this.handleText(i, service);
        } else if (b === 24) {
          i = this.multiByteCharacter(i, service);
        } else if (b === 16) {
          i = this.extendedCommands(i, service);
        } else if (128 <= b && b <= 135) {
          i = this.setCurrentWindow(i, service);
        } else if (152 <= b && b <= 159) {
          i = this.defineWindow(i, service);
        } else if (b === 136) {
          i = this.clearWindows(i, service);
        } else if (b === 140) {
          i = this.deleteWindows(i, service);
        } else if (b === 137) {
          i = this.displayWindows(i, service);
        } else if (b === 138) {
          i = this.hideWindows(i, service);
        } else if (b === 139) {
          i = this.toggleWindows(i, service);
        } else if (b === 151) {
          i = this.setWindowAttributes(i, service);
        } else if (b === 144) {
          i = this.setPenAttributes(i, service);
        } else if (b === 145) {
          i = this.setPenColor(i, service);
        } else if (b === 146) {
          i = this.setPenLocation(i, service);
        } else if (b === 143) {
          service = this.reset(i, service);
        } else if (b === 8) {
          service.currentWindow.backspace();
        } else if (b === 12) {
          service.currentWindow.clearText();
        } else if (b === 13) {
          service.currentWindow.pendingNewLine = true;
        } else if (b === 14) {
          service.currentWindow.clearText();
        } else if (b === 141) {
          i++;
        } else
          ;
      }
    };
    Cea708Stream.prototype.extendedCommands = function(i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[++i];
      if (within708TextBlock(b)) {
        i = this.handleText(i, service, {
          isExtended: true
        });
      }
      return i;
    };
    Cea708Stream.prototype.getPts = function(byteIndex) {
      return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];
    };
    Cea708Stream.prototype.initService = function(serviceNum, i) {
      var serviceName = "SERVICE" + serviceNum;
      var self2 = this;
      var serviceName;
      var encoding;
      if (serviceName in this.serviceEncodings) {
        encoding = this.serviceEncodings[serviceName];
      }
      this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self2);
      this.services[serviceNum].init(this.getPts(i), function(pts) {
        self2.flushDisplayed(pts, self2.services[serviceNum]);
      });
      return this.services[serviceNum];
    };
    Cea708Stream.prototype.handleText = function(i, service, options) {
      var isExtended = options && options.isExtended;
      var isMultiByte = options && options.isMultiByte;
      var packetData = this.current708Packet.data;
      var extended = isExtended ? 4096 : 0;
      var currentByte = packetData[i];
      var nextByte = packetData[i + 1];
      var win3 = service.currentWindow;
      var char;
      var charCodeArray;
      function toHexString2(byteArray) {
        return byteArray.map((byte) => {
          return ("0" + (byte & 255).toString(16)).slice(-2);
        }).join("");
      }
      if (isMultiByte) {
        charCodeArray = [currentByte, nextByte];
        i++;
      } else {
        charCodeArray = [currentByte];
      }
      if (service.textDecoder_ && !isExtended) {
        char = service.textDecoder_.decode(new Uint8Array(charCodeArray));
      } else {
        if (isMultiByte) {
          const unicode = toHexString2(charCodeArray);
          char = String.fromCharCode(parseInt(unicode, 16));
        } else {
          char = get708CharFromCode(extended | currentByte);
        }
      }
      if (win3.pendingNewLine && !win3.isEmpty()) {
        win3.newLine(this.getPts(i));
      }
      win3.pendingNewLine = false;
      win3.addText(char);
      return i;
    };
    Cea708Stream.prototype.multiByteCharacter = function(i, service) {
      var packetData = this.current708Packet.data;
      var firstByte = packetData[i + 1];
      var secondByte = packetData[i + 2];
      if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) {
        i = this.handleText(++i, service, {
          isMultiByte: true
        });
      }
      return i;
    };
    Cea708Stream.prototype.setCurrentWindow = function(i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[i];
      var windowNum = b & 7;
      service.setCurrentWindow(windowNum);
      return i;
    };
    Cea708Stream.prototype.defineWindow = function(i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[i];
      var windowNum = b & 7;
      service.setCurrentWindow(windowNum);
      var win3 = service.currentWindow;
      b = packetData[++i];
      win3.visible = (b & 32) >> 5;
      win3.rowLock = (b & 16) >> 4;
      win3.columnLock = (b & 8) >> 3;
      win3.priority = b & 7;
      b = packetData[++i];
      win3.relativePositioning = (b & 128) >> 7;
      win3.anchorVertical = b & 127;
      b = packetData[++i];
      win3.anchorHorizontal = b;
      b = packetData[++i];
      win3.anchorPoint = (b & 240) >> 4;
      win3.rowCount = b & 15;
      b = packetData[++i];
      win3.columnCount = b & 63;
      b = packetData[++i];
      win3.windowStyle = (b & 56) >> 3;
      win3.penStyle = b & 7;
      win3.virtualRowCount = win3.rowCount + 1;
      return i;
    };
    Cea708Stream.prototype.setWindowAttributes = function(i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[i];
      var winAttr = service.currentWindow.winAttr;
      b = packetData[++i];
      winAttr.fillOpacity = (b & 192) >> 6;
      winAttr.fillRed = (b & 48) >> 4;
      winAttr.fillGreen = (b & 12) >> 2;
      winAttr.fillBlue = b & 3;
      b = packetData[++i];
      winAttr.borderType = (b & 192) >> 6;
      winAttr.borderRed = (b & 48) >> 4;
      winAttr.borderGreen = (b & 12) >> 2;
      winAttr.borderBlue = b & 3;
      b = packetData[++i];
      winAttr.borderType += (b & 128) >> 5;
      winAttr.wordWrap = (b & 64) >> 6;
      winAttr.printDirection = (b & 48) >> 4;
      winAttr.scrollDirection = (b & 12) >> 2;
      winAttr.justify = b & 3;
      b = packetData[++i];
      winAttr.effectSpeed = (b & 240) >> 4;
      winAttr.effectDirection = (b & 12) >> 2;
      winAttr.displayEffect = b & 3;
      return i;
    };
    Cea708Stream.prototype.flushDisplayed = function(pts, service) {
      var displayedText = [];
      for (var winId = 0; winId < 8; winId++) {
        if (service.windows[winId].visible && !service.windows[winId].isEmpty()) {
          displayedText.push(service.windows[winId].getText());
        }
      }
      service.endPts = pts;
      service.text = displayedText.join("\n\n");
      this.pushCaption(service);
      service.startPts = pts;
    };
    Cea708Stream.prototype.pushCaption = function(service) {
      if (service.text !== "") {
        this.trigger("data", {
          startPts: service.startPts,
          endPts: service.endPts,
          text: service.text,
          stream: "cc708_" + service.serviceNum
        });
        service.text = "";
        service.startPts = service.endPts;
      }
    };
    Cea708Stream.prototype.displayWindows = function(i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[++i];
      var pts = this.getPts(i);
      this.flushDisplayed(pts, service);
      for (var winId = 0; winId < 8; winId++) {
        if (b & 1 << winId) {
          service.windows[winId].visible = 1;
        }
      }
      return i;
    };
    Cea708Stream.prototype.hideWindows = function(i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[++i];
      var pts = this.getPts(i);
      this.flushDisplayed(pts, service);
      for (var winId = 0; winId < 8; winId++) {
        if (b & 1 << winId) {
          service.windows[winId].visible = 0;
        }
      }
      return i;
    };
    Cea708Stream.prototype.toggleWindows = function(i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[++i];
      var pts = this.getPts(i);
      this.flushDisplayed(pts, service);
      for (var winId = 0; winId < 8; winId++) {
        if (b & 1 << winId) {
          service.windows[winId].visible ^= 1;
        }
      }
      return i;
    };
    Cea708Stream.prototype.clearWindows = function(i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[++i];
      var pts = this.getPts(i);
      this.flushDisplayed(pts, service);
      for (var winId = 0; winId < 8; winId++) {
        if (b & 1 << winId) {
          service.windows[winId].clearText();
        }
      }
      return i;
    };
    Cea708Stream.prototype.deleteWindows = function(i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[++i];
      var pts = this.getPts(i);
      this.flushDisplayed(pts, service);
      for (var winId = 0; winId < 8; winId++) {
        if (b & 1 << winId) {
          service.windows[winId].reset();
        }
      }
      return i;
    };
    Cea708Stream.prototype.setPenAttributes = function(i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[i];
      var penAttr = service.currentWindow.penAttr;
      b = packetData[++i];
      penAttr.textTag = (b & 240) >> 4;
      penAttr.offset = (b & 12) >> 2;
      penAttr.penSize = b & 3;
      b = packetData[++i];
      penAttr.italics = (b & 128) >> 7;
      penAttr.underline = (b & 64) >> 6;
      penAttr.edgeType = (b & 56) >> 3;
      penAttr.fontStyle = b & 7;
      return i;
    };
    Cea708Stream.prototype.setPenColor = function(i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[i];
      var penColor = service.currentWindow.penColor;
      b = packetData[++i];
      penColor.fgOpacity = (b & 192) >> 6;
      penColor.fgRed = (b & 48) >> 4;
      penColor.fgGreen = (b & 12) >> 2;
      penColor.fgBlue = b & 3;
      b = packetData[++i];
      penColor.bgOpacity = (b & 192) >> 6;
      penColor.bgRed = (b & 48) >> 4;
      penColor.bgGreen = (b & 12) >> 2;
      penColor.bgBlue = b & 3;
      b = packetData[++i];
      penColor.edgeRed = (b & 48) >> 4;
      penColor.edgeGreen = (b & 12) >> 2;
      penColor.edgeBlue = b & 3;
      return i;
    };
    Cea708Stream.prototype.setPenLocation = function(i, service) {
      var packetData = this.current708Packet.data;
      var b = packetData[i];
      var penLoc = service.currentWindow.penLoc;
      service.currentWindow.pendingNewLine = true;
      b = packetData[++i];
      penLoc.row = b & 15;
      b = packetData[++i];
      penLoc.column = b & 63;
      return i;
    };
    Cea708Stream.prototype.reset = function(i, service) {
      var pts = this.getPts(i);
      this.flushDisplayed(pts, service);
      return this.initService(service.serviceNum, i);
    };
    var CHARACTER_TRANSLATION = {
      42: 225,
      // á
      92: 233,
      // é
      94: 237,
      // í
      95: 243,
      // ó
      96: 250,
      // ú
      123: 231,
      // ç
      124: 247,
      // ÷
      125: 209,
      // Ñ
      126: 241,
      // ñ
      127: 9608,
      // █
      304: 174,
      // ®
      305: 176,
      // °
      306: 189,
      // ½
      307: 191,
      // ¿
      308: 8482,
      // ™
      309: 162,
      // ¢
      310: 163,
      // £
      311: 9834,
      // ♪
      312: 224,
      // à
      313: 160,
      //
      314: 232,
      // è
      315: 226,
      // â
      316: 234,
      // ê
      317: 238,
      // î
      318: 244,
      // ô
      319: 251,
      // û
      544: 193,
      // Á
      545: 201,
      // É
      546: 211,
      // Ó
      547: 218,
      // Ú
      548: 220,
      // Ü
      549: 252,
      // ü
      550: 8216,
      // ‘
      551: 161,
      // ¡
      552: 42,
      // *
      553: 39,
      // '
      554: 8212,
      // —
      555: 169,
      // ©
      556: 8480,
      // ℠
      557: 8226,
      // •
      558: 8220,
      // “
      559: 8221,
      // ”
      560: 192,
      // À
      561: 194,
      // Â
      562: 199,
      // Ç
      563: 200,
      // È
      564: 202,
      // Ê
      565: 203,
      // Ë
      566: 235,
      // ë
      567: 206,
      // Î
      568: 207,
      // Ï
      569: 239,
      // ï
      570: 212,
      // Ô
      571: 217,
      // Ù
      572: 249,
      // ù
      573: 219,
      // Û
      574: 171,
      // «
      575: 187,
      // »
      800: 195,
      // Ã
      801: 227,
      // ã
      802: 205,
      // Í
      803: 204,
      // Ì
      804: 236,
      // ì
      805: 210,
      // Ò
      806: 242,
      // ò
      807: 213,
      // Õ
      808: 245,
      // õ
      809: 123,
      // {
      810: 125,
      // }
      811: 92,
      // \
      812: 94,
      // ^
      813: 95,
      // _
      814: 124,
      // |
      815: 126,
      // ~
      816: 196,
      // Ä
      817: 228,
      // ä
      818: 214,
      // Ö
      819: 246,
      // ö
      820: 223,
      // ß
      821: 165,
      // ¥
      822: 164,
      // ¤
      823: 9474,
      // │
      824: 197,
      // Å
      825: 229,
      // å
      826: 216,
      // Ø
      827: 248,
      // ø
      828: 9484,
      // ┌
      829: 9488,
      // ┐
      830: 9492,
      // └
      831: 9496
      // ┘
    };
    var getCharFromCode = function(code) {
      if (code === null) {
        return "";
      }
      code = CHARACTER_TRANSLATION[code] || code;
      return String.fromCharCode(code);
    };
    var BOTTOM_ROW = 14;
    var ROWS = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152];
    var createDisplayBuffer = function() {
      var result = [], i = BOTTOM_ROW + 1;
      while (i--) {
        result.push({
          text: "",
          indent: 0,
          offset: 0
        });
      }
      return result;
    };
    var Cea608Stream = function(field, dataChannel) {
      Cea608Stream.prototype.init.call(this);
      this.field_ = field || 0;
      this.dataChannel_ = dataChannel || 0;
      this.name_ = "CC" + ((this.field_ << 1 | this.dataChannel_) + 1);
      this.setConstants();
      this.reset();
      this.push = function(packet) {
        var data, swap, char0, char1, text;
        data = packet.ccData & 32639;
        if (data === this.lastControlCode_) {
          this.lastControlCode_ = null;
          return;
        }
        if ((data & 61440) === 4096) {
          this.lastControlCode_ = data;
        } else if (data !== this.PADDING_) {
          this.lastControlCode_ = null;
        }
        char0 = data >>> 8;
        char1 = data & 255;
        if (data === this.PADDING_) {
          return;
        } else if (data === this.RESUME_CAPTION_LOADING_) {
          this.mode_ = "popOn";
        } else if (data === this.END_OF_CAPTION_) {
          this.mode_ = "popOn";
          this.clearFormatting(packet.pts);
          this.flushDisplayed(packet.pts);
          swap = this.displayed_;
          this.displayed_ = this.nonDisplayed_;
          this.nonDisplayed_ = swap;
          this.startPts_ = packet.pts;
        } else if (data === this.ROLL_UP_2_ROWS_) {
          this.rollUpRows_ = 2;
          this.setRollUp(packet.pts);
        } else if (data === this.ROLL_UP_3_ROWS_) {
          this.rollUpRows_ = 3;
          this.setRollUp(packet.pts);
        } else if (data === this.ROLL_UP_4_ROWS_) {
          this.rollUpRows_ = 4;
          this.setRollUp(packet.pts);
        } else if (data === this.CARRIAGE_RETURN_) {
          this.clearFormatting(packet.pts);
          this.flushDisplayed(packet.pts);
          this.shiftRowsUp_();
          this.startPts_ = packet.pts;
        } else if (data === this.BACKSPACE_) {
          if (this.mode_ === "popOn") {
            this.nonDisplayed_[this.row_].text = this.nonDisplayed_[this.row_].text.slice(0, -1);
          } else {
            this.displayed_[this.row_].text = this.displayed_[this.row_].text.slice(0, -1);
          }
        } else if (data === this.ERASE_DISPLAYED_MEMORY_) {
          this.flushDisplayed(packet.pts);
          this.displayed_ = createDisplayBuffer();
        } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {
          this.nonDisplayed_ = createDisplayBuffer();
        } else if (data === this.RESUME_DIRECT_CAPTIONING_) {
          if (this.mode_ !== "paintOn") {
            this.flushDisplayed(packet.pts);
            this.displayed_ = createDisplayBuffer();
          }
          this.mode_ = "paintOn";
          this.startPts_ = packet.pts;
        } else if (this.isSpecialCharacter(char0, char1)) {
          char0 = (char0 & 3) << 8;
          text = getCharFromCode(char0 | char1);
          this[this.mode_](packet.pts, text);
          this.column_++;
        } else if (this.isExtCharacter(char0, char1)) {
          if (this.mode_ === "popOn") {
            this.nonDisplayed_[this.row_].text = this.nonDisplayed_[this.row_].text.slice(0, -1);
          } else {
            this.displayed_[this.row_].text = this.displayed_[this.row_].text.slice(0, -1);
          }
          char0 = (char0 & 3) << 8;
          text = getCharFromCode(char0 | char1);
          this[this.mode_](packet.pts, text);
          this.column_++;
        } else if (this.isMidRowCode(char0, char1)) {
          this.clearFormatting(packet.pts);
          this[this.mode_](packet.pts, " ");
          this.column_++;
          if ((char1 & 14) === 14) {
            this.addFormatting(packet.pts, ["i"]);
          }
          if ((char1 & 1) === 1) {
            this.addFormatting(packet.pts, ["u"]);
          }
        } else if (this.isOffsetControlCode(char0, char1)) {
          const offset = char1 & 3;
          this.nonDisplayed_[this.row_].offset = offset;
          this.column_ += offset;
        } else if (this.isPAC(char0, char1)) {
          var row = ROWS.indexOf(data & 7968);
          if (this.mode_ === "rollUp") {
            if (row - this.rollUpRows_ + 1 < 0) {
              row = this.rollUpRows_ - 1;
            }
            this.setRollUp(packet.pts, row);
          }
          if (row !== this.row_) {
            this.clearFormatting(packet.pts);
            this.row_ = row;
          }
          if (char1 & 1 && this.formatting_.indexOf("u") === -1) {
            this.addFormatting(packet.pts, ["u"]);
          }
          if ((data & 16) === 16) {
            const indentations = (data & 14) >> 1;
            this.column_ = indentations * 4;
            this.nonDisplayed_[this.row_].indent += indentations;
          }
          if (this.isColorPAC(char1)) {
            if ((char1 & 14) === 14) {
              this.addFormatting(packet.pts, ["i"]);
            }
          }
        } else if (this.isNormalChar(char0)) {
          if (char1 === 0) {
            char1 = null;
          }
          text = getCharFromCode(char0);
          text += getCharFromCode(char1);
          this[this.mode_](packet.pts, text);
          this.column_ += text.length;
        }
      };
    };
    Cea608Stream.prototype = new Stream$7();
    Cea608Stream.prototype.flushDisplayed = function(pts) {
      const logWarning = (index) => {
        this.trigger("log", {
          level: "warn",
          message: "Skipping a malformed 608 caption at index " + index + "."
        });
      };
      const content = [];
      this.displayed_.forEach((row, i) => {
        if (row && row.text && row.text.length) {
          try {
            row.text = row.text.trim();
          } catch (e) {
            logWarning(i);
          }
          if (row.text.length) {
            content.push({
              // The text to be displayed in the caption from this specific row, with whitespace removed.
              text: row.text,
              // Value between 1 and 15 representing the PAC row used to calculate line height.
              line: i + 1,
              // A number representing the indent position by percentage (CEA-608 PAC indent code).
              // The value will be a number between 10 and 80. Offset is used to add an aditional
              // value to the position if necessary.
              position: 10 + Math.min(70, row.indent * 10) + row.offset * 2.5
            });
          }
        } else if (row === void 0 || row === null) {
          logWarning(i);
        }
      });
      if (content.length) {
        this.trigger("data", {
          startPts: this.startPts_,
          endPts: pts,
          content,
          stream: this.name_
        });
      }
    };
    Cea608Stream.prototype.reset = function() {
      this.mode_ = "popOn";
      this.topRow_ = 0;
      this.startPts_ = 0;
      this.displayed_ = createDisplayBuffer();
      this.nonDisplayed_ = createDisplayBuffer();
      this.lastControlCode_ = null;
      this.column_ = 0;
      this.row_ = BOTTOM_ROW;
      this.rollUpRows_ = 2;
      this.formatting_ = [];
    };
    Cea608Stream.prototype.setConstants = function() {
      if (this.dataChannel_ === 0) {
        this.BASE_ = 16;
        this.EXT_ = 17;
        this.CONTROL_ = (20 | this.field_) << 8;
        this.OFFSET_ = 23;
      } else if (this.dataChannel_ === 1) {
        this.BASE_ = 24;
        this.EXT_ = 25;
        this.CONTROL_ = (28 | this.field_) << 8;
        this.OFFSET_ = 31;
      }
      this.PADDING_ = 0;
      this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 32;
      this.END_OF_CAPTION_ = this.CONTROL_ | 47;
      this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 37;
      this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 38;
      this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 39;
      this.CARRIAGE_RETURN_ = this.CONTROL_ | 45;
      this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 41;
      this.BACKSPACE_ = this.CONTROL_ | 33;
      this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 44;
      this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 46;
    };
    Cea608Stream.prototype.isSpecialCharacter = function(char0, char1) {
      return char0 === this.EXT_ && char1 >= 48 && char1 <= 63;
    };
    Cea608Stream.prototype.isExtCharacter = function(char0, char1) {
      return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 32 && char1 <= 63;
    };
    Cea608Stream.prototype.isMidRowCode = function(char0, char1) {
      return char0 === this.EXT_ && char1 >= 32 && char1 <= 47;
    };
    Cea608Stream.prototype.isOffsetControlCode = function(char0, char1) {
      return char0 === this.OFFSET_ && char1 >= 33 && char1 <= 35;
    };
    Cea608Stream.prototype.isPAC = function(char0, char1) {
      return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 64 && char1 <= 127;
    };
    Cea608Stream.prototype.isColorPAC = function(char1) {
      return char1 >= 64 && char1 <= 79 || char1 >= 96 && char1 <= 127;
    };
    Cea608Stream.prototype.isNormalChar = function(char) {
      return char >= 32 && char <= 127;
    };
    Cea608Stream.prototype.setRollUp = function(pts, newBaseRow) {
      if (this.mode_ !== "rollUp") {
        this.row_ = BOTTOM_ROW;
        this.mode_ = "rollUp";
        this.flushDisplayed(pts);
        this.nonDisplayed_ = createDisplayBuffer();
        this.displayed_ = createDisplayBuffer();
      }
      if (newBaseRow !== void 0 && newBaseRow !== this.row_) {
        for (var i = 0; i < this.rollUpRows_; i++) {
          this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];
          this.displayed_[this.row_ - i] = {
            text: "",
            indent: 0,
            offset: 0
          };
        }
      }
      if (newBaseRow === void 0) {
        newBaseRow = this.row_;
      }
      this.topRow_ = newBaseRow - this.rollUpRows_ + 1;
    };
    Cea608Stream.prototype.addFormatting = function(pts, format) {
      this.formatting_ = this.formatting_.concat(format);
      var text = format.reduce(function(text2, format2) {
        return text2 + "<" + format2 + ">";
      }, "");
      this[this.mode_](pts, text);
    };
    Cea608Stream.prototype.clearFormatting = function(pts) {
      if (!this.formatting_.length) {
        return;
      }
      var text = this.formatting_.reverse().reduce(function(text2, format) {
        return text2 + "</" + format + ">";
      }, "");
      this.formatting_ = [];
      this[this.mode_](pts, text);
    };
    Cea608Stream.prototype.popOn = function(pts, text) {
      var baseRow = this.nonDisplayed_[this.row_].text;
      baseRow += text;
      this.nonDisplayed_[this.row_].text = baseRow;
    };
    Cea608Stream.prototype.rollUp = function(pts, text) {
      var baseRow = this.displayed_[this.row_].text;
      baseRow += text;
      this.displayed_[this.row_].text = baseRow;
    };
    Cea608Stream.prototype.shiftRowsUp_ = function() {
      var i;
      for (i = 0; i < this.topRow_; i++) {
        this.displayed_[i] = {
          text: "",
          indent: 0,
          offset: 0
        };
      }
      for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {
        this.displayed_[i] = {
          text: "",
          indent: 0,
          offset: 0
        };
      }
      for (i = this.topRow_; i < this.row_; i++) {
        this.displayed_[i] = this.displayed_[i + 1];
      }
      this.displayed_[this.row_] = {
        text: "",
        indent: 0,
        offset: 0
      };
    };
    Cea608Stream.prototype.paintOn = function(pts, text) {
      var baseRow = this.displayed_[this.row_].text;
      baseRow += text;
      this.displayed_[this.row_].text = baseRow;
    };
    var captionStream = {
      CaptionStream: CaptionStream$2,
      Cea608Stream,
      Cea708Stream
    };
    var streamTypes = {
      H264_STREAM_TYPE: 27,
      ADTS_STREAM_TYPE: 15,
      METADATA_STREAM_TYPE: 21
    };
    var Stream$6 = stream;
    var MAX_TS = 8589934592;
    var RO_THRESH = 4294967296;
    var TYPE_SHARED = "shared";
    var handleRollover$1 = function(value, reference) {
      var direction = 1;
      if (value > reference) {
        direction = -1;
      }
      while (Math.abs(reference - value) > RO_THRESH) {
        value += direction * MAX_TS;
      }
      return value;
    };
    var TimestampRolloverStream$1 = function(type2) {
      var lastDTS, referenceDTS;
      TimestampRolloverStream$1.prototype.init.call(this);
      this.type_ = type2 || TYPE_SHARED;
      this.push = function(data) {
        if (data.type === "metadata") {
          this.trigger("data", data);
          return;
        }
        if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {
          return;
        }
        if (referenceDTS === void 0) {
          referenceDTS = data.dts;
        }
        data.dts = handleRollover$1(data.dts, referenceDTS);
        data.pts = handleRollover$1(data.pts, referenceDTS);
        lastDTS = data.dts;
        this.trigger("data", data);
      };
      this.flush = function() {
        referenceDTS = lastDTS;
        this.trigger("done");
      };
      this.endTimeline = function() {
        this.flush();
        this.trigger("endedtimeline");
      };
      this.discontinuity = function() {
        referenceDTS = void 0;
        lastDTS = void 0;
      };
      this.reset = function() {
        this.discontinuity();
        this.trigger("reset");
      };
    };
    TimestampRolloverStream$1.prototype = new Stream$6();
    var timestampRolloverStream = {
      TimestampRolloverStream: TimestampRolloverStream$1,
      handleRollover: handleRollover$1
    };
    var typedArrayIndexOf$1 = (typedArray2, element, fromIndex) => {
      if (!typedArray2) {
        return -1;
      }
      var currentIndex = fromIndex;
      for (; currentIndex < typedArray2.length; currentIndex++) {
        if (typedArray2[currentIndex] === element) {
          return currentIndex;
        }
      }
      return -1;
    };
    var typedArray = {
      typedArrayIndexOf: typedArrayIndexOf$1
    };
    var typedArrayIndexOf = typedArray.typedArrayIndexOf, textEncodingDescriptionByte = {
      Iso88591: 0,
      // ISO-8859-1, terminated with \0.
      Utf16: 1,
      // UTF-16 encoded Unicode BOM, terminated with \0\0
      Utf16be: 2,
      // UTF-16BE encoded Unicode, without BOM, terminated with \0\0
      Utf8: 3
      // UTF-8 encoded Unicode, terminated with \0
    }, percentEncode$1 = function(bytes, start, end) {
      var i, result = "";
      for (i = start; i < end; i++) {
        result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
      }
      return result;
    }, parseUtf8 = function(bytes, start, end) {
      return decodeURIComponent(percentEncode$1(bytes, start, end));
    }, parseIso88591$1 = function(bytes, start, end) {
      return unescape(percentEncode$1(bytes, start, end));
    }, parseSyncSafeInteger$1 = function(data) {
      return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
    }, frameParsers = {
      "APIC": function(frame) {
        var i = 1, mimeTypeEndIndex, descriptionEndIndex, LINK_MIME_TYPE = "-->";
        if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {
          return;
        }
        mimeTypeEndIndex = typedArrayIndexOf(frame.data, 0, i);
        if (mimeTypeEndIndex < 0) {
          return;
        }
        frame.mimeType = parseIso88591$1(frame.data, i, mimeTypeEndIndex);
        i = mimeTypeEndIndex + 1;
        frame.pictureType = frame.data[i];
        i++;
        descriptionEndIndex = typedArrayIndexOf(frame.data, 0, i);
        if (descriptionEndIndex < 0) {
          return;
        }
        frame.description = parseUtf8(frame.data, i, descriptionEndIndex);
        i = descriptionEndIndex + 1;
        if (frame.mimeType === LINK_MIME_TYPE) {
          frame.url = parseIso88591$1(frame.data, i, frame.data.length);
        } else {
          frame.pictureData = frame.data.subarray(i, frame.data.length);
        }
      },
      "T*": function(frame) {
        if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {
          return;
        }
        frame.value = parseUtf8(frame.data, 1, frame.data.length).replace(/\0*$/, "");
        frame.values = frame.value.split("\0");
      },
      "TXXX": function(frame) {
        var descriptionEndIndex;
        if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {
          return;
        }
        descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);
        if (descriptionEndIndex === -1) {
          return;
        }
        frame.description = parseUtf8(frame.data, 1, descriptionEndIndex);
        frame.value = parseUtf8(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\0*$/, "");
        frame.data = frame.value;
      },
      "W*": function(frame) {
        frame.url = parseIso88591$1(frame.data, 0, frame.data.length).replace(/\0.*$/, "");
      },
      "WXXX": function(frame) {
        var descriptionEndIndex;
        if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {
          return;
        }
        descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);
        if (descriptionEndIndex === -1) {
          return;
        }
        frame.description = parseUtf8(frame.data, 1, descriptionEndIndex);
        frame.url = parseIso88591$1(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\0.*$/, "");
      },
      "PRIV": function(frame) {
        var i;
        for (i = 0; i < frame.data.length; i++) {
          if (frame.data[i] === 0) {
            frame.owner = parseIso88591$1(frame.data, 0, i);
            break;
          }
        }
        frame.privateData = frame.data.subarray(i + 1);
        frame.data = frame.privateData;
      }
    };
    var parseId3Frames$1 = function(data) {
      var frameSize, frameHeader, frameStart = 10, tagSize = 0, frames = [];
      if (data.length < 10 || data[0] !== "I".charCodeAt(0) || data[1] !== "D".charCodeAt(0) || data[2] !== "3".charCodeAt(0)) {
        return;
      }
      tagSize = parseSyncSafeInteger$1(data.subarray(6, 10));
      tagSize += 10;
      var hasExtendedHeader = data[5] & 64;
      if (hasExtendedHeader) {
        frameStart += 4;
        frameStart += parseSyncSafeInteger$1(data.subarray(10, 14));
        tagSize -= parseSyncSafeInteger$1(data.subarray(16, 20));
      }
      do {
        frameSize = parseSyncSafeInteger$1(data.subarray(frameStart + 4, frameStart + 8));
        if (frameSize < 1) {
          break;
        }
        frameHeader = String.fromCharCode(data[frameStart], data[frameStart + 1], data[frameStart + 2], data[frameStart + 3]);
        var frame = {
          id: frameHeader,
          data: data.subarray(frameStart + 10, frameStart + frameSize + 10)
        };
        frame.key = frame.id;
        if (frameParsers[frame.id]) {
          frameParsers[frame.id](frame);
        } else if (frame.id[0] === "T") {
          frameParsers["T*"](frame);
        } else if (frame.id[0] === "W") {
          frameParsers["W*"](frame);
        }
        frames.push(frame);
        frameStart += 10;
        frameStart += frameSize;
      } while (frameStart < tagSize);
      return frames;
    };
    var parseId3 = {
      parseId3Frames: parseId3Frames$1,
      parseSyncSafeInteger: parseSyncSafeInteger$1,
      frameParsers
    };
    var Stream$5 = stream, StreamTypes$3 = streamTypes, id3 = parseId3, MetadataStream;
    MetadataStream = function(options) {
      var settings = {
        // the bytes of the program-level descriptor field in MP2T
        // see ISO/IEC 13818-1:2013 (E), section 2.6 "Program and
        // program element descriptors"
        descriptor: options && options.descriptor
      }, tagSize = 0, buffer = [], bufferSize = 0, i;
      MetadataStream.prototype.init.call(this);
      this.dispatchType = StreamTypes$3.METADATA_STREAM_TYPE.toString(16);
      if (settings.descriptor) {
        for (i = 0; i < settings.descriptor.length; i++) {
          this.dispatchType += ("00" + settings.descriptor[i].toString(16)).slice(-2);
        }
      }
      this.push = function(chunk) {
        var tag, frameStart, frameSize, frame, i2, frameHeader;
        if (chunk.type !== "timed-metadata") {
          return;
        }
        if (chunk.dataAlignmentIndicator) {
          bufferSize = 0;
          buffer.length = 0;
        }
        if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== "I".charCodeAt(0) || chunk.data[1] !== "D".charCodeAt(0) || chunk.data[2] !== "3".charCodeAt(0))) {
          this.trigger("log", {
            level: "warn",
            message: "Skipping unrecognized metadata packet"
          });
          return;
        }
        buffer.push(chunk);
        bufferSize += chunk.data.byteLength;
        if (buffer.length === 1) {
          tagSize = id3.parseSyncSafeInteger(chunk.data.subarray(6, 10));
          tagSize += 10;
        }
        if (bufferSize < tagSize) {
          return;
        }
        tag = {
          data: new Uint8Array(tagSize),
          frames: [],
          pts: buffer[0].pts,
          dts: buffer[0].dts
        };
        for (i2 = 0; i2 < tagSize; ) {
          tag.data.set(buffer[0].data.subarray(0, tagSize - i2), i2);
          i2 += buffer[0].data.byteLength;
          bufferSize -= buffer[0].data.byteLength;
          buffer.shift();
        }
        frameStart = 10;
        if (tag.data[5] & 64) {
          frameStart += 4;
          frameStart += id3.parseSyncSafeInteger(tag.data.subarray(10, 14));
          tagSize -= id3.parseSyncSafeInteger(tag.data.subarray(16, 20));
        }
        do {
          frameSize = id3.parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));
          if (frameSize < 1) {
            this.trigger("log", {
              level: "warn",
              message: "Malformed ID3 frame encountered. Skipping remaining metadata parsing."
            });
            break;
          }
          frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);
          frame = {
            id: frameHeader,
            data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)
          };
          frame.key = frame.id;
          if (id3.frameParsers[frame.id]) {
            id3.frameParsers[frame.id](frame);
          } else if (frame.id[0] === "T") {
            id3.frameParsers["T*"](frame);
          } else if (frame.id[0] === "W") {
            id3.frameParsers["W*"](frame);
          }
          if (frame.owner === "com.apple.streaming.transportStreamTimestamp") {
            var d = frame.data, size = (d[3] & 1) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;
            size *= 4;
            size += d[7] & 3;
            frame.timeStamp = size;
            if (tag.pts === void 0 && tag.dts === void 0) {
              tag.pts = frame.timeStamp;
              tag.dts = frame.timeStamp;
            }
            this.trigger("timestamp", frame);
          }
          tag.frames.push(frame);
          frameStart += 10;
          frameStart += frameSize;
        } while (frameStart < tagSize);
        this.trigger("data", tag);
      };
    };
    MetadataStream.prototype = new Stream$5();
    var metadataStream = MetadataStream;
    var Stream$4 = stream, CaptionStream$1 = captionStream, StreamTypes$2 = streamTypes, TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream;
    var TransportPacketStream, TransportParseStream, ElementaryStream;
    var MP2T_PACKET_LENGTH$1 = 188, SYNC_BYTE$1 = 71;
    TransportPacketStream = function() {
      var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1), bytesInBuffer = 0;
      TransportPacketStream.prototype.init.call(this);
      this.push = function(bytes) {
        var startIndex = 0, endIndex = MP2T_PACKET_LENGTH$1, everything;
        if (bytesInBuffer) {
          everything = new Uint8Array(bytes.byteLength + bytesInBuffer);
          everything.set(buffer.subarray(0, bytesInBuffer));
          everything.set(bytes, bytesInBuffer);
          bytesInBuffer = 0;
        } else {
          everything = bytes;
        }
        while (endIndex < everything.byteLength) {
          if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {
            this.trigger("data", everything.subarray(startIndex, endIndex));
            startIndex += MP2T_PACKET_LENGTH$1;
            endIndex += MP2T_PACKET_LENGTH$1;
            continue;
          }
          startIndex++;
          endIndex++;
        }
        if (startIndex < everything.byteLength) {
          buffer.set(everything.subarray(startIndex), 0);
          bytesInBuffer = everything.byteLength - startIndex;
        }
      };
      this.flush = function() {
        if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {
          this.trigger("data", buffer);
          bytesInBuffer = 0;
        }
        this.trigger("done");
      };
      this.endTimeline = function() {
        this.flush();
        this.trigger("endedtimeline");
      };
      this.reset = function() {
        bytesInBuffer = 0;
        this.trigger("reset");
      };
    };
    TransportPacketStream.prototype = new Stream$4();
    TransportParseStream = function() {
      var parsePsi, parsePat2, parsePmt2, self2;
      TransportParseStream.prototype.init.call(this);
      self2 = this;
      this.packetsWaitingForPmt = [];
      this.programMapTable = void 0;
      parsePsi = function(payload, psi) {
        var offset = 0;
        if (psi.payloadUnitStartIndicator) {
          offset += payload[offset] + 1;
        }
        if (psi.type === "pat") {
          parsePat2(payload.subarray(offset), psi);
        } else {
          parsePmt2(payload.subarray(offset), psi);
        }
      };
      parsePat2 = function(payload, pat) {
        pat.section_number = payload[7];
        pat.last_section_number = payload[8];
        self2.pmtPid = (payload[10] & 31) << 8 | payload[11];
        pat.pmtPid = self2.pmtPid;
      };
      parsePmt2 = function(payload, pmt) {
        var sectionLength, tableEnd, programInfoLength, offset;
        if (!(payload[5] & 1)) {
          return;
        }
        self2.programMapTable = {
          video: null,
          audio: null,
          "timed-metadata": {}
        };
        sectionLength = (payload[1] & 15) << 8 | payload[2];
        tableEnd = 3 + sectionLength - 4;
        programInfoLength = (payload[10] & 15) << 8 | payload[11];
        offset = 12 + programInfoLength;
        while (offset < tableEnd) {
          var streamType = payload[offset];
          var pid = (payload[offset + 1] & 31) << 8 | payload[offset + 2];
          if (streamType === StreamTypes$2.H264_STREAM_TYPE && self2.programMapTable.video === null) {
            self2.programMapTable.video = pid;
          } else if (streamType === StreamTypes$2.ADTS_STREAM_TYPE && self2.programMapTable.audio === null) {
            self2.programMapTable.audio = pid;
          } else if (streamType === StreamTypes$2.METADATA_STREAM_TYPE) {
            self2.programMapTable["timed-metadata"][pid] = streamType;
          }
          offset += ((payload[offset + 3] & 15) << 8 | payload[offset + 4]) + 5;
        }
        pmt.programMapTable = self2.programMapTable;
      };
      this.push = function(packet) {
        var result = {}, offset = 4;
        result.payloadUnitStartIndicator = !!(packet[1] & 64);
        result.pid = packet[1] & 31;
        result.pid <<= 8;
        result.pid |= packet[2];
        if ((packet[3] & 48) >>> 4 > 1) {
          offset += packet[offset] + 1;
        }
        if (result.pid === 0) {
          result.type = "pat";
          parsePsi(packet.subarray(offset), result);
          this.trigger("data", result);
        } else if (result.pid === this.pmtPid) {
          result.type = "pmt";
          parsePsi(packet.subarray(offset), result);
          this.trigger("data", result);
          while (this.packetsWaitingForPmt.length) {
            this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
          }
        } else if (this.programMapTable === void 0) {
          this.packetsWaitingForPmt.push([packet, offset, result]);
        } else {
          this.processPes_(packet, offset, result);
        }
      };
      this.processPes_ = function(packet, offset, result) {
        if (result.pid === this.programMapTable.video) {
          result.streamType = StreamTypes$2.H264_STREAM_TYPE;
        } else if (result.pid === this.programMapTable.audio) {
          result.streamType = StreamTypes$2.ADTS_STREAM_TYPE;
        } else {
          result.streamType = this.programMapTable["timed-metadata"][result.pid];
        }
        result.type = "pes";
        result.data = packet.subarray(offset);
        this.trigger("data", result);
      };
    };
    TransportParseStream.prototype = new Stream$4();
    TransportParseStream.STREAM_TYPES = {
      h264: 27,
      adts: 15
    };
    ElementaryStream = function() {
      var self2 = this, segmentHadPmt = false, video = {
        data: [],
        size: 0
      }, audio = {
        data: [],
        size: 0
      }, timedMetadata = {
        data: [],
        size: 0
      }, programMapTable, parsePes = function(payload, pes) {
        var ptsDtsFlags;
        const startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2];
        pes.data = new Uint8Array();
        if (startPrefix !== 1) {
          return;
        }
        pes.packetLength = 6 + (payload[4] << 8 | payload[5]);
        pes.dataAlignmentIndicator = (payload[6] & 4) !== 0;
        ptsDtsFlags = payload[7];
        if (ptsDtsFlags & 192) {
          pes.pts = (payload[9] & 14) << 27 | (payload[10] & 255) << 20 | (payload[11] & 254) << 12 | (payload[12] & 255) << 5 | (payload[13] & 254) >>> 3;
          pes.pts *= 4;
          pes.pts += (payload[13] & 6) >>> 1;
          pes.dts = pes.pts;
          if (ptsDtsFlags & 64) {
            pes.dts = (payload[14] & 14) << 27 | (payload[15] & 255) << 20 | (payload[16] & 254) << 12 | (payload[17] & 255) << 5 | (payload[18] & 254) >>> 3;
            pes.dts *= 4;
            pes.dts += (payload[18] & 6) >>> 1;
          }
        }
        pes.data = payload.subarray(9 + payload[8]);
      }, flushStream = function(stream2, type2, forceFlush) {
        var packetData = new Uint8Array(stream2.size), event = {
          type: type2
        }, i = 0, offset = 0, packetFlushable = false, fragment;
        if (!stream2.data.length || stream2.size < 9) {
          return;
        }
        event.trackId = stream2.data[0].pid;
        for (i = 0; i < stream2.data.length; i++) {
          fragment = stream2.data[i];
          packetData.set(fragment.data, offset);
          offset += fragment.data.byteLength;
        }
        parsePes(packetData, event);
        packetFlushable = type2 === "video" || event.packetLength <= stream2.size;
        if (forceFlush || packetFlushable) {
          stream2.size = 0;
          stream2.data.length = 0;
        }
        if (packetFlushable) {
          self2.trigger("data", event);
        }
      };
      ElementaryStream.prototype.init.call(this);
      this.push = function(data) {
        ({
          pat: function() {
          },
          pes: function() {
            var stream2, streamType;
            switch (data.streamType) {
              case StreamTypes$2.H264_STREAM_TYPE:
                stream2 = video;
                streamType = "video";
                break;
              case StreamTypes$2.ADTS_STREAM_TYPE:
                stream2 = audio;
                streamType = "audio";
                break;
              case StreamTypes$2.METADATA_STREAM_TYPE:
                stream2 = timedMetadata;
                streamType = "timed-metadata";
                break;
              default:
                return;
            }
            if (data.payloadUnitStartIndicator) {
              flushStream(stream2, streamType, true);
            }
            stream2.data.push(data);
            stream2.size += data.data.byteLength;
          },
          pmt: function() {
            var event = {
              type: "metadata",
              tracks: []
            };
            programMapTable = data.programMapTable;
            if (programMapTable.video !== null) {
              event.tracks.push({
                timelineStartInfo: {
                  baseMediaDecodeTime: 0
                },
                id: +programMapTable.video,
                codec: "avc",
                type: "video"
              });
            }
            if (programMapTable.audio !== null) {
              event.tracks.push({
                timelineStartInfo: {
                  baseMediaDecodeTime: 0
                },
                id: +programMapTable.audio,
                codec: "adts",
                type: "audio"
              });
            }
            segmentHadPmt = true;
            self2.trigger("data", event);
          }
        })[data.type]();
      };
      this.reset = function() {
        video.size = 0;
        video.data.length = 0;
        audio.size = 0;
        audio.data.length = 0;
        this.trigger("reset");
      };
      this.flushStreams_ = function() {
        flushStream(video, "video");
        flushStream(audio, "audio");
        flushStream(timedMetadata, "timed-metadata");
      };
      this.flush = function() {
        if (!segmentHadPmt && programMapTable) {
          var pmt = {
            type: "metadata",
            tracks: []
          };
          if (programMapTable.video !== null) {
            pmt.tracks.push({
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              id: +programMapTable.video,
              codec: "avc",
              type: "video"
            });
          }
          if (programMapTable.audio !== null) {
            pmt.tracks.push({
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              id: +programMapTable.audio,
              codec: "adts",
              type: "audio"
            });
          }
          self2.trigger("data", pmt);
        }
        segmentHadPmt = false;
        this.flushStreams_();
        this.trigger("done");
      };
    };
    ElementaryStream.prototype = new Stream$4();
    var m2ts$1 = {
      PAT_PID: 0,
      MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,
      TransportPacketStream,
      TransportParseStream,
      ElementaryStream,
      TimestampRolloverStream,
      CaptionStream: CaptionStream$1.CaptionStream,
      Cea608Stream: CaptionStream$1.Cea608Stream,
      Cea708Stream: CaptionStream$1.Cea708Stream,
      MetadataStream: metadataStream
    };
    for (var type in StreamTypes$2) {
      if (StreamTypes$2.hasOwnProperty(type)) {
        m2ts$1[type] = StreamTypes$2[type];
      }
    }
    var m2ts_1 = m2ts$1;
    var Stream$3 = stream;
    var ONE_SECOND_IN_TS$2 = clock$2.ONE_SECOND_IN_TS;
    var AdtsStream$1;
    var ADTS_SAMPLING_FREQUENCIES$1 = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
    AdtsStream$1 = function(handlePartialSegments) {
      var buffer, frameNum = 0;
      AdtsStream$1.prototype.init.call(this);
      this.skipWarn_ = function(start, end) {
        this.trigger("log", {
          level: "warn",
          message: `adts skiping bytes ${start} to ${end} in frame ${frameNum} outside syncword`
        });
      };
      this.push = function(packet) {
        var i = 0, frameLength, protectionSkipBytes, oldBuffer, sampleCount, adtsFrameDuration;
        if (!handlePartialSegments) {
          frameNum = 0;
        }
        if (packet.type !== "audio") {
          return;
        }
        if (buffer && buffer.length) {
          oldBuffer = buffer;
          buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);
          buffer.set(oldBuffer);
          buffer.set(packet.data, oldBuffer.byteLength);
        } else {
          buffer = packet.data;
        }
        var skip;
        while (i + 7 < buffer.length) {
          if (buffer[i] !== 255 || (buffer[i + 1] & 246) !== 240) {
            if (typeof skip !== "number") {
              skip = i;
            }
            i++;
            continue;
          }
          if (typeof skip === "number") {
            this.skipWarn_(skip, i);
            skip = null;
          }
          protectionSkipBytes = (~buffer[i + 1] & 1) * 2;
          frameLength = (buffer[i + 3] & 3) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 224) >> 5;
          sampleCount = ((buffer[i + 6] & 3) + 1) * 1024;
          adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$2 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 60) >>> 2];
          if (buffer.byteLength - i < frameLength) {
            break;
          }
          this.trigger("data", {
            pts: packet.pts + frameNum * adtsFrameDuration,
            dts: packet.dts + frameNum * adtsFrameDuration,
            sampleCount,
            audioobjecttype: (buffer[i + 2] >>> 6 & 3) + 1,
            channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 192) >>> 6,
            samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 60) >>> 2],
            samplingfrequencyindex: (buffer[i + 2] & 60) >>> 2,
            // assume ISO/IEC 14496-12 AudioSampleEntry default of 16
            samplesize: 16,
            // data is the frame without it's header
            data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)
          });
          frameNum++;
          i += frameLength;
        }
        if (typeof skip === "number") {
          this.skipWarn_(skip, i);
          skip = null;
        }
        buffer = buffer.subarray(i);
      };
      this.flush = function() {
        frameNum = 0;
        this.trigger("done");
      };
      this.reset = function() {
        buffer = void 0;
        this.trigger("reset");
      };
      this.endTimeline = function() {
        buffer = void 0;
        this.trigger("endedtimeline");
      };
    };
    AdtsStream$1.prototype = new Stream$3();
    var adts = AdtsStream$1;
    var ExpGolomb$1;
    ExpGolomb$1 = function(workingData) {
      var workingBytesAvailable = workingData.byteLength, workingWord = 0, workingBitsAvailable = 0;
      this.length = function() {
        return 8 * workingBytesAvailable;
      };
      this.bitsAvailable = function() {
        return 8 * workingBytesAvailable + workingBitsAvailable;
      };
      this.loadWord = function() {
        var position2 = workingData.byteLength - workingBytesAvailable, workingBytes = new Uint8Array(4), availableBytes = Math.min(4, workingBytesAvailable);
        if (availableBytes === 0) {
          throw new Error("no bytes available");
        }
        workingBytes.set(workingData.subarray(position2, position2 + availableBytes));
        workingWord = new DataView(workingBytes.buffer).getUint32(0);
        workingBitsAvailable = availableBytes * 8;
        workingBytesAvailable -= availableBytes;
      };
      this.skipBits = function(count) {
        var skipBytes;
        if (workingBitsAvailable > count) {
          workingWord <<= count;
          workingBitsAvailable -= count;
        } else {
          count -= workingBitsAvailable;
          skipBytes = Math.floor(count / 8);
          count -= skipBytes * 8;
          workingBytesAvailable -= skipBytes;
          this.loadWord();
          workingWord <<= count;
          workingBitsAvailable -= count;
        }
      };
      this.readBits = function(size) {
        var bits = Math.min(workingBitsAvailable, size), valu = workingWord >>> 32 - bits;
        workingBitsAvailable -= bits;
        if (workingBitsAvailable > 0) {
          workingWord <<= bits;
        } else if (workingBytesAvailable > 0) {
          this.loadWord();
        }
        bits = size - bits;
        if (bits > 0) {
          return valu << bits | this.readBits(bits);
        }
        return valu;
      };
      this.skipLeadingZeros = function() {
        var leadingZeroCount;
        for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {
          if ((workingWord & 2147483648 >>> leadingZeroCount) !== 0) {
            workingWord <<= leadingZeroCount;
            workingBitsAvailable -= leadingZeroCount;
            return leadingZeroCount;
          }
        }
        this.loadWord();
        return leadingZeroCount + this.skipLeadingZeros();
      };
      this.skipUnsignedExpGolomb = function() {
        this.skipBits(1 + this.skipLeadingZeros());
      };
      this.skipExpGolomb = function() {
        this.skipBits(1 + this.skipLeadingZeros());
      };
      this.readUnsignedExpGolomb = function() {
        var clz = this.skipLeadingZeros();
        return this.readBits(clz + 1) - 1;
      };
      this.readExpGolomb = function() {
        var valu = this.readUnsignedExpGolomb();
        if (1 & valu) {
          return 1 + valu >>> 1;
        }
        return -1 * (valu >>> 1);
      };
      this.readBoolean = function() {
        return this.readBits(1) === 1;
      };
      this.readUnsignedByte = function() {
        return this.readBits(8);
      };
      this.loadWord();
    };
    var expGolomb = ExpGolomb$1;
    var Stream$2 = stream;
    var ExpGolomb = expGolomb;
    var H264Stream$1, NalByteStream;
    var PROFILES_WITH_OPTIONAL_SPS_DATA;
    NalByteStream = function() {
      var syncPoint = 0, i, buffer;
      NalByteStream.prototype.init.call(this);
      this.push = function(data) {
        var swapBuffer;
        if (!buffer) {
          buffer = data.data;
        } else {
          swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);
          swapBuffer.set(buffer);
          swapBuffer.set(data.data, buffer.byteLength);
          buffer = swapBuffer;
        }
        var len = buffer.byteLength;
        for (; syncPoint < len - 3; syncPoint++) {
          if (buffer[syncPoint + 2] === 1) {
            i = syncPoint + 5;
            break;
          }
        }
        while (i < len) {
          switch (buffer[i]) {
            case 0:
              if (buffer[i - 1] !== 0) {
                i += 2;
                break;
              } else if (buffer[i - 2] !== 0) {
                i++;
                break;
              }
              if (syncPoint + 3 !== i - 2) {
                this.trigger("data", buffer.subarray(syncPoint + 3, i - 2));
              }
              do {
                i++;
              } while (buffer[i] !== 1 && i < len);
              syncPoint = i - 2;
              i += 3;
              break;
            case 1:
              if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {
                i += 3;
                break;
              }
              this.trigger("data", buffer.subarray(syncPoint + 3, i - 2));
              syncPoint = i - 2;
              i += 3;
              break;
            default:
              i += 3;
              break;
          }
        }
        buffer = buffer.subarray(syncPoint);
        i -= syncPoint;
        syncPoint = 0;
      };
      this.reset = function() {
        buffer = null;
        syncPoint = 0;
        this.trigger("reset");
      };
      this.flush = function() {
        if (buffer && buffer.byteLength > 3) {
          this.trigger("data", buffer.subarray(syncPoint + 3));
        }
        buffer = null;
        syncPoint = 0;
        this.trigger("done");
      };
      this.endTimeline = function() {
        this.flush();
        this.trigger("endedtimeline");
      };
    };
    NalByteStream.prototype = new Stream$2();
    PROFILES_WITH_OPTIONAL_SPS_DATA = {
      100: true,
      110: true,
      122: true,
      244: true,
      44: true,
      83: true,
      86: true,
      118: true,
      128: true,
      // TODO: the three profiles below don't
      // appear to have sps data in the specificiation anymore?
      138: true,
      139: true,
      134: true
    };
    H264Stream$1 = function() {
      var nalByteStream = new NalByteStream(), self2, trackId, currentPts, currentDts, discardEmulationPreventionBytes3, readSequenceParameterSet, skipScalingList;
      H264Stream$1.prototype.init.call(this);
      self2 = this;
      this.push = function(packet) {
        if (packet.type !== "video") {
          return;
        }
        trackId = packet.trackId;
        currentPts = packet.pts;
        currentDts = packet.dts;
        nalByteStream.push(packet);
      };
      nalByteStream.on("data", function(data) {
        var event = {
          trackId,
          pts: currentPts,
          dts: currentDts,
          data,
          nalUnitTypeCode: data[0] & 31
        };
        switch (event.nalUnitTypeCode) {
          case 5:
            event.nalUnitType = "slice_layer_without_partitioning_rbsp_idr";
            break;
          case 6:
            event.nalUnitType = "sei_rbsp";
            event.escapedRBSP = discardEmulationPreventionBytes3(data.subarray(1));
            break;
          case 7:
            event.nalUnitType = "seq_parameter_set_rbsp";
            event.escapedRBSP = discardEmulationPreventionBytes3(data.subarray(1));
            event.config = readSequenceParameterSet(event.escapedRBSP);
            break;
          case 8:
            event.nalUnitType = "pic_parameter_set_rbsp";
            break;
          case 9:
            event.nalUnitType = "access_unit_delimiter_rbsp";
            break;
        }
        self2.trigger("data", event);
      });
      nalByteStream.on("done", function() {
        self2.trigger("done");
      });
      nalByteStream.on("partialdone", function() {
        self2.trigger("partialdone");
      });
      nalByteStream.on("reset", function() {
        self2.trigger("reset");
      });
      nalByteStream.on("endedtimeline", function() {
        self2.trigger("endedtimeline");
      });
      this.flush = function() {
        nalByteStream.flush();
      };
      this.partialFlush = function() {
        nalByteStream.partialFlush();
      };
      this.reset = function() {
        nalByteStream.reset();
      };
      this.endTimeline = function() {
        nalByteStream.endTimeline();
      };
      skipScalingList = function(count, expGolombDecoder) {
        var lastScale = 8, nextScale = 8, j, deltaScale;
        for (j = 0; j < count; j++) {
          if (nextScale !== 0) {
            deltaScale = expGolombDecoder.readExpGolomb();
            nextScale = (lastScale + deltaScale + 256) % 256;
          }
          lastScale = nextScale === 0 ? lastScale : nextScale;
        }
      };
      discardEmulationPreventionBytes3 = function(data) {
        var length = data.byteLength, emulationPreventionBytesPositions = [], i = 1, newLength, newData;
        while (i < length - 2) {
          if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
            emulationPreventionBytesPositions.push(i + 2);
            i += 2;
          } else {
            i++;
          }
        }
        if (emulationPreventionBytesPositions.length === 0) {
          return data;
        }
        newLength = length - emulationPreventionBytesPositions.length;
        newData = new Uint8Array(newLength);
        var sourceIndex = 0;
        for (i = 0; i < newLength; sourceIndex++, i++) {
          if (sourceIndex === emulationPreventionBytesPositions[0]) {
            sourceIndex++;
            emulationPreventionBytesPositions.shift();
          }
          newData[i] = data[sourceIndex];
        }
        return newData;
      };
      readSequenceParameterSet = function(data) {
        var frameCropLeftOffset = 0, frameCropRightOffset = 0, frameCropTopOffset = 0, frameCropBottomOffset = 0, expGolombDecoder, profileIdc, levelIdc, profileCompatibility, chromaFormatIdc, picOrderCntType, numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1, picHeightInMapUnitsMinus1, frameMbsOnlyFlag, scalingListCount, sarRatio = [1, 1], aspectRatioIdc, i;
        expGolombDecoder = new ExpGolomb(data);
        profileIdc = expGolombDecoder.readUnsignedByte();
        profileCompatibility = expGolombDecoder.readUnsignedByte();
        levelIdc = expGolombDecoder.readUnsignedByte();
        expGolombDecoder.skipUnsignedExpGolomb();
        if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {
          chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();
          if (chromaFormatIdc === 3) {
            expGolombDecoder.skipBits(1);
          }
          expGolombDecoder.skipUnsignedExpGolomb();
          expGolombDecoder.skipUnsignedExpGolomb();
          expGolombDecoder.skipBits(1);
          if (expGolombDecoder.readBoolean()) {
            scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
            for (i = 0; i < scalingListCount; i++) {
              if (expGolombDecoder.readBoolean()) {
                if (i < 6) {
                  skipScalingList(16, expGolombDecoder);
                } else {
                  skipScalingList(64, expGolombDecoder);
                }
              }
            }
          }
        }
        expGolombDecoder.skipUnsignedExpGolomb();
        picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();
        if (picOrderCntType === 0) {
          expGolombDecoder.readUnsignedExpGolomb();
        } else if (picOrderCntType === 1) {
          expGolombDecoder.skipBits(1);
          expGolombDecoder.skipExpGolomb();
          expGolombDecoder.skipExpGolomb();
          numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();
          for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
            expGolombDecoder.skipExpGolomb();
          }
        }
        expGolombDecoder.skipUnsignedExpGolomb();
        expGolombDecoder.skipBits(1);
        picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
        picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
        frameMbsOnlyFlag = expGolombDecoder.readBits(1);
        if (frameMbsOnlyFlag === 0) {
          expGolombDecoder.skipBits(1);
        }
        expGolombDecoder.skipBits(1);
        if (expGolombDecoder.readBoolean()) {
          frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();
          frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();
          frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();
          frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();
        }
        if (expGolombDecoder.readBoolean()) {
          if (expGolombDecoder.readBoolean()) {
            aspectRatioIdc = expGolombDecoder.readUnsignedByte();
            switch (aspectRatioIdc) {
              case 1:
                sarRatio = [1, 1];
                break;
              case 2:
                sarRatio = [12, 11];
                break;
              case 3:
                sarRatio = [10, 11];
                break;
              case 4:
                sarRatio = [16, 11];
                break;
              case 5:
                sarRatio = [40, 33];
                break;
              case 6:
                sarRatio = [24, 11];
                break;
              case 7:
                sarRatio = [20, 11];
                break;
              case 8:
                sarRatio = [32, 11];
                break;
              case 9:
                sarRatio = [80, 33];
                break;
              case 10:
                sarRatio = [18, 11];
                break;
              case 11:
                sarRatio = [15, 11];
                break;
              case 12:
                sarRatio = [64, 33];
                break;
              case 13:
                sarRatio = [160, 99];
                break;
              case 14:
                sarRatio = [4, 3];
                break;
              case 15:
                sarRatio = [3, 2];
                break;
              case 16:
                sarRatio = [2, 1];
                break;
              case 255: {
                sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];
                break;
              }
            }
            if (sarRatio) {
              sarRatio[0] / sarRatio[1];
            }
          }
        }
        return {
          profileIdc,
          levelIdc,
          profileCompatibility,
          width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,
          height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,
          // sar is sample aspect ratio
          sarRatio
        };
      };
    };
    H264Stream$1.prototype = new Stream$2();
    var h264 = {
      H264Stream: H264Stream$1,
      NalByteStream
    };
    var ADTS_SAMPLING_FREQUENCIES = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
    var parseId3TagSize = function(header, byteIndex) {
      var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9], flags = header[byteIndex + 5], footerPresent = (flags & 16) >> 4;
      returnSize = returnSize >= 0 ? returnSize : 0;
      if (footerPresent) {
        return returnSize + 20;
      }
      return returnSize + 10;
    };
    var getId3Offset2 = function(data, offset) {
      if (data.length - offset < 10 || data[offset] !== "I".charCodeAt(0) || data[offset + 1] !== "D".charCodeAt(0) || data[offset + 2] !== "3".charCodeAt(0)) {
        return offset;
      }
      offset += parseId3TagSize(data, offset);
      return getId3Offset2(data, offset);
    };
    var isLikelyAacData$1 = function(data) {
      var offset = getId3Offset2(data, 0);
      return data.length >= offset + 2 && (data[offset] & 255) === 255 && (data[offset + 1] & 240) === 240 && // verify that the 2 layer bits are 0, aka this
      // is not mp3 data but aac data.
      (data[offset + 1] & 22) === 16;
    };
    var parseSyncSafeInteger = function(data) {
      return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
    };
    var percentEncode = function(bytes, start, end) {
      var i, result = "";
      for (i = start; i < end; i++) {
        result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
      }
      return result;
    };
    var parseIso88591 = function(bytes, start, end) {
      return unescape(percentEncode(bytes, start, end));
    };
    var parseAdtsSize = function(header, byteIndex) {
      var lowThree = (header[byteIndex + 5] & 224) >> 5, middle = header[byteIndex + 4] << 3, highTwo = header[byteIndex + 3] & 3 << 11;
      return highTwo | middle | lowThree;
    };
    var parseType$4 = function(header, byteIndex) {
      if (header[byteIndex] === "I".charCodeAt(0) && header[byteIndex + 1] === "D".charCodeAt(0) && header[byteIndex + 2] === "3".charCodeAt(0)) {
        return "timed-metadata";
      } else if (header[byteIndex] & true && (header[byteIndex + 1] & 240) === 240) {
        return "audio";
      }
      return null;
    };
    var parseSampleRate = function(packet) {
      var i = 0;
      while (i + 5 < packet.length) {
        if (packet[i] !== 255 || (packet[i + 1] & 246) !== 240) {
          i++;
          continue;
        }
        return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 60) >>> 2];
      }
      return null;
    };
    var parseAacTimestamp = function(packet) {
      var frameStart, frameSize, frame, frameHeader;
      frameStart = 10;
      if (packet[5] & 64) {
        frameStart += 4;
        frameStart += parseSyncSafeInteger(packet.subarray(10, 14));
      }
      do {
        frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));
        if (frameSize < 1) {
          return null;
        }
        frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);
        if (frameHeader === "PRIV") {
          frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);
          for (var i = 0; i < frame.byteLength; i++) {
            if (frame[i] === 0) {
              var owner = parseIso88591(frame, 0, i);
              if (owner === "com.apple.streaming.transportStreamTimestamp") {
                var d = frame.subarray(i + 1);
                var size = (d[3] & 1) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;
                size *= 4;
                size += d[7] & 3;
                return size;
              }
              break;
            }
          }
        }
        frameStart += 10;
        frameStart += frameSize;
      } while (frameStart < packet.byteLength);
      return null;
    };
    var utils2 = {
      isLikelyAacData: isLikelyAacData$1,
      parseId3TagSize,
      parseAdtsSize,
      parseType: parseType$4,
      parseSampleRate,
      parseAacTimestamp
    };
    var Stream$1 = stream;
    var aacUtils = utils2;
    var AacStream$1;
    AacStream$1 = function() {
      var everything = new Uint8Array(), timeStamp = 0;
      AacStream$1.prototype.init.call(this);
      this.setTimestamp = function(timestamp) {
        timeStamp = timestamp;
      };
      this.push = function(bytes) {
        var frameSize = 0, byteIndex = 0, bytesLeft, chunk, packet, tempLength;
        if (everything.length) {
          tempLength = everything.length;
          everything = new Uint8Array(bytes.byteLength + tempLength);
          everything.set(everything.subarray(0, tempLength));
          everything.set(bytes, tempLength);
        } else {
          everything = bytes;
        }
        while (everything.length - byteIndex >= 3) {
          if (everything[byteIndex] === "I".charCodeAt(0) && everything[byteIndex + 1] === "D".charCodeAt(0) && everything[byteIndex + 2] === "3".charCodeAt(0)) {
            if (everything.length - byteIndex < 10) {
              break;
            }
            frameSize = aacUtils.parseId3TagSize(everything, byteIndex);
            if (byteIndex + frameSize > everything.length) {
              break;
            }
            chunk = {
              type: "timed-metadata",
              data: everything.subarray(byteIndex, byteIndex + frameSize)
            };
            this.trigger("data", chunk);
            byteIndex += frameSize;
            continue;
          } else if ((everything[byteIndex] & 255) === 255 && (everything[byteIndex + 1] & 240) === 240) {
            if (everything.length - byteIndex < 7) {
              break;
            }
            frameSize = aacUtils.parseAdtsSize(everything, byteIndex);
            if (byteIndex + frameSize > everything.length) {
              break;
            }
            packet = {
              type: "audio",
              data: everything.subarray(byteIndex, byteIndex + frameSize),
              pts: timeStamp,
              dts: timeStamp
            };
            this.trigger("data", packet);
            byteIndex += frameSize;
            continue;
          }
          byteIndex++;
        }
        bytesLeft = everything.length - byteIndex;
        if (bytesLeft > 0) {
          everything = everything.subarray(byteIndex);
        } else {
          everything = new Uint8Array();
        }
      };
      this.reset = function() {
        everything = new Uint8Array();
        this.trigger("reset");
      };
      this.endTimeline = function() {
        everything = new Uint8Array();
        this.trigger("endedtimeline");
      };
    };
    AacStream$1.prototype = new Stream$1();
    var aac = AacStream$1;
    var AUDIO_PROPERTIES$1 = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"];
    var audioProperties = AUDIO_PROPERTIES$1;
    var VIDEO_PROPERTIES$1 = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio"];
    var videoProperties = VIDEO_PROPERTIES$1;
    var Stream2 = stream;
    var mp4 = mp4Generator;
    var frameUtils = frameUtils$1;
    var audioFrameUtils = audioFrameUtils$1;
    var trackDecodeInfo = trackDecodeInfo$1;
    var m2ts = m2ts_1;
    var clock2 = clock$2;
    var AdtsStream = adts;
    var H264Stream = h264.H264Stream;
    var AacStream = aac;
    var isLikelyAacData = utils2.isLikelyAacData;
    var ONE_SECOND_IN_TS$1 = clock$2.ONE_SECOND_IN_TS;
    var AUDIO_PROPERTIES = audioProperties;
    var VIDEO_PROPERTIES = videoProperties;
    var VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;
    var retriggerForStream = function(key, event) {
      event.stream = key;
      this.trigger("log", event);
    };
    var addPipelineLogRetriggers = function(transmuxer2, pipeline) {
      var keys2 = Object.keys(pipeline);
      for (var i = 0; i < keys2.length; i++) {
        var key = keys2[i];
        if (key === "headOfPipeline" || !pipeline[key].on) {
          continue;
        }
        pipeline[key].on("log", retriggerForStream.bind(transmuxer2, key));
      }
    };
    var arrayEquals = function(a, b) {
      var i;
      if (a.length !== b.length) {
        return false;
      }
      for (i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    };
    var generateSegmentTimingInfo = function(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {
      var ptsOffsetFromDts = startPts - startDts, decodeDuration = endDts - startDts, presentationDuration = endPts - startPts;
      return {
        start: {
          dts: baseMediaDecodeTime,
          pts: baseMediaDecodeTime + ptsOffsetFromDts
        },
        end: {
          dts: baseMediaDecodeTime + decodeDuration,
          pts: baseMediaDecodeTime + presentationDuration
        },
        prependedContentDuration,
        baseMediaDecodeTime
      };
    };
    AudioSegmentStream = function(track, options) {
      var adtsFrames = [], sequenceNumber, earliestAllowedDts = 0, audioAppendStartTs = 0, videoBaseMediaDecodeTime = Infinity;
      options = options || {};
      sequenceNumber = options.firstSequenceNumber || 0;
      AudioSegmentStream.prototype.init.call(this);
      this.push = function(data) {
        trackDecodeInfo.collectDtsInfo(track, data);
        if (track) {
          AUDIO_PROPERTIES.forEach(function(prop) {
            track[prop] = data[prop];
          });
        }
        adtsFrames.push(data);
      };
      this.setEarliestDts = function(earliestDts) {
        earliestAllowedDts = earliestDts;
      };
      this.setVideoBaseMediaDecodeTime = function(baseMediaDecodeTime) {
        videoBaseMediaDecodeTime = baseMediaDecodeTime;
      };
      this.setAudioAppendStart = function(timestamp) {
        audioAppendStartTs = timestamp;
      };
      this.flush = function() {
        var frames, moof2, mdat2, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed;
        if (adtsFrames.length === 0) {
          this.trigger("done", "AudioSegmentStream");
          return;
        }
        frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);
        track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
        videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime);
        track.samples = audioFrameUtils.generateSampleTable(frames);
        mdat2 = mp4.mdat(audioFrameUtils.concatenateFrameData(frames));
        adtsFrames = [];
        moof2 = mp4.moof(sequenceNumber, [track]);
        boxes = new Uint8Array(moof2.byteLength + mdat2.byteLength);
        sequenceNumber++;
        boxes.set(moof2);
        boxes.set(mdat2, moof2.byteLength);
        trackDecodeInfo.clearDtsInfo(track);
        frameDuration = Math.ceil(ONE_SECOND_IN_TS$1 * 1024 / track.samplerate);
        if (frames.length) {
          segmentDuration = frames.length * frameDuration;
          this.trigger("segmentTimingInfo", generateSegmentTimingInfo(
            // The audio track's baseMediaDecodeTime is in audio clock cycles, but the
            // frame info is in video clock cycles. Convert to match expectation of
            // listeners (that all timestamps will be based on video clock cycles).
            clock2.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate),
            // frame times are already in video clock, as is segment duration
            frames[0].dts,
            frames[0].pts,
            frames[0].dts + segmentDuration,
            frames[0].pts + segmentDuration,
            videoClockCyclesOfSilencePrefixed || 0
          ));
          this.trigger("timingInfo", {
            start: frames[0].pts,
            end: frames[0].pts + segmentDuration
          });
        }
        this.trigger("data", {
          track,
          boxes
        });
        this.trigger("done", "AudioSegmentStream");
      };
      this.reset = function() {
        trackDecodeInfo.clearDtsInfo(track);
        adtsFrames = [];
        this.trigger("reset");
      };
    };
    AudioSegmentStream.prototype = new Stream2();
    VideoSegmentStream = function(track, options) {
      var sequenceNumber, nalUnits = [], gopsToAlignWith = [], config, pps;
      options = options || {};
      sequenceNumber = options.firstSequenceNumber || 0;
      VideoSegmentStream.prototype.init.call(this);
      delete track.minPTS;
      this.gopCache_ = [];
      this.push = function(nalUnit) {
        trackDecodeInfo.collectDtsInfo(track, nalUnit);
        if (nalUnit.nalUnitType === "seq_parameter_set_rbsp" && !config) {
          config = nalUnit.config;
          track.sps = [nalUnit.data];
          VIDEO_PROPERTIES.forEach(function(prop) {
            track[prop] = config[prop];
          }, this);
        }
        if (nalUnit.nalUnitType === "pic_parameter_set_rbsp" && !pps) {
          pps = nalUnit.data;
          track.pps = [nalUnit.data];
        }
        nalUnits.push(nalUnit);
      };
      this.flush = function() {
        var frames, gopForFusion, gops, moof2, mdat2, boxes, prependedContentDuration = 0, firstGop, lastGop;
        while (nalUnits.length) {
          if (nalUnits[0].nalUnitType === "access_unit_delimiter_rbsp") {
            break;
          }
          nalUnits.shift();
        }
        if (nalUnits.length === 0) {
          this.resetStream_();
          this.trigger("done", "VideoSegmentStream");
          return;
        }
        frames = frameUtils.groupNalsIntoFrames(nalUnits);
        gops = frameUtils.groupFramesIntoGops(frames);
        if (!gops[0][0].keyFrame) {
          gopForFusion = this.getGopForFusion_(nalUnits[0], track);
          if (gopForFusion) {
            prependedContentDuration = gopForFusion.duration;
            gops.unshift(gopForFusion);
            gops.byteLength += gopForFusion.byteLength;
            gops.nalCount += gopForFusion.nalCount;
            gops.pts = gopForFusion.pts;
            gops.dts = gopForFusion.dts;
            gops.duration += gopForFusion.duration;
          } else {
            gops = frameUtils.extendFirstKeyFrame(gops);
          }
        }
        if (gopsToAlignWith.length) {
          var alignedGops;
          if (options.alignGopsAtEnd) {
            alignedGops = this.alignGopsAtEnd_(gops);
          } else {
            alignedGops = this.alignGopsAtStart_(gops);
          }
          if (!alignedGops) {
            this.gopCache_.unshift({
              gop: gops.pop(),
              pps: track.pps,
              sps: track.sps
            });
            this.gopCache_.length = Math.min(6, this.gopCache_.length);
            nalUnits = [];
            this.resetStream_();
            this.trigger("done", "VideoSegmentStream");
            return;
          }
          trackDecodeInfo.clearDtsInfo(track);
          gops = alignedGops;
        }
        trackDecodeInfo.collectDtsInfo(track, gops);
        track.samples = frameUtils.generateSampleTable(gops);
        mdat2 = mp4.mdat(frameUtils.concatenateNalData(gops));
        track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
        this.trigger("processedGopsInfo", gops.map(function(gop) {
          return {
            pts: gop.pts,
            dts: gop.dts,
            byteLength: gop.byteLength
          };
        }));
        firstGop = gops[0];
        lastGop = gops[gops.length - 1];
        this.trigger("segmentTimingInfo", generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));
        this.trigger("timingInfo", {
          start: gops[0].pts,
          end: gops[gops.length - 1].pts + gops[gops.length - 1].duration
        });
        this.gopCache_.unshift({
          gop: gops.pop(),
          pps: track.pps,
          sps: track.sps
        });
        this.gopCache_.length = Math.min(6, this.gopCache_.length);
        nalUnits = [];
        this.trigger("baseMediaDecodeTime", track.baseMediaDecodeTime);
        this.trigger("timelineStartInfo", track.timelineStartInfo);
        moof2 = mp4.moof(sequenceNumber, [track]);
        boxes = new Uint8Array(moof2.byteLength + mdat2.byteLength);
        sequenceNumber++;
        boxes.set(moof2);
        boxes.set(mdat2, moof2.byteLength);
        this.trigger("data", {
          track,
          boxes
        });
        this.resetStream_();
        this.trigger("done", "VideoSegmentStream");
      };
      this.reset = function() {
        this.resetStream_();
        nalUnits = [];
        this.gopCache_.length = 0;
        gopsToAlignWith.length = 0;
        this.trigger("reset");
      };
      this.resetStream_ = function() {
        trackDecodeInfo.clearDtsInfo(track);
        config = void 0;
        pps = void 0;
      };
      this.getGopForFusion_ = function(nalUnit) {
        var halfSecond = 45e3, allowableOverlap = 1e4, nearestDistance = Infinity, dtsDistance, nearestGopObj, currentGop, currentGopObj, i;
        for (i = 0; i < this.gopCache_.length; i++) {
          currentGopObj = this.gopCache_[i];
          currentGop = currentGopObj.gop;
          if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {
            continue;
          }
          if (currentGop.dts < track.timelineStartInfo.dts) {
            continue;
          }
          dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration;
          if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {
            if (!nearestGopObj || nearestDistance > dtsDistance) {
              nearestGopObj = currentGopObj;
              nearestDistance = dtsDistance;
            }
          }
        }
        if (nearestGopObj) {
          return nearestGopObj.gop;
        }
        return null;
      };
      this.alignGopsAtStart_ = function(gops) {
        var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration2, alignedGops;
        byteLength = gops.byteLength;
        nalCount = gops.nalCount;
        duration2 = gops.duration;
        alignIndex = gopIndex = 0;
        while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {
          align = gopsToAlignWith[alignIndex];
          gop = gops[gopIndex];
          if (align.pts === gop.pts) {
            break;
          }
          if (gop.pts > align.pts) {
            alignIndex++;
            continue;
          }
          gopIndex++;
          byteLength -= gop.byteLength;
          nalCount -= gop.nalCount;
          duration2 -= gop.duration;
        }
        if (gopIndex === 0) {
          return gops;
        }
        if (gopIndex === gops.length) {
          return null;
        }
        alignedGops = gops.slice(gopIndex);
        alignedGops.byteLength = byteLength;
        alignedGops.duration = duration2;
        alignedGops.nalCount = nalCount;
        alignedGops.pts = alignedGops[0].pts;
        alignedGops.dts = alignedGops[0].dts;
        return alignedGops;
      };
      this.alignGopsAtEnd_ = function(gops) {
        var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;
        alignIndex = gopsToAlignWith.length - 1;
        gopIndex = gops.length - 1;
        alignEndIndex = null;
        matchFound = false;
        while (alignIndex >= 0 && gopIndex >= 0) {
          align = gopsToAlignWith[alignIndex];
          gop = gops[gopIndex];
          if (align.pts === gop.pts) {
            matchFound = true;
            break;
          }
          if (align.pts > gop.pts) {
            alignIndex--;
            continue;
          }
          if (alignIndex === gopsToAlignWith.length - 1) {
            alignEndIndex = gopIndex;
          }
          gopIndex--;
        }
        if (!matchFound && alignEndIndex === null) {
          return null;
        }
        var trimIndex;
        if (matchFound) {
          trimIndex = gopIndex;
        } else {
          trimIndex = alignEndIndex;
        }
        if (trimIndex === 0) {
          return gops;
        }
        var alignedGops = gops.slice(trimIndex);
        var metadata = alignedGops.reduce(function(total, gop2) {
          total.byteLength += gop2.byteLength;
          total.duration += gop2.duration;
          total.nalCount += gop2.nalCount;
          return total;
        }, {
          byteLength: 0,
          duration: 0,
          nalCount: 0
        });
        alignedGops.byteLength = metadata.byteLength;
        alignedGops.duration = metadata.duration;
        alignedGops.nalCount = metadata.nalCount;
        alignedGops.pts = alignedGops[0].pts;
        alignedGops.dts = alignedGops[0].dts;
        return alignedGops;
      };
      this.alignGopsWith = function(newGopsToAlignWith) {
        gopsToAlignWith = newGopsToAlignWith;
      };
    };
    VideoSegmentStream.prototype = new Stream2();
    CoalesceStream = function(options, metadataStream2) {
      this.numberOfTracks = 0;
      this.metadataStream = metadataStream2;
      options = options || {};
      if (typeof options.remux !== "undefined") {
        this.remuxTracks = !!options.remux;
      } else {
        this.remuxTracks = true;
      }
      if (typeof options.keepOriginalTimestamps === "boolean") {
        this.keepOriginalTimestamps = options.keepOriginalTimestamps;
      } else {
        this.keepOriginalTimestamps = false;
      }
      this.pendingTracks = [];
      this.videoTrack = null;
      this.pendingBoxes = [];
      this.pendingCaptions = [];
      this.pendingMetadata = [];
      this.pendingBytes = 0;
      this.emittedTracks = 0;
      CoalesceStream.prototype.init.call(this);
      this.push = function(output) {
        if (output.content || output.text) {
          return this.pendingCaptions.push(output);
        }
        if (output.frames) {
          return this.pendingMetadata.push(output);
        }
        this.pendingTracks.push(output.track);
        this.pendingBytes += output.boxes.byteLength;
        if (output.track.type === "video") {
          this.videoTrack = output.track;
          this.pendingBoxes.push(output.boxes);
        }
        if (output.track.type === "audio") {
          this.audioTrack = output.track;
          this.pendingBoxes.unshift(output.boxes);
        }
      };
    };
    CoalesceStream.prototype = new Stream2();
    CoalesceStream.prototype.flush = function(flushSource) {
      var offset = 0, event = {
        captions: [],
        captionStreams: {},
        metadata: [],
        info: {}
      }, caption, id32, initSegment, timelineStartPts = 0, i;
      if (this.pendingTracks.length < this.numberOfTracks) {
        if (flushSource !== "VideoSegmentStream" && flushSource !== "AudioSegmentStream") {
          return;
        } else if (this.remuxTracks) {
          return;
        } else if (this.pendingTracks.length === 0) {
          this.emittedTracks++;
          if (this.emittedTracks >= this.numberOfTracks) {
            this.trigger("done");
            this.emittedTracks = 0;
          }
          return;
        }
      }
      if (this.videoTrack) {
        timelineStartPts = this.videoTrack.timelineStartInfo.pts;
        VIDEO_PROPERTIES.forEach(function(prop) {
          event.info[prop] = this.videoTrack[prop];
        }, this);
      } else if (this.audioTrack) {
        timelineStartPts = this.audioTrack.timelineStartInfo.pts;
        AUDIO_PROPERTIES.forEach(function(prop) {
          event.info[prop] = this.audioTrack[prop];
        }, this);
      }
      if (this.videoTrack || this.audioTrack) {
        if (this.pendingTracks.length === 1) {
          event.type = this.pendingTracks[0].type;
        } else {
          event.type = "combined";
        }
        this.emittedTracks += this.pendingTracks.length;
        initSegment = mp4.initSegment(this.pendingTracks);
        event.initSegment = new Uint8Array(initSegment.byteLength);
        event.initSegment.set(initSegment);
        event.data = new Uint8Array(this.pendingBytes);
        for (i = 0; i < this.pendingBoxes.length; i++) {
          event.data.set(this.pendingBoxes[i], offset);
          offset += this.pendingBoxes[i].byteLength;
        }
        for (i = 0; i < this.pendingCaptions.length; i++) {
          caption = this.pendingCaptions[i];
          caption.startTime = clock2.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);
          caption.endTime = clock2.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);
          event.captionStreams[caption.stream] = true;
          event.captions.push(caption);
        }
        for (i = 0; i < this.pendingMetadata.length; i++) {
          id32 = this.pendingMetadata[i];
          id32.cueTime = clock2.metadataTsToSeconds(id32.pts, timelineStartPts, this.keepOriginalTimestamps);
          event.metadata.push(id32);
        }
        event.metadata.dispatchType = this.metadataStream.dispatchType;
        this.pendingTracks.length = 0;
        this.videoTrack = null;
        this.pendingBoxes.length = 0;
        this.pendingCaptions.length = 0;
        this.pendingBytes = 0;
        this.pendingMetadata.length = 0;
        this.trigger("data", event);
        for (i = 0; i < event.captions.length; i++) {
          caption = event.captions[i];
          this.trigger("caption", caption);
        }
        for (i = 0; i < event.metadata.length; i++) {
          id32 = event.metadata[i];
          this.trigger("id3Frame", id32);
        }
      }
      if (this.emittedTracks >= this.numberOfTracks) {
        this.trigger("done");
        this.emittedTracks = 0;
      }
    };
    CoalesceStream.prototype.setRemux = function(val) {
      this.remuxTracks = val;
    };
    Transmuxer = function(options) {
      var self2 = this, hasFlushed = true, videoTrack, audioTrack;
      Transmuxer.prototype.init.call(this);
      options = options || {};
      this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;
      this.transmuxPipeline_ = {};
      this.setupAacPipeline = function() {
        var pipeline = {};
        this.transmuxPipeline_ = pipeline;
        pipeline.type = "aac";
        pipeline.metadataStream = new m2ts.MetadataStream();
        pipeline.aacStream = new AacStream();
        pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream("audio");
        pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream("timed-metadata");
        pipeline.adtsStream = new AdtsStream();
        pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);
        pipeline.headOfPipeline = pipeline.aacStream;
        pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);
        pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
        pipeline.metadataStream.on("timestamp", function(frame) {
          pipeline.aacStream.setTimestamp(frame.timeStamp);
        });
        pipeline.aacStream.on("data", function(data) {
          if (data.type !== "timed-metadata" && data.type !== "audio" || pipeline.audioSegmentStream) {
            return;
          }
          audioTrack = audioTrack || {
            timelineStartInfo: {
              baseMediaDecodeTime: self2.baseMediaDecodeTime
            },
            codec: "adts",
            type: "audio"
          };
          pipeline.coalesceStream.numberOfTracks++;
          pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);
          pipeline.audioSegmentStream.on("log", self2.getLogTrigger_("audioSegmentStream"));
          pipeline.audioSegmentStream.on("timingInfo", self2.trigger.bind(self2, "audioTimingInfo"));
          pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
          self2.trigger("trackinfo", {
            hasAudio: !!audioTrack,
            hasVideo: !!videoTrack
          });
        });
        pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
        pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
        addPipelineLogRetriggers(this, pipeline);
      };
      this.setupTsPipeline = function() {
        var pipeline = {};
        this.transmuxPipeline_ = pipeline;
        pipeline.type = "ts";
        pipeline.metadataStream = new m2ts.MetadataStream();
        pipeline.packetStream = new m2ts.TransportPacketStream();
        pipeline.parseStream = new m2ts.TransportParseStream();
        pipeline.elementaryStream = new m2ts.ElementaryStream();
        pipeline.timestampRolloverStream = new m2ts.TimestampRolloverStream();
        pipeline.adtsStream = new AdtsStream();
        pipeline.h264Stream = new H264Stream();
        pipeline.captionStream = new m2ts.CaptionStream(options);
        pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);
        pipeline.headOfPipeline = pipeline.packetStream;
        pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream);
        pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);
        pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);
        pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
        pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);
        pipeline.elementaryStream.on("data", function(data) {
          var i;
          if (data.type === "metadata") {
            i = data.tracks.length;
            while (i--) {
              if (!videoTrack && data.tracks[i].type === "video") {
                videoTrack = data.tracks[i];
                videoTrack.timelineStartInfo.baseMediaDecodeTime = self2.baseMediaDecodeTime;
              } else if (!audioTrack && data.tracks[i].type === "audio") {
                audioTrack = data.tracks[i];
                audioTrack.timelineStartInfo.baseMediaDecodeTime = self2.baseMediaDecodeTime;
              }
            }
            if (videoTrack && !pipeline.videoSegmentStream) {
              pipeline.coalesceStream.numberOfTracks++;
              pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack, options);
              pipeline.videoSegmentStream.on("log", self2.getLogTrigger_("videoSegmentStream"));
              pipeline.videoSegmentStream.on("timelineStartInfo", function(timelineStartInfo) {
                if (audioTrack && !options.keepOriginalTimestamps) {
                  audioTrack.timelineStartInfo = timelineStartInfo;
                  pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self2.baseMediaDecodeTime);
                }
              });
              pipeline.videoSegmentStream.on("processedGopsInfo", self2.trigger.bind(self2, "gopInfo"));
              pipeline.videoSegmentStream.on("segmentTimingInfo", self2.trigger.bind(self2, "videoSegmentTimingInfo"));
              pipeline.videoSegmentStream.on("baseMediaDecodeTime", function(baseMediaDecodeTime) {
                if (audioTrack) {
                  pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);
                }
              });
              pipeline.videoSegmentStream.on("timingInfo", self2.trigger.bind(self2, "videoTimingInfo"));
              pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);
            }
            if (audioTrack && !pipeline.audioSegmentStream) {
              pipeline.coalesceStream.numberOfTracks++;
              pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);
              pipeline.audioSegmentStream.on("log", self2.getLogTrigger_("audioSegmentStream"));
              pipeline.audioSegmentStream.on("timingInfo", self2.trigger.bind(self2, "audioTimingInfo"));
              pipeline.audioSegmentStream.on("segmentTimingInfo", self2.trigger.bind(self2, "audioSegmentTimingInfo"));
              pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
            }
            self2.trigger("trackinfo", {
              hasAudio: !!audioTrack,
              hasVideo: !!videoTrack
            });
          }
        });
        pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
        pipeline.coalesceStream.on("id3Frame", function(id3Frame) {
          id3Frame.dispatchType = pipeline.metadataStream.dispatchType;
          self2.trigger("id3Frame", id3Frame);
        });
        pipeline.coalesceStream.on("caption", this.trigger.bind(this, "caption"));
        pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
        addPipelineLogRetriggers(this, pipeline);
      };
      this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {
        var pipeline = this.transmuxPipeline_;
        if (!options.keepOriginalTimestamps) {
          this.baseMediaDecodeTime = baseMediaDecodeTime;
        }
        if (audioTrack) {
          audioTrack.timelineStartInfo.dts = void 0;
          audioTrack.timelineStartInfo.pts = void 0;
          trackDecodeInfo.clearDtsInfo(audioTrack);
          if (pipeline.audioTimestampRolloverStream) {
            pipeline.audioTimestampRolloverStream.discontinuity();
          }
        }
        if (videoTrack) {
          if (pipeline.videoSegmentStream) {
            pipeline.videoSegmentStream.gopCache_ = [];
          }
          videoTrack.timelineStartInfo.dts = void 0;
          videoTrack.timelineStartInfo.pts = void 0;
          trackDecodeInfo.clearDtsInfo(videoTrack);
          pipeline.captionStream.reset();
        }
        if (pipeline.timestampRolloverStream) {
          pipeline.timestampRolloverStream.discontinuity();
        }
      };
      this.setAudioAppendStart = function(timestamp) {
        if (audioTrack) {
          this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);
        }
      };
      this.setRemux = function(val) {
        var pipeline = this.transmuxPipeline_;
        options.remux = val;
        if (pipeline && pipeline.coalesceStream) {
          pipeline.coalesceStream.setRemux(val);
        }
      };
      this.alignGopsWith = function(gopsToAlignWith) {
        if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {
          this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);
        }
      };
      this.getLogTrigger_ = function(key) {
        var self3 = this;
        return function(event) {
          event.stream = key;
          self3.trigger("log", event);
        };
      };
      this.push = function(data) {
        if (hasFlushed) {
          var isAac = isLikelyAacData(data);
          if (isAac && this.transmuxPipeline_.type !== "aac") {
            this.setupAacPipeline();
          } else if (!isAac && this.transmuxPipeline_.type !== "ts") {
            this.setupTsPipeline();
          }
          hasFlushed = false;
        }
        this.transmuxPipeline_.headOfPipeline.push(data);
      };
      this.flush = function() {
        hasFlushed = true;
        this.transmuxPipeline_.headOfPipeline.flush();
      };
      this.endTimeline = function() {
        this.transmuxPipeline_.headOfPipeline.endTimeline();
      };
      this.reset = function() {
        if (this.transmuxPipeline_.headOfPipeline) {
          this.transmuxPipeline_.headOfPipeline.reset();
        }
      };
      this.resetCaptions = function() {
        if (this.transmuxPipeline_.captionStream) {
          this.transmuxPipeline_.captionStream.reset();
        }
      };
    };
    Transmuxer.prototype = new Stream2();
    var transmuxer = {
      Transmuxer,
      VideoSegmentStream,
      AudioSegmentStream,
      AUDIO_PROPERTIES,
      VIDEO_PROPERTIES,
      // exported for testing
      generateSegmentTimingInfo
    };
    var toUnsigned$3 = function(value) {
      return value >>> 0;
    };
    var toHexString$1 = function(value) {
      return ("00" + value.toString(16)).slice(-2);
    };
    var bin = {
      toUnsigned: toUnsigned$3,
      toHexString: toHexString$1
    };
    var parseType$3 = function(buffer) {
      var result = "";
      result += String.fromCharCode(buffer[0]);
      result += String.fromCharCode(buffer[1]);
      result += String.fromCharCode(buffer[2]);
      result += String.fromCharCode(buffer[3]);
      return result;
    };
    var parseType_1 = parseType$3;
    var toUnsigned$2 = bin.toUnsigned;
    var parseType$2 = parseType_1;
    var findBox$2 = function(data, path) {
      var results = [], i, size, type2, end, subresults;
      if (!path.length) {
        return null;
      }
      for (i = 0; i < data.byteLength; ) {
        size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);
        type2 = parseType$2(data.subarray(i + 4, i + 8));
        end = size > 1 ? i + size : data.byteLength;
        if (type2 === path[0]) {
          if (path.length === 1) {
            results.push(data.subarray(i + 8, end));
          } else {
            subresults = findBox$2(data.subarray(i + 8, end), path.slice(1));
            if (subresults.length) {
              results = results.concat(subresults);
            }
          }
        }
        i = end;
      }
      return results;
    };
    var findBox_1 = findBox$2;
    var toUnsigned$1 = bin.toUnsigned;
    var getUint64$2 = numbers2.getUint64;
    var tfdt = function(data) {
      var result = {
        version: data[0],
        flags: new Uint8Array(data.subarray(1, 4))
      };
      if (result.version === 1) {
        result.baseMediaDecodeTime = getUint64$2(data.subarray(4));
      } else {
        result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);
      }
      return result;
    };
    var parseTfdt$2 = tfdt;
    var parseSampleFlags$1 = function(flags) {
      return {
        isLeading: (flags[0] & 12) >>> 2,
        dependsOn: flags[0] & 3,
        isDependedOn: (flags[1] & 192) >>> 6,
        hasRedundancy: (flags[1] & 48) >>> 4,
        paddingValue: (flags[1] & 14) >>> 1,
        isNonSyncSample: flags[1] & 1,
        degradationPriority: flags[2] << 8 | flags[3]
      };
    };
    var parseSampleFlags_1 = parseSampleFlags$1;
    var parseSampleFlags = parseSampleFlags_1;
    var trun = function(data) {
      var result = {
        version: data[0],
        flags: new Uint8Array(data.subarray(1, 4)),
        samples: []
      }, view = new DataView(data.buffer, data.byteOffset, data.byteLength), dataOffsetPresent = result.flags[2] & 1, firstSampleFlagsPresent = result.flags[2] & 4, sampleDurationPresent = result.flags[1] & 1, sampleSizePresent = result.flags[1] & 2, sampleFlagsPresent = result.flags[1] & 4, sampleCompositionTimeOffsetPresent = result.flags[1] & 8, sampleCount = view.getUint32(4), offset = 8, sample;
      if (dataOffsetPresent) {
        result.dataOffset = view.getInt32(offset);
        offset += 4;
      }
      if (firstSampleFlagsPresent && sampleCount) {
        sample = {
          flags: parseSampleFlags(data.subarray(offset, offset + 4))
        };
        offset += 4;
        if (sampleDurationPresent) {
          sample.duration = view.getUint32(offset);
          offset += 4;
        }
        if (sampleSizePresent) {
          sample.size = view.getUint32(offset);
          offset += 4;
        }
        if (sampleCompositionTimeOffsetPresent) {
          if (result.version === 1) {
            sample.compositionTimeOffset = view.getInt32(offset);
          } else {
            sample.compositionTimeOffset = view.getUint32(offset);
          }
          offset += 4;
        }
        result.samples.push(sample);
        sampleCount--;
      }
      while (sampleCount--) {
        sample = {};
        if (sampleDurationPresent) {
          sample.duration = view.getUint32(offset);
          offset += 4;
        }
        if (sampleSizePresent) {
          sample.size = view.getUint32(offset);
          offset += 4;
        }
        if (sampleFlagsPresent) {
          sample.flags = parseSampleFlags(data.subarray(offset, offset + 4));
          offset += 4;
        }
        if (sampleCompositionTimeOffsetPresent) {
          if (result.version === 1) {
            sample.compositionTimeOffset = view.getInt32(offset);
          } else {
            sample.compositionTimeOffset = view.getUint32(offset);
          }
          offset += 4;
        }
        result.samples.push(sample);
      }
      return result;
    };
    var parseTrun$2 = trun;
    var tfhd = function(data) {
      var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
        version: data[0],
        flags: new Uint8Array(data.subarray(1, 4)),
        trackId: view.getUint32(4)
      }, baseDataOffsetPresent = result.flags[2] & 1, sampleDescriptionIndexPresent = result.flags[2] & 2, defaultSampleDurationPresent = result.flags[2] & 8, defaultSampleSizePresent = result.flags[2] & 16, defaultSampleFlagsPresent = result.flags[2] & 32, durationIsEmpty = result.flags[0] & 65536, defaultBaseIsMoof = result.flags[0] & 131072, i;
      i = 8;
      if (baseDataOffsetPresent) {
        i += 4;
        result.baseDataOffset = view.getUint32(12);
        i += 4;
      }
      if (sampleDescriptionIndexPresent) {
        result.sampleDescriptionIndex = view.getUint32(i);
        i += 4;
      }
      if (defaultSampleDurationPresent) {
        result.defaultSampleDuration = view.getUint32(i);
        i += 4;
      }
      if (defaultSampleSizePresent) {
        result.defaultSampleSize = view.getUint32(i);
        i += 4;
      }
      if (defaultSampleFlagsPresent) {
        result.defaultSampleFlags = view.getUint32(i);
      }
      if (durationIsEmpty) {
        result.durationIsEmpty = true;
      }
      if (!baseDataOffsetPresent && defaultBaseIsMoof) {
        result.baseDataOffsetIsMoof = true;
      }
      return result;
    };
    var parseTfhd$2 = tfhd;
    var win2;
    if (typeof window !== "undefined") {
      win2 = window;
    } else if (typeof commonjsGlobal2 !== "undefined") {
      win2 = commonjsGlobal2;
    } else if (typeof self !== "undefined") {
      win2 = self;
    } else {
      win2 = {};
    }
    var window_12 = win2;
    var discardEmulationPreventionBytes2 = captionPacketParser.discardEmulationPreventionBytes;
    var CaptionStream = captionStream.CaptionStream;
    var findBox$1 = findBox_1;
    var parseTfdt$1 = parseTfdt$2;
    var parseTrun$1 = parseTrun$2;
    var parseTfhd$1 = parseTfhd$2;
    var window$2 = window_12;
    var mapToSample = function(offset, samples) {
      var approximateOffset = offset;
      for (var i = 0; i < samples.length; i++) {
        var sample = samples[i];
        if (approximateOffset < sample.size) {
          return sample;
        }
        approximateOffset -= sample.size;
      }
      return null;
    };
    var findSeiNals = function(avcStream, samples, trackId) {
      var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength), result = {
        logs: [],
        seiNals: []
      }, seiNal, i, length, lastMatchedSample;
      for (i = 0; i + 4 < avcStream.length; i += length) {
        length = avcView.getUint32(i);
        i += 4;
        if (length <= 0) {
          continue;
        }
        switch (avcStream[i] & 31) {
          case 6:
            var data = avcStream.subarray(i + 1, i + 1 + length);
            var matchingSample = mapToSample(i, samples);
            seiNal = {
              nalUnitType: "sei_rbsp",
              size: length,
              data,
              escapedRBSP: discardEmulationPreventionBytes2(data),
              trackId
            };
            if (matchingSample) {
              seiNal.pts = matchingSample.pts;
              seiNal.dts = matchingSample.dts;
              lastMatchedSample = matchingSample;
            } else if (lastMatchedSample) {
              seiNal.pts = lastMatchedSample.pts;
              seiNal.dts = lastMatchedSample.dts;
            } else {
              result.logs.push({
                level: "warn",
                message: "We've encountered a nal unit without data at " + i + " for trackId " + trackId + ". See mux.js#223."
              });
              break;
            }
            result.seiNals.push(seiNal);
            break;
        }
      }
      return result;
    };
    var parseSamples = function(truns, baseMediaDecodeTime, tfhd2) {
      var currentDts = baseMediaDecodeTime;
      var defaultSampleDuration = tfhd2.defaultSampleDuration || 0;
      var defaultSampleSize = tfhd2.defaultSampleSize || 0;
      var trackId = tfhd2.trackId;
      var allSamples = [];
      truns.forEach(function(trun2) {
        var trackRun = parseTrun$1(trun2);
        var samples = trackRun.samples;
        samples.forEach(function(sample) {
          if (sample.duration === void 0) {
            sample.duration = defaultSampleDuration;
          }
          if (sample.size === void 0) {
            sample.size = defaultSampleSize;
          }
          sample.trackId = trackId;
          sample.dts = currentDts;
          if (sample.compositionTimeOffset === void 0) {
            sample.compositionTimeOffset = 0;
          }
          if (typeof currentDts === "bigint") {
            sample.pts = currentDts + window$2.BigInt(sample.compositionTimeOffset);
            currentDts += window$2.BigInt(sample.duration);
          } else {
            sample.pts = currentDts + sample.compositionTimeOffset;
            currentDts += sample.duration;
          }
        });
        allSamples = allSamples.concat(samples);
      });
      return allSamples;
    };
    var parseCaptionNals = function(segment, videoTrackId) {
      var trafs = findBox$1(segment, ["moof", "traf"]);
      var mdats = findBox$1(segment, ["mdat"]);
      var captionNals = {};
      var mdatTrafPairs = [];
      mdats.forEach(function(mdat2, index) {
        var matchingTraf = trafs[index];
        mdatTrafPairs.push({
          mdat: mdat2,
          traf: matchingTraf
        });
      });
      mdatTrafPairs.forEach(function(pair) {
        var mdat2 = pair.mdat;
        var traf2 = pair.traf;
        var tfhd2 = findBox$1(traf2, ["tfhd"]);
        var headerInfo = parseTfhd$1(tfhd2[0]);
        var trackId = headerInfo.trackId;
        var tfdt2 = findBox$1(traf2, ["tfdt"]);
        var baseMediaDecodeTime = tfdt2.length > 0 ? parseTfdt$1(tfdt2[0]).baseMediaDecodeTime : 0;
        var truns = findBox$1(traf2, ["trun"]);
        var samples;
        var result;
        if (videoTrackId === trackId && truns.length > 0) {
          samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);
          result = findSeiNals(mdat2, samples, trackId);
          if (!captionNals[trackId]) {
            captionNals[trackId] = {
              seiNals: [],
              logs: []
            };
          }
          captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);
          captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);
        }
      });
      return captionNals;
    };
    var parseEmbeddedCaptions = function(segment, trackId, timescale2) {
      var captionNals;
      if (trackId === null) {
        return null;
      }
      captionNals = parseCaptionNals(segment, trackId);
      var trackNals = captionNals[trackId] || {};
      return {
        seiNals: trackNals.seiNals,
        logs: trackNals.logs,
        timescale: timescale2
      };
    };
    var CaptionParser = function() {
      var isInitialized = false;
      var captionStream2;
      var segmentCache;
      var trackId;
      var timescale2;
      var parsedCaptions;
      var parsingPartial;
      this.isInitialized = function() {
        return isInitialized;
      };
      this.init = function(options) {
        captionStream2 = new CaptionStream();
        isInitialized = true;
        parsingPartial = options ? options.isPartial : false;
        captionStream2.on("data", function(event) {
          event.startTime = event.startPts / timescale2;
          event.endTime = event.endPts / timescale2;
          parsedCaptions.captions.push(event);
          parsedCaptions.captionStreams[event.stream] = true;
        });
        captionStream2.on("log", function(log2) {
          parsedCaptions.logs.push(log2);
        });
      };
      this.isNewInit = function(videoTrackIds, timescales) {
        if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === "object" && Object.keys(timescales).length === 0) {
          return false;
        }
        return trackId !== videoTrackIds[0] || timescale2 !== timescales[trackId];
      };
      this.parse = function(segment, videoTrackIds, timescales) {
        var parsedData;
        if (!this.isInitialized()) {
          return null;
        } else if (!videoTrackIds || !timescales) {
          return null;
        } else if (this.isNewInit(videoTrackIds, timescales)) {
          trackId = videoTrackIds[0];
          timescale2 = timescales[trackId];
        } else if (trackId === null || !timescale2) {
          segmentCache.push(segment);
          return null;
        }
        while (segmentCache.length > 0) {
          var cachedSegment = segmentCache.shift();
          this.parse(cachedSegment, videoTrackIds, timescales);
        }
        parsedData = parseEmbeddedCaptions(segment, trackId, timescale2);
        if (parsedData && parsedData.logs) {
          parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);
        }
        if (parsedData === null || !parsedData.seiNals) {
          if (parsedCaptions.logs.length) {
            return {
              logs: parsedCaptions.logs,
              captions: [],
              captionStreams: []
            };
          }
          return null;
        }
        this.pushNals(parsedData.seiNals);
        this.flushStream();
        return parsedCaptions;
      };
      this.pushNals = function(nals) {
        if (!this.isInitialized() || !nals || nals.length === 0) {
          return null;
        }
        nals.forEach(function(nal) {
          captionStream2.push(nal);
        });
      };
      this.flushStream = function() {
        if (!this.isInitialized()) {
          return null;
        }
        if (!parsingPartial) {
          captionStream2.flush();
        } else {
          captionStream2.partialFlush();
        }
      };
      this.clearParsedCaptions = function() {
        parsedCaptions.captions = [];
        parsedCaptions.captionStreams = {};
        parsedCaptions.logs = [];
      };
      this.resetCaptionStream = function() {
        if (!this.isInitialized()) {
          return null;
        }
        captionStream2.reset();
      };
      this.clearAllCaptions = function() {
        this.clearParsedCaptions();
        this.resetCaptionStream();
      };
      this.reset = function() {
        segmentCache = [];
        trackId = null;
        timescale2 = null;
        if (!parsedCaptions) {
          parsedCaptions = {
            captions: [],
            // CC1, CC2, CC3, CC4
            captionStreams: {},
            logs: []
          };
        } else {
          this.clearParsedCaptions();
        }
        this.resetCaptionStream();
      };
      this.reset();
    };
    var captionParser = CaptionParser;
    var uint8ToCString$1 = function(data) {
      var index = 0;
      var curChar = String.fromCharCode(data[index]);
      var retString = "";
      while (curChar !== "\0") {
        retString += curChar;
        index++;
        curChar = String.fromCharCode(data[index]);
      }
      retString += curChar;
      return retString;
    };
    var string = {
      uint8ToCString: uint8ToCString$1
    };
    var uint8ToCString = string.uint8ToCString;
    var getUint64$12 = numbers2.getUint64;
    var parseEmsgBox = function(boxData) {
      var offset = 4;
      var version2 = boxData[0];
      var scheme_id_uri, value, timescale2, presentation_time, presentation_time_delta, event_duration, id, message_data;
      if (version2 === 0) {
        scheme_id_uri = uint8ToCString(boxData.subarray(offset));
        offset += scheme_id_uri.length;
        value = uint8ToCString(boxData.subarray(offset));
        offset += value.length;
        var dv = new DataView(boxData.buffer);
        timescale2 = dv.getUint32(offset);
        offset += 4;
        presentation_time_delta = dv.getUint32(offset);
        offset += 4;
        event_duration = dv.getUint32(offset);
        offset += 4;
        id = dv.getUint32(offset);
        offset += 4;
      } else if (version2 === 1) {
        var dv = new DataView(boxData.buffer);
        timescale2 = dv.getUint32(offset);
        offset += 4;
        presentation_time = getUint64$12(boxData.subarray(offset));
        offset += 8;
        event_duration = dv.getUint32(offset);
        offset += 4;
        id = dv.getUint32(offset);
        offset += 4;
        scheme_id_uri = uint8ToCString(boxData.subarray(offset));
        offset += scheme_id_uri.length;
        value = uint8ToCString(boxData.subarray(offset));
        offset += value.length;
      }
      message_data = new Uint8Array(boxData.subarray(offset, boxData.byteLength));
      var emsgBox = {
        scheme_id_uri,
        value,
        // if timescale is undefined or 0 set to 1 
        timescale: timescale2 ? timescale2 : 1,
        presentation_time,
        presentation_time_delta,
        event_duration,
        id,
        message_data
      };
      return isValidEmsgBox(version2, emsgBox) ? emsgBox : void 0;
    };
    var scaleTime = function(presentationTime, timescale2, timeDelta, offset) {
      return presentationTime || presentationTime === 0 ? presentationTime / timescale2 : offset + timeDelta / timescale2;
    };
    var isValidEmsgBox = function(version2, emsg2) {
      var hasScheme = emsg2.scheme_id_uri !== "\0";
      var isValidV0Box = version2 === 0 && isDefined(emsg2.presentation_time_delta) && hasScheme;
      var isValidV1Box = version2 === 1 && isDefined(emsg2.presentation_time) && hasScheme;
      return !(version2 > 1) && isValidV0Box || isValidV1Box;
    };
    var isDefined = function(data) {
      return data !== void 0 || data !== null;
    };
    var emsg$1 = {
      parseEmsgBox,
      scaleTime
    };
    var toUnsigned = bin.toUnsigned;
    var toHexString = bin.toHexString;
    var findBox2 = findBox_1;
    var parseType$1 = parseType_1;
    var emsg = emsg$1;
    var parseTfhd = parseTfhd$2;
    var parseTrun = parseTrun$2;
    var parseTfdt = parseTfdt$2;
    var getUint642 = numbers2.getUint64;
    var timescale, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader, getEmsgID3;
    var window$1 = window_12;
    var parseId3Frames = parseId3.parseId3Frames;
    timescale = function(init) {
      var result = {}, traks = findBox2(init, ["moov", "trak"]);
      return traks.reduce(function(result2, trak2) {
        var tkhd2, version2, index, id, mdhd2;
        tkhd2 = findBox2(trak2, ["tkhd"])[0];
        if (!tkhd2) {
          return null;
        }
        version2 = tkhd2[0];
        index = version2 === 0 ? 12 : 20;
        id = toUnsigned(tkhd2[index] << 24 | tkhd2[index + 1] << 16 | tkhd2[index + 2] << 8 | tkhd2[index + 3]);
        mdhd2 = findBox2(trak2, ["mdia", "mdhd"])[0];
        if (!mdhd2) {
          return null;
        }
        version2 = mdhd2[0];
        index = version2 === 0 ? 12 : 20;
        result2[id] = toUnsigned(mdhd2[index] << 24 | mdhd2[index + 1] << 16 | mdhd2[index + 2] << 8 | mdhd2[index + 3]);
        return result2;
      }, result);
    };
    startTime = function(timescale2, fragment) {
      var trafs;
      trafs = findBox2(fragment, ["moof", "traf"]);
      var lowestTime = trafs.reduce(function(acc, traf2) {
        var tfhd2 = findBox2(traf2, ["tfhd"])[0];
        var id = toUnsigned(tfhd2[4] << 24 | tfhd2[5] << 16 | tfhd2[6] << 8 | tfhd2[7]);
        var scale = timescale2[id] || 9e4;
        var tfdt2 = findBox2(traf2, ["tfdt"])[0];
        var dv = new DataView(tfdt2.buffer, tfdt2.byteOffset, tfdt2.byteLength);
        var baseTime;
        if (tfdt2[0] === 1) {
          baseTime = getUint642(tfdt2.subarray(4, 12));
        } else {
          baseTime = dv.getUint32(4);
        }
        let seconds;
        if (typeof baseTime === "bigint") {
          seconds = baseTime / window$1.BigInt(scale);
        } else if (typeof baseTime === "number" && !isNaN(baseTime)) {
          seconds = baseTime / scale;
        }
        if (seconds < Number.MAX_SAFE_INTEGER) {
          seconds = Number(seconds);
        }
        if (seconds < acc) {
          acc = seconds;
        }
        return acc;
      }, Infinity);
      return typeof lowestTime === "bigint" || isFinite(lowestTime) ? lowestTime : 0;
    };
    compositionStartTime = function(timescales, fragment) {
      var trafBoxes = findBox2(fragment, ["moof", "traf"]);
      var baseMediaDecodeTime = 0;
      var compositionTimeOffset = 0;
      var trackId;
      if (trafBoxes && trafBoxes.length) {
        var tfhd2 = findBox2(trafBoxes[0], ["tfhd"])[0];
        var trun2 = findBox2(trafBoxes[0], ["trun"])[0];
        var tfdt2 = findBox2(trafBoxes[0], ["tfdt"])[0];
        if (tfhd2) {
          var parsedTfhd = parseTfhd(tfhd2);
          trackId = parsedTfhd.trackId;
        }
        if (tfdt2) {
          var parsedTfdt = parseTfdt(tfdt2);
          baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;
        }
        if (trun2) {
          var parsedTrun = parseTrun(trun2);
          if (parsedTrun.samples && parsedTrun.samples.length) {
            compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;
          }
        }
      }
      var timescale2 = timescales[trackId] || 9e4;
      if (typeof baseMediaDecodeTime === "bigint") {
        compositionTimeOffset = window$1.BigInt(compositionTimeOffset);
        timescale2 = window$1.BigInt(timescale2);
      }
      var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale2;
      if (typeof result === "bigint" && result < Number.MAX_SAFE_INTEGER) {
        result = Number(result);
      }
      return result;
    };
    getVideoTrackIds = function(init) {
      var traks = findBox2(init, ["moov", "trak"]);
      var videoTrackIds = [];
      traks.forEach(function(trak2) {
        var hdlrs = findBox2(trak2, ["mdia", "hdlr"]);
        var tkhds = findBox2(trak2, ["tkhd"]);
        hdlrs.forEach(function(hdlr2, index) {
          var handlerType = parseType$1(hdlr2.subarray(8, 12));
          var tkhd2 = tkhds[index];
          var view;
          var version2;
          var trackId;
          if (handlerType === "vide") {
            view = new DataView(tkhd2.buffer, tkhd2.byteOffset, tkhd2.byteLength);
            version2 = view.getUint8(0);
            trackId = version2 === 0 ? view.getUint32(12) : view.getUint32(20);
            videoTrackIds.push(trackId);
          }
        });
      });
      return videoTrackIds;
    };
    getTimescaleFromMediaHeader = function(mdhd2) {
      var version2 = mdhd2[0];
      var index = version2 === 0 ? 12 : 20;
      return toUnsigned(mdhd2[index] << 24 | mdhd2[index + 1] << 16 | mdhd2[index + 2] << 8 | mdhd2[index + 3]);
    };
    getTracks = function(init) {
      var traks = findBox2(init, ["moov", "trak"]);
      var tracks = [];
      traks.forEach(function(trak2) {
        var track = {};
        var tkhd2 = findBox2(trak2, ["tkhd"])[0];
        var view, tkhdVersion;
        if (tkhd2) {
          view = new DataView(tkhd2.buffer, tkhd2.byteOffset, tkhd2.byteLength);
          tkhdVersion = view.getUint8(0);
          track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);
        }
        var hdlr2 = findBox2(trak2, ["mdia", "hdlr"])[0];
        if (hdlr2) {
          var type2 = parseType$1(hdlr2.subarray(8, 12));
          if (type2 === "vide") {
            track.type = "video";
          } else if (type2 === "soun") {
            track.type = "audio";
          } else {
            track.type = type2;
          }
        }
        var stsd2 = findBox2(trak2, ["mdia", "minf", "stbl", "stsd"])[0];
        if (stsd2) {
          var sampleDescriptions = stsd2.subarray(8);
          track.codec = parseType$1(sampleDescriptions.subarray(4, 8));
          var codecBox = findBox2(sampleDescriptions, [track.codec])[0];
          var codecConfig, codecConfigType;
          if (codecBox) {
            if (/^[asm]vc[1-9]$/i.test(track.codec)) {
              codecConfig = codecBox.subarray(78);
              codecConfigType = parseType$1(codecConfig.subarray(4, 8));
              if (codecConfigType === "avcC" && codecConfig.length > 11) {
                track.codec += ".";
                track.codec += toHexString(codecConfig[9]);
                track.codec += toHexString(codecConfig[10]);
                track.codec += toHexString(codecConfig[11]);
              } else {
                track.codec = "avc1.4d400d";
              }
            } else if (/^mp4[a,v]$/i.test(track.codec)) {
              codecConfig = codecBox.subarray(28);
              codecConfigType = parseType$1(codecConfig.subarray(4, 8));
              if (codecConfigType === "esds" && codecConfig.length > 20 && codecConfig[19] !== 0) {
                track.codec += "." + toHexString(codecConfig[19]);
                track.codec += "." + toHexString(codecConfig[20] >>> 2 & 63).replace(/^0/, "");
              } else {
                track.codec = "mp4a.40.2";
              }
            } else {
              track.codec = track.codec.toLowerCase();
            }
          }
        }
        var mdhd2 = findBox2(trak2, ["mdia", "mdhd"])[0];
        if (mdhd2) {
          track.timescale = getTimescaleFromMediaHeader(mdhd2);
        }
        tracks.push(track);
      });
      return tracks;
    };
    getEmsgID3 = function(segmentData, offset = 0) {
      var emsgBoxes = findBox2(segmentData, ["emsg"]);
      return emsgBoxes.map((data) => {
        var parsedBox = emsg.parseEmsgBox(new Uint8Array(data));
        var parsedId3Frames = parseId3Frames(parsedBox.message_data);
        return {
          cueTime: emsg.scaleTime(parsedBox.presentation_time, parsedBox.timescale, parsedBox.presentation_time_delta, offset),
          duration: emsg.scaleTime(parsedBox.event_duration, parsedBox.timescale),
          frames: parsedId3Frames
        };
      });
    };
    var probe$2 = {
      // export mp4 inspector's findBox and parseType for backwards compatibility
      findBox: findBox2,
      parseType: parseType$1,
      timescale,
      startTime,
      compositionStartTime,
      videoTrackIds: getVideoTrackIds,
      tracks: getTracks,
      getTimescaleFromMediaHeader,
      getEmsgID3
    };
    var StreamTypes$1 = streamTypes;
    var parsePid = function(packet) {
      var pid = packet[1] & 31;
      pid <<= 8;
      pid |= packet[2];
      return pid;
    };
    var parsePayloadUnitStartIndicator = function(packet) {
      return !!(packet[1] & 64);
    };
    var parseAdaptionField = function(packet) {
      var offset = 0;
      if ((packet[3] & 48) >>> 4 > 1) {
        offset += packet[4] + 1;
      }
      return offset;
    };
    var parseType = function(packet, pmtPid) {
      var pid = parsePid(packet);
      if (pid === 0) {
        return "pat";
      } else if (pid === pmtPid) {
        return "pmt";
      } else if (pmtPid) {
        return "pes";
      }
      return null;
    };
    var parsePat = function(packet) {
      var pusi = parsePayloadUnitStartIndicator(packet);
      var offset = 4 + parseAdaptionField(packet);
      if (pusi) {
        offset += packet[offset] + 1;
      }
      return (packet[offset + 10] & 31) << 8 | packet[offset + 11];
    };
    var parsePmt = function(packet) {
      var programMapTable = {};
      var pusi = parsePayloadUnitStartIndicator(packet);
      var payloadOffset = 4 + parseAdaptionField(packet);
      if (pusi) {
        payloadOffset += packet[payloadOffset] + 1;
      }
      if (!(packet[payloadOffset + 5] & 1)) {
        return;
      }
      var sectionLength, tableEnd, programInfoLength;
      sectionLength = (packet[payloadOffset + 1] & 15) << 8 | packet[payloadOffset + 2];
      tableEnd = 3 + sectionLength - 4;
      programInfoLength = (packet[payloadOffset + 10] & 15) << 8 | packet[payloadOffset + 11];
      var offset = 12 + programInfoLength;
      while (offset < tableEnd) {
        var i = payloadOffset + offset;
        programMapTable[(packet[i + 1] & 31) << 8 | packet[i + 2]] = packet[i];
        offset += ((packet[i + 3] & 15) << 8 | packet[i + 4]) + 5;
      }
      return programMapTable;
    };
    var parsePesType = function(packet, programMapTable) {
      var pid = parsePid(packet);
      var type2 = programMapTable[pid];
      switch (type2) {
        case StreamTypes$1.H264_STREAM_TYPE:
          return "video";
        case StreamTypes$1.ADTS_STREAM_TYPE:
          return "audio";
        case StreamTypes$1.METADATA_STREAM_TYPE:
          return "timed-metadata";
        default:
          return null;
      }
    };
    var parsePesTime = function(packet) {
      var pusi = parsePayloadUnitStartIndicator(packet);
      if (!pusi) {
        return null;
      }
      var offset = 4 + parseAdaptionField(packet);
      if (offset >= packet.byteLength) {
        return null;
      }
      var pes = null;
      var ptsDtsFlags;
      ptsDtsFlags = packet[offset + 7];
      if (ptsDtsFlags & 192) {
        pes = {};
        pes.pts = (packet[offset + 9] & 14) << 27 | (packet[offset + 10] & 255) << 20 | (packet[offset + 11] & 254) << 12 | (packet[offset + 12] & 255) << 5 | (packet[offset + 13] & 254) >>> 3;
        pes.pts *= 4;
        pes.pts += (packet[offset + 13] & 6) >>> 1;
        pes.dts = pes.pts;
        if (ptsDtsFlags & 64) {
          pes.dts = (packet[offset + 14] & 14) << 27 | (packet[offset + 15] & 255) << 20 | (packet[offset + 16] & 254) << 12 | (packet[offset + 17] & 255) << 5 | (packet[offset + 18] & 254) >>> 3;
          pes.dts *= 4;
          pes.dts += (packet[offset + 18] & 6) >>> 1;
        }
      }
      return pes;
    };
    var parseNalUnitType = function(type2) {
      switch (type2) {
        case 5:
          return "slice_layer_without_partitioning_rbsp_idr";
        case 6:
          return "sei_rbsp";
        case 7:
          return "seq_parameter_set_rbsp";
        case 8:
          return "pic_parameter_set_rbsp";
        case 9:
          return "access_unit_delimiter_rbsp";
        default:
          return null;
      }
    };
    var videoPacketContainsKeyFrame = function(packet) {
      var offset = 4 + parseAdaptionField(packet);
      var frameBuffer = packet.subarray(offset);
      var frameI = 0;
      var frameSyncPoint = 0;
      var foundKeyFrame = false;
      var nalType;
      for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {
        if (frameBuffer[frameSyncPoint + 2] === 1) {
          frameI = frameSyncPoint + 5;
          break;
        }
      }
      while (frameI < frameBuffer.byteLength) {
        switch (frameBuffer[frameI]) {
          case 0:
            if (frameBuffer[frameI - 1] !== 0) {
              frameI += 2;
              break;
            } else if (frameBuffer[frameI - 2] !== 0) {
              frameI++;
              break;
            }
            if (frameSyncPoint + 3 !== frameI - 2) {
              nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
              if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
                foundKeyFrame = true;
              }
            }
            do {
              frameI++;
            } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);
            frameSyncPoint = frameI - 2;
            frameI += 3;
            break;
          case 1:
            if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {
              frameI += 3;
              break;
            }
            nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
            if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
              foundKeyFrame = true;
            }
            frameSyncPoint = frameI - 2;
            frameI += 3;
            break;
          default:
            frameI += 3;
            break;
        }
      }
      frameBuffer = frameBuffer.subarray(frameSyncPoint);
      frameI -= frameSyncPoint;
      frameSyncPoint = 0;
      if (frameBuffer && frameBuffer.byteLength > 3) {
        nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
        if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
          foundKeyFrame = true;
        }
      }
      return foundKeyFrame;
    };
    var probe$1 = {
      parseType,
      parsePat,
      parsePmt,
      parsePayloadUnitStartIndicator,
      parsePesType,
      parsePesTime,
      videoPacketContainsKeyFrame
    };
    var StreamTypes = streamTypes;
    var handleRollover = timestampRolloverStream.handleRollover;
    var probe = {};
    probe.ts = probe$1;
    probe.aac = utils2;
    var ONE_SECOND_IN_TS2 = clock$2.ONE_SECOND_IN_TS;
    var MP2T_PACKET_LENGTH = 188, SYNC_BYTE = 71;
    var parsePsi_ = function(bytes, pmt) {
      var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type2;
      while (endIndex < bytes.byteLength) {
        if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
          packet = bytes.subarray(startIndex, endIndex);
          type2 = probe.ts.parseType(packet, pmt.pid);
          switch (type2) {
            case "pat":
              pmt.pid = probe.ts.parsePat(packet);
              break;
            case "pmt":
              var table = probe.ts.parsePmt(packet);
              pmt.table = pmt.table || {};
              Object.keys(table).forEach(function(key) {
                pmt.table[key] = table[key];
              });
              break;
          }
          startIndex += MP2T_PACKET_LENGTH;
          endIndex += MP2T_PACKET_LENGTH;
          continue;
        }
        startIndex++;
        endIndex++;
      }
    };
    var parseAudioPes_ = function(bytes, pmt, result) {
      var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type2, pesType, pusi, parsed;
      var endLoop = false;
      while (endIndex <= bytes.byteLength) {
        if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
          packet = bytes.subarray(startIndex, endIndex);
          type2 = probe.ts.parseType(packet, pmt.pid);
          switch (type2) {
            case "pes":
              pesType = probe.ts.parsePesType(packet, pmt.table);
              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
              if (pesType === "audio" && pusi) {
                parsed = probe.ts.parsePesTime(packet);
                if (parsed) {
                  parsed.type = "audio";
                  result.audio.push(parsed);
                  endLoop = true;
                }
              }
              break;
          }
          if (endLoop) {
            break;
          }
          startIndex += MP2T_PACKET_LENGTH;
          endIndex += MP2T_PACKET_LENGTH;
          continue;
        }
        startIndex++;
        endIndex++;
      }
      endIndex = bytes.byteLength;
      startIndex = endIndex - MP2T_PACKET_LENGTH;
      endLoop = false;
      while (startIndex >= 0) {
        if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
          packet = bytes.subarray(startIndex, endIndex);
          type2 = probe.ts.parseType(packet, pmt.pid);
          switch (type2) {
            case "pes":
              pesType = probe.ts.parsePesType(packet, pmt.table);
              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
              if (pesType === "audio" && pusi) {
                parsed = probe.ts.parsePesTime(packet);
                if (parsed) {
                  parsed.type = "audio";
                  result.audio.push(parsed);
                  endLoop = true;
                }
              }
              break;
          }
          if (endLoop) {
            break;
          }
          startIndex -= MP2T_PACKET_LENGTH;
          endIndex -= MP2T_PACKET_LENGTH;
          continue;
        }
        startIndex--;
        endIndex--;
      }
    };
    var parseVideoPes_ = function(bytes, pmt, result) {
      var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type2, pesType, pusi, parsed, frame, i, pes;
      var endLoop = false;
      var currentFrame = {
        data: [],
        size: 0
      };
      while (endIndex < bytes.byteLength) {
        if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
          packet = bytes.subarray(startIndex, endIndex);
          type2 = probe.ts.parseType(packet, pmt.pid);
          switch (type2) {
            case "pes":
              pesType = probe.ts.parsePesType(packet, pmt.table);
              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
              if (pesType === "video") {
                if (pusi && !endLoop) {
                  parsed = probe.ts.parsePesTime(packet);
                  if (parsed) {
                    parsed.type = "video";
                    result.video.push(parsed);
                    endLoop = true;
                  }
                }
                if (!result.firstKeyFrame) {
                  if (pusi) {
                    if (currentFrame.size !== 0) {
                      frame = new Uint8Array(currentFrame.size);
                      i = 0;
                      while (currentFrame.data.length) {
                        pes = currentFrame.data.shift();
                        frame.set(pes, i);
                        i += pes.byteLength;
                      }
                      if (probe.ts.videoPacketContainsKeyFrame(frame)) {
                        var firstKeyFrame = probe.ts.parsePesTime(frame);
                        if (firstKeyFrame) {
                          result.firstKeyFrame = firstKeyFrame;
                          result.firstKeyFrame.type = "video";
                        } else {
                          console.warn("Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself.");
                        }
                      }
                      currentFrame.size = 0;
                    }
                  }
                  currentFrame.data.push(packet);
                  currentFrame.size += packet.byteLength;
                }
              }
              break;
          }
          if (endLoop && result.firstKeyFrame) {
            break;
          }
          startIndex += MP2T_PACKET_LENGTH;
          endIndex += MP2T_PACKET_LENGTH;
          continue;
        }
        startIndex++;
        endIndex++;
      }
      endIndex = bytes.byteLength;
      startIndex = endIndex - MP2T_PACKET_LENGTH;
      endLoop = false;
      while (startIndex >= 0) {
        if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
          packet = bytes.subarray(startIndex, endIndex);
          type2 = probe.ts.parseType(packet, pmt.pid);
          switch (type2) {
            case "pes":
              pesType = probe.ts.parsePesType(packet, pmt.table);
              pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
              if (pesType === "video" && pusi) {
                parsed = probe.ts.parsePesTime(packet);
                if (parsed) {
                  parsed.type = "video";
                  result.video.push(parsed);
                  endLoop = true;
                }
              }
              break;
          }
          if (endLoop) {
            break;
          }
          startIndex -= MP2T_PACKET_LENGTH;
          endIndex -= MP2T_PACKET_LENGTH;
          continue;
        }
        startIndex--;
        endIndex--;
      }
    };
    var adjustTimestamp_ = function(segmentInfo, baseTimestamp) {
      if (segmentInfo.audio && segmentInfo.audio.length) {
        var audioBaseTimestamp = baseTimestamp;
        if (typeof audioBaseTimestamp === "undefined" || isNaN(audioBaseTimestamp)) {
          audioBaseTimestamp = segmentInfo.audio[0].dts;
        }
        segmentInfo.audio.forEach(function(info) {
          info.dts = handleRollover(info.dts, audioBaseTimestamp);
          info.pts = handleRollover(info.pts, audioBaseTimestamp);
          info.dtsTime = info.dts / ONE_SECOND_IN_TS2;
          info.ptsTime = info.pts / ONE_SECOND_IN_TS2;
        });
      }
      if (segmentInfo.video && segmentInfo.video.length) {
        var videoBaseTimestamp = baseTimestamp;
        if (typeof videoBaseTimestamp === "undefined" || isNaN(videoBaseTimestamp)) {
          videoBaseTimestamp = segmentInfo.video[0].dts;
        }
        segmentInfo.video.forEach(function(info) {
          info.dts = handleRollover(info.dts, videoBaseTimestamp);
          info.pts = handleRollover(info.pts, videoBaseTimestamp);
          info.dtsTime = info.dts / ONE_SECOND_IN_TS2;
          info.ptsTime = info.pts / ONE_SECOND_IN_TS2;
        });
        if (segmentInfo.firstKeyFrame) {
          var frame = segmentInfo.firstKeyFrame;
          frame.dts = handleRollover(frame.dts, videoBaseTimestamp);
          frame.pts = handleRollover(frame.pts, videoBaseTimestamp);
          frame.dtsTime = frame.dts / ONE_SECOND_IN_TS2;
          frame.ptsTime = frame.pts / ONE_SECOND_IN_TS2;
        }
      }
    };
    var inspectAac_ = function(bytes) {
      var endLoop = false, audioCount = 0, sampleRate = null, timestamp = null, frameSize = 0, byteIndex = 0, packet;
      while (bytes.length - byteIndex >= 3) {
        var type2 = probe.aac.parseType(bytes, byteIndex);
        switch (type2) {
          case "timed-metadata":
            if (bytes.length - byteIndex < 10) {
              endLoop = true;
              break;
            }
            frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);
            if (frameSize > bytes.length) {
              endLoop = true;
              break;
            }
            if (timestamp === null) {
              packet = bytes.subarray(byteIndex, byteIndex + frameSize);
              timestamp = probe.aac.parseAacTimestamp(packet);
            }
            byteIndex += frameSize;
            break;
          case "audio":
            if (bytes.length - byteIndex < 7) {
              endLoop = true;
              break;
            }
            frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);
            if (frameSize > bytes.length) {
              endLoop = true;
              break;
            }
            if (sampleRate === null) {
              packet = bytes.subarray(byteIndex, byteIndex + frameSize);
              sampleRate = probe.aac.parseSampleRate(packet);
            }
            audioCount++;
            byteIndex += frameSize;
            break;
          default:
            byteIndex++;
            break;
        }
        if (endLoop) {
          return null;
        }
      }
      if (sampleRate === null || timestamp === null) {
        return null;
      }
      var audioTimescale = ONE_SECOND_IN_TS2 / sampleRate;
      var result = {
        audio: [{
          type: "audio",
          dts: timestamp,
          pts: timestamp
        }, {
          type: "audio",
          dts: timestamp + audioCount * 1024 * audioTimescale,
          pts: timestamp + audioCount * 1024 * audioTimescale
        }]
      };
      return result;
    };
    var inspectTs_ = function(bytes) {
      var pmt = {
        pid: null,
        table: null
      };
      var result = {};
      parsePsi_(bytes, pmt);
      for (var pid in pmt.table) {
        if (pmt.table.hasOwnProperty(pid)) {
          var type2 = pmt.table[pid];
          switch (type2) {
            case StreamTypes.H264_STREAM_TYPE:
              result.video = [];
              parseVideoPes_(bytes, pmt, result);
              if (result.video.length === 0) {
                delete result.video;
              }
              break;
            case StreamTypes.ADTS_STREAM_TYPE:
              result.audio = [];
              parseAudioPes_(bytes, pmt, result);
              if (result.audio.length === 0) {
                delete result.audio;
              }
              break;
          }
        }
      }
      return result;
    };
    var inspect = function(bytes, baseTimestamp) {
      var isAacData = probe.aac.isLikelyAacData(bytes);
      var result;
      if (isAacData) {
        result = inspectAac_(bytes);
      } else {
        result = inspectTs_(bytes);
      }
      if (!result || !result.audio && !result.video) {
        return null;
      }
      adjustTimestamp_(result, baseTimestamp);
      return result;
    };
    var tsInspector = {
      inspect,
      parseAudioPes_
    };
    const wireTransmuxerEvents = function(self2, transmuxer2) {
      transmuxer2.on("data", function(segment) {
        const initArray = segment.initSegment;
        segment.initSegment = {
          data: initArray.buffer,
          byteOffset: initArray.byteOffset,
          byteLength: initArray.byteLength
        };
        const typedArray2 = segment.data;
        segment.data = typedArray2.buffer;
        self2.postMessage({
          action: "data",
          segment,
          byteOffset: typedArray2.byteOffset,
          byteLength: typedArray2.byteLength
        }, [segment.data]);
      });
      transmuxer2.on("done", function(data) {
        self2.postMessage({
          action: "done"
        });
      });
      transmuxer2.on("gopInfo", function(gopInfo) {
        self2.postMessage({
          action: "gopInfo",
          gopInfo
        });
      });
      transmuxer2.on("videoSegmentTimingInfo", function(timingInfo) {
        const videoSegmentTimingInfo = {
          start: {
            decode: clock$2.videoTsToSeconds(timingInfo.start.dts),
            presentation: clock$2.videoTsToSeconds(timingInfo.start.pts)
          },
          end: {
            decode: clock$2.videoTsToSeconds(timingInfo.end.dts),
            presentation: clock$2.videoTsToSeconds(timingInfo.end.pts)
          },
          baseMediaDecodeTime: clock$2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
        };
        if (timingInfo.prependedContentDuration) {
          videoSegmentTimingInfo.prependedContentDuration = clock$2.videoTsToSeconds(timingInfo.prependedContentDuration);
        }
        self2.postMessage({
          action: "videoSegmentTimingInfo",
          videoSegmentTimingInfo
        });
      });
      transmuxer2.on("audioSegmentTimingInfo", function(timingInfo) {
        const audioSegmentTimingInfo = {
          start: {
            decode: clock$2.videoTsToSeconds(timingInfo.start.dts),
            presentation: clock$2.videoTsToSeconds(timingInfo.start.pts)
          },
          end: {
            decode: clock$2.videoTsToSeconds(timingInfo.end.dts),
            presentation: clock$2.videoTsToSeconds(timingInfo.end.pts)
          },
          baseMediaDecodeTime: clock$2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
        };
        if (timingInfo.prependedContentDuration) {
          audioSegmentTimingInfo.prependedContentDuration = clock$2.videoTsToSeconds(timingInfo.prependedContentDuration);
        }
        self2.postMessage({
          action: "audioSegmentTimingInfo",
          audioSegmentTimingInfo
        });
      });
      transmuxer2.on("id3Frame", function(id3Frame) {
        self2.postMessage({
          action: "id3Frame",
          id3Frame
        });
      });
      transmuxer2.on("caption", function(caption) {
        self2.postMessage({
          action: "caption",
          caption
        });
      });
      transmuxer2.on("trackinfo", function(trackInfo) {
        self2.postMessage({
          action: "trackinfo",
          trackInfo
        });
      });
      transmuxer2.on("audioTimingInfo", function(audioTimingInfo) {
        self2.postMessage({
          action: "audioTimingInfo",
          audioTimingInfo: {
            start: clock$2.videoTsToSeconds(audioTimingInfo.start),
            end: clock$2.videoTsToSeconds(audioTimingInfo.end)
          }
        });
      });
      transmuxer2.on("videoTimingInfo", function(videoTimingInfo) {
        self2.postMessage({
          action: "videoTimingInfo",
          videoTimingInfo: {
            start: clock$2.videoTsToSeconds(videoTimingInfo.start),
            end: clock$2.videoTsToSeconds(videoTimingInfo.end)
          }
        });
      });
      transmuxer2.on("log", function(log2) {
        self2.postMessage({
          action: "log",
          log: log2
        });
      });
    };
    class MessageHandlers {
      constructor(self2, options) {
        this.options = options || {};
        this.self = self2;
        this.init();
      }
      /**
       * initialize our web worker and wire all the events.
       */
      init() {
        if (this.transmuxer) {
          this.transmuxer.dispose();
        }
        this.transmuxer = new transmuxer.Transmuxer(this.options);
        wireTransmuxerEvents(this.self, this.transmuxer);
      }
      pushMp4Captions(data) {
        if (!this.captionParser) {
          this.captionParser = new captionParser();
          this.captionParser.init();
        }
        const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
        const parsed = this.captionParser.parse(segment, data.trackIds, data.timescales);
        this.self.postMessage({
          action: "mp4Captions",
          captions: parsed && parsed.captions || [],
          logs: parsed && parsed.logs || [],
          data: segment.buffer
        }, [segment.buffer]);
      }
      probeMp4StartTime({
        timescales,
        data
      }) {
        const startTime2 = probe$2.startTime(timescales, data);
        this.self.postMessage({
          action: "probeMp4StartTime",
          startTime: startTime2,
          data
        }, [data.buffer]);
      }
      probeMp4Tracks({
        data
      }) {
        const tracks = probe$2.tracks(data);
        this.self.postMessage({
          action: "probeMp4Tracks",
          tracks,
          data
        }, [data.buffer]);
      }
      /**
       * Probes an mp4 segment for EMSG boxes containing ID3 data.
       * https://aomediacodec.github.io/id3-emsg/
       *
       * @param {Uint8Array} data segment data
       * @param {number} offset segment start time
       * @return {Object[]} an array of ID3 frames
       */
      probeEmsgID3({
        data,
        offset
      }) {
        const id3Frames = probe$2.getEmsgID3(data, offset);
        this.self.postMessage({
          action: "probeEmsgID3",
          id3Frames,
          emsgData: data
        }, [data.buffer]);
      }
      /**
       * Probe an mpeg2-ts segment to determine the start time of the segment in it's
       * internal "media time," as well as whether it contains video and/or audio.
       *
       * @private
       * @param {Uint8Array} bytes - segment bytes
       * @param {number} baseStartTime
       *        Relative reference timestamp used when adjusting frame timestamps for rollover.
       *        This value should be in seconds, as it's converted to a 90khz clock within the
       *        function body.
       * @return {Object} The start time of the current segment in "media time" as well as
       *                  whether it contains video and/or audio
       */
      probeTs({
        data,
        baseStartTime
      }) {
        const tsStartTime = typeof baseStartTime === "number" && !isNaN(baseStartTime) ? baseStartTime * clock$2.ONE_SECOND_IN_TS : void 0;
        const timeInfo = tsInspector.inspect(data, tsStartTime);
        let result = null;
        if (timeInfo) {
          result = {
            // each type's time info comes back as an array of 2 times, start and end
            hasVideo: timeInfo.video && timeInfo.video.length === 2 || false,
            hasAudio: timeInfo.audio && timeInfo.audio.length === 2 || false
          };
          if (result.hasVideo) {
            result.videoStart = timeInfo.video[0].ptsTime;
          }
          if (result.hasAudio) {
            result.audioStart = timeInfo.audio[0].ptsTime;
          }
        }
        this.self.postMessage({
          action: "probeTs",
          result,
          data
        }, [data.buffer]);
      }
      clearAllMp4Captions() {
        if (this.captionParser) {
          this.captionParser.clearAllCaptions();
        }
      }
      clearParsedMp4Captions() {
        if (this.captionParser) {
          this.captionParser.clearParsedCaptions();
        }
      }
      /**
       * Adds data (a ts segment) to the start of the transmuxer pipeline for
       * processing.
       *
       * @param {ArrayBuffer} data data to push into the muxer
       */
      push(data) {
        const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
        this.transmuxer.push(segment);
      }
      /**
       * Recreate the transmuxer so that the next segment added via `push`
       * start with a fresh transmuxer.
       */
      reset() {
        this.transmuxer.reset();
      }
      /**
       * Set the value that will be used as the `baseMediaDecodeTime` time for the
       * next segment pushed in. Subsequent segments will have their `baseMediaDecodeTime`
       * set relative to the first based on the PTS values.
       *
       * @param {Object} data used to set the timestamp offset in the muxer
       */
      setTimestampOffset(data) {
        const timestampOffset = data.timestampOffset || 0;
        this.transmuxer.setBaseMediaDecodeTime(Math.round(clock$2.secondsToVideoTs(timestampOffset)));
      }
      setAudioAppendStart(data) {
        this.transmuxer.setAudioAppendStart(Math.ceil(clock$2.secondsToVideoTs(data.appendStart)));
      }
      setRemux(data) {
        this.transmuxer.setRemux(data.remux);
      }
      /**
       * Forces the pipeline to finish processing the last segment and emit it's
       * results.
       *
       * @param {Object} data event data, not really used
       */
      flush(data) {
        this.transmuxer.flush();
        self.postMessage({
          action: "done",
          type: "transmuxed"
        });
      }
      endTimeline() {
        this.transmuxer.endTimeline();
        self.postMessage({
          action: "endedtimeline",
          type: "transmuxed"
        });
      }
      alignGopsWith(data) {
        this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());
      }
    }
    self.onmessage = function(event) {
      if (event.data.action === "init" && event.data.options) {
        this.messageHandlers = new MessageHandlers(self, event.data.options);
        return;
      }
      if (!this.messageHandlers) {
        this.messageHandlers = new MessageHandlers(self);
      }
      if (event.data && event.data.action && event.data.action !== "init") {
        if (this.messageHandlers[event.data.action]) {
          this.messageHandlers[event.data.action](event.data);
        }
      }
    };
  }));
  var TransmuxWorker = factory(workerCode$1);
  const handleData_ = (event, transmuxedData, callback) => {
    const {
      type,
      initSegment,
      captions,
      captionStreams,
      metadata,
      videoFrameDtsTime,
      videoFramePtsTime
    } = event.data.segment;
    transmuxedData.buffer.push({
      captions,
      captionStreams,
      metadata
    });
    const boxes = event.data.segment.boxes || {
      data: event.data.segment.data
    };
    const result = {
      type,
      // cast ArrayBuffer to TypedArray
      data: new Uint8Array(boxes.data, boxes.data.byteOffset, boxes.data.byteLength),
      initSegment: new Uint8Array(initSegment.data, initSegment.byteOffset, initSegment.byteLength)
    };
    if (typeof videoFrameDtsTime !== "undefined") {
      result.videoFrameDtsTime = videoFrameDtsTime;
    }
    if (typeof videoFramePtsTime !== "undefined") {
      result.videoFramePtsTime = videoFramePtsTime;
    }
    callback(result);
  };
  const handleDone_ = ({
    transmuxedData,
    callback
  }) => {
    transmuxedData.buffer = [];
    callback(transmuxedData);
  };
  const handleGopInfo_ = (event, transmuxedData) => {
    transmuxedData.gopInfo = event.data.gopInfo;
  };
  const processTransmux = (options) => {
    const {
      transmuxer,
      bytes,
      audioAppendStart,
      gopsToAlignWith,
      remux,
      onData,
      onTrackInfo,
      onAudioTimingInfo,
      onVideoTimingInfo,
      onVideoSegmentTimingInfo,
      onAudioSegmentTimingInfo,
      onId3,
      onCaptions,
      onDone,
      onEndedTimeline,
      onTransmuxerLog,
      isEndOfTimeline
    } = options;
    const transmuxedData = {
      buffer: []
    };
    let waitForEndedTimelineEvent = isEndOfTimeline;
    const handleMessage = (event) => {
      if (transmuxer.currentTransmux !== options) {
        return;
      }
      if (event.data.action === "data") {
        handleData_(event, transmuxedData, onData);
      }
      if (event.data.action === "trackinfo") {
        onTrackInfo(event.data.trackInfo);
      }
      if (event.data.action === "gopInfo") {
        handleGopInfo_(event, transmuxedData);
      }
      if (event.data.action === "audioTimingInfo") {
        onAudioTimingInfo(event.data.audioTimingInfo);
      }
      if (event.data.action === "videoTimingInfo") {
        onVideoTimingInfo(event.data.videoTimingInfo);
      }
      if (event.data.action === "videoSegmentTimingInfo") {
        onVideoSegmentTimingInfo(event.data.videoSegmentTimingInfo);
      }
      if (event.data.action === "audioSegmentTimingInfo") {
        onAudioSegmentTimingInfo(event.data.audioSegmentTimingInfo);
      }
      if (event.data.action === "id3Frame") {
        onId3([event.data.id3Frame], event.data.id3Frame.dispatchType);
      }
      if (event.data.action === "caption") {
        onCaptions(event.data.caption);
      }
      if (event.data.action === "endedtimeline") {
        waitForEndedTimelineEvent = false;
        onEndedTimeline();
      }
      if (event.data.action === "log") {
        onTransmuxerLog(event.data.log);
      }
      if (event.data.type !== "transmuxed") {
        return;
      }
      if (waitForEndedTimelineEvent) {
        return;
      }
      transmuxer.onmessage = null;
      handleDone_({
        transmuxedData,
        callback: onDone
      });
      dequeue(transmuxer);
    };
    transmuxer.onmessage = handleMessage;
    if (audioAppendStart) {
      transmuxer.postMessage({
        action: "setAudioAppendStart",
        appendStart: audioAppendStart
      });
    }
    if (Array.isArray(gopsToAlignWith)) {
      transmuxer.postMessage({
        action: "alignGopsWith",
        gopsToAlignWith
      });
    }
    if (typeof remux !== "undefined") {
      transmuxer.postMessage({
        action: "setRemux",
        remux
      });
    }
    if (bytes.byteLength) {
      const buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer;
      const byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;
      transmuxer.postMessage({
        action: "push",
        // Send the typed-array of data as an ArrayBuffer so that
        // it can be sent as a "Transferable" and avoid the costly
        // memory copy
        data: buffer,
        // To recreate the original typed-array, we need information
        // about what portion of the ArrayBuffer it was a view into
        byteOffset,
        byteLength: bytes.byteLength
      }, [buffer]);
    }
    if (isEndOfTimeline) {
      transmuxer.postMessage({
        action: "endTimeline"
      });
    }
    transmuxer.postMessage({
      action: "flush"
    });
  };
  const dequeue = (transmuxer) => {
    transmuxer.currentTransmux = null;
    if (transmuxer.transmuxQueue.length) {
      transmuxer.currentTransmux = transmuxer.transmuxQueue.shift();
      if (typeof transmuxer.currentTransmux === "function") {
        transmuxer.currentTransmux();
      } else {
        processTransmux(transmuxer.currentTransmux);
      }
    }
  };
  const processAction = (transmuxer, action) => {
    transmuxer.postMessage({
      action
    });
    dequeue(transmuxer);
  };
  const enqueueAction = (action, transmuxer) => {
    if (!transmuxer.currentTransmux) {
      transmuxer.currentTransmux = action;
      processAction(transmuxer, action);
      return;
    }
    transmuxer.transmuxQueue.push(processAction.bind(null, transmuxer, action));
  };
  const reset = (transmuxer) => {
    enqueueAction("reset", transmuxer);
  };
  const endTimeline = (transmuxer) => {
    enqueueAction("endTimeline", transmuxer);
  };
  const transmux = (options) => {
    if (!options.transmuxer.currentTransmux) {
      options.transmuxer.currentTransmux = options;
      processTransmux(options);
      return;
    }
    options.transmuxer.transmuxQueue.push(options);
  };
  const createTransmuxer = (options) => {
    const transmuxer = new TransmuxWorker();
    transmuxer.currentTransmux = null;
    transmuxer.transmuxQueue = [];
    const term = transmuxer.terminate;
    transmuxer.terminate = () => {
      transmuxer.currentTransmux = null;
      transmuxer.transmuxQueue.length = 0;
      return term.call(transmuxer);
    };
    transmuxer.postMessage({
      action: "init",
      options
    });
    return transmuxer;
  };
  var segmentTransmuxer = {
    reset,
    endTimeline,
    transmux,
    createTransmuxer
  };
  const workerCallback = function(options) {
    const transmuxer = options.transmuxer;
    const endAction = options.endAction || options.action;
    const callback = options.callback;
    const message = _extends$1({}, options, {
      endAction: null,
      transmuxer: null,
      callback: null
    });
    const listenForEndEvent = (event) => {
      if (event.data.action !== endAction) {
        return;
      }
      transmuxer.removeEventListener("message", listenForEndEvent);
      if (event.data.data) {
        event.data.data = new Uint8Array(event.data.data, options.byteOffset || 0, options.byteLength || event.data.data.byteLength);
        if (options.data) {
          options.data = event.data.data;
        }
      }
      callback(event.data);
    };
    transmuxer.addEventListener("message", listenForEndEvent);
    if (options.data) {
      const isArrayBuffer = options.data instanceof ArrayBuffer;
      message.byteOffset = isArrayBuffer ? 0 : options.data.byteOffset;
      message.byteLength = options.data.byteLength;
      const transfers = [isArrayBuffer ? options.data : options.data.buffer];
      transmuxer.postMessage(message, transfers);
    } else {
      transmuxer.postMessage(message);
    }
  };
  const REQUEST_ERRORS = {
    FAILURE: 2,
    TIMEOUT: -101,
    ABORTED: -102
  };
  const abortAll = (activeXhrs) => {
    activeXhrs.forEach((xhr) => {
      xhr.abort();
    });
  };
  const getRequestStats = (request) => {
    return {
      bandwidth: request.bandwidth,
      bytesReceived: request.bytesReceived || 0,
      roundTripTime: request.roundTripTime || 0
    };
  };
  const getProgressStats = (progressEvent) => {
    const request = progressEvent.target;
    const roundTripTime = Date.now() - request.requestTime;
    const stats = {
      bandwidth: Infinity,
      bytesReceived: 0,
      roundTripTime: roundTripTime || 0
    };
    stats.bytesReceived = progressEvent.loaded;
    stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1e3);
    return stats;
  };
  const handleErrors = (error, request) => {
    if (request.timedout) {
      return {
        status: request.status,
        message: "HLS request timed-out at URL: " + request.uri,
        code: REQUEST_ERRORS.TIMEOUT,
        xhr: request
      };
    }
    if (request.aborted) {
      return {
        status: request.status,
        message: "HLS request aborted at URL: " + request.uri,
        code: REQUEST_ERRORS.ABORTED,
        xhr: request
      };
    }
    if (error) {
      return {
        status: request.status,
        message: "HLS request errored at URL: " + request.uri,
        code: REQUEST_ERRORS.FAILURE,
        xhr: request
      };
    }
    if (request.responseType === "arraybuffer" && request.response.byteLength === 0) {
      return {
        status: request.status,
        message: "Empty HLS response at URL: " + request.uri,
        code: REQUEST_ERRORS.FAILURE,
        xhr: request
      };
    }
    return null;
  };
  const handleKeyResponse = (segment, objects, finishProcessingFn) => (error, request) => {
    const response = request.response;
    const errorObj = handleErrors(error, request);
    if (errorObj) {
      return finishProcessingFn(errorObj, segment);
    }
    if (response.byteLength !== 16) {
      return finishProcessingFn({
        status: request.status,
        message: "Invalid HLS key at URL: " + request.uri,
        code: REQUEST_ERRORS.FAILURE,
        xhr: request
      }, segment);
    }
    const view = new DataView(response);
    const bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);
    for (let i = 0; i < objects.length; i++) {
      objects[i].bytes = bytes;
    }
    return finishProcessingFn(null, segment);
  };
  const parseInitSegment = (segment, callback) => {
    const type = detectContainerForBytes(segment.map.bytes);
    if (type !== "mp4") {
      const uri = segment.map.resolvedUri || segment.map.uri;
      return callback({
        internal: true,
        message: `Found unsupported ${type || "unknown"} container for initialization segment at URL: ${uri}`,
        code: REQUEST_ERRORS.FAILURE
      });
    }
    workerCallback({
      action: "probeMp4Tracks",
      data: segment.map.bytes,
      transmuxer: segment.transmuxer,
      callback: ({
        tracks,
        data
      }) => {
        segment.map.bytes = data;
        tracks.forEach(function(track) {
          segment.map.tracks = segment.map.tracks || {};
          if (segment.map.tracks[track.type]) {
            return;
          }
          segment.map.tracks[track.type] = track;
          if (typeof track.id === "number" && track.timescale) {
            segment.map.timescales = segment.map.timescales || {};
            segment.map.timescales[track.id] = track.timescale;
          }
        });
        return callback(null);
      }
    });
  };
  const handleInitSegmentResponse = ({
    segment,
    finishProcessingFn
  }) => (error, request) => {
    const errorObj = handleErrors(error, request);
    if (errorObj) {
      return finishProcessingFn(errorObj, segment);
    }
    const bytes = new Uint8Array(request.response);
    if (segment.map.key) {
      segment.map.encryptedBytes = bytes;
      return finishProcessingFn(null, segment);
    }
    segment.map.bytes = bytes;
    parseInitSegment(segment, function(parseError) {
      if (parseError) {
        parseError.xhr = request;
        parseError.status = request.status;
        return finishProcessingFn(parseError, segment);
      }
      finishProcessingFn(null, segment);
    });
  };
  const handleSegmentResponse = ({
    segment,
    finishProcessingFn,
    responseType
  }) => (error, request) => {
    const errorObj = handleErrors(error, request);
    if (errorObj) {
      return finishProcessingFn(errorObj, segment);
    }
    const newBytes = (
      // although responseText "should" exist, this guard serves to prevent an error being
      // thrown for two primary cases:
      // 1. the mime type override stops working, or is not implemented for a specific
      //    browser
      // 2. when using mock XHR libraries like sinon that do not allow the override behavior
      responseType === "arraybuffer" || !request.responseText ? request.response : stringToArrayBuffer(request.responseText.substring(segment.lastReachedChar || 0))
    );
    segment.stats = getRequestStats(request);
    if (segment.key) {
      segment.encryptedBytes = new Uint8Array(newBytes);
    } else {
      segment.bytes = new Uint8Array(newBytes);
    }
    return finishProcessingFn(null, segment);
  };
  const transmuxAndNotify = ({
    segment,
    bytes,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn,
    doneFn,
    onTransmuxerLog
  }) => {
    const fmp4Tracks = segment.map && segment.map.tracks || {};
    const isMuxed2 = Boolean(fmp4Tracks.audio && fmp4Tracks.video);
    let audioStartFn = timingInfoFn.bind(null, segment, "audio", "start");
    const audioEndFn = timingInfoFn.bind(null, segment, "audio", "end");
    let videoStartFn = timingInfoFn.bind(null, segment, "video", "start");
    const videoEndFn = timingInfoFn.bind(null, segment, "video", "end");
    const finish = () => transmux({
      bytes,
      transmuxer: segment.transmuxer,
      audioAppendStart: segment.audioAppendStart,
      gopsToAlignWith: segment.gopsToAlignWith,
      remux: isMuxed2,
      onData: (result) => {
        result.type = result.type === "combined" ? "video" : result.type;
        dataFn(segment, result);
      },
      onTrackInfo: (trackInfo) => {
        if (trackInfoFn) {
          if (isMuxed2) {
            trackInfo.isMuxed = true;
          }
          trackInfoFn(segment, trackInfo);
        }
      },
      onAudioTimingInfo: (audioTimingInfo) => {
        if (audioStartFn && typeof audioTimingInfo.start !== "undefined") {
          audioStartFn(audioTimingInfo.start);
          audioStartFn = null;
        }
        if (audioEndFn && typeof audioTimingInfo.end !== "undefined") {
          audioEndFn(audioTimingInfo.end);
        }
      },
      onVideoTimingInfo: (videoTimingInfo) => {
        if (videoStartFn && typeof videoTimingInfo.start !== "undefined") {
          videoStartFn(videoTimingInfo.start);
          videoStartFn = null;
        }
        if (videoEndFn && typeof videoTimingInfo.end !== "undefined") {
          videoEndFn(videoTimingInfo.end);
        }
      },
      onVideoSegmentTimingInfo: (videoSegmentTimingInfo) => {
        videoSegmentTimingInfoFn(videoSegmentTimingInfo);
      },
      onAudioSegmentTimingInfo: (audioSegmentTimingInfo) => {
        audioSegmentTimingInfoFn(audioSegmentTimingInfo);
      },
      onId3: (id3Frames, dispatchType) => {
        id3Fn(segment, id3Frames, dispatchType);
      },
      onCaptions: (captions) => {
        captionsFn(segment, [captions]);
      },
      isEndOfTimeline,
      onEndedTimeline: () => {
        endedTimelineFn();
      },
      onTransmuxerLog,
      onDone: (result) => {
        if (!doneFn) {
          return;
        }
        result.type = result.type === "combined" ? "video" : result.type;
        doneFn(null, segment, result);
      }
    });
    workerCallback({
      action: "probeTs",
      transmuxer: segment.transmuxer,
      data: bytes,
      baseStartTime: segment.baseStartTime,
      callback: (data) => {
        segment.bytes = bytes = data.data;
        const probeResult = data.result;
        if (probeResult) {
          trackInfoFn(segment, {
            hasAudio: probeResult.hasAudio,
            hasVideo: probeResult.hasVideo,
            isMuxed: isMuxed2
          });
          trackInfoFn = null;
        }
        finish();
      }
    });
  };
  const handleSegmentBytes = ({
    segment,
    bytes,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn,
    doneFn,
    onTransmuxerLog
  }) => {
    let bytesAsUint8Array = new Uint8Array(bytes);
    if (isLikelyFmp4MediaSegment(bytesAsUint8Array)) {
      segment.isFmp4 = true;
      const {
        tracks
      } = segment.map;
      const trackInfo = {
        isFmp4: true,
        hasVideo: !!tracks.video,
        hasAudio: !!tracks.audio
      };
      if (tracks.audio && tracks.audio.codec && tracks.audio.codec !== "enca") {
        trackInfo.audioCodec = tracks.audio.codec;
      }
      if (tracks.video && tracks.video.codec && tracks.video.codec !== "encv") {
        trackInfo.videoCodec = tracks.video.codec;
      }
      if (tracks.video && tracks.audio) {
        trackInfo.isMuxed = true;
      }
      trackInfoFn(segment, trackInfo);
      const finishLoading = (captions, id3Frames) => {
        dataFn(segment, {
          data: bytesAsUint8Array,
          type: trackInfo.hasAudio && !trackInfo.isMuxed ? "audio" : "video"
        });
        if (id3Frames && id3Frames.length) {
          id3Fn(segment, id3Frames);
        }
        if (captions && captions.length) {
          captionsFn(segment, captions);
        }
        doneFn(null, segment, {});
      };
      workerCallback({
        action: "probeMp4StartTime",
        timescales: segment.map.timescales,
        data: bytesAsUint8Array,
        transmuxer: segment.transmuxer,
        callback: ({
          data,
          startTime
        }) => {
          bytes = data.buffer;
          segment.bytes = bytesAsUint8Array = data;
          if (trackInfo.hasAudio && !trackInfo.isMuxed) {
            timingInfoFn(segment, "audio", "start", startTime);
          }
          if (trackInfo.hasVideo) {
            timingInfoFn(segment, "video", "start", startTime);
          }
          workerCallback({
            action: "probeEmsgID3",
            data: bytesAsUint8Array,
            transmuxer: segment.transmuxer,
            offset: startTime,
            callback: ({
              emsgData,
              id3Frames
            }) => {
              bytes = emsgData.buffer;
              segment.bytes = bytesAsUint8Array = emsgData;
              if (!tracks.video || !emsgData.byteLength || !segment.transmuxer) {
                finishLoading(void 0, id3Frames);
                return;
              }
              workerCallback({
                action: "pushMp4Captions",
                endAction: "mp4Captions",
                transmuxer: segment.transmuxer,
                data: bytesAsUint8Array,
                timescales: segment.map.timescales,
                trackIds: [tracks.video.id],
                callback: (message) => {
                  bytes = message.data.buffer;
                  segment.bytes = bytesAsUint8Array = message.data;
                  message.logs.forEach(function(log2) {
                    onTransmuxerLog(merge(log2, {
                      stream: "mp4CaptionParser"
                    }));
                  });
                  finishLoading(message.captions, id3Frames);
                }
              });
            }
          });
        }
      });
      return;
    }
    if (!segment.transmuxer) {
      doneFn(null, segment, {});
      return;
    }
    if (typeof segment.container === "undefined") {
      segment.container = detectContainerForBytes(bytesAsUint8Array);
    }
    if (segment.container !== "ts" && segment.container !== "aac") {
      trackInfoFn(segment, {
        hasAudio: false,
        hasVideo: false
      });
      doneFn(null, segment, {});
      return;
    }
    transmuxAndNotify({
      segment,
      bytes,
      trackInfoFn,
      timingInfoFn,
      videoSegmentTimingInfoFn,
      audioSegmentTimingInfoFn,
      id3Fn,
      captionsFn,
      isEndOfTimeline,
      endedTimelineFn,
      dataFn,
      doneFn,
      onTransmuxerLog
    });
  };
  const decrypt = function({
    id,
    key,
    encryptedBytes,
    decryptionWorker
  }, callback) {
    const decryptionHandler = (event) => {
      if (event.data.source === id) {
        decryptionWorker.removeEventListener("message", decryptionHandler);
        const decrypted = event.data.decrypted;
        callback(new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength));
      }
    };
    decryptionWorker.addEventListener("message", decryptionHandler);
    let keyBytes;
    if (key.bytes.slice) {
      keyBytes = key.bytes.slice();
    } else {
      keyBytes = new Uint32Array(Array.prototype.slice.call(key.bytes));
    }
    decryptionWorker.postMessage(createTransferableMessage({
      source: id,
      encrypted: encryptedBytes,
      key: keyBytes,
      iv: key.iv
    }), [encryptedBytes.buffer, keyBytes.buffer]);
  };
  const decryptSegment = ({
    decryptionWorker,
    segment,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn,
    doneFn,
    onTransmuxerLog
  }) => {
    decrypt({
      id: segment.requestId,
      key: segment.key,
      encryptedBytes: segment.encryptedBytes,
      decryptionWorker
    }, (decryptedBytes) => {
      segment.bytes = decryptedBytes;
      handleSegmentBytes({
        segment,
        bytes: segment.bytes,
        trackInfoFn,
        timingInfoFn,
        videoSegmentTimingInfoFn,
        audioSegmentTimingInfoFn,
        id3Fn,
        captionsFn,
        isEndOfTimeline,
        endedTimelineFn,
        dataFn,
        doneFn,
        onTransmuxerLog
      });
    });
  };
  const waitForCompletion = ({
    activeXhrs,
    decryptionWorker,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn,
    doneFn,
    onTransmuxerLog
  }) => {
    let count = 0;
    let didError = false;
    return (error, segment) => {
      if (didError) {
        return;
      }
      if (error) {
        didError = true;
        abortAll(activeXhrs);
        return doneFn(error, segment);
      }
      count += 1;
      if (count === activeXhrs.length) {
        const segmentFinish = function() {
          if (segment.encryptedBytes) {
            return decryptSegment({
              decryptionWorker,
              segment,
              trackInfoFn,
              timingInfoFn,
              videoSegmentTimingInfoFn,
              audioSegmentTimingInfoFn,
              id3Fn,
              captionsFn,
              isEndOfTimeline,
              endedTimelineFn,
              dataFn,
              doneFn,
              onTransmuxerLog
            });
          }
          handleSegmentBytes({
            segment,
            bytes: segment.bytes,
            trackInfoFn,
            timingInfoFn,
            videoSegmentTimingInfoFn,
            audioSegmentTimingInfoFn,
            id3Fn,
            captionsFn,
            isEndOfTimeline,
            endedTimelineFn,
            dataFn,
            doneFn,
            onTransmuxerLog
          });
        };
        segment.endOfAllRequests = Date.now();
        if (segment.map && segment.map.encryptedBytes && !segment.map.bytes) {
          return decrypt({
            decryptionWorker,
            // add -init to the "id" to differentiate between segment
            // and init segment decryption, just in case they happen
            // at the same time at some point in the future.
            id: segment.requestId + "-init",
            encryptedBytes: segment.map.encryptedBytes,
            key: segment.map.key
          }, (decryptedBytes) => {
            segment.map.bytes = decryptedBytes;
            parseInitSegment(segment, (parseError) => {
              if (parseError) {
                abortAll(activeXhrs);
                return doneFn(parseError, segment);
              }
              segmentFinish();
            });
          });
        }
        segmentFinish();
      }
    };
  };
  const handleLoadEnd = ({
    loadendState,
    abortFn
  }) => (event) => {
    const request = event.target;
    if (request.aborted && abortFn && !loadendState.calledAbortFn) {
      abortFn();
      loadendState.calledAbortFn = true;
    }
  };
  const handleProgress = ({
    segment,
    progressFn,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn
  }) => (event) => {
    const request = event.target;
    if (request.aborted) {
      return;
    }
    segment.stats = merge(segment.stats, getProgressStats(event));
    if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {
      segment.stats.firstBytesReceivedAt = Date.now();
    }
    return progressFn(event, segment);
  };
  const mediaSegmentRequest = ({
    xhr,
    xhrOptions,
    decryptionWorker,
    segment,
    abortFn,
    progressFn,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn,
    doneFn,
    onTransmuxerLog
  }) => {
    const activeXhrs = [];
    const finishProcessingFn = waitForCompletion({
      activeXhrs,
      decryptionWorker,
      trackInfoFn,
      timingInfoFn,
      videoSegmentTimingInfoFn,
      audioSegmentTimingInfoFn,
      id3Fn,
      captionsFn,
      isEndOfTimeline,
      endedTimelineFn,
      dataFn,
      doneFn,
      onTransmuxerLog
    });
    if (segment.key && !segment.key.bytes) {
      const objects = [segment.key];
      if (segment.map && !segment.map.bytes && segment.map.key && segment.map.key.resolvedUri === segment.key.resolvedUri) {
        objects.push(segment.map.key);
      }
      const keyRequestOptions = merge(xhrOptions, {
        uri: segment.key.resolvedUri,
        responseType: "arraybuffer"
      });
      const keyRequestCallback = handleKeyResponse(segment, objects, finishProcessingFn);
      const keyXhr = xhr(keyRequestOptions, keyRequestCallback);
      activeXhrs.push(keyXhr);
    }
    if (segment.map && !segment.map.bytes) {
      const differentMapKey = segment.map.key && (!segment.key || segment.key.resolvedUri !== segment.map.key.resolvedUri);
      if (differentMapKey) {
        const mapKeyRequestOptions = merge(xhrOptions, {
          uri: segment.map.key.resolvedUri,
          responseType: "arraybuffer"
        });
        const mapKeyRequestCallback = handleKeyResponse(segment, [segment.map.key], finishProcessingFn);
        const mapKeyXhr = xhr(mapKeyRequestOptions, mapKeyRequestCallback);
        activeXhrs.push(mapKeyXhr);
      }
      const initSegmentOptions = merge(xhrOptions, {
        uri: segment.map.resolvedUri,
        responseType: "arraybuffer",
        headers: segmentXhrHeaders(segment.map)
      });
      const initSegmentRequestCallback = handleInitSegmentResponse({
        segment,
        finishProcessingFn
      });
      const initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);
      activeXhrs.push(initSegmentXhr);
    }
    const segmentRequestOptions = merge(xhrOptions, {
      uri: segment.part && segment.part.resolvedUri || segment.resolvedUri,
      responseType: "arraybuffer",
      headers: segmentXhrHeaders(segment)
    });
    const segmentRequestCallback = handleSegmentResponse({
      segment,
      finishProcessingFn,
      responseType: segmentRequestOptions.responseType
    });
    const segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);
    segmentXhr.addEventListener("progress", handleProgress({
      segment,
      progressFn,
      trackInfoFn,
      timingInfoFn,
      videoSegmentTimingInfoFn,
      audioSegmentTimingInfoFn,
      id3Fn,
      captionsFn,
      isEndOfTimeline,
      endedTimelineFn,
      dataFn
    }));
    activeXhrs.push(segmentXhr);
    const loadendState = {};
    activeXhrs.forEach((activeXhr) => {
      activeXhr.addEventListener("loadend", handleLoadEnd({
        loadendState,
        abortFn
      }));
    });
    return () => abortAll(activeXhrs);
  };
  const logFn$1 = logger("CodecUtils");
  const getCodecs = function(media) {
    const mediaAttributes = media.attributes || {};
    if (mediaAttributes.CODECS) {
      return parseCodecs(mediaAttributes.CODECS);
    }
  };
  const isMaat = (main, media) => {
    const mediaAttributes = media.attributes || {};
    return main && main.mediaGroups && main.mediaGroups.AUDIO && mediaAttributes.AUDIO && main.mediaGroups.AUDIO[mediaAttributes.AUDIO];
  };
  const isMuxed = (main, media) => {
    if (!isMaat(main, media)) {
      return true;
    }
    const mediaAttributes = media.attributes || {};
    const audioGroup = main.mediaGroups.AUDIO[mediaAttributes.AUDIO];
    for (const groupId in audioGroup) {
      if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) {
        return true;
      }
    }
    return false;
  };
  const unwrapCodecList = function(codecList) {
    const codecs = {};
    codecList.forEach(({
      mediaType,
      type,
      details
    }) => {
      codecs[mediaType] = codecs[mediaType] || [];
      codecs[mediaType].push(translateLegacyCodec(`${type}${details}`));
    });
    Object.keys(codecs).forEach(function(mediaType) {
      if (codecs[mediaType].length > 1) {
        logFn$1(`multiple ${mediaType} codecs found as attributes: ${codecs[mediaType].join(", ")}. Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.`);
        codecs[mediaType] = null;
        return;
      }
      codecs[mediaType] = codecs[mediaType][0];
    });
    return codecs;
  };
  const codecCount = function(codecObj) {
    let count = 0;
    if (codecObj.audio) {
      count++;
    }
    if (codecObj.video) {
      count++;
    }
    return count;
  };
  const codecsForPlaylist = function(main, media) {
    const mediaAttributes = media.attributes || {};
    const codecInfo = unwrapCodecList(getCodecs(media) || []);
    if (isMaat(main, media) && !codecInfo.audio) {
      if (!isMuxed(main, media)) {
        const defaultCodecs = unwrapCodecList(codecsFromDefault(main, mediaAttributes.AUDIO) || []);
        if (defaultCodecs.audio) {
          codecInfo.audio = defaultCodecs.audio;
        }
      }
    }
    return codecInfo;
  };
  const logFn = logger("PlaylistSelector");
  const representationToString = function(representation) {
    if (!representation || !representation.playlist) {
      return;
    }
    const playlist = representation.playlist;
    return JSON.stringify({
      id: playlist.id,
      bandwidth: representation.bandwidth,
      width: representation.width,
      height: representation.height,
      codecs: playlist.attributes && playlist.attributes.CODECS || ""
    });
  };
  const safeGetComputedStyle = function(el, property) {
    if (!el) {
      return "";
    }
    const result = window.getComputedStyle(el);
    if (!result) {
      return "";
    }
    return result[property];
  };
  const stableSort = function(array, sortFn) {
    const newArray = array.slice();
    array.sort(function(left, right) {
      const cmp = sortFn(left, right);
      if (cmp === 0) {
        return newArray.indexOf(left) - newArray.indexOf(right);
      }
      return cmp;
    });
  };
  const comparePlaylistBandwidth = function(left, right) {
    let leftBandwidth;
    let rightBandwidth;
    if (left.attributes.BANDWIDTH) {
      leftBandwidth = left.attributes.BANDWIDTH;
    }
    leftBandwidth = leftBandwidth || window.Number.MAX_VALUE;
    if (right.attributes.BANDWIDTH) {
      rightBandwidth = right.attributes.BANDWIDTH;
    }
    rightBandwidth = rightBandwidth || window.Number.MAX_VALUE;
    return leftBandwidth - rightBandwidth;
  };
  const comparePlaylistResolution = function(left, right) {
    let leftWidth;
    let rightWidth;
    if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {
      leftWidth = left.attributes.RESOLUTION.width;
    }
    leftWidth = leftWidth || window.Number.MAX_VALUE;
    if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {
      rightWidth = right.attributes.RESOLUTION.width;
    }
    rightWidth = rightWidth || window.Number.MAX_VALUE;
    if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {
      return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;
    }
    return leftWidth - rightWidth;
  };
  let simpleSelector = function(main, playerBandwidth, playerWidth, playerHeight, limitRenditionByPlayerDimensions, playlistController) {
    if (!main) {
      return;
    }
    const options = {
      bandwidth: playerBandwidth,
      width: playerWidth,
      height: playerHeight,
      limitRenditionByPlayerDimensions
    };
    let playlists = main.playlists;
    if (Playlist.isAudioOnly(main)) {
      playlists = playlistController.getAudioTrackPlaylists_();
      options.audioOnly = true;
    }
    let sortedPlaylistReps = playlists.map((playlist) => {
      let bandwidth;
      const width = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;
      const height = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;
      bandwidth = playlist.attributes && playlist.attributes.BANDWIDTH;
      bandwidth = bandwidth || window.Number.MAX_VALUE;
      return {
        bandwidth,
        width,
        height,
        playlist
      };
    });
    stableSort(sortedPlaylistReps, (left, right) => left.bandwidth - right.bandwidth);
    sortedPlaylistReps = sortedPlaylistReps.filter((rep) => !Playlist.isIncompatible(rep.playlist));
    let enabledPlaylistReps = sortedPlaylistReps.filter((rep) => Playlist.isEnabled(rep.playlist));
    if (!enabledPlaylistReps.length) {
      enabledPlaylistReps = sortedPlaylistReps.filter((rep) => !Playlist.isDisabled(rep.playlist));
    }
    const bandwidthPlaylistReps = enabledPlaylistReps.filter((rep) => rep.bandwidth * Config.BANDWIDTH_VARIANCE < playerBandwidth);
    let highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1];
    const bandwidthBestRep = bandwidthPlaylistReps.filter((rep) => rep.bandwidth === highestRemainingBandwidthRep.bandwidth)[0];
    if (limitRenditionByPlayerDimensions === false) {
      const chosenRep2 = bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
      if (chosenRep2 && chosenRep2.playlist) {
        let type = "sortedPlaylistReps";
        if (bandwidthBestRep) {
          type = "bandwidthBestRep";
        }
        if (enabledPlaylistReps[0]) {
          type = "enabledPlaylistReps";
        }
        logFn(`choosing ${representationToString(chosenRep2)} using ${type} with options`, options);
        return chosenRep2.playlist;
      }
      logFn("could not choose a playlist with options", options);
      return null;
    }
    const haveResolution = bandwidthPlaylistReps.filter((rep) => rep.width && rep.height);
    stableSort(haveResolution, (left, right) => left.width - right.width);
    const resolutionBestRepList = haveResolution.filter((rep) => rep.width === playerWidth && rep.height === playerHeight);
    highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1];
    const resolutionBestRep = resolutionBestRepList.filter((rep) => rep.bandwidth === highestRemainingBandwidthRep.bandwidth)[0];
    let resolutionPlusOneList;
    let resolutionPlusOneSmallest;
    let resolutionPlusOneRep;
    if (!resolutionBestRep) {
      resolutionPlusOneList = haveResolution.filter((rep) => rep.width > playerWidth || rep.height > playerHeight);
      resolutionPlusOneSmallest = resolutionPlusOneList.filter((rep) => rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height);
      highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];
      resolutionPlusOneRep = resolutionPlusOneSmallest.filter((rep) => rep.bandwidth === highestRemainingBandwidthRep.bandwidth)[0];
    }
    let leastPixelDiffRep;
    if (playlistController.leastPixelDiffSelector) {
      const leastPixelDiffList = haveResolution.map((rep) => {
        rep.pixelDiff = Math.abs(rep.width - playerWidth) + Math.abs(rep.height - playerHeight);
        return rep;
      });
      stableSort(leastPixelDiffList, (left, right) => {
        if (left.pixelDiff === right.pixelDiff) {
          return right.bandwidth - left.bandwidth;
        }
        return left.pixelDiff - right.pixelDiff;
      });
      leastPixelDiffRep = leastPixelDiffList[0];
    }
    const chosenRep = leastPixelDiffRep || resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
    if (chosenRep && chosenRep.playlist) {
      let type = "sortedPlaylistReps";
      if (leastPixelDiffRep) {
        type = "leastPixelDiffRep";
      } else if (resolutionPlusOneRep) {
        type = "resolutionPlusOneRep";
      } else if (resolutionBestRep) {
        type = "resolutionBestRep";
      } else if (bandwidthBestRep) {
        type = "bandwidthBestRep";
      } else if (enabledPlaylistReps[0]) {
        type = "enabledPlaylistReps";
      }
      logFn(`choosing ${representationToString(chosenRep)} using ${type} with options`, options);
      return chosenRep.playlist;
    }
    logFn("could not choose a playlist with options", options);
    return null;
  };
  const lastBandwidthSelector = function() {
    const pixelRatio = this.useDevicePixelRatio ? window.devicePixelRatio || 1 : 1;
    return simpleSelector(this.playlists.main, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.playlistController_);
  };
  const movingAverageBandwidthSelector = function(decay) {
    let average = -1;
    let lastSystemBandwidth = -1;
    if (decay < 0 || decay > 1) {
      throw new Error("Moving average bandwidth decay must be between 0 and 1.");
    }
    return function() {
      const pixelRatio = this.useDevicePixelRatio ? window.devicePixelRatio || 1 : 1;
      if (average < 0) {
        average = this.systemBandwidth;
        lastSystemBandwidth = this.systemBandwidth;
      }
      if (this.systemBandwidth > 0 && this.systemBandwidth !== lastSystemBandwidth) {
        average = decay * this.systemBandwidth + (1 - decay) * average;
        lastSystemBandwidth = this.systemBandwidth;
      }
      return simpleSelector(this.playlists.main, average, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.playlistController_);
    };
  };
  const minRebufferMaxBandwidthSelector = function(settings) {
    const {
      main,
      currentTime,
      bandwidth,
      duration: duration2,
      segmentDuration,
      timeUntilRebuffer: timeUntilRebuffer2,
      currentTimeline,
      syncController
    } = settings;
    const compatiblePlaylists = main.playlists.filter((playlist) => !Playlist.isIncompatible(playlist));
    let enabledPlaylists = compatiblePlaylists.filter(Playlist.isEnabled);
    if (!enabledPlaylists.length) {
      enabledPlaylists = compatiblePlaylists.filter((playlist) => !Playlist.isDisabled(playlist));
    }
    const bandwidthPlaylists = enabledPlaylists.filter(Playlist.hasAttribute.bind(null, "BANDWIDTH"));
    const rebufferingEstimates = bandwidthPlaylists.map((playlist) => {
      const syncPoint = syncController.getSyncPoint(playlist, duration2, currentTimeline, currentTime);
      const numRequests = syncPoint ? 1 : 2;
      const requestTimeEstimate = Playlist.estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);
      const rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer2;
      return {
        playlist,
        rebufferingImpact
      };
    });
    const noRebufferingPlaylists = rebufferingEstimates.filter((estimate) => estimate.rebufferingImpact <= 0);
    stableSort(noRebufferingPlaylists, (a, b) => comparePlaylistBandwidth(b.playlist, a.playlist));
    if (noRebufferingPlaylists.length) {
      return noRebufferingPlaylists[0];
    }
    stableSort(rebufferingEstimates, (a, b) => a.rebufferingImpact - b.rebufferingImpact);
    return rebufferingEstimates[0] || null;
  };
  const lowestBitrateCompatibleVariantSelector = function() {
    const playlists = this.playlists.main.playlists.filter(Playlist.isEnabled);
    stableSort(playlists, (a, b) => comparePlaylistBandwidth(a, b));
    const playlistsWithVideo = playlists.filter((playlist) => !!codecsForPlaylist(this.playlists.main, playlist).video);
    return playlistsWithVideo[0] || null;
  };
  const concatSegments = (segmentObj) => {
    let offset = 0;
    let tempBuffer;
    if (segmentObj.bytes) {
      tempBuffer = new Uint8Array(segmentObj.bytes);
      segmentObj.segments.forEach((segment) => {
        tempBuffer.set(segment, offset);
        offset += segment.byteLength;
      });
    }
    return tempBuffer;
  };
  const createCaptionsTrackIfNotExists = function(inbandTextTracks, tech, captionStream) {
    if (!inbandTextTracks[captionStream]) {
      tech.trigger({
        type: "usage",
        name: "vhs-608"
      });
      let instreamId = captionStream;
      if (/^cc708_/.test(captionStream)) {
        instreamId = "SERVICE" + captionStream.split("_")[1];
      }
      const track = tech.textTracks().getTrackById(instreamId);
      if (track) {
        inbandTextTracks[captionStream] = track;
      } else {
        const captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
        let label = captionStream;
        let language = captionStream;
        let def = false;
        const captionService = captionServices[instreamId];
        if (captionService) {
          label = captionService.label;
          language = captionService.language;
          def = captionService.default;
        }
        inbandTextTracks[captionStream] = tech.addRemoteTextTrack({
          kind: "captions",
          id: instreamId,
          // TODO: investigate why this doesn't seem to turn the caption on by default
          default: def,
          label,
          language
        }, false).track;
      }
    }
  };
  const addCaptionData = function({
    inbandTextTracks,
    captionArray,
    timestampOffset
  }) {
    if (!captionArray) {
      return;
    }
    const Cue = window.WebKitDataCue || window.VTTCue;
    captionArray.forEach((caption) => {
      const track = caption.stream;
      if (caption.content) {
        caption.content.forEach((value) => {
          const cue = new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, value.text);
          cue.line = value.line;
          cue.align = "left";
          cue.position = value.position;
          cue.positionAlign = "line-left";
          inbandTextTracks[track].addCue(cue);
        });
      } else {
        inbandTextTracks[track].addCue(new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, caption.text));
      }
    });
  };
  const deprecateOldCue = function(cue) {
    Object.defineProperties(cue.frame, {
      id: {
        get() {
          videojs.log.warn("cue.frame.id is deprecated. Use cue.value.key instead.");
          return cue.value.key;
        }
      },
      value: {
        get() {
          videojs.log.warn("cue.frame.value is deprecated. Use cue.value.data instead.");
          return cue.value.data;
        }
      },
      privateData: {
        get() {
          videojs.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead.");
          return cue.value.data;
        }
      }
    });
  };
  const addMetadata = ({
    inbandTextTracks,
    metadataArray,
    timestampOffset,
    videoDuration
  }) => {
    if (!metadataArray) {
      return;
    }
    const Cue = window.WebKitDataCue || window.VTTCue;
    const metadataTrack = inbandTextTracks.metadataTrack_;
    if (!metadataTrack) {
      return;
    }
    metadataArray.forEach((metadata) => {
      const time = metadata.cueTime + timestampOffset;
      if (typeof time !== "number" || window.isNaN(time) || time < 0 || !(time < Infinity)) {
        return;
      }
      if (!metadata.frames || !metadata.frames.length) {
        return;
      }
      metadata.frames.forEach((frame) => {
        const cue = new Cue(time, time, frame.value || frame.url || frame.data || "");
        cue.frame = frame;
        cue.value = frame;
        deprecateOldCue(cue);
        metadataTrack.addCue(cue);
      });
    });
    if (!metadataTrack.cues || !metadataTrack.cues.length) {
      return;
    }
    const cues = metadataTrack.cues;
    const cuesArray = [];
    for (let i = 0; i < cues.length; i++) {
      if (cues[i]) {
        cuesArray.push(cues[i]);
      }
    }
    const cuesGroupedByStartTime = cuesArray.reduce((obj, cue) => {
      const timeSlot = obj[cue.startTime] || [];
      timeSlot.push(cue);
      obj[cue.startTime] = timeSlot;
      return obj;
    }, {});
    const sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort((a, b) => Number(a) - Number(b));
    sortedStartTimes.forEach((startTime, idx) => {
      const cueGroup = cuesGroupedByStartTime[startTime];
      const finiteDuration = isFinite(videoDuration) ? videoDuration : startTime;
      const nextTime = Number(sortedStartTimes[idx + 1]) || finiteDuration;
      cueGroup.forEach((cue) => {
        cue.endTime = nextTime;
      });
    });
  };
  const dateRangeAttr = {
    id: "ID",
    class: "CLASS",
    startDate: "START-DATE",
    duration: "DURATION",
    endDate: "END-DATE",
    endOnNext: "END-ON-NEXT",
    plannedDuration: "PLANNED-DURATION",
    scte35Out: "SCTE35-OUT",
    scte35In: "SCTE35-IN"
  };
  const dateRangeKeysToOmit = /* @__PURE__ */ new Set(["id", "class", "startDate", "duration", "endDate", "endOnNext", "startTime", "endTime", "processDateRange"]);
  const addDateRangeMetadata = ({
    inbandTextTracks,
    dateRanges
  }) => {
    const metadataTrack = inbandTextTracks.metadataTrack_;
    if (!metadataTrack) {
      return;
    }
    const Cue = window.WebKitDataCue || window.VTTCue;
    dateRanges.forEach((dateRange) => {
      for (const key of Object.keys(dateRange)) {
        if (dateRangeKeysToOmit.has(key)) {
          continue;
        }
        const cue = new Cue(dateRange.startTime, dateRange.endTime, "");
        cue.id = dateRange.id;
        cue.type = "com.apple.quicktime.HLS";
        cue.value = {
          key: dateRangeAttr[key],
          data: dateRange[key]
        };
        if (key === "scte35Out" || key === "scte35In") {
          cue.value.data = new Uint8Array(cue.value.data.match(/[\da-f]{2}/gi)).buffer;
        }
        metadataTrack.addCue(cue);
      }
      dateRange.processDateRange();
    });
  };
  const createMetadataTrackIfNotExists = (inbandTextTracks, dispatchType, tech) => {
    if (inbandTextTracks.metadataTrack_) {
      return;
    }
    inbandTextTracks.metadataTrack_ = tech.addRemoteTextTrack({
      kind: "metadata",
      label: "Timed Metadata"
    }, false).track;
    if (!videojs.browser.IS_ANY_SAFARI) {
      inbandTextTracks.metadataTrack_.inBandMetadataTrackDispatchType = dispatchType;
    }
  };
  const removeCuesFromTrack = function(start, end, track) {
    let i;
    let cue;
    if (!track) {
      return;
    }
    if (!track.cues) {
      return;
    }
    i = track.cues.length;
    while (i--) {
      cue = track.cues[i];
      if (cue.startTime >= start && cue.endTime <= end) {
        track.removeCue(cue);
      }
    }
  };
  const removeDuplicateCuesFromTrack = function(track) {
    const cues = track.cues;
    if (!cues) {
      return;
    }
    const uniqueCues = {};
    for (let i = cues.length - 1; i >= 0; i--) {
      const cue = cues[i];
      const cueKey = `${cue.startTime}-${cue.endTime}-${cue.text}`;
      if (uniqueCues[cueKey]) {
        track.removeCue(cue);
      } else {
        uniqueCues[cueKey] = cue;
      }
    }
  };
  const gopsSafeToAlignWith = (buffer, currentTime, mapping) => {
    if (typeof currentTime === "undefined" || currentTime === null || !buffer.length) {
      return [];
    }
    const currentTimePts = Math.ceil((currentTime - mapping + 3) * clock_1);
    let i;
    for (i = 0; i < buffer.length; i++) {
      if (buffer[i].pts > currentTimePts) {
        break;
      }
    }
    return buffer.slice(i);
  };
  const updateGopBuffer = (buffer, gops, replace) => {
    if (!gops.length) {
      return buffer;
    }
    if (replace) {
      return gops.slice();
    }
    const start = gops[0].pts;
    let i = 0;
    for (i; i < buffer.length; i++) {
      if (buffer[i].pts >= start) {
        break;
      }
    }
    return buffer.slice(0, i).concat(gops);
  };
  const removeGopBuffer = (buffer, start, end, mapping) => {
    const startPts = Math.ceil((start - mapping) * clock_1);
    const endPts = Math.ceil((end - mapping) * clock_1);
    const updatedBuffer = buffer.slice();
    let i = buffer.length;
    while (i--) {
      if (buffer[i].pts <= endPts) {
        break;
      }
    }
    if (i === -1) {
      return updatedBuffer;
    }
    let j = i + 1;
    while (j--) {
      if (buffer[j].pts <= startPts) {
        break;
      }
    }
    j = Math.max(j, 0);
    updatedBuffer.splice(j, i - j + 1);
    return updatedBuffer;
  };
  const shallowEqual = function(a, b) {
    if (!a && !b || !a && b || a && !b) {
      return false;
    }
    if (a === b) {
      return true;
    }
    const akeys = Object.keys(a).sort();
    const bkeys = Object.keys(b).sort();
    if (akeys.length !== bkeys.length) {
      return false;
    }
    for (let i = 0; i < akeys.length; i++) {
      const key = akeys[i];
      if (key !== bkeys[i]) {
        return false;
      }
      if (a[key] !== b[key]) {
        return false;
      }
    }
    return true;
  };
  const QUOTA_EXCEEDED_ERR = 22;
  const getSyncSegmentCandidate = function(currentTimeline, segments, targetTime) {
    segments = segments || [];
    const timelineSegments = [];
    let time = 0;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      if (currentTimeline === segment.timeline) {
        timelineSegments.push(i);
        time += segment.duration;
        if (time > targetTime) {
          return i;
        }
      }
    }
    if (timelineSegments.length === 0) {
      return 0;
    }
    return timelineSegments[timelineSegments.length - 1];
  };
  const MIN_BACK_BUFFER = 1;
  const CHECK_BUFFER_DELAY = 500;
  const finite = (num) => typeof num === "number" && isFinite(num);
  const MIN_SEGMENT_DURATION_TO_SAVE_STATS = 1 / 60;
  const illegalMediaSwitch = (loaderType, startingMedia, trackInfo) => {
    if (loaderType !== "main" || !startingMedia || !trackInfo) {
      return null;
    }
    if (!trackInfo.hasAudio && !trackInfo.hasVideo) {
      return "Neither audio nor video found in segment.";
    }
    if (startingMedia.hasVideo && !trackInfo.hasVideo) {
      return "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest.";
    }
    if (!startingMedia.hasVideo && trackInfo.hasVideo) {
      return "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest.";
    }
    return null;
  };
  const safeBackBufferTrimTime = (seekable2, currentTime, targetDuration) => {
    let trimTime = currentTime - Config.BACK_BUFFER_LENGTH;
    if (seekable2.length) {
      trimTime = Math.max(trimTime, seekable2.start(0));
    }
    const maxTrimTime = currentTime - targetDuration;
    return Math.min(maxTrimTime, trimTime);
  };
  const segmentInfoString = (segmentInfo) => {
    const {
      startOfSegment,
      duration: duration2,
      segment,
      part,
      playlist: {
        mediaSequence: seq,
        id,
        segments = []
      },
      mediaIndex: index,
      partIndex,
      timeline
    } = segmentInfo;
    const segmentLen = segments.length - 1;
    let selection = "mediaIndex/partIndex increment";
    if (segmentInfo.getMediaInfoForTime) {
      selection = `getMediaInfoForTime (${segmentInfo.getMediaInfoForTime})`;
    } else if (segmentInfo.isSyncRequest) {
      selection = "getSyncSegmentCandidate (isSyncRequest)";
    }
    if (segmentInfo.independent) {
      selection += ` with independent ${segmentInfo.independent}`;
    }
    const hasPartIndex = typeof partIndex === "number";
    const name = segmentInfo.segment.uri ? "segment" : "pre-segment";
    const zeroBasedPartCount = hasPartIndex ? getKnownPartCount({
      preloadSegment: segment
    }) - 1 : 0;
    return `${name} [${seq + index}/${seq + segmentLen}]` + (hasPartIndex ? ` part [${partIndex}/${zeroBasedPartCount}]` : "") + ` segment start/end [${segment.start} => ${segment.end}]` + (hasPartIndex ? ` part start/end [${part.start} => ${part.end}]` : "") + ` startOfSegment [${startOfSegment}] duration [${duration2}] timeline [${timeline}] selected by [${selection}] playlist [${id}]`;
  };
  const timingInfoPropertyForMedia = (mediaType) => `${mediaType}TimingInfo`;
  const timestampOffsetForSegment = ({
    segmentTimeline,
    currentTimeline,
    startOfSegment,
    buffered,
    overrideCheck
  }) => {
    if (!overrideCheck && segmentTimeline === currentTimeline) {
      return null;
    }
    if (segmentTimeline < currentTimeline) {
      return startOfSegment;
    }
    return buffered.length ? buffered.end(buffered.length - 1) : startOfSegment;
  };
  const shouldWaitForTimelineChange = ({
    timelineChangeController,
    currentTimeline,
    segmentTimeline,
    loaderType,
    audioDisabled
  }) => {
    if (currentTimeline === segmentTimeline) {
      return false;
    }
    if (loaderType === "audio") {
      const lastMainTimelineChange = timelineChangeController.lastTimelineChange({
        type: "main"
      });
      return !lastMainTimelineChange || lastMainTimelineChange.to !== segmentTimeline;
    }
    if (loaderType === "main" && audioDisabled) {
      const pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({
        type: "audio"
      });
      if (pendingAudioTimelineChange && pendingAudioTimelineChange.to === segmentTimeline) {
        return false;
      }
      return true;
    }
    return false;
  };
  const mediaDuration = (timingInfos) => {
    let maxDuration = 0;
    ["video", "audio"].forEach(function(type) {
      const typeTimingInfo = timingInfos[`${type}TimingInfo`];
      if (!typeTimingInfo) {
        return;
      }
      const {
        start,
        end
      } = typeTimingInfo;
      let duration2;
      if (typeof start === "bigint" || typeof end === "bigint") {
        duration2 = window.BigInt(end) - window.BigInt(start);
      } else if (typeof start === "number" && typeof end === "number") {
        duration2 = end - start;
      }
      if (typeof duration2 !== "undefined" && duration2 > maxDuration) {
        maxDuration = duration2;
      }
    });
    if (typeof maxDuration === "bigint" && maxDuration < Number.MAX_SAFE_INTEGER) {
      maxDuration = Number(maxDuration);
    }
    return maxDuration;
  };
  const segmentTooLong = ({
    segmentDuration,
    maxDuration
  }) => {
    if (!segmentDuration) {
      return false;
    }
    return Math.round(segmentDuration) > maxDuration + TIME_FUDGE_FACTOR;
  };
  const getTroublesomeSegmentDurationMessage = (segmentInfo, sourceType) => {
    if (sourceType !== "hls") {
      return null;
    }
    const segmentDuration = mediaDuration({
      audioTimingInfo: segmentInfo.audioTimingInfo,
      videoTimingInfo: segmentInfo.videoTimingInfo
    });
    if (!segmentDuration) {
      return null;
    }
    const targetDuration = segmentInfo.playlist.targetDuration;
    const isSegmentWayTooLong = segmentTooLong({
      segmentDuration,
      maxDuration: targetDuration * 2
    });
    const isSegmentSlightlyTooLong = segmentTooLong({
      segmentDuration,
      maxDuration: targetDuration
    });
    const segmentTooLongMessage = `Segment with index ${segmentInfo.mediaIndex} from playlist ${segmentInfo.playlist.id} has a duration of ${segmentDuration} when the reported duration is ${segmentInfo.duration} and the target duration is ${targetDuration}. For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1`;
    if (isSegmentWayTooLong || isSegmentSlightlyTooLong) {
      return {
        severity: isSegmentWayTooLong ? "warn" : "info",
        message: segmentTooLongMessage
      };
    }
    return null;
  };
  class SegmentLoader extends videojs.EventTarget {
    constructor(settings, options = {}) {
      super();
      if (!settings) {
        throw new TypeError("Initialization settings are required");
      }
      if (typeof settings.currentTime !== "function") {
        throw new TypeError("No currentTime getter specified");
      }
      if (!settings.mediaSource) {
        throw new TypeError("No MediaSource specified");
      }
      this.bandwidth = settings.bandwidth;
      this.throughput = {
        rate: 0,
        count: 0
      };
      this.roundTrip = NaN;
      this.resetStats_();
      this.mediaIndex = null;
      this.partIndex = null;
      this.hasPlayed_ = settings.hasPlayed;
      this.currentTime_ = settings.currentTime;
      this.seekable_ = settings.seekable;
      this.seeking_ = settings.seeking;
      this.duration_ = settings.duration;
      this.mediaSource_ = settings.mediaSource;
      this.vhs_ = settings.vhs;
      this.loaderType_ = settings.loaderType;
      this.currentMediaInfo_ = void 0;
      this.startingMediaInfo_ = void 0;
      this.segmentMetadataTrack_ = settings.segmentMetadataTrack;
      this.goalBufferLength_ = settings.goalBufferLength;
      this.sourceType_ = settings.sourceType;
      this.sourceUpdater_ = settings.sourceUpdater;
      this.inbandTextTracks_ = settings.inbandTextTracks;
      this.state_ = "INIT";
      this.timelineChangeController_ = settings.timelineChangeController;
      this.shouldSaveSegmentTimingInfo_ = true;
      this.parse708captions_ = settings.parse708captions;
      this.useDtsForTimestampOffset_ = settings.useDtsForTimestampOffset;
      this.captionServices_ = settings.captionServices;
      this.exactManifestTimings = settings.exactManifestTimings;
      this.addMetadataToTextTrack = settings.addMetadataToTextTrack;
      this.checkBufferTimeout_ = null;
      this.error_ = void 0;
      this.currentTimeline_ = -1;
      this.shouldForceTimestampOffsetAfterResync_ = false;
      this.pendingSegment_ = null;
      this.xhrOptions_ = null;
      this.pendingSegments_ = [];
      this.audioDisabled_ = false;
      this.isPendingTimestampOffset_ = false;
      this.gopBuffer_ = [];
      this.timeMapping_ = 0;
      this.safeAppend_ = false;
      this.appendInitSegment_ = {
        audio: true,
        video: true
      };
      this.playlistOfLastInitSegment_ = {
        audio: null,
        video: null
      };
      this.callQueue_ = [];
      this.loadQueue_ = [];
      this.metadataQueue_ = {
        id3: [],
        caption: []
      };
      this.waitingOnRemove_ = false;
      this.quotaExceededErrorRetryTimeout_ = null;
      this.activeInitSegmentId_ = null;
      this.initSegments_ = {};
      this.cacheEncryptionKeys_ = settings.cacheEncryptionKeys;
      this.keyCache_ = {};
      this.decrypter_ = settings.decrypter;
      this.syncController_ = settings.syncController;
      this.syncPoint_ = {
        segmentIndex: 0,
        time: 0
      };
      this.transmuxer_ = this.createTransmuxer_();
      this.triggerSyncInfoUpdate_ = () => this.trigger("syncinfoupdate");
      this.syncController_.on("syncinfoupdate", this.triggerSyncInfoUpdate_);
      this.mediaSource_.addEventListener("sourceopen", () => {
        if (!this.isEndOfStream_()) {
          this.ended_ = false;
        }
      });
      this.fetchAtBuffer_ = false;
      this.logger_ = logger(`SegmentLoader[${this.loaderType_}]`);
      Object.defineProperty(this, "state", {
        get() {
          return this.state_;
        },
        set(newState) {
          if (newState !== this.state_) {
            this.logger_(`${this.state_} -> ${newState}`);
            this.state_ = newState;
            this.trigger("statechange");
          }
        }
      });
      this.sourceUpdater_.on("ready", () => {
        if (this.hasEnoughInfoToAppend_()) {
          this.processCallQueue_();
        }
      });
      if (this.loaderType_ === "main") {
        this.timelineChangeController_.on("pendingtimelinechange", () => {
          if (this.hasEnoughInfoToAppend_()) {
            this.processCallQueue_();
          }
        });
      }
      if (this.loaderType_ === "audio") {
        this.timelineChangeController_.on("timelinechange", () => {
          if (this.hasEnoughInfoToLoad_()) {
            this.processLoadQueue_();
          }
          if (this.hasEnoughInfoToAppend_()) {
            this.processCallQueue_();
          }
        });
      }
    }
    createTransmuxer_() {
      return segmentTransmuxer.createTransmuxer({
        remux: false,
        alignGopsAtEnd: this.safeAppend_,
        keepOriginalTimestamps: true,
        parse708captions: this.parse708captions_,
        captionServices: this.captionServices_
      });
    }
    /**
     * reset all of our media stats
     *
     * @private
     */
    resetStats_() {
      this.mediaBytesTransferred = 0;
      this.mediaRequests = 0;
      this.mediaRequestsAborted = 0;
      this.mediaRequestsTimedout = 0;
      this.mediaRequestsErrored = 0;
      this.mediaTransferDuration = 0;
      this.mediaSecondsLoaded = 0;
      this.mediaAppends = 0;
    }
    /**
     * dispose of the SegmentLoader and reset to the default state
     */
    dispose() {
      this.trigger("dispose");
      this.state = "DISPOSED";
      this.pause();
      this.abort_();
      if (this.transmuxer_) {
        this.transmuxer_.terminate();
      }
      this.resetStats_();
      if (this.checkBufferTimeout_) {
        window.clearTimeout(this.checkBufferTimeout_);
      }
      if (this.syncController_ && this.triggerSyncInfoUpdate_) {
        this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_);
      }
      this.off();
    }
    setAudio(enable) {
      this.audioDisabled_ = !enable;
      if (enable) {
        this.appendInitSegment_.audio = true;
      } else {
        this.sourceUpdater_.removeAudio(0, this.duration_());
      }
    }
    /**
     * abort anything that is currently doing on with the SegmentLoader
     * and reset to a default state
     */
    abort() {
      if (this.state !== "WAITING") {
        if (this.pendingSegment_) {
          this.pendingSegment_ = null;
        }
        return;
      }
      this.abort_();
      this.state = "READY";
      if (!this.paused()) {
        this.monitorBuffer_();
      }
    }
    /**
     * abort all pending xhr requests and null any pending segements
     *
     * @private
     */
    abort_() {
      if (this.pendingSegment_ && this.pendingSegment_.abortRequests) {
        this.pendingSegment_.abortRequests();
      }
      this.pendingSegment_ = null;
      this.callQueue_ = [];
      this.loadQueue_ = [];
      this.metadataQueue_.id3 = [];
      this.metadataQueue_.caption = [];
      this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);
      this.waitingOnRemove_ = false;
      window.clearTimeout(this.quotaExceededErrorRetryTimeout_);
      this.quotaExceededErrorRetryTimeout_ = null;
    }
    checkForAbort_(requestId) {
      if (this.state === "APPENDING" && !this.pendingSegment_) {
        this.state = "READY";
        return true;
      }
      if (!this.pendingSegment_ || this.pendingSegment_.requestId !== requestId) {
        return true;
      }
      return false;
    }
    /**
     * set an error on the segment loader and null out any pending segements
     *
     * @param {Error} error the error to set on the SegmentLoader
     * @return {Error} the error that was set or that is currently set
     */
    error(error) {
      if (typeof error !== "undefined") {
        this.logger_("error occurred:", error);
        this.error_ = error;
      }
      this.pendingSegment_ = null;
      return this.error_;
    }
    endOfStream() {
      this.ended_ = true;
      if (this.transmuxer_) {
        segmentTransmuxer.reset(this.transmuxer_);
      }
      this.gopBuffer_.length = 0;
      this.pause();
      this.trigger("ended");
    }
    /**
     * Indicates which time ranges are buffered
     *
     * @return {TimeRange}
     *         TimeRange object representing the current buffered ranges
     */
    buffered_() {
      const trackInfo = this.getMediaInfo_();
      if (!this.sourceUpdater_ || !trackInfo) {
        return createTimeRanges();
      }
      if (this.loaderType_ === "main") {
        const {
          hasAudio,
          hasVideo,
          isMuxed: isMuxed2
        } = trackInfo;
        if (hasVideo && hasAudio && !this.audioDisabled_ && !isMuxed2) {
          return this.sourceUpdater_.buffered();
        }
        if (hasVideo) {
          return this.sourceUpdater_.videoBuffered();
        }
      }
      return this.sourceUpdater_.audioBuffered();
    }
    /**
     * Gets and sets init segment for the provided map
     *
     * @param {Object} map
     *        The map object representing the init segment to get or set
     * @param {boolean=} set
     *        If true, the init segment for the provided map should be saved
     * @return {Object}
     *         map object for desired init segment
     */
    initSegmentForMap(map, set2 = false) {
      if (!map) {
        return null;
      }
      const id = initSegmentId(map);
      let storedMap = this.initSegments_[id];
      if (set2 && !storedMap && map.bytes) {
        this.initSegments_[id] = storedMap = {
          resolvedUri: map.resolvedUri,
          byterange: map.byterange,
          bytes: map.bytes,
          tracks: map.tracks,
          timescales: map.timescales
        };
      }
      return storedMap || map;
    }
    /**
     * Gets and sets key for the provided key
     *
     * @param {Object} key
     *        The key object representing the key to get or set
     * @param {boolean=} set
     *        If true, the key for the provided key should be saved
     * @return {Object}
     *         Key object for desired key
     */
    segmentKey(key, set2 = false) {
      if (!key) {
        return null;
      }
      const id = segmentKeyId(key);
      let storedKey = this.keyCache_[id];
      if (this.cacheEncryptionKeys_ && set2 && !storedKey && key.bytes) {
        this.keyCache_[id] = storedKey = {
          resolvedUri: key.resolvedUri,
          bytes: key.bytes
        };
      }
      const result = {
        resolvedUri: (storedKey || key).resolvedUri
      };
      if (storedKey) {
        result.bytes = storedKey.bytes;
      }
      return result;
    }
    /**
     * Returns true if all configuration required for loading is present, otherwise false.
     *
     * @return {boolean} True if the all configuration is ready for loading
     * @private
     */
    couldBeginLoading_() {
      return this.playlist_ && !this.paused();
    }
    /**
     * load a playlist and start to fill the buffer
     */
    load() {
      this.monitorBuffer_();
      if (!this.playlist_) {
        return;
      }
      if (this.state === "INIT" && this.couldBeginLoading_()) {
        return this.init_();
      }
      if (!this.couldBeginLoading_() || this.state !== "READY" && this.state !== "INIT") {
        return;
      }
      this.state = "READY";
    }
    /**
     * Once all the starting parameters have been specified, begin
     * operation. This method should only be invoked from the INIT
     * state.
     *
     * @private
     */
    init_() {
      this.state = "READY";
      this.resetEverything();
      return this.monitorBuffer_();
    }
    /**
     * set a playlist on the segment loader
     *
     * @param {PlaylistLoader} media the playlist to set on the segment loader
     */
    playlist(newPlaylist, options = {}) {
      if (!newPlaylist) {
        return;
      }
      const oldPlaylist = this.playlist_;
      const segmentInfo = this.pendingSegment_;
      this.playlist_ = newPlaylist;
      this.xhrOptions_ = options;
      if (this.state === "INIT") {
        newPlaylist.syncInfo = {
          mediaSequence: newPlaylist.mediaSequence,
          time: 0
        };
        if (this.loaderType_ === "main") {
          this.syncController_.setDateTimeMappingForStart(newPlaylist);
        }
      }
      let oldId = null;
      if (oldPlaylist) {
        if (oldPlaylist.id) {
          oldId = oldPlaylist.id;
        } else if (oldPlaylist.uri) {
          oldId = oldPlaylist.uri;
        }
      }
      this.logger_(`playlist update [${oldId} => ${newPlaylist.id || newPlaylist.uri}]`);
      this.syncController_.updateMediaSequenceMap(newPlaylist, this.currentTime_(), this.loaderType_);
      this.trigger("syncinfoupdate");
      if (this.state === "INIT" && this.couldBeginLoading_()) {
        return this.init_();
      }
      if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {
        if (this.mediaIndex !== null) {
          const isLLHLS = !newPlaylist.endList && typeof newPlaylist.partTargetDuration === "number";
          if (isLLHLS) {
            this.resetLoader();
          } else {
            this.resyncLoader();
          }
        }
        this.currentMediaInfo_ = void 0;
        this.trigger("playlistupdate");
        return;
      }
      const mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
      this.logger_(`live window shift [${mediaSequenceDiff}]`);
      if (this.mediaIndex !== null) {
        this.mediaIndex -= mediaSequenceDiff;
        if (this.mediaIndex < 0) {
          this.mediaIndex = null;
          this.partIndex = null;
        } else {
          const segment = this.playlist_.segments[this.mediaIndex];
          if (this.partIndex && (!segment.parts || !segment.parts.length || !segment.parts[this.partIndex])) {
            const mediaIndex = this.mediaIndex;
            this.logger_(`currently processing part (index ${this.partIndex}) no longer exists.`);
            this.resetLoader();
            this.mediaIndex = mediaIndex;
          }
        }
      }
      if (segmentInfo) {
        segmentInfo.mediaIndex -= mediaSequenceDiff;
        if (segmentInfo.mediaIndex < 0) {
          segmentInfo.mediaIndex = null;
          segmentInfo.partIndex = null;
        } else {
          if (segmentInfo.mediaIndex >= 0) {
            segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];
          }
          if (segmentInfo.partIndex >= 0 && segmentInfo.segment.parts) {
            segmentInfo.part = segmentInfo.segment.parts[segmentInfo.partIndex];
          }
        }
      }
      this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);
    }
    /**
     * Prevent the loader from fetching additional segments. If there
     * is a segment request outstanding, it will finish processing
     * before the loader halts. A segment loader can be unpaused by
     * calling load().
     */
    pause() {
      if (this.checkBufferTimeout_) {
        window.clearTimeout(this.checkBufferTimeout_);
        this.checkBufferTimeout_ = null;
      }
    }
    /**
     * Returns whether the segment loader is fetching additional
     * segments when given the opportunity. This property can be
     * modified through calls to pause() and load().
     */
    paused() {
      return this.checkBufferTimeout_ === null;
    }
    /**
     * Delete all the buffered data and reset the SegmentLoader
     *
     * @param {Function} [done] an optional callback to be executed when the remove
     * operation is complete
     */
    resetEverything(done) {
      this.ended_ = false;
      this.activeInitSegmentId_ = null;
      this.appendInitSegment_ = {
        audio: true,
        video: true
      };
      this.resetLoader();
      this.remove(0, Infinity, done);
      if (this.transmuxer_) {
        this.transmuxer_.postMessage({
          action: "clearAllMp4Captions"
        });
        this.transmuxer_.postMessage({
          action: "reset"
        });
      }
    }
    /**
     * Force the SegmentLoader to resync and start loading around the currentTime instead
     * of starting at the end of the buffer
     *
     * Useful for fast quality changes
     */
    resetLoader() {
      this.fetchAtBuffer_ = false;
      this.resyncLoader();
    }
    /**
     * Force the SegmentLoader to restart synchronization and make a conservative guess
     * before returning to the simple walk-forward method
     */
    resyncLoader() {
      if (this.transmuxer_) {
        segmentTransmuxer.reset(this.transmuxer_);
      }
      this.mediaIndex = null;
      this.partIndex = null;
      this.syncPoint_ = null;
      this.isPendingTimestampOffset_ = false;
      this.shouldForceTimestampOffsetAfterResync_ = true;
      this.callQueue_ = [];
      this.loadQueue_ = [];
      this.metadataQueue_.id3 = [];
      this.metadataQueue_.caption = [];
      this.abort();
      if (this.transmuxer_) {
        this.transmuxer_.postMessage({
          action: "clearParsedMp4Captions"
        });
      }
    }
    /**
     * Remove any data in the source buffer between start and end times
     *
     * @param {number} start - the start time of the region to remove from the buffer
     * @param {number} end - the end time of the region to remove from the buffer
     * @param {Function} [done] - an optional callback to be executed when the remove
     * @param {boolean} force - force all remove operations to happen
     * operation is complete
     */
    remove(start, end, done = () => {
    }, force = false) {
      if (end === Infinity) {
        end = this.duration_();
      }
      if (end <= start) {
        this.logger_("skipping remove because end ${end} is <= start ${start}");
        return;
      }
      if (!this.sourceUpdater_ || !this.getMediaInfo_()) {
        this.logger_("skipping remove because no source updater or starting media info");
        return;
      }
      let removesRemaining = 1;
      const removeFinished = () => {
        removesRemaining--;
        if (removesRemaining === 0) {
          done();
        }
      };
      if (force || !this.audioDisabled_) {
        removesRemaining++;
        this.sourceUpdater_.removeAudio(start, end, removeFinished);
      }
      if (force || this.loaderType_ === "main") {
        this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start, end, this.timeMapping_);
        removesRemaining++;
        this.sourceUpdater_.removeVideo(start, end, removeFinished);
      }
      for (const track in this.inbandTextTracks_) {
        removeCuesFromTrack(start, end, this.inbandTextTracks_[track]);
      }
      removeCuesFromTrack(start, end, this.segmentMetadataTrack_);
      removeFinished();
    }
    /**
     * (re-)schedule monitorBufferTick_ to run as soon as possible
     *
     * @private
     */
    monitorBuffer_() {
      if (this.checkBufferTimeout_) {
        window.clearTimeout(this.checkBufferTimeout_);
      }
      this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), 1);
    }
    /**
     * As long as the SegmentLoader is in the READY state, periodically
     * invoke fillBuffer_().
     *
     * @private
     */
    monitorBufferTick_() {
      if (this.state === "READY") {
        this.fillBuffer_();
      }
      if (this.checkBufferTimeout_) {
        window.clearTimeout(this.checkBufferTimeout_);
      }
      this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);
    }
    /**
     * fill the buffer with segements unless the sourceBuffers are
     * currently updating
     *
     * Note: this function should only ever be called by monitorBuffer_
     * and never directly
     *
     * @private
     */
    fillBuffer_() {
      if (this.sourceUpdater_.updating()) {
        return;
      }
      const segmentInfo = this.chooseNextRequest_();
      if (!segmentInfo) {
        return;
      }
      if (typeof segmentInfo.timestampOffset === "number") {
        this.isPendingTimestampOffset_ = false;
        this.timelineChangeController_.pendingTimelineChange({
          type: this.loaderType_,
          from: this.currentTimeline_,
          to: segmentInfo.timeline
        });
      }
      this.loadSegment_(segmentInfo);
    }
    /**
     * Determines if we should call endOfStream on the media source based
     * on the state of the buffer or if appened segment was the final
     * segment in the playlist.
     *
     * @param {number} [mediaIndex] the media index of segment we last appended
     * @param {Object} [playlist] a media playlist object
     * @return {boolean} do we need to call endOfStream on the MediaSource
     */
    isEndOfStream_(mediaIndex = this.mediaIndex, playlist = this.playlist_, partIndex = this.partIndex) {
      if (!playlist || !this.mediaSource_) {
        return false;
      }
      const segment = typeof mediaIndex === "number" && playlist.segments[mediaIndex];
      const appendedLastSegment = mediaIndex + 1 === playlist.segments.length;
      const appendedLastPart = !segment || !segment.parts || partIndex + 1 === segment.parts.length;
      return playlist.endList && this.mediaSource_.readyState === "open" && appendedLastSegment && appendedLastPart;
    }
    /**
     * Determines what request should be made given current segment loader state.
     *
     * @return {Object} a request object that describes the segment/part to load
     */
    chooseNextRequest_() {
      const buffered = this.buffered_();
      const bufferedEnd = lastBufferedEnd(buffered) || 0;
      const bufferedTime = timeAheadOf(buffered, this.currentTime_());
      const preloaded = !this.hasPlayed_() && bufferedTime >= 1;
      const haveEnoughBuffer = bufferedTime >= this.goalBufferLength_();
      const segments = this.playlist_.segments;
      if (!segments.length || preloaded || haveEnoughBuffer) {
        return null;
      }
      this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_(), this.loaderType_);
      const next = {
        partIndex: null,
        mediaIndex: null,
        startOfSegment: null,
        playlist: this.playlist_,
        isSyncRequest: Boolean(!this.syncPoint_)
      };
      if (next.isSyncRequest) {
        next.mediaIndex = getSyncSegmentCandidate(this.currentTimeline_, segments, bufferedEnd);
        this.logger_(`choose next request. Can not find sync point. Fallback to media Index: ${next.mediaIndex}`);
      } else if (this.mediaIndex !== null) {
        const segment = segments[this.mediaIndex];
        const partIndex = typeof this.partIndex === "number" ? this.partIndex : -1;
        next.startOfSegment = segment.end ? segment.end : bufferedEnd;
        if (segment.parts && segment.parts[partIndex + 1]) {
          next.mediaIndex = this.mediaIndex;
          next.partIndex = partIndex + 1;
        } else {
          next.mediaIndex = this.mediaIndex + 1;
        }
      } else {
        const {
          segmentIndex,
          startTime,
          partIndex
        } = Playlist.getMediaInfoForTime({
          exactManifestTimings: this.exactManifestTimings,
          playlist: this.playlist_,
          currentTime: this.fetchAtBuffer_ ? bufferedEnd : this.currentTime_(),
          startingPartIndex: this.syncPoint_.partIndex,
          startingSegmentIndex: this.syncPoint_.segmentIndex,
          startTime: this.syncPoint_.time
        });
        next.getMediaInfoForTime = this.fetchAtBuffer_ ? `bufferedEnd ${bufferedEnd}` : `currentTime ${this.currentTime_()}`;
        next.mediaIndex = segmentIndex;
        next.startOfSegment = startTime;
        next.partIndex = partIndex;
        this.logger_(`choose next request. Playlist switched and we have a sync point. Media Index: ${next.mediaIndex} `);
      }
      const nextSegment = segments[next.mediaIndex];
      let nextPart = nextSegment && typeof next.partIndex === "number" && nextSegment.parts && nextSegment.parts[next.partIndex];
      if (!nextSegment || typeof next.partIndex === "number" && !nextPart) {
        return null;
      }
      if (typeof next.partIndex !== "number" && nextSegment.parts) {
        next.partIndex = 0;
        nextPart = nextSegment.parts[0];
      }
      const hasIndependentSegments = this.vhs_.playlists && this.vhs_.playlists.main && this.vhs_.playlists.main.independentSegments || this.playlist_.independentSegments;
      if (!bufferedTime && nextPart && !hasIndependentSegments && !nextPart.independent) {
        if (next.partIndex === 0) {
          const lastSegment = segments[next.mediaIndex - 1];
          const lastSegmentLastPart = lastSegment.parts && lastSegment.parts.length && lastSegment.parts[lastSegment.parts.length - 1];
          if (lastSegmentLastPart && lastSegmentLastPart.independent) {
            next.mediaIndex -= 1;
            next.partIndex = lastSegment.parts.length - 1;
            next.independent = "previous segment";
          }
        } else if (nextSegment.parts[next.partIndex - 1].independent) {
          next.partIndex -= 1;
          next.independent = "previous part";
        }
      }
      const ended = this.mediaSource_ && this.mediaSource_.readyState === "ended";
      if (next.mediaIndex >= segments.length - 1 && ended && !this.seeking_()) {
        return null;
      }
      if (this.shouldForceTimestampOffsetAfterResync_) {
        this.shouldForceTimestampOffsetAfterResync_ = false;
        next.forceTimestampOffset = true;
        this.logger_("choose next request. Force timestamp offset after loader resync");
      }
      return this.generateSegmentInfo_(next);
    }
    generateSegmentInfo_(options) {
      const {
        independent,
        playlist,
        mediaIndex,
        startOfSegment,
        isSyncRequest,
        partIndex,
        forceTimestampOffset,
        getMediaInfoForTime: getMediaInfoForTime2
      } = options;
      const segment = playlist.segments[mediaIndex];
      const part = typeof partIndex === "number" && segment.parts[partIndex];
      const segmentInfo = {
        requestId: "segment-loader-" + Math.random(),
        // resolve the segment URL relative to the playlist
        uri: part && part.resolvedUri || segment.resolvedUri,
        // the segment's mediaIndex at the time it was requested
        mediaIndex,
        partIndex: part ? partIndex : null,
        // whether or not to update the SegmentLoader's state with this
        // segment's mediaIndex
        isSyncRequest,
        startOfSegment,
        // the segment's playlist
        playlist,
        // unencrypted bytes of the segment
        bytes: null,
        // when a key is defined for this segment, the encrypted bytes
        encryptedBytes: null,
        // The target timestampOffset for this segment when we append it
        // to the source buffer
        timestampOffset: null,
        // The timeline that the segment is in
        timeline: segment.timeline,
        // The expected duration of the segment in seconds
        duration: part && part.duration || segment.duration,
        // retain the segment in case the playlist updates while doing an async process
        segment,
        part,
        byteLength: 0,
        transmuxer: this.transmuxer_,
        // type of getMediaInfoForTime that was used to get this segment
        getMediaInfoForTime: getMediaInfoForTime2,
        independent
      };
      const overrideCheck = typeof forceTimestampOffset !== "undefined" ? forceTimestampOffset : this.isPendingTimestampOffset_;
      segmentInfo.timestampOffset = this.timestampOffsetForSegment_({
        segmentTimeline: segment.timeline,
        currentTimeline: this.currentTimeline_,
        startOfSegment,
        buffered: this.buffered_(),
        overrideCheck
      });
      const audioBufferedEnd = lastBufferedEnd(this.sourceUpdater_.audioBuffered());
      if (typeof audioBufferedEnd === "number") {
        segmentInfo.audioAppendStart = audioBufferedEnd - this.sourceUpdater_.audioTimestampOffset();
      }
      if (this.sourceUpdater_.videoBuffered().length) {
        segmentInfo.gopsToAlignWith = gopsSafeToAlignWith(
          this.gopBuffer_,
          // since the transmuxer is using the actual timing values, but the time is
          // adjusted by the timestmap offset, we must adjust the value here
          this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(),
          this.timeMapping_
        );
      }
      return segmentInfo;
    }
    // get the timestampoffset for a segment,
    // added so that vtt segment loader can override and prevent
    // adding timestamp offsets.
    timestampOffsetForSegment_(options) {
      return timestampOffsetForSegment(options);
    }
    /**
     * Determines if the network has enough bandwidth to complete the current segment
     * request in a timely manner. If not, the request will be aborted early and bandwidth
     * updated to trigger a playlist switch.
     *
     * @param {Object} stats
     *        Object containing stats about the request timing and size
     * @private
     */
    earlyAbortWhenNeeded_(stats) {
      if (this.vhs_.tech_.paused() || // Don't abort if the current playlist is on the lowestEnabledRendition
      // TODO: Replace using timeout with a boolean indicating whether this playlist is
      //       the lowestEnabledRendition.
      !this.xhrOptions_.timeout || // Don't abort if we have no bandwidth information to estimate segment sizes
      !this.playlist_.attributes.BANDWIDTH) {
        return;
      }
      if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1e3) {
        return;
      }
      const currentTime = this.currentTime_();
      const measuredBandwidth = stats.bandwidth;
      const segmentDuration = this.pendingSegment_.duration;
      const requestTimeRemaining = Playlist.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived);
      const timeUntilRebuffer$1 = timeUntilRebuffer(this.buffered_(), currentTime, this.vhs_.tech_.playbackRate()) - 1;
      if (requestTimeRemaining <= timeUntilRebuffer$1) {
        return;
      }
      const switchCandidate = minRebufferMaxBandwidthSelector({
        main: this.vhs_.playlists.main,
        currentTime,
        bandwidth: measuredBandwidth,
        duration: this.duration_(),
        segmentDuration,
        timeUntilRebuffer: timeUntilRebuffer$1,
        currentTimeline: this.currentTimeline_,
        syncController: this.syncController_
      });
      if (!switchCandidate) {
        return;
      }
      const rebufferingImpact = requestTimeRemaining - timeUntilRebuffer$1;
      const timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;
      let minimumTimeSaving = 0.5;
      if (timeUntilRebuffer$1 <= TIME_FUDGE_FACTOR) {
        minimumTimeSaving = 1;
      }
      if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {
        return;
      }
      this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * Config.BANDWIDTH_VARIANCE + 1;
      this.trigger("earlyabort");
    }
    handleAbort_(segmentInfo) {
      this.logger_(`Aborting ${segmentInfoString(segmentInfo)}`);
      this.mediaRequestsAborted += 1;
    }
    /**
     * XHR `progress` event handler
     *
     * @param {Event}
     *        The XHR `progress` event
     * @param {Object} simpleSegment
     *        A simplified segment object copy
     * @private
     */
    handleProgress_(event, simpleSegment) {
      this.earlyAbortWhenNeeded_(simpleSegment.stats);
      if (this.checkForAbort_(simpleSegment.requestId)) {
        return;
      }
      this.trigger("progress");
    }
    handleTrackInfo_(simpleSegment, trackInfo) {
      this.earlyAbortWhenNeeded_(simpleSegment.stats);
      if (this.checkForAbort_(simpleSegment.requestId)) {
        return;
      }
      if (this.checkForIllegalMediaSwitch(trackInfo)) {
        return;
      }
      trackInfo = trackInfo || {};
      if (!shallowEqual(this.currentMediaInfo_, trackInfo)) {
        this.appendInitSegment_ = {
          audio: true,
          video: true
        };
        this.startingMediaInfo_ = trackInfo;
        this.currentMediaInfo_ = trackInfo;
        this.logger_("trackinfo update", trackInfo);
        this.trigger("trackinfo");
      }
      if (this.checkForAbort_(simpleSegment.requestId)) {
        return;
      }
      this.pendingSegment_.trackInfo = trackInfo;
      if (this.hasEnoughInfoToAppend_()) {
        this.processCallQueue_();
      }
    }
    handleTimingInfo_(simpleSegment, mediaType, timeType, time) {
      this.earlyAbortWhenNeeded_(simpleSegment.stats);
      if (this.checkForAbort_(simpleSegment.requestId)) {
        return;
      }
      const segmentInfo = this.pendingSegment_;
      const timingInfoProperty = timingInfoPropertyForMedia(mediaType);
      segmentInfo[timingInfoProperty] = segmentInfo[timingInfoProperty] || {};
      segmentInfo[timingInfoProperty][timeType] = time;
      this.logger_(`timinginfo: ${mediaType} - ${timeType} - ${time}`);
      if (this.hasEnoughInfoToAppend_()) {
        this.processCallQueue_();
      }
    }
    handleCaptions_(simpleSegment, captionData) {
      this.earlyAbortWhenNeeded_(simpleSegment.stats);
      if (this.checkForAbort_(simpleSegment.requestId)) {
        return;
      }
      if (captionData.length === 0) {
        this.logger_("SegmentLoader received no captions from a caption event");
        return;
      }
      const segmentInfo = this.pendingSegment_;
      if (!segmentInfo.hasAppendedData_) {
        this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, simpleSegment, captionData));
        return;
      }
      const timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
      const captionTracks = {};
      captionData.forEach((caption) => {
        captionTracks[caption.stream] = captionTracks[caption.stream] || {
          // Infinity, as any other value will be less than this
          startTime: Infinity,
          captions: [],
          // 0 as an other value will be more than this
          endTime: 0
        };
        const captionTrack = captionTracks[caption.stream];
        captionTrack.startTime = Math.min(captionTrack.startTime, caption.startTime + timestampOffset);
        captionTrack.endTime = Math.max(captionTrack.endTime, caption.endTime + timestampOffset);
        captionTrack.captions.push(caption);
      });
      Object.keys(captionTracks).forEach((trackName) => {
        const {
          startTime,
          endTime,
          captions
        } = captionTracks[trackName];
        const inbandTextTracks = this.inbandTextTracks_;
        this.logger_(`adding cues from ${startTime} -> ${endTime} for ${trackName}`);
        createCaptionsTrackIfNotExists(inbandTextTracks, this.vhs_.tech_, trackName);
        removeCuesFromTrack(startTime, endTime, inbandTextTracks[trackName]);
        addCaptionData({
          captionArray: captions,
          inbandTextTracks,
          timestampOffset
        });
      });
      if (this.transmuxer_) {
        this.transmuxer_.postMessage({
          action: "clearParsedMp4Captions"
        });
      }
    }
    handleId3_(simpleSegment, id3Frames, dispatchType) {
      this.earlyAbortWhenNeeded_(simpleSegment.stats);
      if (this.checkForAbort_(simpleSegment.requestId)) {
        return;
      }
      const segmentInfo = this.pendingSegment_;
      if (!segmentInfo.hasAppendedData_) {
        this.metadataQueue_.id3.push(this.handleId3_.bind(this, simpleSegment, id3Frames, dispatchType));
        return;
      }
      this.addMetadataToTextTrack(dispatchType, id3Frames, this.duration_());
    }
    processMetadataQueue_() {
      this.metadataQueue_.id3.forEach((fn) => fn());
      this.metadataQueue_.caption.forEach((fn) => fn());
      this.metadataQueue_.id3 = [];
      this.metadataQueue_.caption = [];
    }
    processCallQueue_() {
      const callQueue = this.callQueue_;
      this.callQueue_ = [];
      callQueue.forEach((fun) => fun());
    }
    processLoadQueue_() {
      const loadQueue = this.loadQueue_;
      this.loadQueue_ = [];
      loadQueue.forEach((fun) => fun());
    }
    /**
     * Determines whether the loader has enough info to load the next segment.
     *
     * @return {boolean}
     *         Whether or not the loader has enough info to load the next segment
     */
    hasEnoughInfoToLoad_() {
      if (this.loaderType_ !== "audio") {
        return true;
      }
      const segmentInfo = this.pendingSegment_;
      if (!segmentInfo) {
        return false;
      }
      if (!this.getCurrentMediaInfo_()) {
        return true;
      }
      if (
        // Technically, instead of waiting to load a segment on timeline changes, a segment
        // can be requested and downloaded and only wait before it is transmuxed or parsed.
        // But in practice, there are a few reasons why it is better to wait until a loader
        // is ready to append that segment before requesting and downloading:
        //
        // 1. Because audio and main loaders cross discontinuities together, if this loader
        //    is waiting for the other to catch up, then instead of requesting another
        //    segment and using up more bandwidth, by not yet loading, more bandwidth is
        //    allotted to the loader currently behind.
        // 2. media-segment-request doesn't have to have logic to consider whether a segment
        // is ready to be processed or not, isolating the queueing behavior to the loader.
        // 3. The audio loader bases some of its segment properties on timing information
        //    provided by the main loader, meaning that, if the logic for waiting on
        //    processing was in media-segment-request, then it would also need to know how
        //    to re-generate the segment information after the main loader caught up.
        shouldWaitForTimelineChange({
          timelineChangeController: this.timelineChangeController_,
          currentTimeline: this.currentTimeline_,
          segmentTimeline: segmentInfo.timeline,
          loaderType: this.loaderType_,
          audioDisabled: this.audioDisabled_
        })
      ) {
        return false;
      }
      return true;
    }
    getCurrentMediaInfo_(segmentInfo = this.pendingSegment_) {
      return segmentInfo && segmentInfo.trackInfo || this.currentMediaInfo_;
    }
    getMediaInfo_(segmentInfo = this.pendingSegment_) {
      return this.getCurrentMediaInfo_(segmentInfo) || this.startingMediaInfo_;
    }
    getPendingSegmentPlaylist() {
      return this.pendingSegment_ ? this.pendingSegment_.playlist : null;
    }
    hasEnoughInfoToAppend_() {
      if (!this.sourceUpdater_.ready()) {
        return false;
      }
      if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) {
        return false;
      }
      const segmentInfo = this.pendingSegment_;
      const trackInfo = this.getCurrentMediaInfo_();
      if (!segmentInfo || !trackInfo) {
        return false;
      }
      const {
        hasAudio,
        hasVideo,
        isMuxed: isMuxed2
      } = trackInfo;
      if (hasVideo && !segmentInfo.videoTimingInfo) {
        return false;
      }
      if (hasAudio && !this.audioDisabled_ && !isMuxed2 && !segmentInfo.audioTimingInfo) {
        return false;
      }
      if (shouldWaitForTimelineChange({
        timelineChangeController: this.timelineChangeController_,
        currentTimeline: this.currentTimeline_,
        segmentTimeline: segmentInfo.timeline,
        loaderType: this.loaderType_,
        audioDisabled: this.audioDisabled_
      })) {
        return false;
      }
      return true;
    }
    handleData_(simpleSegment, result) {
      this.earlyAbortWhenNeeded_(simpleSegment.stats);
      if (this.checkForAbort_(simpleSegment.requestId)) {
        return;
      }
      if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {
        this.callQueue_.push(this.handleData_.bind(this, simpleSegment, result));
        return;
      }
      const segmentInfo = this.pendingSegment_;
      this.setTimeMapping_(segmentInfo.timeline);
      this.updateMediaSecondsLoaded_(segmentInfo.part || segmentInfo.segment);
      if (this.mediaSource_.readyState === "closed") {
        return;
      }
      if (simpleSegment.map) {
        simpleSegment.map = this.initSegmentForMap(simpleSegment.map, true);
        segmentInfo.segment.map = simpleSegment.map;
      }
      if (simpleSegment.key) {
        this.segmentKey(simpleSegment.key, true);
      }
      segmentInfo.isFmp4 = simpleSegment.isFmp4;
      segmentInfo.timingInfo = segmentInfo.timingInfo || {};
      if (segmentInfo.isFmp4) {
        this.trigger("fmp4");
        segmentInfo.timingInfo.start = segmentInfo[timingInfoPropertyForMedia(result.type)].start;
      } else {
        const trackInfo = this.getCurrentMediaInfo_();
        const useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
        let firstVideoFrameTimeForData;
        if (useVideoTimingInfo) {
          firstVideoFrameTimeForData = segmentInfo.videoTimingInfo.start;
        }
        segmentInfo.timingInfo.start = this.trueSegmentStart_({
          currentStart: segmentInfo.timingInfo.start,
          playlist: segmentInfo.playlist,
          mediaIndex: segmentInfo.mediaIndex,
          currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
          useVideoTimingInfo,
          firstVideoFrameTimeForData,
          videoTimingInfo: segmentInfo.videoTimingInfo,
          audioTimingInfo: segmentInfo.audioTimingInfo
        });
      }
      this.updateAppendInitSegmentStatus(segmentInfo, result.type);
      this.updateSourceBufferTimestampOffset_(segmentInfo);
      if (segmentInfo.isSyncRequest) {
        this.updateTimingInfoEnd_(segmentInfo);
        this.syncController_.saveSegmentTimingInfo({
          segmentInfo,
          shouldSaveTimelineMapping: this.loaderType_ === "main"
        });
        const next = this.chooseNextRequest_();
        if (next.mediaIndex !== segmentInfo.mediaIndex || next.partIndex !== segmentInfo.partIndex) {
          this.logger_("sync segment was incorrect, not appending");
          return;
        }
        this.logger_("sync segment was correct, appending");
      }
      segmentInfo.hasAppendedData_ = true;
      this.processMetadataQueue_();
      this.appendData_(segmentInfo, result);
    }
    updateAppendInitSegmentStatus(segmentInfo, type) {
      if (this.loaderType_ === "main" && typeof segmentInfo.timestampOffset === "number" && // in the case that we're handling partial data, we don't want to append an init
      // segment for each chunk
      !segmentInfo.changedTimestampOffset) {
        this.appendInitSegment_ = {
          audio: true,
          video: true
        };
      }
      if (this.playlistOfLastInitSegment_[type] !== segmentInfo.playlist) {
        this.appendInitSegment_[type] = true;
      }
    }
    getInitSegmentAndUpdateState_({
      type,
      initSegment,
      map,
      playlist
    }) {
      if (map) {
        const id = initSegmentId(map);
        if (this.activeInitSegmentId_ === id) {
          return null;
        }
        initSegment = this.initSegmentForMap(map, true).bytes;
        this.activeInitSegmentId_ = id;
      }
      if (initSegment && this.appendInitSegment_[type]) {
        this.playlistOfLastInitSegment_[type] = playlist;
        this.appendInitSegment_[type] = false;
        this.activeInitSegmentId_ = null;
        return initSegment;
      }
      return null;
    }
    handleQuotaExceededError_({
      segmentInfo,
      type,
      bytes
    }, error) {
      const audioBuffered = this.sourceUpdater_.audioBuffered();
      const videoBuffered = this.sourceUpdater_.videoBuffered();
      if (audioBuffered.length > 1) {
        this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + timeRangesToArray(audioBuffered).join(", "));
      }
      if (videoBuffered.length > 1) {
        this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + timeRangesToArray(videoBuffered).join(", "));
      }
      const audioBufferStart = audioBuffered.length ? audioBuffered.start(0) : 0;
      const audioBufferEnd = audioBuffered.length ? audioBuffered.end(audioBuffered.length - 1) : 0;
      const videoBufferStart = videoBuffered.length ? videoBuffered.start(0) : 0;
      const videoBufferEnd = videoBuffered.length ? videoBuffered.end(videoBuffered.length - 1) : 0;
      if (audioBufferEnd - audioBufferStart <= MIN_BACK_BUFFER && videoBufferEnd - videoBufferStart <= MIN_BACK_BUFFER) {
        this.logger_(`On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. Appended byte length: ${bytes.byteLength}, audio buffer: ${timeRangesToArray(audioBuffered).join(", ")}, video buffer: ${timeRangesToArray(videoBuffered).join(", ")}, `);
        this.error({
          message: "Quota exceeded error with append of a single segment of content",
          excludeUntil: Infinity
        });
        this.trigger("error");
        return;
      }
      this.waitingOnRemove_ = true;
      this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {
        segmentInfo,
        type,
        bytes
      }));
      const currentTime = this.currentTime_();
      const timeToRemoveUntil = currentTime - MIN_BACK_BUFFER;
      this.logger_(`On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to ${timeToRemoveUntil}`);
      this.remove(0, timeToRemoveUntil, () => {
        this.logger_(`On QUOTA_EXCEEDED_ERR, retrying append in ${MIN_BACK_BUFFER}s`);
        this.waitingOnRemove_ = false;
        this.quotaExceededErrorRetryTimeout_ = window.setTimeout(() => {
          this.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue");
          this.quotaExceededErrorRetryTimeout_ = null;
          this.processCallQueue_();
        }, MIN_BACK_BUFFER * 1e3);
      }, true);
    }
    handleAppendError_({
      segmentInfo,
      type,
      bytes
    }, error) {
      if (!error) {
        return;
      }
      if (error.code === QUOTA_EXCEEDED_ERR) {
        this.handleQuotaExceededError_({
          segmentInfo,
          type,
          bytes
        });
        return;
      }
      this.logger_("Received non QUOTA_EXCEEDED_ERR on append", error);
      this.error(`${type} append of ${bytes.length}b failed for segment #${segmentInfo.mediaIndex} in playlist ${segmentInfo.playlist.id}`);
      this.trigger("appenderror");
    }
    appendToSourceBuffer_({
      segmentInfo,
      type,
      initSegment,
      data,
      bytes
    }) {
      if (!bytes) {
        const segments = [data];
        let byteLength = data.byteLength;
        if (initSegment) {
          segments.unshift(initSegment);
          byteLength += initSegment.byteLength;
        }
        bytes = concatSegments({
          bytes: byteLength,
          segments
        });
      }
      this.sourceUpdater_.appendBuffer({
        segmentInfo,
        type,
        bytes
      }, this.handleAppendError_.bind(this, {
        segmentInfo,
        type,
        bytes
      }));
    }
    handleSegmentTimingInfo_(type, requestId, segmentTimingInfo) {
      if (!this.pendingSegment_ || requestId !== this.pendingSegment_.requestId) {
        return;
      }
      const segment = this.pendingSegment_.segment;
      const timingInfoProperty = `${type}TimingInfo`;
      if (!segment[timingInfoProperty]) {
        segment[timingInfoProperty] = {};
      }
      segment[timingInfoProperty].transmuxerPrependedSeconds = segmentTimingInfo.prependedContentDuration || 0;
      segment[timingInfoProperty].transmuxedPresentationStart = segmentTimingInfo.start.presentation;
      segment[timingInfoProperty].transmuxedDecodeStart = segmentTimingInfo.start.decode;
      segment[timingInfoProperty].transmuxedPresentationEnd = segmentTimingInfo.end.presentation;
      segment[timingInfoProperty].transmuxedDecodeEnd = segmentTimingInfo.end.decode;
      segment[timingInfoProperty].baseMediaDecodeTime = segmentTimingInfo.baseMediaDecodeTime;
    }
    appendData_(segmentInfo, result) {
      const {
        type,
        data
      } = result;
      if (!data || !data.byteLength) {
        return;
      }
      if (type === "audio" && this.audioDisabled_) {
        return;
      }
      const initSegment = this.getInitSegmentAndUpdateState_({
        type,
        initSegment: result.initSegment,
        playlist: segmentInfo.playlist,
        map: segmentInfo.isFmp4 ? segmentInfo.segment.map : null
      });
      this.appendToSourceBuffer_({
        segmentInfo,
        type,
        initSegment,
        data
      });
    }
    /**
     * load a specific segment from a request into the buffer
     *
     * @private
     */
    loadSegment_(segmentInfo) {
      this.state = "WAITING";
      this.pendingSegment_ = segmentInfo;
      this.trimBackBuffer_(segmentInfo);
      if (typeof segmentInfo.timestampOffset === "number") {
        if (this.transmuxer_) {
          this.transmuxer_.postMessage({
            action: "clearAllMp4Captions"
          });
        }
      }
      if (!this.hasEnoughInfoToLoad_()) {
        this.loadQueue_.push(() => {
          const options = _extends$1({}, segmentInfo, {
            forceTimestampOffset: true
          });
          _extends$1(segmentInfo, this.generateSegmentInfo_(options));
          this.isPendingTimestampOffset_ = false;
          this.updateTransmuxerAndRequestSegment_(segmentInfo);
        });
        return;
      }
      this.updateTransmuxerAndRequestSegment_(segmentInfo);
    }
    updateTransmuxerAndRequestSegment_(segmentInfo) {
      if (this.shouldUpdateTransmuxerTimestampOffset_(segmentInfo.timestampOffset)) {
        this.gopBuffer_.length = 0;
        segmentInfo.gopsToAlignWith = [];
        this.timeMapping_ = 0;
        this.transmuxer_.postMessage({
          action: "reset"
        });
        this.transmuxer_.postMessage({
          action: "setTimestampOffset",
          timestampOffset: segmentInfo.timestampOffset
        });
      }
      const simpleSegment = this.createSimplifiedSegmentObj_(segmentInfo);
      const isEndOfStream = this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex);
      const isWalkingForward = this.mediaIndex !== null;
      const isDiscontinuity = segmentInfo.timeline !== this.currentTimeline_ && // currentTimeline starts at -1, so we shouldn't end the timeline switching to 0,
      // the first timeline
      segmentInfo.timeline > 0;
      const isEndOfTimeline = isEndOfStream || isWalkingForward && isDiscontinuity;
      this.logger_(`Requesting ${segmentInfoString(segmentInfo)}`);
      if (simpleSegment.map && !simpleSegment.map.bytes) {
        this.logger_("going to request init segment.");
        this.appendInitSegment_ = {
          video: true,
          audio: true
        };
      }
      segmentInfo.abortRequests = mediaSegmentRequest({
        xhr: this.vhs_.xhr,
        xhrOptions: this.xhrOptions_,
        decryptionWorker: this.decrypter_,
        segment: simpleSegment,
        abortFn: this.handleAbort_.bind(this, segmentInfo),
        progressFn: this.handleProgress_.bind(this),
        trackInfoFn: this.handleTrackInfo_.bind(this),
        timingInfoFn: this.handleTimingInfo_.bind(this),
        videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", segmentInfo.requestId),
        audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", segmentInfo.requestId),
        captionsFn: this.handleCaptions_.bind(this),
        isEndOfTimeline,
        endedTimelineFn: () => {
          this.logger_("received endedtimeline callback");
        },
        id3Fn: this.handleId3_.bind(this),
        dataFn: this.handleData_.bind(this),
        doneFn: this.segmentRequestFinished_.bind(this),
        onTransmuxerLog: ({
          message,
          level,
          stream
        }) => {
          this.logger_(`${segmentInfoString(segmentInfo)} logged from transmuxer stream ${stream} as a ${level}: ${message}`);
        }
      });
    }
    /**
     * trim the back buffer so that we don't have too much data
     * in the source buffer
     *
     * @private
     *
     * @param {Object} segmentInfo - the current segment
     */
    trimBackBuffer_(segmentInfo) {
      const removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);
      if (removeToTime > 0) {
        this.remove(0, removeToTime);
      }
    }
    /**
     * created a simplified copy of the segment object with just the
     * information necessary to perform the XHR and decryption
     *
     * @private
     *
     * @param {Object} segmentInfo - the current segment
     * @return {Object} a simplified segment object copy
     */
    createSimplifiedSegmentObj_(segmentInfo) {
      const segment = segmentInfo.segment;
      const part = segmentInfo.part;
      const simpleSegment = {
        resolvedUri: part ? part.resolvedUri : segment.resolvedUri,
        byterange: part ? part.byterange : segment.byterange,
        requestId: segmentInfo.requestId,
        transmuxer: segmentInfo.transmuxer,
        audioAppendStart: segmentInfo.audioAppendStart,
        gopsToAlignWith: segmentInfo.gopsToAlignWith,
        part: segmentInfo.part
      };
      const previousSegment = segmentInfo.playlist.segments[segmentInfo.mediaIndex - 1];
      if (previousSegment && previousSegment.timeline === segment.timeline) {
        if (previousSegment.videoTimingInfo) {
          simpleSegment.baseStartTime = previousSegment.videoTimingInfo.transmuxedDecodeEnd;
        } else if (previousSegment.audioTimingInfo) {
          simpleSegment.baseStartTime = previousSegment.audioTimingInfo.transmuxedDecodeEnd;
        }
      }
      if (segment.key) {
        const iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);
        simpleSegment.key = this.segmentKey(segment.key);
        simpleSegment.key.iv = iv;
      }
      if (segment.map) {
        simpleSegment.map = this.initSegmentForMap(segment.map);
      }
      return simpleSegment;
    }
    saveTransferStats_(stats) {
      this.mediaRequests += 1;
      if (stats) {
        this.mediaBytesTransferred += stats.bytesReceived;
        this.mediaTransferDuration += stats.roundTripTime;
      }
    }
    saveBandwidthRelatedStats_(duration2, stats) {
      this.pendingSegment_.byteLength = stats.bytesReceived;
      if (duration2 < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
        this.logger_(`Ignoring segment's bandwidth because its duration of ${duration2} is less than the min to record ${MIN_SEGMENT_DURATION_TO_SAVE_STATS}`);
        return;
      }
      this.bandwidth = stats.bandwidth;
      this.roundTrip = stats.roundTripTime;
    }
    handleTimeout_() {
      this.mediaRequestsTimedout += 1;
      this.bandwidth = 1;
      this.roundTrip = NaN;
      this.trigger("bandwidthupdate");
      this.trigger("timeout");
    }
    /**
     * Handle the callback from the segmentRequest function and set the
     * associated SegmentLoader state and errors if necessary
     *
     * @private
     */
    segmentRequestFinished_(error, simpleSegment, result) {
      if (this.callQueue_.length) {
        this.callQueue_.push(this.segmentRequestFinished_.bind(this, error, simpleSegment, result));
        return;
      }
      this.saveTransferStats_(simpleSegment.stats);
      if (!this.pendingSegment_) {
        return;
      }
      if (simpleSegment.requestId !== this.pendingSegment_.requestId) {
        return;
      }
      if (error) {
        this.pendingSegment_ = null;
        this.state = "READY";
        if (error.code === REQUEST_ERRORS.ABORTED) {
          return;
        }
        this.pause();
        if (error.code === REQUEST_ERRORS.TIMEOUT) {
          this.handleTimeout_();
          return;
        }
        this.mediaRequestsErrored += 1;
        this.error(error);
        this.trigger("error");
        return;
      }
      const segmentInfo = this.pendingSegment_;
      this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
      segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;
      if (result.gopInfo) {
        this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, result.gopInfo, this.safeAppend_);
      }
      this.state = "APPENDING";
      this.trigger("appending");
      this.waitForAppendsToComplete_(segmentInfo);
    }
    setTimeMapping_(timeline) {
      const timelineMapping = this.syncController_.mappingForTimeline(timeline);
      if (timelineMapping !== null) {
        this.timeMapping_ = timelineMapping;
      }
    }
    updateMediaSecondsLoaded_(segment) {
      if (typeof segment.start === "number" && typeof segment.end === "number") {
        this.mediaSecondsLoaded += segment.end - segment.start;
      } else {
        this.mediaSecondsLoaded += segment.duration;
      }
    }
    shouldUpdateTransmuxerTimestampOffset_(timestampOffset) {
      if (timestampOffset === null) {
        return false;
      }
      if (this.loaderType_ === "main" && timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {
        return true;
      }
      if (!this.audioDisabled_ && timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {
        return true;
      }
      return false;
    }
    trueSegmentStart_({
      currentStart,
      playlist,
      mediaIndex,
      firstVideoFrameTimeForData,
      currentVideoTimestampOffset,
      useVideoTimingInfo,
      videoTimingInfo,
      audioTimingInfo
    }) {
      if (typeof currentStart !== "undefined") {
        return currentStart;
      }
      if (!useVideoTimingInfo) {
        return audioTimingInfo.start;
      }
      const previousSegment = playlist.segments[mediaIndex - 1];
      if (mediaIndex === 0 || !previousSegment || typeof previousSegment.start === "undefined" || previousSegment.end !== firstVideoFrameTimeForData + currentVideoTimestampOffset) {
        return firstVideoFrameTimeForData;
      }
      return videoTimingInfo.start;
    }
    waitForAppendsToComplete_(segmentInfo) {
      const trackInfo = this.getCurrentMediaInfo_(segmentInfo);
      if (!trackInfo) {
        this.error({
          message: "No starting media returned, likely due to an unsupported media format.",
          playlistExclusionDuration: Infinity
        });
        this.trigger("error");
        return;
      }
      const {
        hasAudio,
        hasVideo,
        isMuxed: isMuxed2
      } = trackInfo;
      const waitForVideo = this.loaderType_ === "main" && hasVideo;
      const waitForAudio = !this.audioDisabled_ && hasAudio && !isMuxed2;
      segmentInfo.waitingOnAppends = 0;
      if (!segmentInfo.hasAppendedData_) {
        if (!segmentInfo.timingInfo && typeof segmentInfo.timestampOffset === "number") {
          this.isPendingTimestampOffset_ = true;
        }
        segmentInfo.timingInfo = {
          start: 0
        };
        segmentInfo.waitingOnAppends++;
        if (!this.isPendingTimestampOffset_) {
          this.updateSourceBufferTimestampOffset_(segmentInfo);
          this.processMetadataQueue_();
        }
        this.checkAppendsDone_(segmentInfo);
        return;
      }
      if (waitForVideo) {
        segmentInfo.waitingOnAppends++;
      }
      if (waitForAudio) {
        segmentInfo.waitingOnAppends++;
      }
      if (waitForVideo) {
        this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
      }
      if (waitForAudio) {
        this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
      }
    }
    checkAppendsDone_(segmentInfo) {
      if (this.checkForAbort_(segmentInfo.requestId)) {
        return;
      }
      segmentInfo.waitingOnAppends--;
      if (segmentInfo.waitingOnAppends === 0) {
        this.handleAppendsDone_();
      }
    }
    checkForIllegalMediaSwitch(trackInfo) {
      const illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.getCurrentMediaInfo_(), trackInfo);
      if (illegalMediaSwitchError) {
        this.error({
          message: illegalMediaSwitchError,
          playlistExclusionDuration: Infinity
        });
        this.trigger("error");
        return true;
      }
      return false;
    }
    updateSourceBufferTimestampOffset_(segmentInfo) {
      if (segmentInfo.timestampOffset === null || // we don't yet have the start for whatever media type (video or audio) has
      // priority, timing-wise, so we must wait
      typeof segmentInfo.timingInfo.start !== "number" || // already updated the timestamp offset for this segment
      segmentInfo.changedTimestampOffset || // the alt audio loader should not be responsible for setting the timestamp offset
      this.loaderType_ !== "main") {
        return;
      }
      let didChange = false;
      segmentInfo.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({
        videoTimingInfo: segmentInfo.segment.videoTimingInfo,
        audioTimingInfo: segmentInfo.segment.audioTimingInfo,
        timingInfo: segmentInfo.timingInfo
      });
      segmentInfo.changedTimestampOffset = true;
      if (segmentInfo.timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {
        this.sourceUpdater_.videoTimestampOffset(segmentInfo.timestampOffset);
        didChange = true;
      }
      if (segmentInfo.timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {
        this.sourceUpdater_.audioTimestampOffset(segmentInfo.timestampOffset);
        didChange = true;
      }
      if (didChange) {
        this.trigger("timestampoffset");
      }
    }
    getSegmentStartTimeForTimestampOffsetCalculation_({
      videoTimingInfo,
      audioTimingInfo,
      timingInfo
    }) {
      if (!this.useDtsForTimestampOffset_) {
        return timingInfo.start;
      }
      if (videoTimingInfo && typeof videoTimingInfo.transmuxedDecodeStart === "number") {
        return videoTimingInfo.transmuxedDecodeStart;
      }
      if (audioTimingInfo && typeof audioTimingInfo.transmuxedDecodeStart === "number") {
        return audioTimingInfo.transmuxedDecodeStart;
      }
      return timingInfo.start;
    }
    updateTimingInfoEnd_(segmentInfo) {
      segmentInfo.timingInfo = segmentInfo.timingInfo || {};
      const trackInfo = this.getMediaInfo_();
      const useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
      const prioritizedTimingInfo = useVideoTimingInfo && segmentInfo.videoTimingInfo ? segmentInfo.videoTimingInfo : segmentInfo.audioTimingInfo;
      if (!prioritizedTimingInfo) {
        return;
      }
      segmentInfo.timingInfo.end = typeof prioritizedTimingInfo.end === "number" ? (
        // End time may not exist in a case where we aren't parsing the full segment (one
        // current example is the case of fmp4), so use the rough duration to calculate an
        // end time.
        prioritizedTimingInfo.end
      ) : prioritizedTimingInfo.start + segmentInfo.duration;
    }
    /**
     * callback to run when appendBuffer is finished. detects if we are
     * in a good state to do things with the data we got, or if we need
     * to wait for more
     *
     * @private
     */
    handleAppendsDone_() {
      if (this.pendingSegment_) {
        this.trigger("appendsdone");
      }
      if (!this.pendingSegment_) {
        this.state = "READY";
        if (!this.paused()) {
          this.monitorBuffer_();
        }
        return;
      }
      const segmentInfo = this.pendingSegment_;
      this.updateTimingInfoEnd_(segmentInfo);
      if (this.shouldSaveSegmentTimingInfo_) {
        this.syncController_.saveSegmentTimingInfo({
          segmentInfo,
          shouldSaveTimelineMapping: this.loaderType_ === "main"
        });
      }
      const segmentDurationMessage = getTroublesomeSegmentDurationMessage(segmentInfo, this.sourceType_);
      if (segmentDurationMessage) {
        if (segmentDurationMessage.severity === "warn") {
          videojs.log.warn(segmentDurationMessage.message);
        } else {
          this.logger_(segmentDurationMessage.message);
        }
      }
      this.recordThroughput_(segmentInfo);
      this.pendingSegment_ = null;
      this.state = "READY";
      if (segmentInfo.isSyncRequest) {
        this.trigger("syncinfoupdate");
        if (!segmentInfo.hasAppendedData_) {
          this.logger_(`Throwing away un-appended sync request ${segmentInfoString(segmentInfo)}`);
          return;
        }
      }
      this.logger_(`Appended ${segmentInfoString(segmentInfo)}`);
      this.addSegmentMetadataCue_(segmentInfo);
      this.fetchAtBuffer_ = true;
      if (this.currentTimeline_ !== segmentInfo.timeline) {
        this.timelineChangeController_.lastTimelineChange({
          type: this.loaderType_,
          from: this.currentTimeline_,
          to: segmentInfo.timeline
        });
        if (this.loaderType_ === "main" && !this.audioDisabled_) {
          this.timelineChangeController_.lastTimelineChange({
            type: "audio",
            from: this.currentTimeline_,
            to: segmentInfo.timeline
          });
        }
      }
      this.currentTimeline_ = segmentInfo.timeline;
      this.trigger("syncinfoupdate");
      const segment = segmentInfo.segment;
      const part = segmentInfo.part;
      const badSegmentGuess = segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3;
      const badPartGuess = part && part.end && this.currentTime_() - part.end > segmentInfo.playlist.partTargetDuration * 3;
      if (badSegmentGuess || badPartGuess) {
        this.logger_(`bad ${badSegmentGuess ? "segment" : "part"} ${segmentInfoString(segmentInfo)}`);
        this.resetEverything();
        return;
      }
      const isWalkingForward = this.mediaIndex !== null;
      if (isWalkingForward) {
        this.trigger("bandwidthupdate");
      }
      this.trigger("progress");
      this.mediaIndex = segmentInfo.mediaIndex;
      this.partIndex = segmentInfo.partIndex;
      if (this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex)) {
        this.endOfStream();
      }
      this.trigger("appended");
      if (segmentInfo.hasAppendedData_) {
        this.mediaAppends++;
      }
      if (!this.paused()) {
        this.monitorBuffer_();
      }
    }
    /**
     * Records the current throughput of the decrypt, transmux, and append
     * portion of the semgment pipeline. `throughput.rate` is a the cumulative
     * moving average of the throughput. `throughput.count` is the number of
     * data points in the average.
     *
     * @private
     * @param {Object} segmentInfo the object returned by loadSegment
     */
    recordThroughput_(segmentInfo) {
      if (segmentInfo.duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
        this.logger_(`Ignoring segment's throughput because its duration of ${segmentInfo.duration} is less than the min to record ${MIN_SEGMENT_DURATION_TO_SAVE_STATS}`);
        return;
      }
      const rate = this.throughput.rate;
      const segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1;
      const segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1e3);
      this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;
    }
    /**
     * Adds a cue to the segment-metadata track with some metadata information about the
     * segment
     *
     * @private
     * @param {Object} segmentInfo
     *        the object returned by loadSegment
     * @method addSegmentMetadataCue_
     */
    addSegmentMetadataCue_(segmentInfo) {
      if (!this.segmentMetadataTrack_) {
        return;
      }
      const segment = segmentInfo.segment;
      const start = segment.start;
      const end = segment.end;
      if (!finite(start) || !finite(end)) {
        return;
      }
      removeCuesFromTrack(start, end, this.segmentMetadataTrack_);
      const Cue = window.WebKitDataCue || window.VTTCue;
      const value = {
        custom: segment.custom,
        dateTimeObject: segment.dateTimeObject,
        dateTimeString: segment.dateTimeString,
        programDateTime: segment.programDateTime,
        bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,
        resolution: segmentInfo.playlist.attributes.RESOLUTION,
        codecs: segmentInfo.playlist.attributes.CODECS,
        byteLength: segmentInfo.byteLength,
        uri: segmentInfo.uri,
        timeline: segmentInfo.timeline,
        playlist: segmentInfo.playlist.id,
        start,
        end
      };
      const data = JSON.stringify(value);
      const cue = new Cue(start, end, data);
      cue.value = value;
      this.segmentMetadataTrack_.addCue(cue);
    }
  }
  function noop() {
  }
  const toTitleCase = function(string) {
    if (typeof string !== "string") {
      return string;
    }
    return string.replace(/./, (w) => w.toUpperCase());
  };
  const bufferTypes = ["video", "audio"];
  const updating = (type, sourceUpdater) => {
    const sourceBuffer = sourceUpdater[`${type}Buffer`];
    return sourceBuffer && sourceBuffer.updating || sourceUpdater.queuePending[type];
  };
  const nextQueueIndexOfType = (type, queue) => {
    for (let i = 0; i < queue.length; i++) {
      const queueEntry = queue[i];
      if (queueEntry.type === "mediaSource") {
        return null;
      }
      if (queueEntry.type === type) {
        return i;
      }
    }
    return null;
  };
  const shiftQueue = (type, sourceUpdater) => {
    if (sourceUpdater.queue.length === 0) {
      return;
    }
    let queueIndex = 0;
    let queueEntry = sourceUpdater.queue[queueIndex];
    if (queueEntry.type === "mediaSource") {
      if (!sourceUpdater.updating() && sourceUpdater.mediaSource.readyState !== "closed") {
        sourceUpdater.queue.shift();
        queueEntry.action(sourceUpdater);
        if (queueEntry.doneFn) {
          queueEntry.doneFn();
        }
        shiftQueue("audio", sourceUpdater);
        shiftQueue("video", sourceUpdater);
      }
      return;
    }
    if (type === "mediaSource") {
      return;
    }
    if (!sourceUpdater.ready() || sourceUpdater.mediaSource.readyState === "closed" || updating(type, sourceUpdater)) {
      return;
    }
    if (queueEntry.type !== type) {
      queueIndex = nextQueueIndexOfType(type, sourceUpdater.queue);
      if (queueIndex === null) {
        return;
      }
      queueEntry = sourceUpdater.queue[queueIndex];
    }
    sourceUpdater.queue.splice(queueIndex, 1);
    sourceUpdater.queuePending[type] = queueEntry;
    queueEntry.action(type, sourceUpdater);
    if (!queueEntry.doneFn) {
      sourceUpdater.queuePending[type] = null;
      shiftQueue(type, sourceUpdater);
      return;
    }
  };
  const cleanupBuffer = (type, sourceUpdater) => {
    const buffer = sourceUpdater[`${type}Buffer`];
    const titleType = toTitleCase(type);
    if (!buffer) {
      return;
    }
    buffer.removeEventListener("updateend", sourceUpdater[`on${titleType}UpdateEnd_`]);
    buffer.removeEventListener("error", sourceUpdater[`on${titleType}Error_`]);
    sourceUpdater.codecs[type] = null;
    sourceUpdater[`${type}Buffer`] = null;
  };
  const inSourceBuffers = (mediaSource, sourceBuffer) => mediaSource && sourceBuffer && Array.prototype.indexOf.call(mediaSource.sourceBuffers, sourceBuffer) !== -1;
  const actions = {
    appendBuffer: (bytes, segmentInfo, onError2) => (type, sourceUpdater) => {
      const sourceBuffer = sourceUpdater[`${type}Buffer`];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_(`Appending segment ${segmentInfo.mediaIndex}'s ${bytes.length} bytes to ${type}Buffer`);
      try {
        sourceBuffer.appendBuffer(bytes);
      } catch (e) {
        sourceUpdater.logger_(`Error with code ${e.code} ` + (e.code === QUOTA_EXCEEDED_ERR ? "(QUOTA_EXCEEDED_ERR) " : "") + `when appending segment ${segmentInfo.mediaIndex} to ${type}Buffer`);
        sourceUpdater.queuePending[type] = null;
        onError2(e);
      }
    },
    remove: (start, end) => (type, sourceUpdater) => {
      const sourceBuffer = sourceUpdater[`${type}Buffer`];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_(`Removing ${start} to ${end} from ${type}Buffer`);
      try {
        sourceBuffer.remove(start, end);
      } catch (e) {
        sourceUpdater.logger_(`Remove ${start} to ${end} from ${type}Buffer failed`);
      }
    },
    timestampOffset: (offset) => (type, sourceUpdater) => {
      const sourceBuffer = sourceUpdater[`${type}Buffer`];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_(`Setting ${type}timestampOffset to ${offset}`);
      sourceBuffer.timestampOffset = offset;
    },
    callback: (callback) => (type, sourceUpdater) => {
      callback();
    },
    endOfStream: (error) => (sourceUpdater) => {
      if (sourceUpdater.mediaSource.readyState !== "open") {
        return;
      }
      sourceUpdater.logger_(`Calling mediaSource endOfStream(${error || ""})`);
      try {
        sourceUpdater.mediaSource.endOfStream(error);
      } catch (e) {
        videojs.log.warn("Failed to call media source endOfStream", e);
      }
    },
    duration: (duration2) => (sourceUpdater) => {
      sourceUpdater.logger_(`Setting mediaSource duration to ${duration2}`);
      try {
        sourceUpdater.mediaSource.duration = duration2;
      } catch (e) {
        videojs.log.warn("Failed to set media source duration", e);
      }
    },
    abort: () => (type, sourceUpdater) => {
      if (sourceUpdater.mediaSource.readyState !== "open") {
        return;
      }
      const sourceBuffer = sourceUpdater[`${type}Buffer`];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_(`calling abort on ${type}Buffer`);
      try {
        sourceBuffer.abort();
      } catch (e) {
        videojs.log.warn(`Failed to abort on ${type}Buffer`, e);
      }
    },
    addSourceBuffer: (type, codec) => (sourceUpdater) => {
      const titleType = toTitleCase(type);
      const mime = getMimeForCodec(codec);
      sourceUpdater.logger_(`Adding ${type}Buffer with codec ${codec} to mediaSource`);
      const sourceBuffer = sourceUpdater.mediaSource.addSourceBuffer(mime);
      sourceBuffer.addEventListener("updateend", sourceUpdater[`on${titleType}UpdateEnd_`]);
      sourceBuffer.addEventListener("error", sourceUpdater[`on${titleType}Error_`]);
      sourceUpdater.codecs[type] = codec;
      sourceUpdater[`${type}Buffer`] = sourceBuffer;
    },
    removeSourceBuffer: (type) => (sourceUpdater) => {
      const sourceBuffer = sourceUpdater[`${type}Buffer`];
      cleanupBuffer(type, sourceUpdater);
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_(`Removing ${type}Buffer with codec ${sourceUpdater.codecs[type]} from mediaSource`);
      try {
        sourceUpdater.mediaSource.removeSourceBuffer(sourceBuffer);
      } catch (e) {
        videojs.log.warn(`Failed to removeSourceBuffer ${type}Buffer`, e);
      }
    },
    changeType: (codec) => (type, sourceUpdater) => {
      const sourceBuffer = sourceUpdater[`${type}Buffer`];
      const mime = getMimeForCodec(codec);
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      if (sourceUpdater.codecs[type] === codec) {
        return;
      }
      sourceUpdater.logger_(`changing ${type}Buffer codec from ${sourceUpdater.codecs[type]} to ${codec}`);
      sourceBuffer.changeType(mime);
      sourceUpdater.codecs[type] = codec;
    }
  };
  const pushQueue = ({
    type,
    sourceUpdater,
    action,
    doneFn,
    name
  }) => {
    sourceUpdater.queue.push({
      type,
      action,
      doneFn,
      name
    });
    shiftQueue(type, sourceUpdater);
  };
  const onUpdateend = (type, sourceUpdater) => (e) => {
    if (sourceUpdater.queuePending[type]) {
      const doneFn = sourceUpdater.queuePending[type].doneFn;
      sourceUpdater.queuePending[type] = null;
      if (doneFn) {
        doneFn(sourceUpdater[`${type}Error_`]);
      }
    }
    shiftQueue(type, sourceUpdater);
  };
  class SourceUpdater extends videojs.EventTarget {
    constructor(mediaSource) {
      super();
      this.mediaSource = mediaSource;
      this.sourceopenListener_ = () => shiftQueue("mediaSource", this);
      this.mediaSource.addEventListener("sourceopen", this.sourceopenListener_);
      this.logger_ = logger("SourceUpdater");
      this.audioTimestampOffset_ = 0;
      this.videoTimestampOffset_ = 0;
      this.queue = [];
      this.queuePending = {
        audio: null,
        video: null
      };
      this.delayedAudioAppendQueue_ = [];
      this.videoAppendQueued_ = false;
      this.codecs = {};
      this.onVideoUpdateEnd_ = onUpdateend("video", this);
      this.onAudioUpdateEnd_ = onUpdateend("audio", this);
      this.onVideoError_ = (e) => {
        this.videoError_ = e;
      };
      this.onAudioError_ = (e) => {
        this.audioError_ = e;
      };
      this.createdSourceBuffers_ = false;
      this.initializedEme_ = false;
      this.triggeredReady_ = false;
    }
    initializedEme() {
      this.initializedEme_ = true;
      this.triggerReady();
    }
    hasCreatedSourceBuffers() {
      return this.createdSourceBuffers_;
    }
    hasInitializedAnyEme() {
      return this.initializedEme_;
    }
    ready() {
      return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();
    }
    createSourceBuffers(codecs) {
      if (this.hasCreatedSourceBuffers()) {
        return;
      }
      this.addOrChangeSourceBuffers(codecs);
      this.createdSourceBuffers_ = true;
      this.trigger("createdsourcebuffers");
      this.triggerReady();
    }
    triggerReady() {
      if (this.ready() && !this.triggeredReady_) {
        this.triggeredReady_ = true;
        this.trigger("ready");
      }
    }
    /**
     * Add a type of source buffer to the media source.
     *
     * @param {string} type
     *        The type of source buffer to add.
     *
     * @param {string} codec
     *        The codec to add the source buffer with.
     */
    addSourceBuffer(type, codec) {
      pushQueue({
        type: "mediaSource",
        sourceUpdater: this,
        action: actions.addSourceBuffer(type, codec),
        name: "addSourceBuffer"
      });
    }
    /**
     * call abort on a source buffer.
     *
     * @param {string} type
     *        The type of source buffer to call abort on.
     */
    abort(type) {
      pushQueue({
        type,
        sourceUpdater: this,
        action: actions.abort(type),
        name: "abort"
      });
    }
    /**
     * Call removeSourceBuffer and remove a specific type
     * of source buffer on the mediaSource.
     *
     * @param {string} type
     *        The type of source buffer to remove.
     */
    removeSourceBuffer(type) {
      if (!this.canRemoveSourceBuffer()) {
        videojs.log.error("removeSourceBuffer is not supported!");
        return;
      }
      pushQueue({
        type: "mediaSource",
        sourceUpdater: this,
        action: actions.removeSourceBuffer(type),
        name: "removeSourceBuffer"
      });
    }
    /**
     * Whether or not the removeSourceBuffer function is supported
     * on the mediaSource.
     *
     * @return {boolean}
     *          if removeSourceBuffer can be called.
     */
    canRemoveSourceBuffer() {
      return !videojs.browser.IS_FIREFOX && window.MediaSource && window.MediaSource.prototype && typeof window.MediaSource.prototype.removeSourceBuffer === "function";
    }
    /**
     * Whether or not the changeType function is supported
     * on our SourceBuffers.
     *
     * @return {boolean}
     *         if changeType can be called.
     */
    static canChangeType() {
      return window.SourceBuffer && window.SourceBuffer.prototype && typeof window.SourceBuffer.prototype.changeType === "function";
    }
    /**
     * Whether or not the changeType function is supported
     * on our SourceBuffers.
     *
     * @return {boolean}
     *         if changeType can be called.
     */
    canChangeType() {
      return this.constructor.canChangeType();
    }
    /**
     * Call the changeType function on a source buffer, given the code and type.
     *
     * @param {string} type
     *        The type of source buffer to call changeType on.
     *
     * @param {string} codec
     *        The codec string to change type with on the source buffer.
     */
    changeType(type, codec) {
      if (!this.canChangeType()) {
        videojs.log.error("changeType is not supported!");
        return;
      }
      pushQueue({
        type,
        sourceUpdater: this,
        action: actions.changeType(codec),
        name: "changeType"
      });
    }
    /**
     * Add source buffers with a codec or, if they are already created,
     * call changeType on source buffers using changeType.
     *
     * @param {Object} codecs
     *        Codecs to switch to
     */
    addOrChangeSourceBuffers(codecs) {
      if (!codecs || typeof codecs !== "object" || Object.keys(codecs).length === 0) {
        throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs");
      }
      Object.keys(codecs).forEach((type) => {
        const codec = codecs[type];
        if (!this.hasCreatedSourceBuffers()) {
          return this.addSourceBuffer(type, codec);
        }
        if (this.canChangeType()) {
          this.changeType(type, codec);
        }
      });
    }
    /**
     * Queue an update to append an ArrayBuffer.
     *
     * @param {MediaObject} object containing audioBytes and/or videoBytes
     * @param {Function} done the function to call when done
     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-appendBuffer-void-ArrayBuffer-data
     */
    appendBuffer(options, doneFn) {
      const {
        segmentInfo,
        type,
        bytes
      } = options;
      this.processedAppend_ = true;
      if (type === "audio" && this.videoBuffer && !this.videoAppendQueued_) {
        this.delayedAudioAppendQueue_.push([options, doneFn]);
        this.logger_(`delayed audio append of ${bytes.length} until video append`);
        return;
      }
      const onError2 = doneFn;
      pushQueue({
        type,
        sourceUpdater: this,
        action: actions.appendBuffer(bytes, segmentInfo || {
          mediaIndex: -1
        }, onError2),
        doneFn,
        name: "appendBuffer"
      });
      if (type === "video") {
        this.videoAppendQueued_ = true;
        if (!this.delayedAudioAppendQueue_.length) {
          return;
        }
        const queue = this.delayedAudioAppendQueue_.slice();
        this.logger_(`queuing delayed audio ${queue.length} appendBuffers`);
        this.delayedAudioAppendQueue_.length = 0;
        queue.forEach((que) => {
          this.appendBuffer.apply(this, que);
        });
      }
    }
    /**
     * Get the audio buffer's buffered timerange.
     *
     * @return {TimeRange}
     *         The audio buffer's buffered time range
     */
    audioBuffered() {
      if (!inSourceBuffers(this.mediaSource, this.audioBuffer)) {
        return createTimeRanges();
      }
      return this.audioBuffer.buffered ? this.audioBuffer.buffered : createTimeRanges();
    }
    /**
     * Get the video buffer's buffered timerange.
     *
     * @return {TimeRange}
     *         The video buffer's buffered time range
     */
    videoBuffered() {
      if (!inSourceBuffers(this.mediaSource, this.videoBuffer)) {
        return createTimeRanges();
      }
      return this.videoBuffer.buffered ? this.videoBuffer.buffered : createTimeRanges();
    }
    /**
     * Get a combined video/audio buffer's buffered timerange.
     *
     * @return {TimeRange}
     *         the combined time range
     */
    buffered() {
      const video = inSourceBuffers(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null;
      const audio = inSourceBuffers(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
      if (audio && !video) {
        return this.audioBuffered();
      }
      if (video && !audio) {
        return this.videoBuffered();
      }
      return bufferIntersection(this.audioBuffered(), this.videoBuffered());
    }
    /**
     * Add a callback to the queue that will set duration on the mediaSource.
     *
     * @param {number} duration
     *        The duration to set
     *
     * @param {Function} [doneFn]
     *        function to run after duration has been set.
     */
    setDuration(duration2, doneFn = noop) {
      pushQueue({
        type: "mediaSource",
        sourceUpdater: this,
        action: actions.duration(duration2),
        name: "duration",
        doneFn
      });
    }
    /**
     * Add a mediaSource endOfStream call to the queue
     *
     * @param {Error} [error]
     *        Call endOfStream with an error
     *
     * @param {Function} [doneFn]
     *        A function that should be called when the
     *        endOfStream call has finished.
     */
    endOfStream(error = null, doneFn = noop) {
      if (typeof error !== "string") {
        error = void 0;
      }
      pushQueue({
        type: "mediaSource",
        sourceUpdater: this,
        action: actions.endOfStream(error),
        name: "endOfStream",
        doneFn
      });
    }
    /**
     * Queue an update to remove a time range from the buffer.
     *
     * @param {number} start where to start the removal
     * @param {number} end where to end the removal
     * @param {Function} [done=noop] optional callback to be executed when the remove
     * operation is complete
     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end
     */
    removeAudio(start, end, done = noop) {
      if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {
        done();
        return;
      }
      pushQueue({
        type: "audio",
        sourceUpdater: this,
        action: actions.remove(start, end),
        doneFn: done,
        name: "remove"
      });
    }
    /**
     * Queue an update to remove a time range from the buffer.
     *
     * @param {number} start where to start the removal
     * @param {number} end where to end the removal
     * @param {Function} [done=noop] optional callback to be executed when the remove
     * operation is complete
     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end
     */
    removeVideo(start, end, done = noop) {
      if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {
        done();
        return;
      }
      pushQueue({
        type: "video",
        sourceUpdater: this,
        action: actions.remove(start, end),
        doneFn: done,
        name: "remove"
      });
    }
    /**
     * Whether the underlying sourceBuffer is updating or not
     *
     * @return {boolean} the updating status of the SourceBuffer
     */
    updating() {
      if (updating("audio", this) || updating("video", this)) {
        return true;
      }
      return false;
    }
    /**
     * Set/get the timestampoffset on the audio SourceBuffer
     *
     * @return {number} the timestamp offset
     */
    audioTimestampOffset(offset) {
      if (typeof offset !== "undefined" && this.audioBuffer && // no point in updating if it's the same
      this.audioTimestampOffset_ !== offset) {
        pushQueue({
          type: "audio",
          sourceUpdater: this,
          action: actions.timestampOffset(offset),
          name: "timestampOffset"
        });
        this.audioTimestampOffset_ = offset;
      }
      return this.audioTimestampOffset_;
    }
    /**
     * Set/get the timestampoffset on the video SourceBuffer
     *
     * @return {number} the timestamp offset
     */
    videoTimestampOffset(offset) {
      if (typeof offset !== "undefined" && this.videoBuffer && // no point in updating if it's the same
      this.videoTimestampOffset !== offset) {
        pushQueue({
          type: "video",
          sourceUpdater: this,
          action: actions.timestampOffset(offset),
          name: "timestampOffset"
        });
        this.videoTimestampOffset_ = offset;
      }
      return this.videoTimestampOffset_;
    }
    /**
     * Add a function to the queue that will be called
     * when it is its turn to run in the audio queue.
     *
     * @param {Function} callback
     *        The callback to queue.
     */
    audioQueueCallback(callback) {
      if (!this.audioBuffer) {
        return;
      }
      pushQueue({
        type: "audio",
        sourceUpdater: this,
        action: actions.callback(callback),
        name: "callback"
      });
    }
    /**
     * Add a function to the queue that will be called
     * when it is its turn to run in the video queue.
     *
     * @param {Function} callback
     *        The callback to queue.
     */
    videoQueueCallback(callback) {
      if (!this.videoBuffer) {
        return;
      }
      pushQueue({
        type: "video",
        sourceUpdater: this,
        action: actions.callback(callback),
        name: "callback"
      });
    }
    /**
     * dispose of the source updater and the underlying sourceBuffer
     */
    dispose() {
      this.trigger("dispose");
      bufferTypes.forEach((type) => {
        this.abort(type);
        if (this.canRemoveSourceBuffer()) {
          this.removeSourceBuffer(type);
        } else {
          this[`${type}QueueCallback`](() => cleanupBuffer(type, this));
        }
      });
      this.videoAppendQueued_ = false;
      this.delayedAudioAppendQueue_.length = 0;
      if (this.sourceopenListener_) {
        this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_);
      }
      this.off();
    }
  }
  const uint8ToUtf8 = (uintArray) => decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));
  const bufferToHexString = (buffer) => {
    const uInt8Buffer = new Uint8Array(buffer);
    return Array.from(uInt8Buffer).map((byte) => byte.toString(16).padStart(2, "0")).join("");
  };
  const VTT_LINE_TERMINATORS = new Uint8Array("\n\n".split("").map((char) => char.charCodeAt(0)));
  class NoVttJsError extends Error {
    constructor() {
      super("Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded.");
    }
  }
  class VTTSegmentLoader extends SegmentLoader {
    constructor(settings, options = {}) {
      super(settings, options);
      this.mediaSource_ = null;
      this.subtitlesTrack_ = null;
      this.loaderType_ = "subtitle";
      this.featuresNativeTextTracks_ = settings.featuresNativeTextTracks;
      this.loadVttJs = settings.loadVttJs;
      this.shouldSaveSegmentTimingInfo_ = false;
    }
    createTransmuxer_() {
      return null;
    }
    /**
     * Indicates which time ranges are buffered
     *
     * @return {TimeRange}
     *         TimeRange object representing the current buffered ranges
     */
    buffered_() {
      if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) {
        return createTimeRanges();
      }
      const cues = this.subtitlesTrack_.cues;
      const start = cues[0].startTime;
      const end = cues[cues.length - 1].startTime;
      return createTimeRanges([[start, end]]);
    }
    /**
     * Gets and sets init segment for the provided map
     *
     * @param {Object} map
     *        The map object representing the init segment to get or set
     * @param {boolean=} set
     *        If true, the init segment for the provided map should be saved
     * @return {Object}
     *         map object for desired init segment
     */
    initSegmentForMap(map, set2 = false) {
      if (!map) {
        return null;
      }
      const id = initSegmentId(map);
      let storedMap = this.initSegments_[id];
      if (set2 && !storedMap && map.bytes) {
        const combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;
        const combinedSegment = new Uint8Array(combinedByteLength);
        combinedSegment.set(map.bytes);
        combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);
        this.initSegments_[id] = storedMap = {
          resolvedUri: map.resolvedUri,
          byterange: map.byterange,
          bytes: combinedSegment
        };
      }
      return storedMap || map;
    }
    /**
     * Returns true if all configuration required for loading is present, otherwise false.
     *
     * @return {boolean} True if the all configuration is ready for loading
     * @private
     */
    couldBeginLoading_() {
      return this.playlist_ && this.subtitlesTrack_ && !this.paused();
    }
    /**
     * Once all the starting parameters have been specified, begin
     * operation. This method should only be invoked from the INIT
     * state.
     *
     * @private
     */
    init_() {
      this.state = "READY";
      this.resetEverything();
      return this.monitorBuffer_();
    }
    /**
     * Set a subtitle track on the segment loader to add subtitles to
     *
     * @param {TextTrack=} track
     *        The text track to add loaded subtitles to
     * @return {TextTrack}
     *        Returns the subtitles track
     */
    track(track) {
      if (typeof track === "undefined") {
        return this.subtitlesTrack_;
      }
      this.subtitlesTrack_ = track;
      if (this.state === "INIT" && this.couldBeginLoading_()) {
        this.init_();
      }
      return this.subtitlesTrack_;
    }
    /**
     * Remove any data in the source buffer between start and end times
     *
     * @param {number} start - the start time of the region to remove from the buffer
     * @param {number} end - the end time of the region to remove from the buffer
     */
    remove(start, end) {
      removeCuesFromTrack(start, end, this.subtitlesTrack_);
    }
    /**
     * fill the buffer with segements unless the sourceBuffers are
     * currently updating
     *
     * Note: this function should only ever be called by monitorBuffer_
     * and never directly
     *
     * @private
     */
    fillBuffer_() {
      const segmentInfo = this.chooseNextRequest_();
      if (!segmentInfo) {
        return;
      }
      if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {
        const checkTimestampOffset = () => {
          this.state = "READY";
          if (!this.paused()) {
            this.monitorBuffer_();
          }
        };
        this.syncController_.one("timestampoffset", checkTimestampOffset);
        this.state = "WAITING_ON_TIMELINE";
        return;
      }
      this.loadSegment_(segmentInfo);
    }
    // never set a timestamp offset for vtt segments.
    timestampOffsetForSegment_() {
      return null;
    }
    chooseNextRequest_() {
      return this.skipEmptySegments_(super.chooseNextRequest_());
    }
    /**
     * Prevents the segment loader from requesting segments we know contain no subtitles
     * by walking forward until we find the next segment that we don't know whether it is
     * empty or not.
     *
     * @param {Object} segmentInfo
     *        a segment info object that describes the current segment
     * @return {Object}
     *         a segment info object that describes the current segment
     */
    skipEmptySegments_(segmentInfo) {
      while (segmentInfo && segmentInfo.segment.empty) {
        if (segmentInfo.mediaIndex + 1 >= segmentInfo.playlist.segments.length) {
          segmentInfo = null;
          break;
        }
        segmentInfo = this.generateSegmentInfo_({
          playlist: segmentInfo.playlist,
          mediaIndex: segmentInfo.mediaIndex + 1,
          startOfSegment: segmentInfo.startOfSegment + segmentInfo.duration,
          isSyncRequest: segmentInfo.isSyncRequest
        });
      }
      return segmentInfo;
    }
    stopForError(error) {
      this.error(error);
      this.state = "READY";
      this.pause();
      this.trigger("error");
    }
    /**
     * append a decrypted segement to the SourceBuffer through a SourceUpdater
     *
     * @private
     */
    segmentRequestFinished_(error, simpleSegment, result) {
      if (!this.subtitlesTrack_) {
        this.state = "READY";
        return;
      }
      this.saveTransferStats_(simpleSegment.stats);
      if (!this.pendingSegment_) {
        this.state = "READY";
        this.mediaRequestsAborted += 1;
        return;
      }
      if (error) {
        if (error.code === REQUEST_ERRORS.TIMEOUT) {
          this.handleTimeout_();
        }
        if (error.code === REQUEST_ERRORS.ABORTED) {
          this.mediaRequestsAborted += 1;
        } else {
          this.mediaRequestsErrored += 1;
        }
        this.stopForError(error);
        return;
      }
      const segmentInfo = this.pendingSegment_;
      this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
      if (simpleSegment.key) {
        this.segmentKey(simpleSegment.key, true);
      }
      this.state = "APPENDING";
      this.trigger("appending");
      const segment = segmentInfo.segment;
      if (segment.map) {
        segment.map.bytes = simpleSegment.map.bytes;
      }
      segmentInfo.bytes = simpleSegment.bytes;
      if (typeof window.WebVTT !== "function" && typeof this.loadVttJs === "function") {
        this.state = "WAITING_ON_VTTJS";
        this.loadVttJs().then(() => this.segmentRequestFinished_(error, simpleSegment, result), () => this.stopForError({
          message: "Error loading vtt.js"
        }));
        return;
      }
      segment.requested = true;
      try {
        this.parseVTTCues_(segmentInfo);
      } catch (e) {
        this.stopForError({
          message: e.message
        });
        return;
      }
      this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);
      if (segmentInfo.cues.length) {
        segmentInfo.timingInfo = {
          start: segmentInfo.cues[0].startTime,
          end: segmentInfo.cues[segmentInfo.cues.length - 1].endTime
        };
      } else {
        segmentInfo.timingInfo = {
          start: segmentInfo.startOfSegment,
          end: segmentInfo.startOfSegment + segmentInfo.duration
        };
      }
      if (segmentInfo.isSyncRequest) {
        this.trigger("syncinfoupdate");
        this.pendingSegment_ = null;
        this.state = "READY";
        return;
      }
      segmentInfo.byteLength = segmentInfo.bytes.byteLength;
      this.mediaSecondsLoaded += segment.duration;
      segmentInfo.cues.forEach((cue) => {
        this.subtitlesTrack_.addCue(this.featuresNativeTextTracks_ ? new window.VTTCue(cue.startTime, cue.endTime, cue.text) : cue);
      });
      removeDuplicateCuesFromTrack(this.subtitlesTrack_);
      this.handleAppendsDone_();
    }
    handleData_() {
    }
    updateTimingInfoEnd_() {
    }
    /**
     * Uses the WebVTT parser to parse the segment response
     *
     * @throws NoVttJsError
     *
     * @param {Object} segmentInfo
     *        a segment info object that describes the current segment
     * @private
     */
    parseVTTCues_(segmentInfo) {
      let decoder;
      let decodeBytesToString = false;
      if (typeof window.WebVTT !== "function") {
        throw new NoVttJsError();
      }
      if (typeof window.TextDecoder === "function") {
        decoder = new window.TextDecoder("utf8");
      } else {
        decoder = window.WebVTT.StringDecoder();
        decodeBytesToString = true;
      }
      const parser = new window.WebVTT.Parser(window, window.vttjs, decoder);
      segmentInfo.cues = [];
      segmentInfo.timestampmap = {
        MPEGTS: 0,
        LOCAL: 0
      };
      parser.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);
      parser.ontimestampmap = (map) => {
        segmentInfo.timestampmap = map;
      };
      parser.onparsingerror = (error) => {
        videojs.log.warn("Error encountered when parsing cues: " + error.message);
      };
      if (segmentInfo.segment.map) {
        let mapData = segmentInfo.segment.map.bytes;
        if (decodeBytesToString) {
          mapData = uint8ToUtf8(mapData);
        }
        parser.parse(mapData);
      }
      let segmentData = segmentInfo.bytes;
      if (decodeBytesToString) {
        segmentData = uint8ToUtf8(segmentData);
      }
      parser.parse(segmentData);
      parser.flush();
    }
    /**
     * Updates the start and end times of any cues parsed by the WebVTT parser using
     * the information parsed from the X-TIMESTAMP-MAP header and a TS to media time mapping
     * from the SyncController
     *
     * @param {Object} segmentInfo
     *        a segment info object that describes the current segment
     * @param {Object} mappingObj
     *        object containing a mapping from TS to media time
     * @param {Object} playlist
     *        the playlist object containing the segment
     * @private
     */
    updateTimeMapping_(segmentInfo, mappingObj, playlist) {
      const segment = segmentInfo.segment;
      if (!mappingObj) {
        return;
      }
      if (!segmentInfo.cues.length) {
        segment.empty = true;
        return;
      }
      const timestampmap = segmentInfo.timestampmap;
      const diff = timestampmap.MPEGTS / clock_1 - timestampmap.LOCAL + mappingObj.mapping;
      segmentInfo.cues.forEach((cue) => {
        cue.startTime += diff;
        cue.endTime += diff;
      });
      if (!playlist.syncInfo) {
        const firstStart = segmentInfo.cues[0].startTime;
        const lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;
        playlist.syncInfo = {
          mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,
          time: Math.min(firstStart, lastStart - segment.duration)
        };
      }
    }
  }
  const findAdCue = function(track, mediaTime) {
    const cues = track.cues;
    for (let i = 0; i < cues.length; i++) {
      const cue = cues[i];
      if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {
        return cue;
      }
    }
    return null;
  };
  const updateAdCues = function(media, track, offset = 0) {
    if (!media.segments) {
      return;
    }
    let mediaTime = offset;
    let cue;
    for (let i = 0; i < media.segments.length; i++) {
      const segment = media.segments[i];
      if (!cue) {
        cue = findAdCue(track, mediaTime + segment.duration / 2);
      }
      if (cue) {
        if ("cueIn" in segment) {
          cue.endTime = mediaTime;
          cue.adEndTime = mediaTime;
          mediaTime += segment.duration;
          cue = null;
          continue;
        }
        if (mediaTime < cue.endTime) {
          mediaTime += segment.duration;
          continue;
        }
        cue.endTime += segment.duration;
      } else {
        if ("cueOut" in segment) {
          cue = new window.VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);
          cue.adStartTime = mediaTime;
          cue.adEndTime = mediaTime + parseFloat(segment.cueOut);
          track.addCue(cue);
        }
        if ("cueOutCont" in segment) {
          const [adOffset, adTotal] = segment.cueOutCont.split("/").map(parseFloat);
          cue = new window.VTTCue(mediaTime, mediaTime + segment.duration, "");
          cue.adStartTime = mediaTime - adOffset;
          cue.adEndTime = cue.adStartTime + adTotal;
          track.addCue(cue);
        }
      }
      mediaTime += segment.duration;
    }
  };
  const MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC = 86400;
  const syncPointStrategies = [
    // Stategy "VOD": Handle the VOD-case where the sync-point is *always*
    //                the equivalence display-time 0 === segment-index 0
    {
      name: "VOD",
      run: (syncController, playlist, duration2, currentTimeline, currentTime) => {
        if (duration2 !== Infinity) {
          const syncPoint = {
            time: 0,
            segmentIndex: 0,
            partIndex: null
          };
          return syncPoint;
        }
        return null;
      }
    },
    {
      name: "MediaSequence",
      /**
       * run media sequence strategy
       *
       * @param {SyncController} syncController
       * @param {Object} playlist
       * @param {number} duration
       * @param {number} currentTimeline
       * @param {number} currentTime
       * @param {string} type
       */
      run: (syncController, playlist, duration2, currentTimeline, currentTime, type) => {
        if (!type) {
          return null;
        }
        const mediaSequenceMap = syncController.getMediaSequenceMap(type);
        if (!mediaSequenceMap || mediaSequenceMap.size === 0) {
          return null;
        }
        if (playlist.mediaSequence === void 0 || !Array.isArray(playlist.segments) || !playlist.segments.length) {
          return null;
        }
        let currentMediaSequence = playlist.mediaSequence;
        let segmentIndex = 0;
        for (const segment of playlist.segments) {
          const range2 = mediaSequenceMap.get(currentMediaSequence);
          if (!range2) {
            break;
          }
          if (currentTime >= range2.start && currentTime < range2.end) {
            if (Array.isArray(segment.parts) && segment.parts.length) {
              let currentPartStart = range2.start;
              let partIndex = 0;
              for (const part of segment.parts) {
                const start = currentPartStart;
                const end = start + part.duration;
                if (currentTime >= start && currentTime < end) {
                  return {
                    time: range2.start,
                    segmentIndex,
                    partIndex
                  };
                }
                partIndex++;
                currentPartStart = end;
              }
            }
            return {
              time: range2.start,
              segmentIndex,
              partIndex: null
            };
          }
          segmentIndex++;
          currentMediaSequence++;
        }
        return null;
      }
    },
    // Stategy "ProgramDateTime": We have a program-date-time tag in this playlist
    {
      name: "ProgramDateTime",
      run: (syncController, playlist, duration2, currentTimeline, currentTime) => {
        if (!Object.keys(syncController.timelineToDatetimeMappings).length) {
          return null;
        }
        let syncPoint = null;
        let lastDistance = null;
        const partsAndSegments = getPartsAndSegments(playlist);
        currentTime = currentTime || 0;
        for (let i = 0; i < partsAndSegments.length; i++) {
          const index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
          const partAndSegment = partsAndSegments[index];
          const segment = partAndSegment.segment;
          const datetimeMapping = syncController.timelineToDatetimeMappings[segment.timeline];
          if (!datetimeMapping || !segment.dateTimeObject) {
            continue;
          }
          const segmentTime = segment.dateTimeObject.getTime() / 1e3;
          let start = segmentTime + datetimeMapping;
          if (segment.parts && typeof partAndSegment.partIndex === "number") {
            for (let z = 0; z < partAndSegment.partIndex; z++) {
              start += segment.parts[z].duration;
            }
          }
          const distance = Math.abs(currentTime - start);
          if (lastDistance !== null && (distance === 0 || lastDistance < distance)) {
            break;
          }
          lastDistance = distance;
          syncPoint = {
            time: start,
            segmentIndex: partAndSegment.segmentIndex,
            partIndex: partAndSegment.partIndex
          };
        }
        return syncPoint;
      }
    },
    // Stategy "Segment": We have a known time mapping for a timeline and a
    //                    segment in the current timeline with timing data
    {
      name: "Segment",
      run: (syncController, playlist, duration2, currentTimeline, currentTime) => {
        let syncPoint = null;
        let lastDistance = null;
        currentTime = currentTime || 0;
        const partsAndSegments = getPartsAndSegments(playlist);
        for (let i = 0; i < partsAndSegments.length; i++) {
          const index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
          const partAndSegment = partsAndSegments[index];
          const segment = partAndSegment.segment;
          const start = partAndSegment.part && partAndSegment.part.start || segment && segment.start;
          if (segment.timeline === currentTimeline && typeof start !== "undefined") {
            const distance = Math.abs(currentTime - start);
            if (lastDistance !== null && lastDistance < distance) {
              break;
            }
            if (!syncPoint || lastDistance === null || lastDistance >= distance) {
              lastDistance = distance;
              syncPoint = {
                time: start,
                segmentIndex: partAndSegment.segmentIndex,
                partIndex: partAndSegment.partIndex
              };
            }
          }
        }
        return syncPoint;
      }
    },
    // Stategy "Discontinuity": We have a discontinuity with a known
    //                          display-time
    {
      name: "Discontinuity",
      run: (syncController, playlist, duration2, currentTimeline, currentTime) => {
        let syncPoint = null;
        currentTime = currentTime || 0;
        if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
          let lastDistance = null;
          for (let i = 0; i < playlist.discontinuityStarts.length; i++) {
            const segmentIndex = playlist.discontinuityStarts[i];
            const discontinuity = playlist.discontinuitySequence + i + 1;
            const discontinuitySync = syncController.discontinuities[discontinuity];
            if (discontinuitySync) {
              const distance = Math.abs(currentTime - discontinuitySync.time);
              if (lastDistance !== null && lastDistance < distance) {
                break;
              }
              if (!syncPoint || lastDistance === null || lastDistance >= distance) {
                lastDistance = distance;
                syncPoint = {
                  time: discontinuitySync.time,
                  segmentIndex,
                  partIndex: null
                };
              }
            }
          }
        }
        return syncPoint;
      }
    },
    // Stategy "Playlist": We have a playlist with a known mapping of
    //                     segment index to display time
    {
      name: "Playlist",
      run: (syncController, playlist, duration2, currentTimeline, currentTime) => {
        if (playlist.syncInfo) {
          const syncPoint = {
            time: playlist.syncInfo.time,
            segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence,
            partIndex: null
          };
          return syncPoint;
        }
        return null;
      }
    }
  ];
  class SyncController extends videojs.EventTarget {
    constructor(options = {}) {
      super();
      this.timelines = [];
      this.discontinuities = [];
      this.timelineToDatetimeMappings = {};
      this.mediaSequenceStorage_ = /* @__PURE__ */ new Map();
      this.logger_ = logger("SyncController");
    }
    /**
     * Get media sequence map by type
     *
     * @param {string} type - segment loader type
     * @return {Map<number, { start: number, end: number }> | undefined}
     */
    getMediaSequenceMap(type) {
      return this.mediaSequenceStorage_.get(type);
    }
    /**
     * Update Media Sequence Map -> <MediaSequence, Range>
     *
     * @param {Object} playlist - parsed playlist
     * @param {number} currentTime - current player's time
     * @param {string} type - segment loader type
     * @return {void}
     */
    updateMediaSequenceMap(playlist, currentTime, type) {
      if (playlist.mediaSequence === void 0 || !Array.isArray(playlist.segments) || !playlist.segments.length) {
        return;
      }
      const currentMap = this.getMediaSequenceMap(type);
      const result = /* @__PURE__ */ new Map();
      let currentMediaSequence = playlist.mediaSequence;
      let currentBaseTime;
      if (!currentMap) {
        currentBaseTime = 0;
      } else if (currentMap.has(playlist.mediaSequence)) {
        currentBaseTime = currentMap.get(playlist.mediaSequence).start;
      } else {
        this.logger_(`MediaSequence sync for ${type} segment loader - received a gap between playlists.
Fallback base time to: ${currentTime}.
Received media sequence: ${currentMediaSequence}.
Current map: `, currentMap);
        currentBaseTime = currentTime;
      }
      this.logger_(`MediaSequence sync for ${type} segment loader.
Received media sequence: ${currentMediaSequence}.
base time is ${currentBaseTime}
Current map: `, currentMap);
      playlist.segments.forEach((segment) => {
        const start = currentBaseTime;
        const end = start + segment.duration;
        const range2 = {
          start,
          end
        };
        result.set(currentMediaSequence, range2);
        currentMediaSequence++;
        currentBaseTime = end;
      });
      this.mediaSequenceStorage_.set(type, result);
    }
    /**
     * Find a sync-point for the playlist specified
     *
     * A sync-point is defined as a known mapping from display-time to
     * a segment-index in the current playlist.
     *
     * @param {Playlist} playlist
     *        The playlist that needs a sync-point
     * @param {number} duration
     *        Duration of the MediaSource (Infinite if playing a live source)
     * @param {number} currentTimeline
     *        The last timeline from which a segment was loaded
     * @param {number} currentTime
     *        Current player's time
     * @param {string} type
     *        Segment loader type
     * @return {Object}
     *          A sync-point object
     */
    getSyncPoint(playlist, duration2, currentTimeline, currentTime, type) {
      if (duration2 !== Infinity) {
        const vodSyncPointStrategy = syncPointStrategies.find(({
          name
        }) => name === "VOD");
        return vodSyncPointStrategy.run(this, playlist, duration2);
      }
      const syncPoints = this.runStrategies_(playlist, duration2, currentTimeline, currentTime, type);
      if (!syncPoints.length) {
        return null;
      }
      for (const syncPointInfo of syncPoints) {
        const {
          syncPoint,
          strategy
        } = syncPointInfo;
        const {
          segmentIndex,
          time
        } = syncPoint;
        if (segmentIndex < 0) {
          continue;
        }
        const selectedSegment = playlist.segments[segmentIndex];
        const start = time;
        const end = start + selectedSegment.duration;
        this.logger_(`Strategy: ${strategy}. Current time: ${currentTime}. selected segment: ${segmentIndex}. Time: [${start} -> ${end}]}`);
        if (currentTime >= start && currentTime < end) {
          this.logger_("Found sync point with exact match: ", syncPoint);
          return syncPoint;
        }
      }
      return this.selectSyncPoint_(syncPoints, {
        key: "time",
        value: currentTime
      });
    }
    /**
     * Calculate the amount of time that has expired off the playlist during playback
     *
     * @param {Playlist} playlist
     *        Playlist object to calculate expired from
     * @param {number} duration
     *        Duration of the MediaSource (Infinity if playling a live source)
     * @return {number|null}
     *          The amount of time that has expired off the playlist during playback. Null
     *          if no sync-points for the playlist can be found.
     */
    getExpiredTime(playlist, duration2) {
      if (!playlist || !playlist.segments) {
        return null;
      }
      const syncPoints = this.runStrategies_(playlist, duration2, playlist.discontinuitySequence, 0, "main");
      if (!syncPoints.length) {
        return null;
      }
      const syncPoint = this.selectSyncPoint_(syncPoints, {
        key: "segmentIndex",
        value: 0
      });
      if (syncPoint.segmentIndex > 0) {
        syncPoint.time *= -1;
      }
      return Math.abs(syncPoint.time + sumDurations({
        defaultDuration: playlist.targetDuration,
        durationList: playlist.segments,
        startIndex: syncPoint.segmentIndex,
        endIndex: 0
      }));
    }
    /**
     * Runs each sync-point strategy and returns a list of sync-points returned by the
     * strategies
     *
     * @private
     * @param {Playlist} playlist
     *        The playlist that needs a sync-point
     * @param {number} duration
     *        Duration of the MediaSource (Infinity if playing a live source)
     * @param {number} currentTimeline
     *        The last timeline from which a segment was loaded
     * @param {number} currentTime
     *        Current player's time
     * @param {string} type
     *        Segment loader type
     * @return {Array}
     *          A list of sync-point objects
     */
    runStrategies_(playlist, duration2, currentTimeline, currentTime, type) {
      const syncPoints = [];
      for (let i = 0; i < syncPointStrategies.length; i++) {
        const strategy = syncPointStrategies[i];
        const syncPoint = strategy.run(this, playlist, duration2, currentTimeline, currentTime, type);
        if (syncPoint) {
          syncPoint.strategy = strategy.name;
          syncPoints.push({
            strategy: strategy.name,
            syncPoint
          });
        }
      }
      return syncPoints;
    }
    /**
     * Selects the sync-point nearest the specified target
     *
     * @private
     * @param {Array} syncPoints
     *        List of sync-points to select from
     * @param {Object} target
     *        Object specifying the property and value we are targeting
     * @param {string} target.key
     *        Specifies the property to target. Must be either 'time' or 'segmentIndex'
     * @param {number} target.value
     *        The value to target for the specified key.
     * @return {Object}
     *          The sync-point nearest the target
     */
    selectSyncPoint_(syncPoints, target) {
      let bestSyncPoint = syncPoints[0].syncPoint;
      let bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);
      let bestStrategy = syncPoints[0].strategy;
      for (let i = 1; i < syncPoints.length; i++) {
        const newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);
        if (newDistance < bestDistance) {
          bestDistance = newDistance;
          bestSyncPoint = syncPoints[i].syncPoint;
          bestStrategy = syncPoints[i].strategy;
        }
      }
      this.logger_(`syncPoint for [${target.key}: ${target.value}] chosen with strategy [${bestStrategy}]: [time:${bestSyncPoint.time}, segmentIndex:${bestSyncPoint.segmentIndex}` + (typeof bestSyncPoint.partIndex === "number" ? `,partIndex:${bestSyncPoint.partIndex}` : "") + "]");
      return bestSyncPoint;
    }
    /**
     * Save any meta-data present on the segments when segments leave
     * the live window to the playlist to allow for synchronization at the
     * playlist level later.
     *
     * @param {Playlist} oldPlaylist - The previous active playlist
     * @param {Playlist} newPlaylist - The updated and most current playlist
     */
    saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {
      const mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
      if (mediaSequenceDiff > MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC) {
        videojs.log.warn(`Not saving expired segment info. Media sequence gap ${mediaSequenceDiff} is too large.`);
        return;
      }
      for (let i = mediaSequenceDiff - 1; i >= 0; i--) {
        const lastRemovedSegment = oldPlaylist.segments[i];
        if (lastRemovedSegment && typeof lastRemovedSegment.start !== "undefined") {
          newPlaylist.syncInfo = {
            mediaSequence: oldPlaylist.mediaSequence + i,
            time: lastRemovedSegment.start
          };
          this.logger_(`playlist refresh sync: [time:${newPlaylist.syncInfo.time}, mediaSequence: ${newPlaylist.syncInfo.mediaSequence}]`);
          this.trigger("syncinfoupdate");
          break;
        }
      }
    }
    /**
     * Save the mapping from playlist's ProgramDateTime to display. This should only happen
     * before segments start to load.
     *
     * @param {Playlist} playlist - The currently active playlist
     */
    setDateTimeMappingForStart(playlist) {
      this.timelineToDatetimeMappings = {};
      if (playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {
        const firstSegment = playlist.segments[0];
        const playlistTimestamp = firstSegment.dateTimeObject.getTime() / 1e3;
        this.timelineToDatetimeMappings[firstSegment.timeline] = -playlistTimestamp;
      }
    }
    /**
     * Calculates and saves timeline mappings, playlist sync info, and segment timing values
     * based on the latest timing information.
     *
     * @param {Object} options
     *        Options object
     * @param {SegmentInfo} options.segmentInfo
     *        The current active request information
     * @param {boolean} options.shouldSaveTimelineMapping
     *        If there's a timeline change, determines if the timeline mapping should be
     *        saved for timeline mapping and program date time mappings.
     */
    saveSegmentTimingInfo({
      segmentInfo,
      shouldSaveTimelineMapping
    }) {
      const didCalculateSegmentTimeMapping = this.calculateSegmentTimeMapping_(segmentInfo, segmentInfo.timingInfo, shouldSaveTimelineMapping);
      const segment = segmentInfo.segment;
      if (didCalculateSegmentTimeMapping) {
        this.saveDiscontinuitySyncInfo_(segmentInfo);
        if (!segmentInfo.playlist.syncInfo) {
          segmentInfo.playlist.syncInfo = {
            mediaSequence: segmentInfo.playlist.mediaSequence + segmentInfo.mediaIndex,
            time: segment.start
          };
        }
      }
      const dateTime = segment.dateTimeObject;
      if (segment.discontinuity && shouldSaveTimelineMapping && dateTime) {
        this.timelineToDatetimeMappings[segment.timeline] = -(dateTime.getTime() / 1e3);
      }
    }
    timestampOffsetForTimeline(timeline) {
      if (typeof this.timelines[timeline] === "undefined") {
        return null;
      }
      return this.timelines[timeline].time;
    }
    mappingForTimeline(timeline) {
      if (typeof this.timelines[timeline] === "undefined") {
        return null;
      }
      return this.timelines[timeline].mapping;
    }
    /**
     * Use the "media time" for a segment to generate a mapping to "display time" and
     * save that display time to the segment.
     *
     * @private
     * @param {SegmentInfo} segmentInfo
     *        The current active request information
     * @param {Object} timingInfo
     *        The start and end time of the current segment in "media time"
     * @param {boolean} shouldSaveTimelineMapping
     *        If there's a timeline change, determines if the timeline mapping should be
     *        saved in timelines.
     * @return {boolean}
     *          Returns false if segment time mapping could not be calculated
     */
    calculateSegmentTimeMapping_(segmentInfo, timingInfo, shouldSaveTimelineMapping) {
      const segment = segmentInfo.segment;
      const part = segmentInfo.part;
      let mappingObj = this.timelines[segmentInfo.timeline];
      let start;
      let end;
      if (typeof segmentInfo.timestampOffset === "number") {
        mappingObj = {
          time: segmentInfo.startOfSegment,
          mapping: segmentInfo.startOfSegment - timingInfo.start
        };
        if (shouldSaveTimelineMapping) {
          this.timelines[segmentInfo.timeline] = mappingObj;
          this.trigger("timestampoffset");
          this.logger_(`time mapping for timeline ${segmentInfo.timeline}: [time: ${mappingObj.time}] [mapping: ${mappingObj.mapping}]`);
        }
        start = segmentInfo.startOfSegment;
        end = timingInfo.end + mappingObj.mapping;
      } else if (mappingObj) {
        start = timingInfo.start + mappingObj.mapping;
        end = timingInfo.end + mappingObj.mapping;
      } else {
        return false;
      }
      if (part) {
        part.start = start;
        part.end = end;
      }
      if (!segment.start || start < segment.start) {
        segment.start = start;
      }
      segment.end = end;
      return true;
    }
    /**
     * Each time we have discontinuity in the playlist, attempt to calculate the location
     * in display of the start of the discontinuity and save that. We also save an accuracy
     * value so that we save values with the most accuracy (closest to 0.)
     *
     * @private
     * @param {SegmentInfo} segmentInfo - The current active request information
     */
    saveDiscontinuitySyncInfo_(segmentInfo) {
      const playlist = segmentInfo.playlist;
      const segment = segmentInfo.segment;
      if (segment.discontinuity) {
        this.discontinuities[segment.timeline] = {
          time: segment.start,
          accuracy: 0
        };
      } else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
        for (let i = 0; i < playlist.discontinuityStarts.length; i++) {
          const segmentIndex = playlist.discontinuityStarts[i];
          const discontinuity = playlist.discontinuitySequence + i + 1;
          const mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;
          const accuracy = Math.abs(mediaIndexDiff);
          if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {
            let time;
            if (mediaIndexDiff < 0) {
              time = segment.start - sumDurations({
                defaultDuration: playlist.targetDuration,
                durationList: playlist.segments,
                startIndex: segmentInfo.mediaIndex,
                endIndex: segmentIndex
              });
            } else {
              time = segment.end + sumDurations({
                defaultDuration: playlist.targetDuration,
                durationList: playlist.segments,
                startIndex: segmentInfo.mediaIndex + 1,
                endIndex: segmentIndex
              });
            }
            this.discontinuities[discontinuity] = {
              time,
              accuracy
            };
          }
        }
      }
    }
    dispose() {
      this.trigger("dispose");
      this.off();
    }
  }
  class TimelineChangeController extends videojs.EventTarget {
    constructor() {
      super();
      this.pendingTimelineChanges_ = {};
      this.lastTimelineChanges_ = {};
    }
    clearPendingTimelineChange(type) {
      this.pendingTimelineChanges_[type] = null;
      this.trigger("pendingtimelinechange");
    }
    pendingTimelineChange({
      type,
      from: from2,
      to
    }) {
      if (typeof from2 === "number" && typeof to === "number") {
        this.pendingTimelineChanges_[type] = {
          type,
          from: from2,
          to
        };
        this.trigger("pendingtimelinechange");
      }
      return this.pendingTimelineChanges_[type];
    }
    lastTimelineChange({
      type,
      from: from2,
      to
    }) {
      if (typeof from2 === "number" && typeof to === "number") {
        this.lastTimelineChanges_[type] = {
          type,
          from: from2,
          to
        };
        delete this.pendingTimelineChanges_[type];
        this.trigger("timelinechange");
      }
      return this.lastTimelineChanges_[type];
    }
    dispose() {
      this.trigger("dispose");
      this.pendingTimelineChanges_ = {};
      this.lastTimelineChanges_ = {};
      this.off();
    }
  }
  const workerCode = transform(getWorkerString(function() {
    var Stream2 = /* @__PURE__ */ function() {
      function Stream3() {
        this.listeners = {};
      }
      var _proto = Stream3.prototype;
      _proto.on = function on2(type, listener) {
        if (!this.listeners[type]) {
          this.listeners[type] = [];
        }
        this.listeners[type].push(listener);
      };
      _proto.off = function off2(type, listener) {
        if (!this.listeners[type]) {
          return false;
        }
        var index = this.listeners[type].indexOf(listener);
        this.listeners[type] = this.listeners[type].slice(0);
        this.listeners[type].splice(index, 1);
        return index > -1;
      };
      _proto.trigger = function trigger2(type) {
        var callbacks = this.listeners[type];
        if (!callbacks) {
          return;
        }
        if (arguments.length === 2) {
          var length = callbacks.length;
          for (var i = 0; i < length; ++i) {
            callbacks[i].call(this, arguments[1]);
          }
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          var _length = callbacks.length;
          for (var _i = 0; _i < _length; ++_i) {
            callbacks[_i].apply(this, args);
          }
        }
      };
      _proto.dispose = function dispose() {
        this.listeners = {};
      };
      _proto.pipe = function pipe(destination) {
        this.on("data", function(data) {
          destination.push(data);
        });
      };
      return Stream3;
    }();
    /*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */
    function unpad(padded) {
      return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
    }
    /*! @name aes-decrypter @version 4.0.1 @license Apache-2.0 */
    const precompute = function() {
      const tables = [[[], [], [], [], []], [[], [], [], [], []]];
      const encTable = tables[0];
      const decTable = tables[1];
      const sbox = encTable[4];
      const sboxInv = decTable[4];
      let i;
      let x;
      let xInv;
      const d = [];
      const th = [];
      let x2;
      let x4;
      let x8;
      let s;
      let tEnc;
      let tDec;
      for (i = 0; i < 256; i++) {
        th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
      }
      for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
        s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
        s = s >> 8 ^ s & 255 ^ 99;
        sbox[x] = s;
        sboxInv[s] = x;
        x8 = d[x4 = d[x2 = d[x]]];
        tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
        tEnc = d[s] * 257 ^ s * 16843008;
        for (i = 0; i < 4; i++) {
          encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
          decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
        }
      }
      for (i = 0; i < 5; i++) {
        encTable[i] = encTable[i].slice(0);
        decTable[i] = decTable[i].slice(0);
      }
      return tables;
    };
    let aesTables = null;
    class AES {
      constructor(key) {
        if (!aesTables) {
          aesTables = precompute();
        }
        this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];
        let i;
        let j;
        let tmp;
        const sbox = this._tables[0][4];
        const decTable = this._tables[1];
        const keyLen = key.length;
        let rcon = 1;
        if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
          throw new Error("Invalid aes key size");
        }
        const encKey = key.slice(0);
        const decKey = [];
        this._key = [encKey, decKey];
        for (i = keyLen; i < 4 * keyLen + 28; i++) {
          tmp = encKey[i - 1];
          if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
            tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
            if (i % keyLen === 0) {
              tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
              rcon = rcon << 1 ^ (rcon >> 7) * 283;
            }
          }
          encKey[i] = encKey[i - keyLen] ^ tmp;
        }
        for (j = 0; i; j++, i--) {
          tmp = encKey[j & 3 ? i : i - 4];
          if (i <= 4 || j < 4) {
            decKey[j] = tmp;
          } else {
            decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
          }
        }
      }
      /**
       * Decrypt 16 bytes, specified as four 32-bit words.
       *
       * @param {number} encrypted0 the first word to decrypt
       * @param {number} encrypted1 the second word to decrypt
       * @param {number} encrypted2 the third word to decrypt
       * @param {number} encrypted3 the fourth word to decrypt
       * @param {Int32Array} out the array to write the decrypted words
       * into
       * @param {number} offset the offset into the output array to start
       * writing results
       * @return {Array} The plaintext.
       */
      decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {
        const key = this._key[1];
        let a = encrypted0 ^ key[0];
        let b = encrypted3 ^ key[1];
        let c = encrypted2 ^ key[2];
        let d = encrypted1 ^ key[3];
        let a2;
        let b2;
        let c2;
        const nInnerRounds = key.length / 4 - 2;
        let i;
        let kIndex = 4;
        const table = this._tables[1];
        const table0 = table[0];
        const table1 = table[1];
        const table2 = table[2];
        const table3 = table[3];
        const sbox = table[4];
        for (i = 0; i < nInnerRounds; i++) {
          a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];
          b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];
          c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];
          d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];
          kIndex += 4;
          a = a2;
          b = b2;
          c = c2;
        }
        for (i = 0; i < 4; i++) {
          out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
          a2 = a;
          a = b;
          b = c;
          c = d;
          d = a2;
        }
      }
    }
    class AsyncStream extends Stream2 {
      constructor() {
        super(Stream2);
        this.jobs = [];
        this.delay = 1;
        this.timeout_ = null;
      }
      /**
       * process an async job
       *
       * @private
       */
      processJob_() {
        this.jobs.shift()();
        if (this.jobs.length) {
          this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
        } else {
          this.timeout_ = null;
        }
      }
      /**
       * push a job into the stream
       *
       * @param {Function} job the job to push into the stream
       */
      push(job) {
        this.jobs.push(job);
        if (!this.timeout_) {
          this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
        }
      }
    }
    const ntoh = function(word) {
      return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
    };
    const decrypt2 = function(encrypted, key, initVector) {
      const encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);
      const decipher = new AES(Array.prototype.slice.call(key));
      const decrypted = new Uint8Array(encrypted.byteLength);
      const decrypted32 = new Int32Array(decrypted.buffer);
      let init0;
      let init1;
      let init2;
      let init3;
      let encrypted0;
      let encrypted1;
      let encrypted2;
      let encrypted3;
      let wordIx;
      init0 = initVector[0];
      init1 = initVector[1];
      init2 = initVector[2];
      init3 = initVector[3];
      for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {
        encrypted0 = ntoh(encrypted32[wordIx]);
        encrypted1 = ntoh(encrypted32[wordIx + 1]);
        encrypted2 = ntoh(encrypted32[wordIx + 2]);
        encrypted3 = ntoh(encrypted32[wordIx + 3]);
        decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);
        decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);
        decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);
        decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);
        decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3);
        init0 = encrypted0;
        init1 = encrypted1;
        init2 = encrypted2;
        init3 = encrypted3;
      }
      return decrypted;
    };
    class Decrypter2 {
      constructor(encrypted, key, initVector, done) {
        const step = Decrypter2.STEP;
        const encrypted32 = new Int32Array(encrypted.buffer);
        const decrypted = new Uint8Array(encrypted.byteLength);
        let i = 0;
        this.asyncStream_ = new AsyncStream();
        this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
        for (i = step; i < encrypted32.length; i += step) {
          initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);
          this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
        }
        this.asyncStream_.push(function() {
          done(null, unpad(decrypted));
        });
      }
      /**
       * a getter for step the maximum number of bytes to process at one time
       *
       * @return {number} the value of step 32000
       */
      static get STEP() {
        return 32e3;
      }
      /**
       * @private
       */
      decryptChunk_(encrypted, key, initVector, decrypted) {
        return function() {
          const bytes = decrypt2(encrypted, key, initVector);
          decrypted.set(bytes, encrypted.byteOffset);
        };
      }
    }
    var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var win2;
    if (typeof window !== "undefined") {
      win2 = window;
    } else if (typeof commonjsGlobal2 !== "undefined") {
      win2 = commonjsGlobal2;
    } else if (typeof self !== "undefined") {
      win2 = self;
    } else {
      win2 = {};
    }
    var window_12 = win2;
    var isArrayBufferView2 = function isArrayBufferView3(obj) {
      if (ArrayBuffer.isView === "function") {
        return ArrayBuffer.isView(obj);
      }
      return obj && obj.buffer instanceof ArrayBuffer;
    };
    var BigInt2 = window_12.BigInt || Number;
    [BigInt2("0x1"), BigInt2("0x100"), BigInt2("0x10000"), BigInt2("0x1000000"), BigInt2("0x100000000"), BigInt2("0x10000000000"), BigInt2("0x1000000000000"), BigInt2("0x100000000000000"), BigInt2("0x10000000000000000")];
    (function() {
      var a = new Uint16Array([65484]);
      var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
      if (b[0] === 255) {
        return "big";
      }
      if (b[0] === 204) {
        return "little";
      }
      return "unknown";
    })();
    const createTransferableMessage2 = function(message) {
      const transferable = {};
      Object.keys(message).forEach((key) => {
        const value = message[key];
        if (isArrayBufferView2(value)) {
          transferable[key] = {
            bytes: value.buffer,
            byteOffset: value.byteOffset,
            byteLength: value.byteLength
          };
        } else {
          transferable[key] = value;
        }
      });
      return transferable;
    };
    self.onmessage = function(event) {
      const data = event.data;
      const encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);
      const key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);
      const iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);
      new Decrypter2(encrypted, key, iv, function(err, bytes) {
        self.postMessage(createTransferableMessage2({
          source: data.source,
          decrypted: bytes
        }), [bytes.buffer]);
      });
    };
  }));
  var Decrypter = factory(workerCode);
  const audioTrackKind_ = (properties) => {
    let kind = properties.default ? "main" : "alternative";
    if (properties.characteristics && properties.characteristics.indexOf("public.accessibility.describes-video") >= 0) {
      kind = "main-desc";
    }
    return kind;
  };
  const stopLoaders = (segmentLoader, mediaType) => {
    segmentLoader.abort();
    segmentLoader.pause();
    if (mediaType && mediaType.activePlaylistLoader) {
      mediaType.activePlaylistLoader.pause();
      mediaType.activePlaylistLoader = null;
    }
  };
  const startLoaders = (playlistLoader, mediaType) => {
    mediaType.activePlaylistLoader = playlistLoader;
    playlistLoader.load();
  };
  const onGroupChanged = (type, settings) => () => {
    const {
      segmentLoaders: {
        [type]: segmentLoader,
        main: mainSegmentLoader
      },
      mediaTypes: {
        [type]: mediaType
      }
    } = settings;
    const activeTrack2 = mediaType.activeTrack();
    const activeGroup2 = mediaType.getActiveGroup();
    const previousActiveLoader = mediaType.activePlaylistLoader;
    const lastGroup = mediaType.lastGroup_;
    if (activeGroup2 && lastGroup && activeGroup2.id === lastGroup.id) {
      return;
    }
    mediaType.lastGroup_ = activeGroup2;
    mediaType.lastTrack_ = activeTrack2;
    stopLoaders(segmentLoader, mediaType);
    if (!activeGroup2 || activeGroup2.isMainPlaylist) {
      return;
    }
    if (!activeGroup2.playlistLoader) {
      if (previousActiveLoader) {
        mainSegmentLoader.resetEverything();
      }
      return;
    }
    segmentLoader.resyncLoader();
    startLoaders(activeGroup2.playlistLoader, mediaType);
  };
  const onGroupChanging = (type, settings) => () => {
    const {
      segmentLoaders: {
        [type]: segmentLoader
      },
      mediaTypes: {
        [type]: mediaType
      }
    } = settings;
    mediaType.lastGroup_ = null;
    segmentLoader.abort();
    segmentLoader.pause();
  };
  const onTrackChanged = (type, settings) => () => {
    const {
      mainPlaylistLoader,
      segmentLoaders: {
        [type]: segmentLoader,
        main: mainSegmentLoader
      },
      mediaTypes: {
        [type]: mediaType
      }
    } = settings;
    const activeTrack2 = mediaType.activeTrack();
    const activeGroup2 = mediaType.getActiveGroup();
    const previousActiveLoader = mediaType.activePlaylistLoader;
    const lastTrack = mediaType.lastTrack_;
    if (lastTrack && activeTrack2 && lastTrack.id === activeTrack2.id) {
      return;
    }
    mediaType.lastGroup_ = activeGroup2;
    mediaType.lastTrack_ = activeTrack2;
    stopLoaders(segmentLoader, mediaType);
    if (!activeGroup2) {
      return;
    }
    if (activeGroup2.isMainPlaylist) {
      if (!activeTrack2 || !lastTrack || activeTrack2.id === lastTrack.id) {
        return;
      }
      const pc = settings.vhs.playlistController_;
      const newPlaylist = pc.selectPlaylist();
      if (pc.media() === newPlaylist) {
        return;
      }
      mediaType.logger_(`track change. Switching main audio from ${lastTrack.id} to ${activeTrack2.id}`);
      mainPlaylistLoader.pause();
      mainSegmentLoader.resetEverything();
      pc.fastQualityChange_(newPlaylist);
      return;
    }
    if (type === "AUDIO") {
      if (!activeGroup2.playlistLoader) {
        mainSegmentLoader.setAudio(true);
        mainSegmentLoader.resetEverything();
        return;
      }
      segmentLoader.setAudio(true);
      mainSegmentLoader.setAudio(false);
    }
    if (previousActiveLoader === activeGroup2.playlistLoader) {
      startLoaders(activeGroup2.playlistLoader, mediaType);
      return;
    }
    if (segmentLoader.track) {
      segmentLoader.track(activeTrack2);
    }
    segmentLoader.resetEverything();
    startLoaders(activeGroup2.playlistLoader, mediaType);
  };
  const onError = {
    /**
     * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
     * an error.
     *
     * @param {string} type
     *        MediaGroup type
     * @param {Object} settings
     *        Object containing required information for media groups
     * @return {Function}
     *         Error handler. Logs warning (or error if the playlist is excluded) to
     *         console and switches back to default audio track.
     * @function onError.AUDIO
     */
    AUDIO: (type, settings) => () => {
      const {
        mediaTypes: {
          [type]: mediaType
        },
        excludePlaylist
      } = settings;
      const activeTrack2 = mediaType.activeTrack();
      const activeGroup2 = mediaType.activeGroup();
      const id = (activeGroup2.filter((group) => group.default)[0] || activeGroup2[0]).id;
      const defaultTrack = mediaType.tracks[id];
      if (activeTrack2 === defaultTrack) {
        excludePlaylist({
          error: {
            message: "Problem encountered loading the default audio track."
          }
        });
        return;
      }
      videojs.log.warn("Problem encountered loading the alternate audio track.Switching back to default.");
      for (const trackId in mediaType.tracks) {
        mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;
      }
      mediaType.onTrackChanged();
    },
    /**
     * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
     * an error.
     *
     * @param {string} type
     *        MediaGroup type
     * @param {Object} settings
     *        Object containing required information for media groups
     * @return {Function}
     *         Error handler. Logs warning to console and disables the active subtitle track
     * @function onError.SUBTITLES
     */
    SUBTITLES: (type, settings) => () => {
      const {
        mediaTypes: {
          [type]: mediaType
        }
      } = settings;
      videojs.log.warn("Problem encountered loading the subtitle track.Disabling subtitle track.");
      const track = mediaType.activeTrack();
      if (track) {
        track.mode = "disabled";
      }
      mediaType.onTrackChanged();
    }
  };
  const setupListeners = {
    /**
     * Setup event listeners for audio playlist loader
     *
     * @param {string} type
     *        MediaGroup type
     * @param {PlaylistLoader|null} playlistLoader
     *        PlaylistLoader to register listeners on
     * @param {Object} settings
     *        Object containing required information for media groups
     * @function setupListeners.AUDIO
     */
    AUDIO: (type, playlistLoader, settings) => {
      if (!playlistLoader) {
        return;
      }
      const {
        tech,
        requestOptions,
        segmentLoaders: {
          [type]: segmentLoader
        }
      } = settings;
      playlistLoader.on("loadedmetadata", () => {
        const media = playlistLoader.media();
        segmentLoader.playlist(media, requestOptions);
        if (!tech.paused() || media.endList && tech.preload() !== "none") {
          segmentLoader.load();
        }
      });
      playlistLoader.on("loadedplaylist", () => {
        segmentLoader.playlist(playlistLoader.media(), requestOptions);
        if (!tech.paused()) {
          segmentLoader.load();
        }
      });
      playlistLoader.on("error", onError[type](type, settings));
    },
    /**
     * Setup event listeners for subtitle playlist loader
     *
     * @param {string} type
     *        MediaGroup type
     * @param {PlaylistLoader|null} playlistLoader
     *        PlaylistLoader to register listeners on
     * @param {Object} settings
     *        Object containing required information for media groups
     * @function setupListeners.SUBTITLES
     */
    SUBTITLES: (type, playlistLoader, settings) => {
      const {
        tech,
        requestOptions,
        segmentLoaders: {
          [type]: segmentLoader
        },
        mediaTypes: {
          [type]: mediaType
        }
      } = settings;
      playlistLoader.on("loadedmetadata", () => {
        const media = playlistLoader.media();
        segmentLoader.playlist(media, requestOptions);
        segmentLoader.track(mediaType.activeTrack());
        if (!tech.paused() || media.endList && tech.preload() !== "none") {
          segmentLoader.load();
        }
      });
      playlistLoader.on("loadedplaylist", () => {
        segmentLoader.playlist(playlistLoader.media(), requestOptions);
        if (!tech.paused()) {
          segmentLoader.load();
        }
      });
      playlistLoader.on("error", onError[type](type, settings));
    }
  };
  const initialize = {
    /**
     * Setup PlaylistLoaders and AudioTracks for the audio groups
     *
     * @param {string} type
     *        MediaGroup type
     * @param {Object} settings
     *        Object containing required information for media groups
     * @function initialize.AUDIO
     */
    "AUDIO": (type, settings) => {
      const {
        vhs,
        sourceType,
        segmentLoaders: {
          [type]: segmentLoader
        },
        requestOptions,
        main: {
          mediaGroups
        },
        mediaTypes: {
          [type]: {
            groups,
            tracks,
            logger_
          }
        },
        mainPlaylistLoader
      } = settings;
      const audioOnlyMain = isAudioOnly(mainPlaylistLoader.main);
      if (!mediaGroups[type] || Object.keys(mediaGroups[type]).length === 0) {
        mediaGroups[type] = {
          main: {
            default: {
              default: true
            }
          }
        };
        if (audioOnlyMain) {
          mediaGroups[type].main.default.playlists = mainPlaylistLoader.main.playlists;
        }
      }
      for (const groupId in mediaGroups[type]) {
        if (!groups[groupId]) {
          groups[groupId] = [];
        }
        for (const variantLabel in mediaGroups[type][groupId]) {
          let properties = mediaGroups[type][groupId][variantLabel];
          let playlistLoader;
          if (audioOnlyMain) {
            logger_(`AUDIO group '${groupId}' label '${variantLabel}' is a main playlist`);
            properties.isMainPlaylist = true;
            playlistLoader = null;
          } else if (sourceType === "vhs-json" && properties.playlists) {
            playlistLoader = new PlaylistLoader(properties.playlists[0], vhs, requestOptions);
          } else if (properties.resolvedUri) {
            playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);
          } else if (properties.playlists && sourceType === "dash") {
            playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, mainPlaylistLoader);
          } else {
            playlistLoader = null;
          }
          properties = merge({
            id: variantLabel,
            playlistLoader
          }, properties);
          setupListeners[type](type, properties.playlistLoader, settings);
          groups[groupId].push(properties);
          if (typeof tracks[variantLabel] === "undefined") {
            const track = new videojs.AudioTrack({
              id: variantLabel,
              kind: audioTrackKind_(properties),
              enabled: false,
              language: properties.language,
              default: properties.default,
              label: variantLabel
            });
            tracks[variantLabel] = track;
          }
        }
      }
      segmentLoader.on("error", onError[type](type, settings));
    },
    /**
     * Setup PlaylistLoaders and TextTracks for the subtitle groups
     *
     * @param {string} type
     *        MediaGroup type
     * @param {Object} settings
     *        Object containing required information for media groups
     * @function initialize.SUBTITLES
     */
    "SUBTITLES": (type, settings) => {
      const {
        tech,
        vhs,
        sourceType,
        segmentLoaders: {
          [type]: segmentLoader
        },
        requestOptions,
        main: {
          mediaGroups
        },
        mediaTypes: {
          [type]: {
            groups,
            tracks
          }
        },
        mainPlaylistLoader
      } = settings;
      for (const groupId in mediaGroups[type]) {
        if (!groups[groupId]) {
          groups[groupId] = [];
        }
        for (const variantLabel in mediaGroups[type][groupId]) {
          if (!vhs.options_.useForcedSubtitles && mediaGroups[type][groupId][variantLabel].forced) {
            continue;
          }
          let properties = mediaGroups[type][groupId][variantLabel];
          let playlistLoader;
          if (sourceType === "hls") {
            playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);
          } else if (sourceType === "dash") {
            const playlists = properties.playlists.filter((p) => p.excludeUntil !== Infinity);
            if (!playlists.length) {
              return;
            }
            playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, mainPlaylistLoader);
          } else if (sourceType === "vhs-json") {
            playlistLoader = new PlaylistLoader(
              // if the vhs-json object included the media playlist, use the media playlist
              // as provided, otherwise use the resolved URI to load the playlist
              properties.playlists ? properties.playlists[0] : properties.resolvedUri,
              vhs,
              requestOptions
            );
          }
          properties = merge({
            id: variantLabel,
            playlistLoader
          }, properties);
          setupListeners[type](type, properties.playlistLoader, settings);
          groups[groupId].push(properties);
          if (typeof tracks[variantLabel] === "undefined") {
            const track = tech.addRemoteTextTrack({
              id: variantLabel,
              kind: "subtitles",
              default: properties.default && properties.autoselect,
              language: properties.language,
              label: variantLabel
            }, false).track;
            tracks[variantLabel] = track;
          }
        }
      }
      segmentLoader.on("error", onError[type](type, settings));
    },
    /**
     * Setup TextTracks for the closed-caption groups
     *
     * @param {String} type
     *        MediaGroup type
     * @param {Object} settings
     *        Object containing required information for media groups
     * @function initialize['CLOSED-CAPTIONS']
     */
    "CLOSED-CAPTIONS": (type, settings) => {
      const {
        tech,
        main: {
          mediaGroups
        },
        mediaTypes: {
          [type]: {
            groups,
            tracks
          }
        }
      } = settings;
      for (const groupId in mediaGroups[type]) {
        if (!groups[groupId]) {
          groups[groupId] = [];
        }
        for (const variantLabel in mediaGroups[type][groupId]) {
          const properties = mediaGroups[type][groupId][variantLabel];
          if (!/^(?:CC|SERVICE)/.test(properties.instreamId)) {
            continue;
          }
          const captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
          let newProps = {
            label: variantLabel,
            language: properties.language,
            instreamId: properties.instreamId,
            default: properties.default && properties.autoselect
          };
          if (captionServices[newProps.instreamId]) {
            newProps = merge(newProps, captionServices[newProps.instreamId]);
          }
          if (newProps.default === void 0) {
            delete newProps.default;
          }
          groups[groupId].push(merge({
            id: variantLabel
          }, properties));
          if (typeof tracks[variantLabel] === "undefined") {
            const track = tech.addRemoteTextTrack({
              id: newProps.instreamId,
              kind: "captions",
              default: newProps.default,
              language: newProps.language,
              label: newProps.label
            }, false).track;
            tracks[variantLabel] = track;
          }
        }
      }
    }
  };
  const groupMatch = (list, media) => {
    for (let i = 0; i < list.length; i++) {
      if (playlistMatch(media, list[i])) {
        return true;
      }
      if (list[i].playlists && groupMatch(list[i].playlists, media)) {
        return true;
      }
    }
    return false;
  };
  const activeGroup = (type, settings) => (track) => {
    const {
      mainPlaylistLoader,
      mediaTypes: {
        [type]: {
          groups
        }
      }
    } = settings;
    const media = mainPlaylistLoader.media();
    if (!media) {
      return null;
    }
    let variants = null;
    if (media.attributes[type]) {
      variants = groups[media.attributes[type]];
    }
    const groupKeys = Object.keys(groups);
    if (!variants) {
      if (type === "AUDIO" && groupKeys.length > 1 && isAudioOnly(settings.main)) {
        for (let i = 0; i < groupKeys.length; i++) {
          const groupPropertyList = groups[groupKeys[i]];
          if (groupMatch(groupPropertyList, media)) {
            variants = groupPropertyList;
            break;
          }
        }
      } else if (groups.main) {
        variants = groups.main;
      } else if (groupKeys.length === 1) {
        variants = groups[groupKeys[0]];
      }
    }
    if (typeof track === "undefined") {
      return variants;
    }
    if (track === null || !variants) {
      return null;
    }
    return variants.filter((props) => props.id === track.id)[0] || null;
  };
  const activeTrack = {
    /**
     * Returns a function used to get the active track of type provided
     *
     * @param {string} type
     *        MediaGroup type
     * @param {Object} settings
     *        Object containing required information for media groups
     * @return {Function}
     *         Function that returns the active media track for the provided type. Returns
     *         null if no track is active
     * @function activeTrack.AUDIO
     */
    AUDIO: (type, settings) => () => {
      const {
        mediaTypes: {
          [type]: {
            tracks
          }
        }
      } = settings;
      for (const id in tracks) {
        if (tracks[id].enabled) {
          return tracks[id];
        }
      }
      return null;
    },
    /**
     * Returns a function used to get the active track of type provided
     *
     * @param {string} type
     *        MediaGroup type
     * @param {Object} settings
     *        Object containing required information for media groups
     * @return {Function}
     *         Function that returns the active media track for the provided type. Returns
     *         null if no track is active
     * @function activeTrack.SUBTITLES
     */
    SUBTITLES: (type, settings) => () => {
      const {
        mediaTypes: {
          [type]: {
            tracks
          }
        }
      } = settings;
      for (const id in tracks) {
        if (tracks[id].mode === "showing" || tracks[id].mode === "hidden") {
          return tracks[id];
        }
      }
      return null;
    }
  };
  const getActiveGroup = (type, {
    mediaTypes: mediaTypes2
  }) => () => {
    const activeTrack_ = mediaTypes2[type].activeTrack();
    if (!activeTrack_) {
      return null;
    }
    return mediaTypes2[type].activeGroup(activeTrack_);
  };
  const setupMediaGroups = (settings) => {
    ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((type) => {
      initialize[type](type, settings);
    });
    const {
      mediaTypes: mediaTypes2,
      mainPlaylistLoader,
      tech,
      vhs,
      segmentLoaders: {
        ["AUDIO"]: audioSegmentLoader,
        main: mainSegmentLoader
      }
    } = settings;
    ["AUDIO", "SUBTITLES"].forEach((type) => {
      mediaTypes2[type].activeGroup = activeGroup(type, settings);
      mediaTypes2[type].activeTrack = activeTrack[type](type, settings);
      mediaTypes2[type].onGroupChanged = onGroupChanged(type, settings);
      mediaTypes2[type].onGroupChanging = onGroupChanging(type, settings);
      mediaTypes2[type].onTrackChanged = onTrackChanged(type, settings);
      mediaTypes2[type].getActiveGroup = getActiveGroup(type, settings);
    });
    const audioGroup = mediaTypes2.AUDIO.activeGroup();
    if (audioGroup) {
      const groupId = (audioGroup.filter((group) => group.default)[0] || audioGroup[0]).id;
      mediaTypes2.AUDIO.tracks[groupId].enabled = true;
      mediaTypes2.AUDIO.onGroupChanged();
      mediaTypes2.AUDIO.onTrackChanged();
      const activeAudioGroup = mediaTypes2.AUDIO.getActiveGroup();
      if (!activeAudioGroup.playlistLoader) {
        mainSegmentLoader.setAudio(true);
      } else {
        mainSegmentLoader.setAudio(false);
        audioSegmentLoader.setAudio(true);
      }
    }
    mainPlaylistLoader.on("mediachange", () => {
      ["AUDIO", "SUBTITLES"].forEach((type) => mediaTypes2[type].onGroupChanged());
    });
    mainPlaylistLoader.on("mediachanging", () => {
      ["AUDIO", "SUBTITLES"].forEach((type) => mediaTypes2[type].onGroupChanging());
    });
    const onAudioTrackChanged = () => {
      mediaTypes2.AUDIO.onTrackChanged();
      tech.trigger({
        type: "usage",
        name: "vhs-audio-change"
      });
    };
    tech.audioTracks().addEventListener("change", onAudioTrackChanged);
    tech.remoteTextTracks().addEventListener("change", mediaTypes2.SUBTITLES.onTrackChanged);
    vhs.on("dispose", () => {
      tech.audioTracks().removeEventListener("change", onAudioTrackChanged);
      tech.remoteTextTracks().removeEventListener("change", mediaTypes2.SUBTITLES.onTrackChanged);
    });
    tech.clearTracks("audio");
    for (const id in mediaTypes2.AUDIO.tracks) {
      tech.audioTracks().addTrack(mediaTypes2.AUDIO.tracks[id]);
    }
  };
  const createMediaTypes = () => {
    const mediaTypes2 = {};
    ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((type) => {
      mediaTypes2[type] = {
        groups: {},
        tracks: {},
        activePlaylistLoader: null,
        activeGroup: noop,
        activeTrack: noop,
        getActiveGroup: noop,
        onGroupChanged: noop,
        onTrackChanged: noop,
        lastTrack_: null,
        logger_: logger(`MediaGroups[${type}]`)
      };
    });
    return mediaTypes2;
  };
  class SteeringManifest {
    constructor() {
      this.priority_ = [];
      this.pathwayClones_ = /* @__PURE__ */ new Map();
    }
    set version(number) {
      if (number === 1) {
        this.version_ = number;
      }
    }
    set ttl(seconds) {
      this.ttl_ = seconds || 300;
    }
    set reloadUri(uri) {
      if (uri) {
        this.reloadUri_ = resolveUrl(this.reloadUri_, uri);
      }
    }
    set priority(array) {
      if (array && array.length) {
        this.priority_ = array;
      }
    }
    set pathwayClones(array) {
      if (array && array.length) {
        this.pathwayClones_ = new Map(array.map((clone) => [clone.ID, clone]));
      }
    }
    get version() {
      return this.version_;
    }
    get ttl() {
      return this.ttl_;
    }
    get reloadUri() {
      return this.reloadUri_;
    }
    get priority() {
      return this.priority_;
    }
    get pathwayClones() {
      return this.pathwayClones_;
    }
  }
  class ContentSteeringController extends videojs.EventTarget {
    constructor(xhr, bandwidth) {
      super();
      this.currentPathway = null;
      this.defaultPathway = null;
      this.queryBeforeStart = false;
      this.availablePathways_ = /* @__PURE__ */ new Set();
      this.steeringManifest = new SteeringManifest();
      this.proxyServerUrl_ = null;
      this.manifestType_ = null;
      this.ttlTimeout_ = null;
      this.request_ = null;
      this.currentPathwayClones = /* @__PURE__ */ new Map();
      this.nextPathwayClones = /* @__PURE__ */ new Map();
      this.excludedSteeringManifestURLs = /* @__PURE__ */ new Set();
      this.logger_ = logger("Content Steering");
      this.xhr_ = xhr;
      this.getBandwidth_ = bandwidth;
    }
    /**
     * Assigns the content steering tag properties to the steering controller
     *
     * @param {string} baseUrl the baseURL from the main manifest for resolving the steering manifest url
     * @param {Object} steeringTag the content steering tag from the main manifest
     */
    assignTagProperties(baseUrl, steeringTag) {
      this.manifestType_ = steeringTag.serverUri ? "HLS" : "DASH";
      const steeringUri = steeringTag.serverUri || steeringTag.serverURL;
      if (!steeringUri) {
        this.logger_(`steering manifest URL is ${steeringUri}, cannot request steering manifest.`);
        this.trigger("error");
        return;
      }
      if (steeringUri.startsWith("data:")) {
        this.decodeDataUriManifest_(steeringUri.substring(steeringUri.indexOf(",") + 1));
        return;
      }
      this.steeringManifest.reloadUri = resolveUrl(baseUrl, steeringUri);
      this.defaultPathway = steeringTag.pathwayId || steeringTag.defaultServiceLocation;
      this.queryBeforeStart = steeringTag.queryBeforeStart;
      this.proxyServerUrl_ = steeringTag.proxyServerURL;
      if (this.defaultPathway && !this.queryBeforeStart) {
        this.trigger("content-steering");
      }
    }
    /**
     * Requests the content steering manifest and parse the response. This should only be called after
     * assignTagProperties was called with a content steering tag.
     *
     * @param {string} initialUri The optional uri to make the request with.
     *    If set, the request should be made with exactly what is passed in this variable.
     *    This scenario should only happen once on initalization.
     */
    requestSteeringManifest(initial) {
      const reloadUri = this.steeringManifest.reloadUri;
      if (!reloadUri) {
        return;
      }
      const uri = initial ? reloadUri : this.getRequestURI(reloadUri);
      if (!uri) {
        this.logger_("No valid content steering manifest URIs. Stopping content steering.");
        this.trigger("error");
        this.dispose();
        return;
      }
      this.request_ = this.xhr_({
        uri
      }, (error, errorInfo) => {
        if (error) {
          if (errorInfo.status === 410) {
            this.logger_(`manifest request 410 ${error}.`);
            this.logger_(`There will be no more content steering requests to ${uri} this session.`);
            this.excludedSteeringManifestURLs.add(uri);
            return;
          }
          if (errorInfo.status === 429) {
            const retrySeconds = errorInfo.responseHeaders["retry-after"];
            this.logger_(`manifest request 429 ${error}.`);
            this.logger_(`content steering will retry in ${retrySeconds} seconds.`);
            this.startTTLTimeout_(parseInt(retrySeconds, 10));
            return;
          }
          this.logger_(`manifest failed to load ${error}.`);
          this.startTTLTimeout_();
          return;
        }
        const steeringManifestJson = JSON.parse(this.request_.responseText);
        this.assignSteeringProperties_(steeringManifestJson);
        this.startTTLTimeout_();
      });
    }
    /**
     * Set the proxy server URL and add the steering manifest url as a URI encoded parameter.
     *
     * @param {string} steeringUrl the steering manifest url
     * @return the steering manifest url to a proxy server with all parameters set
     */
    setProxyServerUrl_(steeringUrl) {
      const steeringUrlObject = new window.URL(steeringUrl);
      const proxyServerUrlObject = new window.URL(this.proxyServerUrl_);
      proxyServerUrlObject.searchParams.set("url", encodeURI(steeringUrlObject.toString()));
      return this.setSteeringParams_(proxyServerUrlObject.toString());
    }
    /**
     * Decodes and parses the data uri encoded steering manifest
     *
     * @param {string} dataUri the data uri to be decoded and parsed.
     */
    decodeDataUriManifest_(dataUri) {
      const steeringManifestJson = JSON.parse(window.atob(dataUri));
      this.assignSteeringProperties_(steeringManifestJson);
    }
    /**
     * Set the HLS or DASH content steering manifest request query parameters. For example:
     * _HLS_pathway="<CURRENT-PATHWAY-ID>" and _HLS_throughput=<THROUGHPUT>
     * _DASH_pathway and _DASH_throughput
     *
     * @param {string} uri to add content steering server parameters to.
     * @return a new uri as a string with the added steering query parameters.
     */
    setSteeringParams_(url) {
      const urlObject = new window.URL(url);
      const path = this.getPathway();
      const networkThroughput = this.getBandwidth_();
      if (path) {
        const pathwayKey = `_${this.manifestType_}_pathway`;
        urlObject.searchParams.set(pathwayKey, path);
      }
      if (networkThroughput) {
        const throughputKey = `_${this.manifestType_}_throughput`;
        urlObject.searchParams.set(throughputKey, networkThroughput);
      }
      return urlObject.toString();
    }
    /**
     * Assigns the current steering manifest properties and to the SteeringManifest object
     *
     * @param {Object} steeringJson the raw JSON steering manifest
     */
    assignSteeringProperties_(steeringJson) {
      this.steeringManifest.version = steeringJson.VERSION;
      if (!this.steeringManifest.version) {
        this.logger_(`manifest version is ${steeringJson.VERSION}, which is not supported.`);
        this.trigger("error");
        return;
      }
      this.steeringManifest.ttl = steeringJson.TTL;
      this.steeringManifest.reloadUri = steeringJson["RELOAD-URI"];
      this.steeringManifest.priority = steeringJson["PATHWAY-PRIORITY"] || steeringJson["SERVICE-LOCATION-PRIORITY"];
      this.steeringManifest.pathwayClones = steeringJson["PATHWAY-CLONES"];
      this.nextPathwayClones = this.steeringManifest.pathwayClones;
      if (!this.availablePathways_.size) {
        this.logger_("There are no available pathways for content steering. Ending content steering.");
        this.trigger("error");
        this.dispose();
      }
      const chooseNextPathway = (pathwaysByPriority) => {
        for (const path of pathwaysByPriority) {
          if (this.availablePathways_.has(path)) {
            return path;
          }
        }
        return [...this.availablePathways_][0];
      };
      const nextPathway = chooseNextPathway(this.steeringManifest.priority);
      if (this.currentPathway !== nextPathway) {
        this.currentPathway = nextPathway;
        this.trigger("content-steering");
      }
    }
    /**
     * Returns the pathway to use for steering decisions
     *
     * @return {string} returns the current pathway or the default
     */
    getPathway() {
      return this.currentPathway || this.defaultPathway;
    }
    /**
     * Chooses the manifest request URI based on proxy URIs and server URLs.
     * Also accounts for exclusion on certain manifest URIs.
     *
     * @param {string} reloadUri the base uri before parameters
     *
     * @return {string} the final URI for the request to the manifest server.
     */
    getRequestURI(reloadUri) {
      if (!reloadUri) {
        return null;
      }
      const isExcluded2 = (uri) => this.excludedSteeringManifestURLs.has(uri);
      if (this.proxyServerUrl_) {
        const proxyURI = this.setProxyServerUrl_(reloadUri);
        if (!isExcluded2(proxyURI)) {
          return proxyURI;
        }
      }
      const steeringURI = this.setSteeringParams_(reloadUri);
      if (!isExcluded2(steeringURI)) {
        return steeringURI;
      }
      return null;
    }
    /**
     * Start the timeout for re-requesting the steering manifest at the TTL interval.
     *
     * @param {number} ttl time in seconds of the timeout. Defaults to the
     *        ttl interval in the steering manifest
     */
    startTTLTimeout_(ttl = this.steeringManifest.ttl) {
      const ttlMS = ttl * 1e3;
      this.ttlTimeout_ = window.setTimeout(() => {
        this.requestSteeringManifest();
      }, ttlMS);
    }
    /**
     * Clear the TTL timeout if necessary.
     */
    clearTTLTimeout_() {
      window.clearTimeout(this.ttlTimeout_);
      this.ttlTimeout_ = null;
    }
    /**
     * aborts any current steering xhr and sets the current request object to null
     */
    abort() {
      if (this.request_) {
        this.request_.abort();
      }
      this.request_ = null;
    }
    /**
     * aborts steering requests clears the ttl timeout and resets all properties.
     */
    dispose() {
      this.off("content-steering");
      this.off("error");
      this.abort();
      this.clearTTLTimeout_();
      this.currentPathway = null;
      this.defaultPathway = null;
      this.queryBeforeStart = null;
      this.proxyServerUrl_ = null;
      this.manifestType_ = null;
      this.ttlTimeout_ = null;
      this.request_ = null;
      this.excludedSteeringManifestURLs = /* @__PURE__ */ new Set();
      this.availablePathways_ = /* @__PURE__ */ new Set();
      this.steeringManifest = new SteeringManifest();
    }
    /**
     * adds a pathway to the available pathways set
     *
     * @param {string} pathway the pathway string to add
     */
    addAvailablePathway(pathway) {
      if (pathway) {
        this.availablePathways_.add(pathway);
      }
    }
    /**
     * Clears all pathways from the available pathways set
     */
    clearAvailablePathways() {
      this.availablePathways_.clear();
    }
    /**
     * Removes a pathway from the available pathways set.
     */
    excludePathway(pathway) {
      return this.availablePathways_.delete(pathway);
    }
    /**
     * Checks the refreshed DASH manifest content steering tag for changes.
     *
     * @param {string} baseURL new steering tag on DASH manifest refresh
     * @param {Object} newTag the new tag to check for changes
     * @return a true or false whether the new tag has different values
     */
    didDASHTagChange(baseURL, newTag) {
      return !newTag && this.steeringManifest.reloadUri || newTag && (resolveUrl(baseURL, newTag.serverURL) !== this.steeringManifest.reloadUri || newTag.defaultServiceLocation !== this.defaultPathway || newTag.queryBeforeStart !== this.queryBeforeStart || newTag.proxyServerURL !== this.proxyServerUrl_);
    }
    getAvailablePathways() {
      return this.availablePathways_;
    }
  }
  const ABORT_EARLY_EXCLUSION_SECONDS = 10;
  let Vhs$1;
  const loaderStats = ["mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends"];
  const sumLoaderStat = function(stat) {
    return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];
  };
  const shouldSwitchToMedia = function({
    currentPlaylist,
    buffered,
    currentTime,
    nextPlaylist,
    bufferLowWaterLine,
    bufferHighWaterLine,
    duration: duration2,
    bufferBasedABR,
    log: log2
  }) {
    if (!nextPlaylist) {
      videojs.log.warn("We received no playlist to switch to. Please check your stream.");
      return false;
    }
    const sharedLogLine = `allowing switch ${currentPlaylist && currentPlaylist.id || "null"} -> ${nextPlaylist.id}`;
    if (!currentPlaylist) {
      log2(`${sharedLogLine} as current playlist is not set`);
      return true;
    }
    if (nextPlaylist.id === currentPlaylist.id) {
      return false;
    }
    const isBuffered = Boolean(findRange(buffered, currentTime).length);
    if (!currentPlaylist.endList) {
      if (!isBuffered && typeof currentPlaylist.partTargetDuration === "number") {
        log2(`not ${sharedLogLine} as current playlist is live llhls, but currentTime isn't in buffered.`);
        return false;
      }
      log2(`${sharedLogLine} as current playlist is live`);
      return true;
    }
    const forwardBuffer = timeAheadOf(buffered, currentTime);
    const maxBufferLowWaterLine = bufferBasedABR ? Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Config.MAX_BUFFER_LOW_WATER_LINE;
    if (duration2 < maxBufferLowWaterLine) {
      log2(`${sharedLogLine} as duration < max low water line (${duration2} < ${maxBufferLowWaterLine})`);
      return true;
    }
    const nextBandwidth = nextPlaylist.attributes.BANDWIDTH;
    const currBandwidth = currentPlaylist.attributes.BANDWIDTH;
    if (nextBandwidth < currBandwidth && (!bufferBasedABR || forwardBuffer < bufferHighWaterLine)) {
      let logLine = `${sharedLogLine} as next bandwidth < current bandwidth (${nextBandwidth} < ${currBandwidth})`;
      if (bufferBasedABR) {
        logLine += ` and forwardBuffer < bufferHighWaterLine (${forwardBuffer} < ${bufferHighWaterLine})`;
      }
      log2(logLine);
      return true;
    }
    if ((!bufferBasedABR || nextBandwidth > currBandwidth) && forwardBuffer >= bufferLowWaterLine) {
      let logLine = `${sharedLogLine} as forwardBuffer >= bufferLowWaterLine (${forwardBuffer} >= ${bufferLowWaterLine})`;
      if (bufferBasedABR) {
        logLine += ` and next bandwidth > current bandwidth (${nextBandwidth} > ${currBandwidth})`;
      }
      log2(logLine);
      return true;
    }
    log2(`not ${sharedLogLine} as no switching criteria met`);
    return false;
  };
  class PlaylistController extends videojs.EventTarget {
    constructor(options) {
      super();
      const {
        src,
        withCredentials,
        tech,
        bandwidth,
        externVhs,
        useCueTags,
        playlistExclusionDuration,
        enableLowInitialPlaylist,
        sourceType,
        cacheEncryptionKeys,
        bufferBasedABR,
        leastPixelDiffSelector,
        captionServices
      } = options;
      if (!src) {
        throw new Error("A non-empty playlist URL or JSON manifest string is required");
      }
      let {
        maxPlaylistRetries
      } = options;
      if (maxPlaylistRetries === null || typeof maxPlaylistRetries === "undefined") {
        maxPlaylistRetries = Infinity;
      }
      Vhs$1 = externVhs;
      this.bufferBasedABR = Boolean(bufferBasedABR);
      this.leastPixelDiffSelector = Boolean(leastPixelDiffSelector);
      this.withCredentials = withCredentials;
      this.tech_ = tech;
      this.vhs_ = tech.vhs;
      this.sourceType_ = sourceType;
      this.useCueTags_ = useCueTags;
      this.playlistExclusionDuration = playlistExclusionDuration;
      this.maxPlaylistRetries = maxPlaylistRetries;
      this.enableLowInitialPlaylist = enableLowInitialPlaylist;
      if (this.useCueTags_) {
        this.cueTagsTrack_ = this.tech_.addTextTrack("metadata", "ad-cues");
        this.cueTagsTrack_.inBandMetadataTrackDispatchType = "";
      }
      this.requestOptions_ = {
        withCredentials,
        maxPlaylistRetries,
        timeout: null
      };
      this.on("error", this.pauseLoading);
      this.mediaTypes_ = createMediaTypes();
      this.mediaSource = new window.MediaSource();
      this.handleDurationChange_ = this.handleDurationChange_.bind(this);
      this.handleSourceOpen_ = this.handleSourceOpen_.bind(this);
      this.handleSourceEnded_ = this.handleSourceEnded_.bind(this);
      this.mediaSource.addEventListener("durationchange", this.handleDurationChange_);
      this.mediaSource.addEventListener("sourceopen", this.handleSourceOpen_);
      this.mediaSource.addEventListener("sourceended", this.handleSourceEnded_);
      this.seekable_ = createTimeRanges();
      this.hasPlayed_ = false;
      this.syncController_ = new SyncController(options);
      this.segmentMetadataTrack_ = tech.addRemoteTextTrack({
        kind: "metadata",
        label: "segment-metadata"
      }, false).track;
      this.decrypter_ = new Decrypter();
      this.sourceUpdater_ = new SourceUpdater(this.mediaSource);
      this.inbandTextTracks_ = {};
      this.timelineChangeController_ = new TimelineChangeController();
      this.keyStatusMap_ = /* @__PURE__ */ new Map();
      const segmentLoaderSettings = {
        vhs: this.vhs_,
        parse708captions: options.parse708captions,
        useDtsForTimestampOffset: options.useDtsForTimestampOffset,
        captionServices,
        mediaSource: this.mediaSource,
        currentTime: this.tech_.currentTime.bind(this.tech_),
        seekable: () => this.seekable(),
        seeking: () => this.tech_.seeking(),
        duration: () => this.duration(),
        hasPlayed: () => this.hasPlayed_,
        goalBufferLength: () => this.goalBufferLength(),
        bandwidth,
        syncController: this.syncController_,
        decrypter: this.decrypter_,
        sourceType: this.sourceType_,
        inbandTextTracks: this.inbandTextTracks_,
        cacheEncryptionKeys,
        sourceUpdater: this.sourceUpdater_,
        timelineChangeController: this.timelineChangeController_,
        exactManifestTimings: options.exactManifestTimings,
        addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this)
      };
      this.mainPlaylistLoader_ = this.sourceType_ === "dash" ? new DashPlaylistLoader(src, this.vhs_, merge(this.requestOptions_, {
        addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this)
      })) : new PlaylistLoader(src, this.vhs_, merge(this.requestOptions_, {
        addDateRangesToTextTrack: this.addDateRangesToTextTrack_.bind(this)
      }));
      this.setupMainPlaylistLoaderListeners_();
      this.mainSegmentLoader_ = new SegmentLoader(merge(segmentLoaderSettings, {
        segmentMetadataTrack: this.segmentMetadataTrack_,
        loaderType: "main"
      }), options);
      this.audioSegmentLoader_ = new SegmentLoader(merge(segmentLoaderSettings, {
        loaderType: "audio"
      }), options);
      this.subtitleSegmentLoader_ = new VTTSegmentLoader(merge(segmentLoaderSettings, {
        loaderType: "vtt",
        featuresNativeTextTracks: this.tech_.featuresNativeTextTracks,
        loadVttJs: () => new Promise((resolve, reject) => {
          function onLoad() {
            tech.off("vttjserror", onError2);
            resolve();
          }
          function onError2() {
            tech.off("vttjsloaded", onLoad);
            reject();
          }
          tech.one("vttjsloaded", onLoad);
          tech.one("vttjserror", onError2);
          tech.addWebVttScript_();
        })
      }), options);
      const getBandwidth = () => {
        return this.mainSegmentLoader_.bandwidth;
      };
      this.contentSteeringController_ = new ContentSteeringController(this.vhs_.xhr, getBandwidth);
      this.setupSegmentLoaderListeners_();
      if (this.bufferBasedABR) {
        this.mainPlaylistLoader_.one("loadedplaylist", () => this.startABRTimer_());
        this.tech_.on("pause", () => this.stopABRTimer_());
        this.tech_.on("play", () => this.startABRTimer_());
      }
      loaderStats.forEach((stat) => {
        this[stat + "_"] = sumLoaderStat.bind(this, stat);
      });
      this.logger_ = logger("pc");
      this.triggeredFmp4Usage = false;
      if (this.tech_.preload() === "none") {
        this.loadOnPlay_ = () => {
          this.loadOnPlay_ = null;
          this.mainPlaylistLoader_.load();
        };
        this.tech_.one("play", this.loadOnPlay_);
      } else {
        this.mainPlaylistLoader_.load();
      }
      this.timeToLoadedData__ = -1;
      this.mainAppendsToLoadedData__ = -1;
      this.audioAppendsToLoadedData__ = -1;
      const event = this.tech_.preload() === "none" ? "play" : "loadstart";
      this.tech_.one(event, () => {
        const timeToLoadedDataStart = Date.now();
        this.tech_.one("loadeddata", () => {
          this.timeToLoadedData__ = Date.now() - timeToLoadedDataStart;
          this.mainAppendsToLoadedData__ = this.mainSegmentLoader_.mediaAppends;
          this.audioAppendsToLoadedData__ = this.audioSegmentLoader_.mediaAppends;
        });
      });
    }
    mainAppendsToLoadedData_() {
      return this.mainAppendsToLoadedData__;
    }
    audioAppendsToLoadedData_() {
      return this.audioAppendsToLoadedData__;
    }
    appendsToLoadedData_() {
      const main = this.mainAppendsToLoadedData_();
      const audio = this.audioAppendsToLoadedData_();
      if (main === -1 || audio === -1) {
        return -1;
      }
      return main + audio;
    }
    timeToLoadedData_() {
      return this.timeToLoadedData__;
    }
    /**
     * Run selectPlaylist and switch to the new playlist if we should
     *
     * @param {string} [reason=abr] a reason for why the ABR check is made
     * @private
     */
    checkABR_(reason = "abr") {
      const nextPlaylist = this.selectPlaylist();
      if (nextPlaylist && this.shouldSwitchToMedia_(nextPlaylist)) {
        this.switchMedia_(nextPlaylist, reason);
      }
    }
    switchMedia_(playlist, cause, delay) {
      const oldMedia = this.media();
      const oldId = oldMedia && (oldMedia.id || oldMedia.uri);
      const newId = playlist && (playlist.id || playlist.uri);
      if (oldId && oldId !== newId) {
        this.logger_(`switch media ${oldId} -> ${newId} from ${cause}`);
        this.tech_.trigger({
          type: "usage",
          name: `vhs-rendition-change-${cause}`
        });
      }
      this.mainPlaylistLoader_.media(playlist, delay);
    }
    /**
     * A function that ensures we switch our playlists inside of `mediaTypes`
     * to match the current `serviceLocation` provided by the contentSteering controller.
     * We want to check media types of `AUDIO`, `SUBTITLES`, and `CLOSED-CAPTIONS`.
     *
     * This should only be called on a DASH playback scenario while using content steering.
     * This is necessary due to differences in how media in HLS manifests are generally tied to
     * a video playlist, where in DASH that is not always the case.
     */
    switchMediaForDASHContentSteering_() {
      ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((type) => {
        const mediaType = this.mediaTypes_[type];
        const activeGroup2 = mediaType ? mediaType.activeGroup() : null;
        const pathway = this.contentSteeringController_.getPathway();
        if (activeGroup2 && pathway) {
          const mediaPlaylists = activeGroup2.length ? activeGroup2[0].playlists : activeGroup2.playlists;
          const dashMediaPlaylists = mediaPlaylists.filter((p) => p.attributes.serviceLocation === pathway);
          if (dashMediaPlaylists.length) {
            this.mediaTypes_[type].activePlaylistLoader.media(dashMediaPlaylists[0]);
          }
        }
      });
    }
    /**
     * Start a timer that periodically calls checkABR_
     *
     * @private
     */
    startABRTimer_() {
      this.stopABRTimer_();
      this.abrTimer_ = window.setInterval(() => this.checkABR_(), 250);
    }
    /**
     * Stop the timer that periodically calls checkABR_
     *
     * @private
     */
    stopABRTimer_() {
      if (this.tech_.scrubbing && this.tech_.scrubbing()) {
        return;
      }
      window.clearInterval(this.abrTimer_);
      this.abrTimer_ = null;
    }
    /**
     * Get a list of playlists for the currently selected audio playlist
     *
     * @return {Array} the array of audio playlists
     */
    getAudioTrackPlaylists_() {
      const main = this.main();
      const defaultPlaylists = main && main.playlists || [];
      if (!main || !main.mediaGroups || !main.mediaGroups.AUDIO) {
        return defaultPlaylists;
      }
      const AUDIO = main.mediaGroups.AUDIO;
      const groupKeys = Object.keys(AUDIO);
      let track;
      if (Object.keys(this.mediaTypes_.AUDIO.groups).length) {
        track = this.mediaTypes_.AUDIO.activeTrack();
      } else {
        const defaultGroup = AUDIO.main || groupKeys.length && AUDIO[groupKeys[0]];
        for (const label in defaultGroup) {
          if (defaultGroup[label].default) {
            track = {
              label
            };
            break;
          }
        }
      }
      if (!track) {
        return defaultPlaylists;
      }
      const playlists = [];
      for (const group in AUDIO) {
        if (AUDIO[group][track.label]) {
          const properties = AUDIO[group][track.label];
          if (properties.playlists && properties.playlists.length) {
            playlists.push.apply(playlists, properties.playlists);
          } else if (properties.uri) {
            playlists.push(properties);
          } else if (main.playlists.length) {
            for (let i = 0; i < main.playlists.length; i++) {
              const playlist = main.playlists[i];
              if (playlist.attributes && playlist.attributes.AUDIO && playlist.attributes.AUDIO === group) {
                playlists.push(playlist);
              }
            }
          }
        }
      }
      if (!playlists.length) {
        return defaultPlaylists;
      }
      return playlists;
    }
    /**
     * Register event handlers on the main playlist loader. A helper
     * function for construction time.
     *
     * @private
     */
    setupMainPlaylistLoaderListeners_() {
      this.mainPlaylistLoader_.on("loadedmetadata", () => {
        const media = this.mainPlaylistLoader_.media();
        const requestTimeout = media.targetDuration * 1.5 * 1e3;
        if (isLowestEnabledRendition(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media())) {
          this.requestOptions_.timeout = 0;
        } else {
          this.requestOptions_.timeout = requestTimeout;
        }
        if (media.endList && this.tech_.preload() !== "none") {
          this.mainSegmentLoader_.playlist(media, this.requestOptions_);
          this.mainSegmentLoader_.load();
        }
        setupMediaGroups({
          sourceType: this.sourceType_,
          segmentLoaders: {
            AUDIO: this.audioSegmentLoader_,
            SUBTITLES: this.subtitleSegmentLoader_,
            main: this.mainSegmentLoader_
          },
          tech: this.tech_,
          requestOptions: this.requestOptions_,
          mainPlaylistLoader: this.mainPlaylistLoader_,
          vhs: this.vhs_,
          main: this.main(),
          mediaTypes: this.mediaTypes_,
          excludePlaylist: this.excludePlaylist.bind(this)
        });
        this.triggerPresenceUsage_(this.main(), media);
        this.setupFirstPlay();
        if (!this.mediaTypes_.AUDIO.activePlaylistLoader || this.mediaTypes_.AUDIO.activePlaylistLoader.media()) {
          this.trigger("selectedinitialmedia");
        } else {
          this.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", () => {
            this.trigger("selectedinitialmedia");
          });
        }
      });
      this.mainPlaylistLoader_.on("loadedplaylist", () => {
        if (this.loadOnPlay_) {
          this.tech_.off("play", this.loadOnPlay_);
        }
        let updatedPlaylist = this.mainPlaylistLoader_.media();
        if (!updatedPlaylist) {
          this.attachContentSteeringListeners_();
          this.initContentSteeringController_();
          this.excludeUnsupportedVariants_();
          let selectedMedia;
          if (this.enableLowInitialPlaylist) {
            selectedMedia = this.selectInitialPlaylist();
          }
          if (!selectedMedia) {
            selectedMedia = this.selectPlaylist();
          }
          if (!selectedMedia || !this.shouldSwitchToMedia_(selectedMedia)) {
            return;
          }
          this.initialMedia_ = selectedMedia;
          this.switchMedia_(this.initialMedia_, "initial");
          const haveJsonSource = this.sourceType_ === "vhs-json" && this.initialMedia_.segments;
          if (!haveJsonSource) {
            return;
          }
          updatedPlaylist = this.initialMedia_;
        }
        this.handleUpdatedMediaPlaylist(updatedPlaylist);
      });
      this.mainPlaylistLoader_.on("error", () => {
        const error = this.mainPlaylistLoader_.error;
        this.excludePlaylist({
          playlistToExclude: error.playlist,
          error
        });
      });
      this.mainPlaylistLoader_.on("mediachanging", () => {
        this.mainSegmentLoader_.abort();
        this.mainSegmentLoader_.pause();
      });
      this.mainPlaylistLoader_.on("mediachange", () => {
        const media = this.mainPlaylistLoader_.media();
        const requestTimeout = media.targetDuration * 1.5 * 1e3;
        if (isLowestEnabledRendition(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media())) {
          this.requestOptions_.timeout = 0;
        } else {
          this.requestOptions_.timeout = requestTimeout;
        }
        if (this.sourceType_ === "dash") {
          this.mainPlaylistLoader_.load();
        }
        this.mainSegmentLoader_.pause();
        this.mainSegmentLoader_.playlist(media, this.requestOptions_);
        if (this.waitingForFastQualityPlaylistReceived_) {
          this.runFastQualitySwitch_();
        } else {
          this.mainSegmentLoader_.load();
        }
        this.tech_.trigger({
          type: "mediachange",
          bubbles: true
        });
      });
      this.mainPlaylistLoader_.on("playlistunchanged", () => {
        const updatedPlaylist = this.mainPlaylistLoader_.media();
        if (updatedPlaylist.lastExcludeReason_ === "playlist-unchanged") {
          return;
        }
        const playlistOutdated = this.stuckAtPlaylistEnd_(updatedPlaylist);
        if (playlistOutdated) {
          this.excludePlaylist({
            error: {
              message: "Playlist no longer updating.",
              reason: "playlist-unchanged"
            }
          });
          this.tech_.trigger("playliststuck");
        }
      });
      this.mainPlaylistLoader_.on("renditiondisabled", () => {
        this.tech_.trigger({
          type: "usage",
          name: "vhs-rendition-disabled"
        });
      });
      this.mainPlaylistLoader_.on("renditionenabled", () => {
        this.tech_.trigger({
          type: "usage",
          name: "vhs-rendition-enabled"
        });
      });
    }
    /**
     * Given an updated media playlist (whether it was loaded for the first time, or
     * refreshed for live playlists), update any relevant properties and state to reflect
     * changes in the media that should be accounted for (e.g., cues and duration).
     *
     * @param {Object} updatedPlaylist the updated media playlist object
     *
     * @private
     */
    handleUpdatedMediaPlaylist(updatedPlaylist) {
      if (this.useCueTags_) {
        this.updateAdCues_(updatedPlaylist);
      }
      this.mainSegmentLoader_.pause();
      this.mainSegmentLoader_.playlist(updatedPlaylist, this.requestOptions_);
      if (this.waitingForFastQualityPlaylistReceived_) {
        this.runFastQualitySwitch_();
      }
      this.updateDuration(!updatedPlaylist.endList);
      if (!this.tech_.paused()) {
        this.mainSegmentLoader_.load();
        if (this.audioSegmentLoader_) {
          this.audioSegmentLoader_.load();
        }
      }
    }
    /**
     * A helper function for triggerring presence usage events once per source
     *
     * @private
     */
    triggerPresenceUsage_(main, media) {
      const mediaGroups = main.mediaGroups || {};
      let defaultDemuxed = true;
      const audioGroupKeys = Object.keys(mediaGroups.AUDIO);
      for (const mediaGroup in mediaGroups.AUDIO) {
        for (const label in mediaGroups.AUDIO[mediaGroup]) {
          const properties = mediaGroups.AUDIO[mediaGroup][label];
          if (!properties.uri) {
            defaultDemuxed = false;
          }
        }
      }
      if (defaultDemuxed) {
        this.tech_.trigger({
          type: "usage",
          name: "vhs-demuxed"
        });
      }
      if (Object.keys(mediaGroups.SUBTITLES).length) {
        this.tech_.trigger({
          type: "usage",
          name: "vhs-webvtt"
        });
      }
      if (Vhs$1.Playlist.isAes(media)) {
        this.tech_.trigger({
          type: "usage",
          name: "vhs-aes"
        });
      }
      if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {
        this.tech_.trigger({
          type: "usage",
          name: "vhs-alternate-audio"
        });
      }
      if (this.useCueTags_) {
        this.tech_.trigger({
          type: "usage",
          name: "vhs-playlist-cue-tags"
        });
      }
    }
    shouldSwitchToMedia_(nextPlaylist) {
      const currentPlaylist = this.mainPlaylistLoader_.media() || this.mainPlaylistLoader_.pendingMedia_;
      const currentTime = this.tech_.currentTime();
      const bufferLowWaterLine = this.bufferLowWaterLine();
      const bufferHighWaterLine = this.bufferHighWaterLine();
      const buffered = this.tech_.buffered();
      return shouldSwitchToMedia({
        buffered,
        currentTime,
        currentPlaylist,
        nextPlaylist,
        bufferLowWaterLine,
        bufferHighWaterLine,
        duration: this.duration(),
        bufferBasedABR: this.bufferBasedABR,
        log: this.logger_
      });
    }
    /**
     * Register event handlers on the segment loaders. A helper function
     * for construction time.
     *
     * @private
     */
    setupSegmentLoaderListeners_() {
      this.mainSegmentLoader_.on("bandwidthupdate", () => {
        this.checkABR_("bandwidthupdate");
        this.tech_.trigger("bandwidthupdate");
      });
      this.mainSegmentLoader_.on("timeout", () => {
        if (this.bufferBasedABR) {
          this.mainSegmentLoader_.load();
        }
      });
      if (!this.bufferBasedABR) {
        this.mainSegmentLoader_.on("progress", () => {
          this.trigger("progress");
        });
      }
      this.mainSegmentLoader_.on("error", () => {
        const error = this.mainSegmentLoader_.error();
        this.excludePlaylist({
          playlistToExclude: error.playlist,
          error
        });
      });
      this.mainSegmentLoader_.on("appenderror", () => {
        this.error = this.mainSegmentLoader_.error_;
        this.trigger("error");
      });
      this.mainSegmentLoader_.on("syncinfoupdate", () => {
        this.onSyncInfoUpdate_();
      });
      this.mainSegmentLoader_.on("timestampoffset", () => {
        this.tech_.trigger({
          type: "usage",
          name: "vhs-timestamp-offset"
        });
      });
      this.audioSegmentLoader_.on("syncinfoupdate", () => {
        this.onSyncInfoUpdate_();
      });
      this.audioSegmentLoader_.on("appenderror", () => {
        this.error = this.audioSegmentLoader_.error_;
        this.trigger("error");
      });
      this.mainSegmentLoader_.on("ended", () => {
        this.logger_("main segment loader ended");
        this.onEndOfStream();
      });
      this.mainSegmentLoader_.on("earlyabort", (event) => {
        if (this.bufferBasedABR) {
          return;
        }
        this.delegateLoaders_("all", ["abort"]);
        this.excludePlaylist({
          error: {
            message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering."
          },
          playlistExclusionDuration: ABORT_EARLY_EXCLUSION_SECONDS
        });
      });
      const updateCodecs = () => {
        if (!this.sourceUpdater_.hasCreatedSourceBuffers()) {
          return this.tryToCreateSourceBuffers_();
        }
        const codecs = this.getCodecsOrExclude_();
        if (!codecs) {
          return;
        }
        this.sourceUpdater_.addOrChangeSourceBuffers(codecs);
      };
      this.mainSegmentLoader_.on("trackinfo", updateCodecs);
      this.audioSegmentLoader_.on("trackinfo", updateCodecs);
      this.mainSegmentLoader_.on("fmp4", () => {
        if (!this.triggeredFmp4Usage) {
          this.tech_.trigger({
            type: "usage",
            name: "vhs-fmp4"
          });
          this.triggeredFmp4Usage = true;
        }
      });
      this.audioSegmentLoader_.on("fmp4", () => {
        if (!this.triggeredFmp4Usage) {
          this.tech_.trigger({
            type: "usage",
            name: "vhs-fmp4"
          });
          this.triggeredFmp4Usage = true;
        }
      });
      this.audioSegmentLoader_.on("ended", () => {
        this.logger_("audioSegmentLoader ended");
        this.onEndOfStream();
      });
    }
    mediaSecondsLoaded_() {
      return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);
    }
    /**
     * Call load on our SegmentLoaders
     */
    load() {
      this.mainSegmentLoader_.load();
      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
        this.audioSegmentLoader_.load();
      }
      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
        this.subtitleSegmentLoader_.load();
      }
    }
    /**
     * Re-tune playback quality level for the current player
     * conditions. This method will perform destructive actions like removing
     * already buffered content in order to readjust the currently active
     * playlist quickly. This is good for manual quality changes
     *
     * @private
     */
    fastQualityChange_(media = this.selectPlaylist()) {
      if (media && media === this.mainPlaylistLoader_.media()) {
        this.logger_("skipping fastQualityChange because new media is same as old");
        return;
      }
      this.switchMedia_(media, "fast-quality");
      this.waitingForFastQualityPlaylistReceived_ = true;
    }
    runFastQualitySwitch_() {
      this.waitingForFastQualityPlaylistReceived_ = false;
      this.mainSegmentLoader_.pause();
      this.mainSegmentLoader_.resetEverything(() => {
        this.tech_.setCurrentTime(this.tech_.currentTime());
      });
    }
    /**
     * Begin playback.
     */
    play() {
      if (this.setupFirstPlay()) {
        return;
      }
      if (this.tech_.ended()) {
        this.tech_.setCurrentTime(0);
      }
      if (this.hasPlayed_) {
        this.load();
      }
      const seekable2 = this.tech_.seekable();
      if (this.tech_.duration() === Infinity) {
        if (this.tech_.currentTime() < seekable2.start(0)) {
          return this.tech_.setCurrentTime(seekable2.end(seekable2.length - 1));
        }
      }
    }
    /**
     * Seek to the latest media position if this is a live video and the
     * player and video are loaded and initialized.
     */
    setupFirstPlay() {
      const media = this.mainPlaylistLoader_.media();
      if (!media || this.tech_.paused() || this.hasPlayed_) {
        return false;
      }
      if (!media.endList || media.start) {
        const seekable2 = this.seekable();
        if (!seekable2.length) {
          return false;
        }
        const seekableEnd = seekable2.end(0);
        let startPoint = seekableEnd;
        if (media.start) {
          const offset = media.start.timeOffset;
          if (offset < 0) {
            startPoint = Math.max(seekableEnd + offset, seekable2.start(0));
          } else {
            startPoint = Math.min(seekableEnd, offset);
          }
        }
        this.trigger("firstplay");
        this.tech_.setCurrentTime(startPoint);
      }
      this.hasPlayed_ = true;
      this.load();
      return true;
    }
    /**
     * handle the sourceopen event on the MediaSource
     *
     * @private
     */
    handleSourceOpen_() {
      this.tryToCreateSourceBuffers_();
      if (this.tech_.autoplay()) {
        const playPromise = this.tech_.play();
        if (typeof playPromise !== "undefined" && typeof playPromise.then === "function") {
          playPromise.then(null, (e) => {
          });
        }
      }
      this.trigger("sourceopen");
    }
    /**
     * handle the sourceended event on the MediaSource
     *
     * @private
     */
    handleSourceEnded_() {
      if (!this.inbandTextTracks_.metadataTrack_) {
        return;
      }
      const cues = this.inbandTextTracks_.metadataTrack_.cues;
      if (!cues || !cues.length) {
        return;
      }
      const duration2 = this.duration();
      cues[cues.length - 1].endTime = isNaN(duration2) || Math.abs(duration2) === Infinity ? Number.MAX_VALUE : duration2;
    }
    /**
     * handle the durationchange event on the MediaSource
     *
     * @private
     */
    handleDurationChange_() {
      this.tech_.trigger("durationchange");
    }
    /**
     * Calls endOfStream on the media source when all active stream types have called
     * endOfStream
     *
     * @param {string} streamType
     *        Stream type of the segment loader that called endOfStream
     * @private
     */
    onEndOfStream() {
      let isEndOfStream = this.mainSegmentLoader_.ended_;
      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
        const mainMediaInfo = this.mainSegmentLoader_.getCurrentMediaInfo_();
        if (!mainMediaInfo || mainMediaInfo.hasVideo) {
          isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;
        } else {
          isEndOfStream = this.audioSegmentLoader_.ended_;
        }
      }
      if (!isEndOfStream) {
        return;
      }
      this.stopABRTimer_();
      this.sourceUpdater_.endOfStream();
    }
    /**
     * Check if a playlist has stopped being updated
     *
     * @param {Object} playlist the media playlist object
     * @return {boolean} whether the playlist has stopped being updated or not
     */
    stuckAtPlaylistEnd_(playlist) {
      const seekable2 = this.seekable();
      if (!seekable2.length) {
        return false;
      }
      const expired = this.syncController_.getExpiredTime(playlist, this.duration());
      if (expired === null) {
        return false;
      }
      const absolutePlaylistEnd = Vhs$1.Playlist.playlistEnd(playlist, expired);
      const currentTime = this.tech_.currentTime();
      const buffered = this.tech_.buffered();
      if (!buffered.length) {
        return absolutePlaylistEnd - currentTime <= SAFE_TIME_DELTA;
      }
      const bufferedEnd = buffered.end(buffered.length - 1);
      return bufferedEnd - currentTime <= SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= SAFE_TIME_DELTA;
    }
    /**
     * Exclude a playlist for a set amount of time, making it unavailable for selection by
     * the rendition selection algorithm, then force a new playlist (rendition) selection.
     *
     * @param {Object=} playlistToExclude
     *                  the playlist to exclude, defaults to the currently selected playlist
     * @param {Object=} error
     *                  an optional error
     * @param {number=} playlistExclusionDuration
     *                  an optional number of seconds to exclude the playlist
     */
    excludePlaylist({
      playlistToExclude = this.mainPlaylistLoader_.media(),
      error = {},
      playlistExclusionDuration
    }) {
      playlistToExclude = playlistToExclude || this.mainPlaylistLoader_.media();
      playlistExclusionDuration = playlistExclusionDuration || error.playlistExclusionDuration || this.playlistExclusionDuration;
      if (!playlistToExclude) {
        this.error = error;
        if (this.mediaSource.readyState !== "open") {
          this.trigger("error");
        } else {
          this.sourceUpdater_.endOfStream("network");
        }
        return;
      }
      playlistToExclude.playlistErrors_++;
      const playlists = this.mainPlaylistLoader_.main.playlists;
      const enabledPlaylists = playlists.filter(isEnabled);
      const isFinalRendition = enabledPlaylists.length === 1 && enabledPlaylists[0] === playlistToExclude;
      if (playlists.length === 1 && playlistExclusionDuration !== Infinity) {
        videojs.log.warn(`Problem encountered with playlist ${playlistToExclude.id}. Trying again since it is the only playlist.`);
        this.tech_.trigger("retryplaylist");
        return this.mainPlaylistLoader_.load(isFinalRendition);
      }
      if (isFinalRendition) {
        if (this.main().contentSteering) {
          const pathway = this.pathwayAttribute_(playlistToExclude);
          const reIncludeDelay = this.contentSteeringController_.steeringManifest.ttl * 1e3;
          this.contentSteeringController_.excludePathway(pathway);
          this.excludeThenChangePathway_();
          setTimeout(() => {
            this.contentSteeringController_.addAvailablePathway(pathway);
          }, reIncludeDelay);
          return;
        }
        let reincluded = false;
        playlists.forEach((playlist) => {
          if (playlist === playlistToExclude) {
            return;
          }
          const excludeUntil2 = playlist.excludeUntil;
          if (typeof excludeUntil2 !== "undefined" && excludeUntil2 !== Infinity) {
            reincluded = true;
            delete playlist.excludeUntil;
          }
        });
        if (reincluded) {
          videojs.log.warn("Removing other playlists from the exclusion list because the last rendition is about to be excluded.");
          this.tech_.trigger("retryplaylist");
        }
      }
      let excludeUntil;
      if (playlistToExclude.playlistErrors_ > this.maxPlaylistRetries) {
        excludeUntil = Infinity;
      } else {
        excludeUntil = Date.now() + playlistExclusionDuration * 1e3;
      }
      playlistToExclude.excludeUntil = excludeUntil;
      if (error.reason) {
        playlistToExclude.lastExcludeReason_ = error.reason;
      }
      this.tech_.trigger("excludeplaylist");
      this.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-excluded"
      });
      const nextPlaylist = this.selectPlaylist();
      if (!nextPlaylist) {
        this.error = "Playback cannot continue. No available working or supported playlists.";
        this.trigger("error");
        return;
      }
      const logFn2 = error.internal ? this.logger_ : videojs.log.warn;
      const errorMessage = error.message ? " " + error.message : "";
      logFn2(`${error.internal ? "Internal problem" : "Problem"} encountered with playlist ${playlistToExclude.id}.${errorMessage} Switching to playlist ${nextPlaylist.id}.`);
      if (nextPlaylist.attributes.AUDIO !== playlistToExclude.attributes.AUDIO) {
        this.delegateLoaders_("audio", ["abort", "pause"]);
      }
      if (nextPlaylist.attributes.SUBTITLES !== playlistToExclude.attributes.SUBTITLES) {
        this.delegateLoaders_("subtitle", ["abort", "pause"]);
      }
      this.delegateLoaders_("main", ["abort", "pause"]);
      const delayDuration = nextPlaylist.targetDuration / 2 * 1e3 || 5 * 1e3;
      const shouldDelay = typeof nextPlaylist.lastRequest === "number" && Date.now() - nextPlaylist.lastRequest <= delayDuration;
      return this.switchMedia_(nextPlaylist, "exclude", isFinalRendition || shouldDelay);
    }
    /**
     * Pause all segment/playlist loaders
     */
    pauseLoading() {
      this.delegateLoaders_("all", ["abort", "pause"]);
      this.stopABRTimer_();
    }
    /**
     * Call a set of functions in order on playlist loaders, segment loaders,
     * or both types of loaders.
     *
     * @param {string} filter
     *        Filter loaders that should call fnNames using a string. Can be:
     *        * all - run on all loaders
     *        * audio - run on all audio loaders
     *        * subtitle - run on all subtitle loaders
     *        * main - run on the main loaders
     *
     * @param {Array|string} fnNames
     *        A string or array of function names to call.
     */
    delegateLoaders_(filter, fnNames) {
      const loaders = [];
      const dontFilterPlaylist = filter === "all";
      if (dontFilterPlaylist || filter === "main") {
        loaders.push(this.mainPlaylistLoader_);
      }
      const mediaTypes2 = [];
      if (dontFilterPlaylist || filter === "audio") {
        mediaTypes2.push("AUDIO");
      }
      if (dontFilterPlaylist || filter === "subtitle") {
        mediaTypes2.push("CLOSED-CAPTIONS");
        mediaTypes2.push("SUBTITLES");
      }
      mediaTypes2.forEach((mediaType) => {
        const loader = this.mediaTypes_[mediaType] && this.mediaTypes_[mediaType].activePlaylistLoader;
        if (loader) {
          loaders.push(loader);
        }
      });
      ["main", "audio", "subtitle"].forEach((name) => {
        const loader = this[`${name}SegmentLoader_`];
        if (loader && (filter === name || filter === "all")) {
          loaders.push(loader);
        }
      });
      loaders.forEach((loader) => fnNames.forEach((fnName) => {
        if (typeof loader[fnName] === "function") {
          loader[fnName]();
        }
      }));
    }
    /**
     * set the current time on all segment loaders
     *
     * @param {TimeRange} currentTime the current time to set
     * @return {TimeRange} the current time
     */
    setCurrentTime(currentTime) {
      const buffered = findRange(this.tech_.buffered(), currentTime);
      if (!(this.mainPlaylistLoader_ && this.mainPlaylistLoader_.media())) {
        return 0;
      }
      if (!this.mainPlaylistLoader_.media().segments) {
        return 0;
      }
      if (buffered && buffered.length) {
        return currentTime;
      }
      this.mainSegmentLoader_.pause();
      this.mainSegmentLoader_.resetEverything();
      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
        this.audioSegmentLoader_.pause();
        this.audioSegmentLoader_.resetEverything();
      }
      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
        this.subtitleSegmentLoader_.pause();
        this.subtitleSegmentLoader_.resetEverything();
      }
      this.load();
    }
    /**
     * get the current duration
     *
     * @return {TimeRange} the duration
     */
    duration() {
      if (!this.mainPlaylistLoader_) {
        return 0;
      }
      const media = this.mainPlaylistLoader_.media();
      if (!media) {
        return 0;
      }
      if (!media.endList) {
        return Infinity;
      }
      if (this.mediaSource) {
        return this.mediaSource.duration;
      }
      return Vhs$1.Playlist.duration(media);
    }
    /**
     * check the seekable range
     *
     * @return {TimeRange} the seekable range
     */
    seekable() {
      return this.seekable_;
    }
    onSyncInfoUpdate_() {
      let audioSeekable;
      if (!this.mainPlaylistLoader_) {
        return;
      }
      let media = this.mainPlaylistLoader_.media();
      if (!media) {
        return;
      }
      let expired = this.syncController_.getExpiredTime(media, this.duration());
      if (expired === null) {
        return;
      }
      const main = this.mainPlaylistLoader_.main;
      const mainSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(main, media));
      if (mainSeekable.length === 0) {
        return;
      }
      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
        media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();
        expired = this.syncController_.getExpiredTime(media, this.duration());
        if (expired === null) {
          return;
        }
        audioSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(main, media));
        if (audioSeekable.length === 0) {
          return;
        }
      }
      let oldEnd;
      let oldStart;
      if (this.seekable_ && this.seekable_.length) {
        oldEnd = this.seekable_.end(0);
        oldStart = this.seekable_.start(0);
      }
      if (!audioSeekable) {
        this.seekable_ = mainSeekable;
      } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {
        this.seekable_ = mainSeekable;
      } else {
        this.seekable_ = createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);
      }
      if (this.seekable_ && this.seekable_.length) {
        if (this.seekable_.end(0) === oldEnd && this.seekable_.start(0) === oldStart) {
          return;
        }
      }
      this.logger_(`seekable updated [${printableRange(this.seekable_)}]`);
      this.tech_.trigger("seekablechanged");
    }
    /**
     * Update the player duration
     */
    updateDuration(isLive) {
      if (this.updateDuration_) {
        this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
        this.updateDuration_ = null;
      }
      if (this.mediaSource.readyState !== "open") {
        this.updateDuration_ = this.updateDuration.bind(this, isLive);
        this.mediaSource.addEventListener("sourceopen", this.updateDuration_);
        return;
      }
      if (isLive) {
        const seekable2 = this.seekable();
        if (!seekable2.length) {
          return;
        }
        if (isNaN(this.mediaSource.duration) || this.mediaSource.duration < seekable2.end(seekable2.length - 1)) {
          this.sourceUpdater_.setDuration(seekable2.end(seekable2.length - 1));
        }
        return;
      }
      const buffered = this.tech_.buffered();
      let duration2 = Vhs$1.Playlist.duration(this.mainPlaylistLoader_.media());
      if (buffered.length > 0) {
        duration2 = Math.max(duration2, buffered.end(buffered.length - 1));
      }
      if (this.mediaSource.duration !== duration2) {
        this.sourceUpdater_.setDuration(duration2);
      }
    }
    /**
     * dispose of the PlaylistController and everything
     * that it controls
     */
    dispose() {
      this.trigger("dispose");
      this.decrypter_.terminate();
      this.mainPlaylistLoader_.dispose();
      this.mainSegmentLoader_.dispose();
      this.contentSteeringController_.dispose();
      this.keyStatusMap_.clear();
      if (this.loadOnPlay_) {
        this.tech_.off("play", this.loadOnPlay_);
      }
      ["AUDIO", "SUBTITLES"].forEach((type) => {
        const groups = this.mediaTypes_[type].groups;
        for (const id in groups) {
          groups[id].forEach((group) => {
            if (group.playlistLoader) {
              group.playlistLoader.dispose();
            }
          });
        }
      });
      this.audioSegmentLoader_.dispose();
      this.subtitleSegmentLoader_.dispose();
      this.sourceUpdater_.dispose();
      this.timelineChangeController_.dispose();
      this.stopABRTimer_();
      if (this.updateDuration_) {
        this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
      }
      this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_);
      this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_);
      this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_);
      this.off();
    }
    /**
     * return the main playlist object if we have one
     *
     * @return {Object} the main playlist object that we parsed
     */
    main() {
      return this.mainPlaylistLoader_.main;
    }
    /**
     * return the currently selected playlist
     *
     * @return {Object} the currently selected playlist object that we parsed
     */
    media() {
      return this.mainPlaylistLoader_.media() || this.initialMedia_;
    }
    areMediaTypesKnown_() {
      const usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
      const hasMainMediaInfo = !!this.mainSegmentLoader_.getCurrentMediaInfo_();
      const hasAudioMediaInfo = !usingAudioLoader ? true : !!this.audioSegmentLoader_.getCurrentMediaInfo_();
      if (!hasMainMediaInfo || !hasAudioMediaInfo) {
        return false;
      }
      return true;
    }
    getCodecsOrExclude_() {
      const media = {
        main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},
        audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}
      };
      const playlist = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media();
      media.video = media.main;
      const playlistCodecs = codecsForPlaylist(this.main(), playlist);
      const codecs = {};
      const usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
      if (media.main.hasVideo) {
        codecs.video = playlistCodecs.video || media.main.videoCodec || DEFAULT_VIDEO_CODEC;
      }
      if (media.main.isMuxed) {
        codecs.video += `,${playlistCodecs.audio || media.main.audioCodec || DEFAULT_AUDIO_CODEC}`;
      }
      if (media.main.hasAudio && !media.main.isMuxed || media.audio.hasAudio || usingAudioLoader) {
        codecs.audio = playlistCodecs.audio || media.main.audioCodec || media.audio.audioCodec || DEFAULT_AUDIO_CODEC;
        media.audio.isFmp4 = media.main.hasAudio && !media.main.isMuxed ? media.main.isFmp4 : media.audio.isFmp4;
      }
      if (!codecs.audio && !codecs.video) {
        this.excludePlaylist({
          playlistToExclude: playlist,
          error: {
            message: "Could not determine codecs for playlist."
          },
          playlistExclusionDuration: Infinity
        });
        return;
      }
      const supportFunction = (isFmp4, codec) => isFmp4 ? browserSupportsCodec(codec) : muxerSupportsCodec(codec);
      const unsupportedCodecs = {};
      let unsupportedAudio;
      ["video", "audio"].forEach(function(type) {
        if (codecs.hasOwnProperty(type) && !supportFunction(media[type].isFmp4, codecs[type])) {
          const supporter = media[type].isFmp4 ? "browser" : "muxer";
          unsupportedCodecs[supporter] = unsupportedCodecs[supporter] || [];
          unsupportedCodecs[supporter].push(codecs[type]);
          if (type === "audio") {
            unsupportedAudio = supporter;
          }
        }
      });
      if (usingAudioLoader && unsupportedAudio && playlist.attributes.AUDIO) {
        const audioGroup = playlist.attributes.AUDIO;
        this.main().playlists.forEach((variant) => {
          const variantAudioGroup = variant.attributes && variant.attributes.AUDIO;
          if (variantAudioGroup === audioGroup && variant !== playlist) {
            variant.excludeUntil = Infinity;
          }
        });
        this.logger_(`excluding audio group ${audioGroup} as ${unsupportedAudio} does not support codec(s): "${codecs.audio}"`);
      }
      if (Object.keys(unsupportedCodecs).length) {
        const message = Object.keys(unsupportedCodecs).reduce((acc, supporter) => {
          if (acc) {
            acc += ", ";
          }
          acc += `${supporter} does not support codec(s): "${unsupportedCodecs[supporter].join(",")}"`;
          return acc;
        }, "") + ".";
        this.excludePlaylist({
          playlistToExclude: playlist,
          error: {
            internal: true,
            message
          },
          playlistExclusionDuration: Infinity
        });
        return;
      }
      if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
        const switchMessages = [];
        ["video", "audio"].forEach((type) => {
          const newCodec = (parseCodecs(this.sourceUpdater_.codecs[type] || "")[0] || {}).type;
          const oldCodec = (parseCodecs(codecs[type] || "")[0] || {}).type;
          if (newCodec && oldCodec && newCodec.toLowerCase() !== oldCodec.toLowerCase()) {
            switchMessages.push(`"${this.sourceUpdater_.codecs[type]}" -> "${codecs[type]}"`);
          }
        });
        if (switchMessages.length) {
          this.excludePlaylist({
            playlistToExclude: playlist,
            error: {
              message: `Codec switching not supported: ${switchMessages.join(", ")}.`,
              internal: true
            },
            playlistExclusionDuration: Infinity
          });
          return;
        }
      }
      return codecs;
    }
    /**
     * Create source buffers and exlude any incompatible renditions.
     *
     * @private
     */
    tryToCreateSourceBuffers_() {
      if (this.mediaSource.readyState !== "open" || this.sourceUpdater_.hasCreatedSourceBuffers()) {
        return;
      }
      if (!this.areMediaTypesKnown_()) {
        return;
      }
      const codecs = this.getCodecsOrExclude_();
      if (!codecs) {
        return;
      }
      this.sourceUpdater_.createSourceBuffers(codecs);
      const codecString = [codecs.video, codecs.audio].filter(Boolean).join(",");
      this.excludeIncompatibleVariants_(codecString);
    }
    /**
     * Excludes playlists with codecs that are unsupported by the muxer and browser.
     */
    excludeUnsupportedVariants_() {
      const playlists = this.main().playlists;
      const ids = [];
      Object.keys(playlists).forEach((key) => {
        const variant = playlists[key];
        if (ids.indexOf(variant.id) !== -1) {
          return;
        }
        ids.push(variant.id);
        const codecs = codecsForPlaylist(this.main, variant);
        const unsupported = [];
        if (codecs.audio && !muxerSupportsCodec(codecs.audio) && !browserSupportsCodec(codecs.audio)) {
          unsupported.push(`audio codec ${codecs.audio}`);
        }
        if (codecs.video && !muxerSupportsCodec(codecs.video) && !browserSupportsCodec(codecs.video)) {
          unsupported.push(`video codec ${codecs.video}`);
        }
        if (codecs.text && codecs.text === "stpp.ttml.im1t") {
          unsupported.push(`text codec ${codecs.text}`);
        }
        if (unsupported.length) {
          variant.excludeUntil = Infinity;
          this.logger_(`excluding ${variant.id} for unsupported: ${unsupported.join(", ")}`);
        }
      });
    }
    /**
     * Exclude playlists that are known to be codec or
     * stream-incompatible with the SourceBuffer configuration. For
     * instance, Media Source Extensions would cause the video element to
     * stall waiting for video data if you switched from a variant with
     * video and audio to an audio-only one.
     *
     * @param {Object} media a media playlist compatible with the current
     * set of SourceBuffers. Variants in the current main playlist that
     * do not appear to have compatible codec or stream configurations
     * will be excluded from the default playlist selection algorithm
     * indefinitely.
     * @private
     */
    excludeIncompatibleVariants_(codecString) {
      const ids = [];
      const playlists = this.main().playlists;
      const codecs = unwrapCodecList(parseCodecs(codecString));
      const codecCount_ = codecCount(codecs);
      const videoDetails = codecs.video && parseCodecs(codecs.video)[0] || null;
      const audioDetails = codecs.audio && parseCodecs(codecs.audio)[0] || null;
      Object.keys(playlists).forEach((key) => {
        const variant = playlists[key];
        if (ids.indexOf(variant.id) !== -1 || variant.excludeUntil === Infinity) {
          return;
        }
        ids.push(variant.id);
        const exclusionReasons = [];
        const variantCodecs = codecsForPlaylist(this.mainPlaylistLoader_.main, variant);
        const variantCodecCount = codecCount(variantCodecs);
        if (!variantCodecs.audio && !variantCodecs.video) {
          return;
        }
        if (variantCodecCount !== codecCount_) {
          exclusionReasons.push(`codec count "${variantCodecCount}" !== "${codecCount_}"`);
        }
        if (!this.sourceUpdater_.canChangeType()) {
          const variantVideoDetails = variantCodecs.video && parseCodecs(variantCodecs.video)[0] || null;
          const variantAudioDetails = variantCodecs.audio && parseCodecs(variantCodecs.audio)[0] || null;
          if (variantVideoDetails && videoDetails && variantVideoDetails.type.toLowerCase() !== videoDetails.type.toLowerCase()) {
            exclusionReasons.push(`video codec "${variantVideoDetails.type}" !== "${videoDetails.type}"`);
          }
          if (variantAudioDetails && audioDetails && variantAudioDetails.type.toLowerCase() !== audioDetails.type.toLowerCase()) {
            exclusionReasons.push(`audio codec "${variantAudioDetails.type}" !== "${audioDetails.type}"`);
          }
        }
        if (exclusionReasons.length) {
          variant.excludeUntil = Infinity;
          this.logger_(`excluding ${variant.id}: ${exclusionReasons.join(" && ")}`);
        }
      });
    }
    updateAdCues_(media) {
      let offset = 0;
      const seekable2 = this.seekable();
      if (seekable2.length) {
        offset = seekable2.start(0);
      }
      updateAdCues(media, this.cueTagsTrack_, offset);
    }
    /**
     * Calculates the desired forward buffer length based on current time
     *
     * @return {number} Desired forward buffer length in seconds
     */
    goalBufferLength() {
      const currentTime = this.tech_.currentTime();
      const initial = Config.GOAL_BUFFER_LENGTH;
      const rate = Config.GOAL_BUFFER_LENGTH_RATE;
      const max = Math.max(initial, Config.MAX_GOAL_BUFFER_LENGTH);
      return Math.min(initial + currentTime * rate, max);
    }
    /**
     * Calculates the desired buffer low water line based on current time
     *
     * @return {number} Desired buffer low water line in seconds
     */
    bufferLowWaterLine() {
      const currentTime = this.tech_.currentTime();
      const initial = Config.BUFFER_LOW_WATER_LINE;
      const rate = Config.BUFFER_LOW_WATER_LINE_RATE;
      const max = Math.max(initial, Config.MAX_BUFFER_LOW_WATER_LINE);
      const newMax = Math.max(initial, Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);
      return Math.min(initial + currentTime * rate, this.bufferBasedABR ? newMax : max);
    }
    bufferHighWaterLine() {
      return Config.BUFFER_HIGH_WATER_LINE;
    }
    addDateRangesToTextTrack_(dateRanges) {
      createMetadataTrackIfNotExists(this.inbandTextTracks_, "com.apple.streaming", this.tech_);
      addDateRangeMetadata({
        inbandTextTracks: this.inbandTextTracks_,
        dateRanges
      });
    }
    addMetadataToTextTrack(dispatchType, metadataArray, videoDuration) {
      const timestampOffset = this.sourceUpdater_.videoBuffer ? this.sourceUpdater_.videoTimestampOffset() : this.sourceUpdater_.audioTimestampOffset();
      createMetadataTrackIfNotExists(this.inbandTextTracks_, dispatchType, this.tech_);
      addMetadata({
        inbandTextTracks: this.inbandTextTracks_,
        metadataArray,
        timestampOffset,
        videoDuration
      });
    }
    /**
     * Utility for getting the pathway or service location from an HLS or DASH playlist.
     *
     * @param {Object} playlist for getting pathway from.
     * @return the pathway attribute of a playlist
     */
    pathwayAttribute_(playlist) {
      return playlist.attributes["PATHWAY-ID"] || playlist.attributes.serviceLocation;
    }
    /**
     * Initialize available pathways and apply the tag properties.
     */
    initContentSteeringController_() {
      const main = this.main();
      if (!main.contentSteering) {
        return;
      }
      for (const playlist of main.playlists) {
        this.contentSteeringController_.addAvailablePathway(this.pathwayAttribute_(playlist));
      }
      this.contentSteeringController_.assignTagProperties(main.uri, main.contentSteering);
      if (this.contentSteeringController_.queryBeforeStart) {
        this.contentSteeringController_.requestSteeringManifest(true);
        return;
      }
      this.tech_.one("canplay", () => {
        this.contentSteeringController_.requestSteeringManifest();
      });
    }
    /**
     * Reset the content steering controller and re-init.
     */
    resetContentSteeringController_() {
      this.contentSteeringController_.clearAvailablePathways();
      this.contentSteeringController_.dispose();
      this.initContentSteeringController_();
    }
    /**
     * Attaches the listeners for content steering.
     */
    attachContentSteeringListeners_() {
      this.contentSteeringController_.on("content-steering", this.excludeThenChangePathway_.bind(this));
      if (this.sourceType_ === "dash") {
        this.mainPlaylistLoader_.on("loadedplaylist", () => {
          const main = this.main();
          const didDashTagChange = this.contentSteeringController_.didDASHTagChange(main.uri, main.contentSteering);
          const didPathwaysChange = () => {
            const availablePathways = this.contentSteeringController_.getAvailablePathways();
            const newPathways = [];
            for (const playlist of main.playlists) {
              const serviceLocation = playlist.attributes.serviceLocation;
              if (serviceLocation) {
                newPathways.push(serviceLocation);
                if (!availablePathways.has(serviceLocation)) {
                  return true;
                }
              }
            }
            if (!newPathways.length && availablePathways.size) {
              return true;
            }
            return false;
          };
          if (didDashTagChange || didPathwaysChange()) {
            this.resetContentSteeringController_();
          }
        });
      }
    }
    /**
     * Simple exclude and change playlist logic for content steering.
     */
    excludeThenChangePathway_() {
      const currentPathway = this.contentSteeringController_.getPathway();
      if (!currentPathway) {
        return;
      }
      this.handlePathwayClones_();
      const main = this.main();
      const playlists = main.playlists;
      const ids = /* @__PURE__ */ new Set();
      let didEnablePlaylists = false;
      Object.keys(playlists).forEach((key) => {
        const variant = playlists[key];
        const pathwayId = this.pathwayAttribute_(variant);
        const differentPathwayId = pathwayId && currentPathway !== pathwayId;
        const steeringExclusion = variant.excludeUntil === Infinity && variant.lastExcludeReason_ === "content-steering";
        if (steeringExclusion && !differentPathwayId) {
          delete variant.excludeUntil;
          delete variant.lastExcludeReason_;
          didEnablePlaylists = true;
        }
        const noExcludeUntil = !variant.excludeUntil && variant.excludeUntil !== Infinity;
        const shouldExclude = !ids.has(variant.id) && differentPathwayId && noExcludeUntil;
        if (!shouldExclude) {
          return;
        }
        ids.add(variant.id);
        variant.excludeUntil = Infinity;
        variant.lastExcludeReason_ = "content-steering";
        this.logger_(`excluding ${variant.id} for ${variant.lastExcludeReason_}`);
      });
      if (this.contentSteeringController_.manifestType_ === "DASH") {
        Object.keys(this.mediaTypes_).forEach((key) => {
          const type = this.mediaTypes_[key];
          if (type.activePlaylistLoader) {
            const currentPlaylist = type.activePlaylistLoader.media_;
            if (currentPlaylist && currentPlaylist.attributes.serviceLocation !== currentPathway) {
              didEnablePlaylists = true;
            }
          }
        });
      }
      if (didEnablePlaylists) {
        this.changeSegmentPathway_();
      }
    }
    /**
     * Add, update, or delete playlists and media groups for
     * the pathway clones for HLS Content Steering.
     *
     * See https://datatracker.ietf.org/doc/draft-pantos-hls-rfc8216bis/
     *
     * NOTE: Pathway cloning does not currently support the `PER_VARIANT_URIS` and
     * `PER_RENDITION_URIS` as we do not handle `STABLE-VARIANT-ID` or
     * `STABLE-RENDITION-ID` values.
     */
    handlePathwayClones_() {
      const main = this.main();
      const playlists = main.playlists;
      const currentPathwayClones = this.contentSteeringController_.currentPathwayClones;
      const nextPathwayClones = this.contentSteeringController_.nextPathwayClones;
      const hasClones = currentPathwayClones && currentPathwayClones.size || nextPathwayClones && nextPathwayClones.size;
      if (!hasClones) {
        return;
      }
      for (const [id, clone] of currentPathwayClones.entries()) {
        const newClone = nextPathwayClones.get(id);
        if (!newClone) {
          this.mainPlaylistLoader_.updateOrDeleteClone(clone);
          this.contentSteeringController_.excludePathway(id);
        }
      }
      for (const [id, clone] of nextPathwayClones.entries()) {
        const oldClone = currentPathwayClones.get(id);
        if (!oldClone) {
          const playlistsToClone = playlists.filter((p) => {
            return p.attributes["PATHWAY-ID"] === clone["BASE-ID"];
          });
          playlistsToClone.forEach((p) => {
            this.mainPlaylistLoader_.addClonePathway(clone, p);
          });
          this.contentSteeringController_.addAvailablePathway(id);
          continue;
        }
        if (this.equalPathwayClones_(oldClone, clone)) {
          continue;
        }
        this.mainPlaylistLoader_.updateOrDeleteClone(clone, true);
        this.contentSteeringController_.addAvailablePathway(id);
      }
      this.contentSteeringController_.currentPathwayClones = new Map(JSON.parse(JSON.stringify([...nextPathwayClones])));
    }
    /**
     * Determines whether two pathway clone objects are equivalent.
     *
     * @param {Object} a The first pathway clone object.
     * @param {Object} b The second pathway clone object.
     * @return {boolean} True if the pathway clone objects are equal, false otherwise.
     */
    equalPathwayClones_(a, b) {
      if (a["BASE-ID"] !== b["BASE-ID"] || a.ID !== b.ID || a["URI-REPLACEMENT"].HOST !== b["URI-REPLACEMENT"].HOST) {
        return false;
      }
      const aParams = a["URI-REPLACEMENT"].PARAMS;
      const bParams = b["URI-REPLACEMENT"].PARAMS;
      for (const p in aParams) {
        if (aParams[p] !== bParams[p]) {
          return false;
        }
      }
      for (const p in bParams) {
        if (aParams[p] !== bParams[p]) {
          return false;
        }
      }
      return true;
    }
    /**
     * Changes the current playlists for audio, video and subtitles after a new pathway
     * is chosen from content steering.
     */
    changeSegmentPathway_() {
      const nextPlaylist = this.selectPlaylist();
      this.pauseLoading();
      if (this.contentSteeringController_.manifestType_ === "DASH") {
        this.switchMediaForDASHContentSteering_();
      }
      this.switchMedia_(nextPlaylist, "content-steering");
    }
    /**
     * Iterates through playlists and check their keyId set and compare with the
     * keyStatusMap, only enable playlists that have a usable key. If the playlist
     * has no keyId leave it enabled by default.
     */
    excludeNonUsablePlaylistsByKeyId_() {
      if (!this.mainPlaylistLoader_ || !this.mainPlaylistLoader_.main) {
        return;
      }
      let nonUsableKeyStatusCount = 0;
      const NON_USABLE = "non-usable";
      this.mainPlaylistLoader_.main.playlists.forEach((playlist) => {
        const keyIdSet = this.mainPlaylistLoader_.getKeyIdSet(playlist);
        if (!keyIdSet || !keyIdSet.size) {
          return;
        }
        keyIdSet.forEach((key) => {
          const USABLE = "usable";
          const hasUsableKeyStatus = this.keyStatusMap_.has(key) && this.keyStatusMap_.get(key) === USABLE;
          const nonUsableExclusion = playlist.lastExcludeReason_ === NON_USABLE && playlist.excludeUntil === Infinity;
          if (!hasUsableKeyStatus) {
            if (playlist.excludeUntil !== Infinity && playlist.lastExcludeReason_ !== NON_USABLE) {
              playlist.excludeUntil = Infinity;
              playlist.lastExcludeReason_ = NON_USABLE;
              this.logger_(`excluding playlist ${playlist.id} because the key ID ${key} doesn't exist in the keyStatusMap or is not ${USABLE}`);
            }
            nonUsableKeyStatusCount++;
          } else if (hasUsableKeyStatus && nonUsableExclusion) {
            delete playlist.excludeUntil;
            delete playlist.lastExcludeReason_;
            this.logger_(`enabling playlist ${playlist.id} because key ID ${key} is ${USABLE}`);
          }
        });
      });
      if (nonUsableKeyStatusCount >= this.mainPlaylistLoader_.main.playlists.length) {
        this.mainPlaylistLoader_.main.playlists.forEach((playlist) => {
          const isNonHD = playlist && playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height < 720;
          const excludedForNonUsableKey = playlist.excludeUntil === Infinity && playlist.lastExcludeReason_ === NON_USABLE;
          if (isNonHD && excludedForNonUsableKey) {
            delete playlist.excludeUntil;
            videojs.log.warn(`enabling non-HD playlist ${playlist.id} because all playlists were excluded due to ${NON_USABLE} key IDs`);
          }
        });
      }
    }
    /**
     * Adds a keystatus to the keystatus map, tries to convert to string if necessary.
     *
     * @param {any} keyId the keyId to add a status for
     * @param {string} status the status of the keyId
     */
    addKeyStatus_(keyId, status2) {
      const isString = typeof keyId === "string";
      const keyIdHexString = isString ? keyId : bufferToHexString(keyId);
      const formattedKeyIdString = keyIdHexString.slice(0, 32).toLowerCase();
      this.logger_(`KeyStatus '${status2}' with key ID ${formattedKeyIdString} added to the keyStatusMap`);
      this.keyStatusMap_.set(formattedKeyIdString, status2);
    }
    /**
     * Utility function for adding key status to the keyStatusMap and filtering usable encrypted playlists.
     *
     * @param {any} keyId the keyId from the keystatuschange event
     * @param {string} status the key status string
     */
    updatePlaylistByKeyStatus(keyId, status2) {
      this.addKeyStatus_(keyId, status2);
      if (!this.waitingForFastQualityPlaylistReceived_) {
        this.excludeNonUsableThenChangePlaylist_();
      }
      this.mainPlaylistLoader_.off("loadedplaylist", this.excludeNonUsableThenChangePlaylist_.bind(this));
      this.mainPlaylistLoader_.on("loadedplaylist", this.excludeNonUsableThenChangePlaylist_.bind(this));
    }
    excludeNonUsableThenChangePlaylist_() {
      this.excludeNonUsablePlaylistsByKeyId_();
      this.fastQualityChange_();
    }
  }
  const enableFunction = (loader, playlistID, changePlaylistFn) => (enable) => {
    const playlist = loader.main.playlists[playlistID];
    const incompatible = isIncompatible(playlist);
    const currentlyEnabled = isEnabled(playlist);
    if (typeof enable === "undefined") {
      return currentlyEnabled;
    }
    if (enable) {
      delete playlist.disabled;
    } else {
      playlist.disabled = true;
    }
    if (enable !== currentlyEnabled && !incompatible) {
      changePlaylistFn();
      if (enable) {
        loader.trigger("renditionenabled");
      } else {
        loader.trigger("renditiondisabled");
      }
    }
    return enable;
  };
  class Representation {
    constructor(vhsHandler, playlist, id) {
      const {
        playlistController_: pc
      } = vhsHandler;
      const qualityChangeFunction = pc.fastQualityChange_.bind(pc);
      if (playlist.attributes) {
        const resolution = playlist.attributes.RESOLUTION;
        this.width = resolution && resolution.width;
        this.height = resolution && resolution.height;
        this.bandwidth = playlist.attributes.BANDWIDTH;
        this.frameRate = playlist.attributes["FRAME-RATE"];
      }
      this.codecs = codecsForPlaylist(pc.main(), playlist);
      this.playlist = playlist;
      this.id = id;
      this.enabled = enableFunction(vhsHandler.playlists, playlist.id, qualityChangeFunction);
    }
  }
  const renditionSelectionMixin = function(vhsHandler) {
    vhsHandler.representations = () => {
      const main = vhsHandler.playlistController_.main();
      const playlists = isAudioOnly(main) ? vhsHandler.playlistController_.getAudioTrackPlaylists_() : main.playlists;
      if (!playlists) {
        return [];
      }
      return playlists.filter((media) => !isIncompatible(media)).map((e, i) => new Representation(vhsHandler, e, e.id));
    };
  };
  const timerCancelEvents = ["seeking", "seeked", "pause", "playing", "error"];
  class PlaybackWatcher {
    /**
     * Represents an PlaybackWatcher object.
     *
     * @class
     * @param {Object} options an object that includes the tech and settings
     */
    constructor(options) {
      this.playlistController_ = options.playlistController;
      this.tech_ = options.tech;
      this.seekable = options.seekable;
      this.allowSeeksWithinUnsafeLiveWindow = options.allowSeeksWithinUnsafeLiveWindow;
      this.liveRangeSafeTimeDelta = options.liveRangeSafeTimeDelta;
      this.media = options.media;
      this.consecutiveUpdates = 0;
      this.lastRecordedTime = null;
      this.checkCurrentTimeTimeout_ = null;
      this.logger_ = logger("PlaybackWatcher");
      this.logger_("initialize");
      const playHandler = () => this.monitorCurrentTime_();
      const canPlayHandler = () => this.monitorCurrentTime_();
      const waitingHandler = () => this.techWaiting_();
      const cancelTimerHandler = () => this.resetTimeUpdate_();
      const pc = this.playlistController_;
      const loaderTypes = ["main", "subtitle", "audio"];
      const loaderChecks = {};
      loaderTypes.forEach((type) => {
        loaderChecks[type] = {
          reset: () => this.resetSegmentDownloads_(type),
          updateend: () => this.checkSegmentDownloads_(type)
        };
        pc[`${type}SegmentLoader_`].on("appendsdone", loaderChecks[type].updateend);
        pc[`${type}SegmentLoader_`].on("playlistupdate", loaderChecks[type].reset);
        this.tech_.on(["seeked", "seeking"], loaderChecks[type].reset);
      });
      const setSeekingHandlers = (fn) => {
        ["main", "audio"].forEach((type) => {
          pc[`${type}SegmentLoader_`][fn]("appended", this.seekingAppendCheck_);
        });
      };
      this.seekingAppendCheck_ = () => {
        if (this.fixesBadSeeks_()) {
          this.consecutiveUpdates = 0;
          this.lastRecordedTime = this.tech_.currentTime();
          setSeekingHandlers("off");
        }
      };
      this.clearSeekingAppendCheck_ = () => setSeekingHandlers("off");
      this.watchForBadSeeking_ = () => {
        this.clearSeekingAppendCheck_();
        setSeekingHandlers("on");
      };
      this.tech_.on("seeked", this.clearSeekingAppendCheck_);
      this.tech_.on("seeking", this.watchForBadSeeking_);
      this.tech_.on("waiting", waitingHandler);
      this.tech_.on(timerCancelEvents, cancelTimerHandler);
      this.tech_.on("canplay", canPlayHandler);
      this.tech_.one("play", playHandler);
      this.dispose = () => {
        this.clearSeekingAppendCheck_();
        this.logger_("dispose");
        this.tech_.off("waiting", waitingHandler);
        this.tech_.off(timerCancelEvents, cancelTimerHandler);
        this.tech_.off("canplay", canPlayHandler);
        this.tech_.off("play", playHandler);
        this.tech_.off("seeking", this.watchForBadSeeking_);
        this.tech_.off("seeked", this.clearSeekingAppendCheck_);
        loaderTypes.forEach((type) => {
          pc[`${type}SegmentLoader_`].off("appendsdone", loaderChecks[type].updateend);
          pc[`${type}SegmentLoader_`].off("playlistupdate", loaderChecks[type].reset);
          this.tech_.off(["seeked", "seeking"], loaderChecks[type].reset);
        });
        if (this.checkCurrentTimeTimeout_) {
          window.clearTimeout(this.checkCurrentTimeTimeout_);
        }
        this.resetTimeUpdate_();
      };
    }
    /**
     * Periodically check current time to see if playback stopped
     *
     * @private
     */
    monitorCurrentTime_() {
      this.checkCurrentTime_();
      if (this.checkCurrentTimeTimeout_) {
        window.clearTimeout(this.checkCurrentTimeTimeout_);
      }
      this.checkCurrentTimeTimeout_ = window.setTimeout(this.monitorCurrentTime_.bind(this), 250);
    }
    /**
     * Reset stalled download stats for a specific type of loader
     *
     * @param {string} type
     *        The segment loader type to check.
     *
     * @listens SegmentLoader#playlistupdate
     * @listens Tech#seeking
     * @listens Tech#seeked
     */
    resetSegmentDownloads_(type) {
      const loader = this.playlistController_[`${type}SegmentLoader_`];
      if (this[`${type}StalledDownloads_`] > 0) {
        this.logger_(`resetting possible stalled download count for ${type} loader`);
      }
      this[`${type}StalledDownloads_`] = 0;
      this[`${type}Buffered_`] = loader.buffered_();
    }
    /**
     * Checks on every segment `appendsdone` to see
     * if segment appends are making progress. If they are not
     * and we are still downloading bytes. We exclude the playlist.
     *
     * @param {string} type
     *        The segment loader type to check.
     *
     * @listens SegmentLoader#appendsdone
     */
    checkSegmentDownloads_(type) {
      const pc = this.playlistController_;
      const loader = pc[`${type}SegmentLoader_`];
      const buffered = loader.buffered_();
      const isBufferedDifferent = isRangeDifferent(this[`${type}Buffered_`], buffered);
      this[`${type}Buffered_`] = buffered;
      if (isBufferedDifferent) {
        this.resetSegmentDownloads_(type);
        return;
      }
      this[`${type}StalledDownloads_`]++;
      this.logger_(`found #${this[`${type}StalledDownloads_`]} ${type} appends that did not increase buffer (possible stalled download)`, {
        playlistId: loader.playlist_ && loader.playlist_.id,
        buffered: timeRangesToArray(buffered)
      });
      if (this[`${type}StalledDownloads_`] < 10) {
        return;
      }
      this.logger_(`${type} loader stalled download exclusion`);
      this.resetSegmentDownloads_(type);
      this.tech_.trigger({
        type: "usage",
        name: `vhs-${type}-download-exclusion`
      });
      if (type === "subtitle") {
        return;
      }
      pc.excludePlaylist({
        error: {
          message: `Excessive ${type} segment downloading detected.`
        },
        playlistExclusionDuration: Infinity
      });
    }
    /**
     * The purpose of this function is to emulate the "waiting" event on
     * browsers that do not emit it when they are waiting for more
     * data to continue playback
     *
     * @private
     */
    checkCurrentTime_() {
      if (this.tech_.paused() || this.tech_.seeking()) {
        return;
      }
      const currentTime = this.tech_.currentTime();
      const buffered = this.tech_.buffered();
      if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) {
        return this.techWaiting_();
      }
      if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {
        this.consecutiveUpdates++;
        this.waiting_();
      } else if (currentTime === this.lastRecordedTime) {
        this.consecutiveUpdates++;
      } else {
        this.consecutiveUpdates = 0;
        this.lastRecordedTime = currentTime;
      }
    }
    /**
     * Resets the 'timeupdate' mechanism designed to detect that we are stalled
     *
     * @private
     */
    resetTimeUpdate_() {
      this.consecutiveUpdates = 0;
    }
    /**
     * Fixes situations where there's a bad seek
     *
     * @return {boolean} whether an action was taken to fix the seek
     * @private
     */
    fixesBadSeeks_() {
      const seeking = this.tech_.seeking();
      if (!seeking) {
        return false;
      }
      const seekable2 = this.seekable();
      const currentTime = this.tech_.currentTime();
      const isAfterSeekableRange = this.afterSeekableWindow_(seekable2, currentTime, this.media(), this.allowSeeksWithinUnsafeLiveWindow);
      let seekTo;
      if (isAfterSeekableRange) {
        const seekableEnd = seekable2.end(seekable2.length - 1);
        seekTo = seekableEnd;
      }
      if (this.beforeSeekableWindow_(seekable2, currentTime)) {
        const seekableStart = seekable2.start(0);
        seekTo = seekableStart + // if the playlist is too short and the seekable range is an exact time (can
        // happen in live with a 3 segment playlist), then don't use a time delta
        (seekableStart === seekable2.end(0) ? 0 : SAFE_TIME_DELTA);
      }
      if (typeof seekTo !== "undefined") {
        this.logger_(`Trying to seek outside of seekable at time ${currentTime} with seekable range ${printableRange(seekable2)}. Seeking to ${seekTo}.`);
        this.tech_.setCurrentTime(seekTo);
        return true;
      }
      const sourceUpdater = this.playlistController_.sourceUpdater_;
      const buffered = this.tech_.buffered();
      const audioBuffered = sourceUpdater.audioBuffer ? sourceUpdater.audioBuffered() : null;
      const videoBuffered = sourceUpdater.videoBuffer ? sourceUpdater.videoBuffered() : null;
      const media = this.media();
      const minAppendedDuration = media.partTargetDuration ? media.partTargetDuration : (media.targetDuration - TIME_FUDGE_FACTOR) * 2;
      const bufferedToCheck = [audioBuffered, videoBuffered];
      for (let i = 0; i < bufferedToCheck.length; i++) {
        if (!bufferedToCheck[i]) {
          continue;
        }
        const timeAhead = timeAheadOf(bufferedToCheck[i], currentTime);
        if (timeAhead < minAppendedDuration) {
          return false;
        }
      }
      const nextRange = findNextRange(buffered, currentTime);
      if (nextRange.length === 0) {
        return false;
      }
      seekTo = nextRange.start(0) + SAFE_TIME_DELTA;
      this.logger_(`Buffered region starts (${nextRange.start(0)})  just beyond seek point (${currentTime}). Seeking to ${seekTo}.`);
      this.tech_.setCurrentTime(seekTo);
      return true;
    }
    /**
     * Handler for situations when we determine the player is waiting.
     *
     * @private
     */
    waiting_() {
      if (this.techWaiting_()) {
        return;
      }
      const currentTime = this.tech_.currentTime();
      const buffered = this.tech_.buffered();
      const currentRange = findRange(buffered, currentTime);
      if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {
        this.resetTimeUpdate_();
        this.tech_.setCurrentTime(currentTime);
        this.logger_(`Stopped at ${currentTime} while inside a buffered region [${currentRange.start(0)} -> ${currentRange.end(0)}]. Attempting to resume playback by seeking to the current time.`);
        this.tech_.trigger({
          type: "usage",
          name: "vhs-unknown-waiting"
        });
        return;
      }
    }
    /**
     * Handler for situations when the tech fires a `waiting` event
     *
     * @return {boolean}
     *         True if an action (or none) was needed to correct the waiting. False if no
     *         checks passed
     * @private
     */
    techWaiting_() {
      const seekable2 = this.seekable();
      const currentTime = this.tech_.currentTime();
      if (this.tech_.seeking()) {
        return true;
      }
      if (this.beforeSeekableWindow_(seekable2, currentTime)) {
        const livePoint = seekable2.end(seekable2.length - 1);
        this.logger_(`Fell out of live window at time ${currentTime}. Seeking to live point (seekable end) ${livePoint}`);
        this.resetTimeUpdate_();
        this.tech_.setCurrentTime(livePoint);
        this.tech_.trigger({
          type: "usage",
          name: "vhs-live-resync"
        });
        return true;
      }
      const sourceUpdater = this.tech_.vhs.playlistController_.sourceUpdater_;
      const buffered = this.tech_.buffered();
      const videoUnderflow = this.videoUnderflow_({
        audioBuffered: sourceUpdater.audioBuffered(),
        videoBuffered: sourceUpdater.videoBuffered(),
        currentTime
      });
      if (videoUnderflow) {
        this.resetTimeUpdate_();
        this.tech_.setCurrentTime(currentTime);
        this.tech_.trigger({
          type: "usage",
          name: "vhs-video-underflow"
        });
        return true;
      }
      const nextRange = findNextRange(buffered, currentTime);
      if (nextRange.length > 0) {
        this.logger_(`Stopped at ${currentTime} and seeking to ${nextRange.start(0)}`);
        this.resetTimeUpdate_();
        this.skipTheGap_(currentTime);
        return true;
      }
      return false;
    }
    afterSeekableWindow_(seekable2, currentTime, playlist, allowSeeksWithinUnsafeLiveWindow = false) {
      if (!seekable2.length) {
        return false;
      }
      let allowedEnd = seekable2.end(seekable2.length - 1) + SAFE_TIME_DELTA;
      const isLive = !playlist.endList;
      const isLLHLS = typeof playlist.partTargetDuration === "number";
      if (isLive && (isLLHLS || allowSeeksWithinUnsafeLiveWindow)) {
        allowedEnd = seekable2.end(seekable2.length - 1) + playlist.targetDuration * 3;
      }
      if (currentTime > allowedEnd) {
        return true;
      }
      return false;
    }
    beforeSeekableWindow_(seekable2, currentTime) {
      if (seekable2.length && // can't fall before 0 and 0 seekable start identifies VOD stream
      seekable2.start(0) > 0 && currentTime < seekable2.start(0) - this.liveRangeSafeTimeDelta) {
        return true;
      }
      return false;
    }
    videoUnderflow_({
      videoBuffered,
      audioBuffered,
      currentTime
    }) {
      if (!videoBuffered) {
        return;
      }
      let gap;
      if (videoBuffered.length && audioBuffered.length) {
        const lastVideoRange = findRange(videoBuffered, currentTime - 3);
        const videoRange = findRange(videoBuffered, currentTime);
        const audioRange = findRange(audioBuffered, currentTime);
        if (audioRange.length && !videoRange.length && lastVideoRange.length) {
          gap = {
            start: lastVideoRange.end(0),
            end: audioRange.end(0)
          };
        }
      } else {
        const nextRange = findNextRange(videoBuffered, currentTime);
        if (!nextRange.length) {
          gap = this.gapFromVideoUnderflow_(videoBuffered, currentTime);
        }
      }
      if (gap) {
        this.logger_(`Encountered a gap in video from ${gap.start} to ${gap.end}. Seeking to current time ${currentTime}`);
        return true;
      }
      return false;
    }
    /**
     * Timer callback. If playback still has not proceeded, then we seek
     * to the start of the next buffered region.
     *
     * @private
     */
    skipTheGap_(scheduledCurrentTime) {
      const buffered = this.tech_.buffered();
      const currentTime = this.tech_.currentTime();
      const nextRange = findNextRange(buffered, currentTime);
      this.resetTimeUpdate_();
      if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {
        return;
      }
      this.logger_("skipTheGap_:", "currentTime:", currentTime, "scheduled currentTime:", scheduledCurrentTime, "nextRange start:", nextRange.start(0));
      this.tech_.setCurrentTime(nextRange.start(0) + TIME_FUDGE_FACTOR);
      this.tech_.trigger({
        type: "usage",
        name: "vhs-gap-skip"
      });
    }
    gapFromVideoUnderflow_(buffered, currentTime) {
      const gaps = findGaps(buffered);
      for (let i = 0; i < gaps.length; i++) {
        const start = gaps.start(i);
        const end = gaps.end(i);
        if (currentTime - start < 4 && currentTime - start > 2) {
          return {
            start,
            end
          };
        }
      }
      return null;
    }
  }
  const defaultOptions = {
    errorInterval: 30,
    getSource(next) {
      const tech = this.tech({
        IWillNotUseThisInPlugins: true
      });
      const sourceObj = tech.currentSource_ || this.currentSource();
      return next(sourceObj);
    }
  };
  const initPlugin = function(player, options) {
    let lastCalled = 0;
    let seekTo = 0;
    const localOptions = merge(defaultOptions, options);
    player.ready(() => {
      player.trigger({
        type: "usage",
        name: "vhs-error-reload-initialized"
      });
    });
    const loadedMetadataHandler = function() {
      if (seekTo) {
        player.currentTime(seekTo);
      }
    };
    const setSource2 = function(sourceObj) {
      if (sourceObj === null || sourceObj === void 0) {
        return;
      }
      seekTo = player.duration() !== Infinity && player.currentTime() || 0;
      player.one("loadedmetadata", loadedMetadataHandler);
      player.src(sourceObj);
      player.trigger({
        type: "usage",
        name: "vhs-error-reload"
      });
      player.play();
    };
    const errorHandler = function() {
      if (Date.now() - lastCalled < localOptions.errorInterval * 1e3) {
        player.trigger({
          type: "usage",
          name: "vhs-error-reload-canceled"
        });
        return;
      }
      if (!localOptions.getSource || typeof localOptions.getSource !== "function") {
        videojs.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!");
        return;
      }
      lastCalled = Date.now();
      return localOptions.getSource.call(player, setSource2);
    };
    const cleanupEvents = function() {
      player.off("loadedmetadata", loadedMetadataHandler);
      player.off("error", errorHandler);
      player.off("dispose", cleanupEvents);
    };
    const reinitPlugin = function(newOptions) {
      cleanupEvents();
      initPlugin(player, newOptions);
    };
    player.on("error", errorHandler);
    player.on("dispose", cleanupEvents);
    player.reloadSourceOnError = reinitPlugin;
  };
  const reloadSourceOnError = function(options) {
    initPlugin(this, options);
  };
  var version$4 = "3.9.1";
  var version$3 = "7.0.2";
  var version$2 = "1.3.0";
  var version$1 = "7.1.0";
  var version = "4.0.1";
  const Vhs = {
    PlaylistLoader,
    Playlist,
    utils,
    STANDARD_PLAYLIST_SELECTOR: lastBandwidthSelector,
    INITIAL_PLAYLIST_SELECTOR: lowestBitrateCompatibleVariantSelector,
    lastBandwidthSelector,
    movingAverageBandwidthSelector,
    comparePlaylistBandwidth,
    comparePlaylistResolution,
    xhr: xhrFactory()
  };
  Object.keys(Config).forEach((prop) => {
    Object.defineProperty(Vhs, prop, {
      get() {
        videojs.log.warn(`using Vhs.${prop} is UNSAFE be sure you know what you are doing`);
        return Config[prop];
      },
      set(value) {
        videojs.log.warn(`using Vhs.${prop} is UNSAFE be sure you know what you are doing`);
        if (typeof value !== "number" || value < 0) {
          videojs.log.warn(`value of Vhs.${prop} must be greater than or equal to 0`);
          return;
        }
        Config[prop] = value;
      }
    });
  });
  const LOCAL_STORAGE_KEY = "videojs-vhs";
  const handleVhsMediaChange = function(qualityLevels, playlistLoader) {
    const newPlaylist = playlistLoader.media();
    let selectedIndex = -1;
    for (let i = 0; i < qualityLevels.length; i++) {
      if (qualityLevels[i].id === newPlaylist.id) {
        selectedIndex = i;
        break;
      }
    }
    qualityLevels.selectedIndex_ = selectedIndex;
    qualityLevels.trigger({
      selectedIndex,
      type: "change"
    });
  };
  const handleVhsLoadedMetadata = function(qualityLevels, vhs) {
    vhs.representations().forEach((rep) => {
      qualityLevels.addQualityLevel(rep);
    });
    handleVhsMediaChange(qualityLevels, vhs.playlists);
  };
  Vhs.canPlaySource = function() {
    return videojs.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.");
  };
  const emeKeySystems = (keySystemOptions, mainPlaylist, audioPlaylist) => {
    if (!keySystemOptions) {
      return keySystemOptions;
    }
    let codecs = {};
    if (mainPlaylist && mainPlaylist.attributes && mainPlaylist.attributes.CODECS) {
      codecs = unwrapCodecList(parseCodecs(mainPlaylist.attributes.CODECS));
    }
    if (audioPlaylist && audioPlaylist.attributes && audioPlaylist.attributes.CODECS) {
      codecs.audio = audioPlaylist.attributes.CODECS;
    }
    const videoContentType = getMimeForCodec(codecs.video);
    const audioContentType = getMimeForCodec(codecs.audio);
    const keySystemContentTypes = {};
    for (const keySystem in keySystemOptions) {
      keySystemContentTypes[keySystem] = {};
      if (audioContentType) {
        keySystemContentTypes[keySystem].audioContentType = audioContentType;
      }
      if (videoContentType) {
        keySystemContentTypes[keySystem].videoContentType = videoContentType;
      }
      if (mainPlaylist.contentProtection && mainPlaylist.contentProtection[keySystem] && mainPlaylist.contentProtection[keySystem].pssh) {
        keySystemContentTypes[keySystem].pssh = mainPlaylist.contentProtection[keySystem].pssh;
      }
      if (typeof keySystemOptions[keySystem] === "string") {
        keySystemContentTypes[keySystem].url = keySystemOptions[keySystem];
      }
    }
    return merge(keySystemOptions, keySystemContentTypes);
  };
  const getAllPsshKeySystemsOptions = (playlists, keySystems) => {
    return playlists.reduce((keySystemsArr, playlist) => {
      if (!playlist.contentProtection) {
        return keySystemsArr;
      }
      const keySystemsOptions = keySystems.reduce((keySystemsObj, keySystem) => {
        const keySystemOptions = playlist.contentProtection[keySystem];
        if (keySystemOptions && keySystemOptions.pssh) {
          keySystemsObj[keySystem] = {
            pssh: keySystemOptions.pssh
          };
        }
        return keySystemsObj;
      }, {});
      if (Object.keys(keySystemsOptions).length) {
        keySystemsArr.push(keySystemsOptions);
      }
      return keySystemsArr;
    }, []);
  };
  const waitForKeySessionCreation = ({
    player,
    sourceKeySystems,
    audioMedia,
    mainPlaylists
  }) => {
    if (!player.eme.initializeMediaKeys) {
      return Promise.resolve();
    }
    const playlists = audioMedia ? mainPlaylists.concat([audioMedia]) : mainPlaylists;
    const keySystemsOptionsArr = getAllPsshKeySystemsOptions(playlists, Object.keys(sourceKeySystems));
    const initializationFinishedPromises = [];
    const keySessionCreatedPromises = [];
    keySystemsOptionsArr.forEach((keySystemsOptions) => {
      keySessionCreatedPromises.push(new Promise((resolve, reject) => {
        player.tech_.one("keysessioncreated", resolve);
      }));
      initializationFinishedPromises.push(new Promise((resolve, reject) => {
        player.eme.initializeMediaKeys({
          keySystems: keySystemsOptions
        }, (err) => {
          if (err) {
            reject(err);
            return;
          }
          resolve();
        });
      }));
    });
    return Promise.race([
      // If a session was previously created, these will all finish resolving without
      // creating a new session, otherwise it will take until the end of all license
      // requests, which is why the key session check is used (to make setup much faster).
      Promise.all(initializationFinishedPromises),
      // Once a single session is created, the browser knows DRM will be used.
      Promise.race(keySessionCreatedPromises)
    ]);
  };
  const setupEmeOptions = ({
    player,
    sourceKeySystems,
    media,
    audioMedia
  }) => {
    const sourceOptions = emeKeySystems(sourceKeySystems, media, audioMedia);
    if (!sourceOptions) {
      return false;
    }
    player.currentSource().keySystems = sourceOptions;
    if (sourceOptions && !player.eme) {
      videojs.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin");
      return false;
    }
    return true;
  };
  const getVhsLocalStorage = () => {
    if (!window.localStorage) {
      return null;
    }
    const storedObject = window.localStorage.getItem(LOCAL_STORAGE_KEY);
    if (!storedObject) {
      return null;
    }
    try {
      return JSON.parse(storedObject);
    } catch (e) {
      return null;
    }
  };
  const updateVhsLocalStorage = (options) => {
    if (!window.localStorage) {
      return false;
    }
    let objectToStore = getVhsLocalStorage();
    objectToStore = objectToStore ? merge(objectToStore, options) : options;
    try {
      window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(objectToStore));
    } catch (e) {
      return false;
    }
    return objectToStore;
  };
  const expandDataUri = (dataUri) => {
    if (dataUri.toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") === 0) {
      return JSON.parse(dataUri.substring(dataUri.indexOf(",") + 1));
    }
    return dataUri;
  };
  const addOnRequestHook = (xhr, callback) => {
    if (!xhr._requestCallbackSet) {
      xhr._requestCallbackSet = /* @__PURE__ */ new Set();
    }
    xhr._requestCallbackSet.add(callback);
  };
  const addOnResponseHook = (xhr, callback) => {
    if (!xhr._responseCallbackSet) {
      xhr._responseCallbackSet = /* @__PURE__ */ new Set();
    }
    xhr._responseCallbackSet.add(callback);
  };
  const removeOnRequestHook = (xhr, callback) => {
    if (!xhr._requestCallbackSet) {
      return;
    }
    xhr._requestCallbackSet.delete(callback);
    if (!xhr._requestCallbackSet.size) {
      delete xhr._requestCallbackSet;
    }
  };
  const removeOnResponseHook = (xhr, callback) => {
    if (!xhr._responseCallbackSet) {
      return;
    }
    xhr._responseCallbackSet.delete(callback);
    if (!xhr._responseCallbackSet.size) {
      delete xhr._responseCallbackSet;
    }
  };
  Vhs.supportsNativeHls = function() {
    if (!document || !document.createElement) {
      return false;
    }
    const video = document.createElement("video");
    if (!videojs.getTech("Html5").isSupported()) {
      return false;
    }
    const canPlay = [
      // Apple santioned
      "application/vnd.apple.mpegurl",
      // Apple sanctioned for backwards compatibility
      "audio/mpegurl",
      // Very common
      "audio/x-mpegurl",
      // Very common
      "application/x-mpegurl",
      // Included for completeness
      "video/x-mpegurl",
      "video/mpegurl",
      "application/mpegurl"
    ];
    return canPlay.some(function(canItPlay) {
      return /maybe|probably/i.test(video.canPlayType(canItPlay));
    });
  }();
  Vhs.supportsNativeDash = function() {
    if (!document || !document.createElement || !videojs.getTech("Html5").isSupported()) {
      return false;
    }
    return /maybe|probably/i.test(document.createElement("video").canPlayType("application/dash+xml"));
  }();
  Vhs.supportsTypeNatively = (type) => {
    if (type === "hls") {
      return Vhs.supportsNativeHls;
    }
    if (type === "dash") {
      return Vhs.supportsNativeDash;
    }
    return false;
  };
  Vhs.isSupported = function() {
    return videojs.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.");
  };
  Vhs.xhr.onRequest = function(callback) {
    addOnRequestHook(Vhs.xhr, callback);
  };
  Vhs.xhr.onResponse = function(callback) {
    addOnResponseHook(Vhs.xhr, callback);
  };
  Vhs.xhr.offRequest = function(callback) {
    removeOnRequestHook(Vhs.xhr, callback);
  };
  Vhs.xhr.offResponse = function(callback) {
    removeOnResponseHook(Vhs.xhr, callback);
  };
  const Component = videojs.getComponent("Component");
  class VhsHandler extends Component {
    constructor(source, tech, options) {
      super(tech, options.vhs);
      if (typeof options.initialBandwidth === "number") {
        this.options_.bandwidth = options.initialBandwidth;
      }
      this.logger_ = logger("VhsHandler");
      if (tech.options_ && tech.options_.playerId) {
        const _player = videojs.getPlayer(tech.options_.playerId);
        this.player_ = _player;
      }
      this.tech_ = tech;
      this.source_ = source;
      this.stats = {};
      this.ignoreNextSeekingEvent_ = false;
      this.setOptions_();
      if (this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) {
        tech.overrideNativeAudioTracks(true);
        tech.overrideNativeVideoTracks(true);
      } else if (this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) {
        throw new Error("Overriding native VHS requires emulated tracks. See https://git.io/vMpjB");
      }
      this.on(document, ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"], (event) => {
        const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        if (fullscreenElement && fullscreenElement.contains(this.tech_.el())) {
          this.playlistController_.fastQualityChange_();
        } else {
          this.playlistController_.checkABR_();
        }
      });
      this.on(this.tech_, "seeking", function() {
        if (this.ignoreNextSeekingEvent_) {
          this.ignoreNextSeekingEvent_ = false;
          return;
        }
        this.setCurrentTime(this.tech_.currentTime());
      });
      this.on(this.tech_, "error", function() {
        if (this.tech_.error() && this.playlistController_) {
          this.playlistController_.pauseLoading();
        }
      });
      this.on(this.tech_, "play", this.play);
    }
    /**
     * Set VHS options based on options from configuration, as well as partial
     * options to be passed at a later time.
     *
     * @param {Object} options A partial chunk of config options
     */
    setOptions_(options = {}) {
      this.options_ = merge(this.options_, options);
      this.options_.withCredentials = this.options_.withCredentials || false;
      this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions === false ? false : true;
      this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || false;
      this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage !== "undefined" ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || false;
      this.options_.useForcedSubtitles = this.options_.useForcedSubtitles || false;
      this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || false;
      this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || false;
      this.options_.customTagParsers = this.options_.customTagParsers || [];
      this.options_.customTagMappers = this.options_.customTagMappers || [];
      this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || false;
      this.options_.llhls = this.options_.llhls === false ? false : true;
      this.options_.bufferBasedABR = this.options_.bufferBasedABR || false;
      if (typeof this.options_.playlistExclusionDuration !== "number") {
        this.options_.playlistExclusionDuration = 60;
      }
      if (typeof this.options_.bandwidth !== "number") {
        if (this.options_.useBandwidthFromLocalStorage) {
          const storedObject = getVhsLocalStorage();
          if (storedObject && storedObject.bandwidth) {
            this.options_.bandwidth = storedObject.bandwidth;
            this.tech_.trigger({
              type: "usage",
              name: "vhs-bandwidth-from-local-storage"
            });
          }
          if (storedObject && storedObject.throughput) {
            this.options_.throughput = storedObject.throughput;
            this.tech_.trigger({
              type: "usage",
              name: "vhs-throughput-from-local-storage"
            });
          }
        }
      }
      if (typeof this.options_.bandwidth !== "number") {
        this.options_.bandwidth = Config.INITIAL_BANDWIDTH;
      }
      this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Config.INITIAL_BANDWIDTH;
      ["withCredentials", "useDevicePixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "customTagParsers", "customTagMappers", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "bufferBasedABR", "liveRangeSafeTimeDelta", "llhls", "useForcedSubtitles", "useNetworkInformationApi", "useDtsForTimestampOffset", "exactManifestTimings", "leastPixelDiffSelector"].forEach((option) => {
        if (typeof this.source_[option] !== "undefined") {
          this.options_[option] = this.source_[option];
        }
      });
      this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions;
      this.useDevicePixelRatio = this.options_.useDevicePixelRatio;
    }
    // alias for public method to set options
    setOptions(options = {}) {
      this.setOptions_(options);
    }
    /**
     * called when player.src gets called, handle a new source
     *
     * @param {Object} src the source object to handle
     */
    src(src, type) {
      if (!src) {
        return;
      }
      this.setOptions_();
      this.options_.src = expandDataUri(this.source_.src);
      this.options_.tech = this.tech_;
      this.options_.externVhs = Vhs;
      this.options_.sourceType = simpleTypeFromSourceType(type);
      this.options_.seekTo = (time) => {
        this.tech_.setCurrentTime(time);
      };
      this.playlistController_ = new PlaylistController(this.options_);
      const playbackWatcherOptions = merge({
        liveRangeSafeTimeDelta: SAFE_TIME_DELTA
      }, this.options_, {
        seekable: () => this.seekable(),
        media: () => this.playlistController_.media(),
        playlistController: this.playlistController_
      });
      this.playbackWatcher_ = new PlaybackWatcher(playbackWatcherOptions);
      this.playlistController_.on("error", () => {
        const player = videojs.players[this.tech_.options_.playerId];
        let error = this.playlistController_.error;
        if (typeof error === "object" && !error.code) {
          error.code = 3;
        } else if (typeof error === "string") {
          error = {
            message: error,
            code: 3
          };
        }
        player.error(error);
      });
      const defaultSelector = this.options_.bufferBasedABR ? Vhs.movingAverageBandwidthSelector(0.55) : Vhs.STANDARD_PLAYLIST_SELECTOR;
      this.playlistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : defaultSelector.bind(this);
      this.playlistController_.selectInitialPlaylist = Vhs.INITIAL_PLAYLIST_SELECTOR.bind(this);
      this.playlists = this.playlistController_.mainPlaylistLoader_;
      this.mediaSource = this.playlistController_.mediaSource;
      Object.defineProperties(this, {
        selectPlaylist: {
          get() {
            return this.playlistController_.selectPlaylist;
          },
          set(selectPlaylist) {
            this.playlistController_.selectPlaylist = selectPlaylist.bind(this);
          }
        },
        throughput: {
          get() {
            return this.playlistController_.mainSegmentLoader_.throughput.rate;
          },
          set(throughput) {
            this.playlistController_.mainSegmentLoader_.throughput.rate = throughput;
            this.playlistController_.mainSegmentLoader_.throughput.count = 1;
          }
        },
        bandwidth: {
          get() {
            let playerBandwidthEst = this.playlistController_.mainSegmentLoader_.bandwidth;
            const networkInformation = window.navigator.connection || window.navigator.mozConnection || window.navigator.webkitConnection;
            const tenMbpsAsBitsPerSecond = 1e7;
            if (this.options_.useNetworkInformationApi && networkInformation) {
              const networkInfoBandwidthEstBitsPerSec = networkInformation.downlink * 1e3 * 1e3;
              if (networkInfoBandwidthEstBitsPerSec >= tenMbpsAsBitsPerSecond && playerBandwidthEst >= tenMbpsAsBitsPerSecond) {
                playerBandwidthEst = Math.max(playerBandwidthEst, networkInfoBandwidthEstBitsPerSec);
              } else {
                playerBandwidthEst = networkInfoBandwidthEstBitsPerSec;
              }
            }
            return playerBandwidthEst;
          },
          set(bandwidth) {
            this.playlistController_.mainSegmentLoader_.bandwidth = bandwidth;
            this.playlistController_.mainSegmentLoader_.throughput = {
              rate: 0,
              count: 0
            };
          }
        },
        /**
         * `systemBandwidth` is a combination of two serial processes bit-rates. The first
         * is the network bitrate provided by `bandwidth` and the second is the bitrate of
         * the entire process after that - decryption, transmuxing, and appending - provided
         * by `throughput`.
         *
         * Since the two process are serial, the overall system bandwidth is given by:
         *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)
         */
        systemBandwidth: {
          get() {
            const invBandwidth = 1 / (this.bandwidth || 1);
            let invThroughput;
            if (this.throughput > 0) {
              invThroughput = 1 / this.throughput;
            } else {
              invThroughput = 0;
            }
            const systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));
            return systemBitrate;
          },
          set() {
            videojs.log.error('The "systemBandwidth" property is read-only');
          }
        }
      });
      if (this.options_.bandwidth) {
        this.bandwidth = this.options_.bandwidth;
      }
      if (this.options_.throughput) {
        this.throughput = this.options_.throughput;
      }
      Object.defineProperties(this.stats, {
        bandwidth: {
          get: () => this.bandwidth || 0,
          enumerable: true
        },
        mediaRequests: {
          get: () => this.playlistController_.mediaRequests_() || 0,
          enumerable: true
        },
        mediaRequestsAborted: {
          get: () => this.playlistController_.mediaRequestsAborted_() || 0,
          enumerable: true
        },
        mediaRequestsTimedout: {
          get: () => this.playlistController_.mediaRequestsTimedout_() || 0,
          enumerable: true
        },
        mediaRequestsErrored: {
          get: () => this.playlistController_.mediaRequestsErrored_() || 0,
          enumerable: true
        },
        mediaTransferDuration: {
          get: () => this.playlistController_.mediaTransferDuration_() || 0,
          enumerable: true
        },
        mediaBytesTransferred: {
          get: () => this.playlistController_.mediaBytesTransferred_() || 0,
          enumerable: true
        },
        mediaSecondsLoaded: {
          get: () => this.playlistController_.mediaSecondsLoaded_() || 0,
          enumerable: true
        },
        mediaAppends: {
          get: () => this.playlistController_.mediaAppends_() || 0,
          enumerable: true
        },
        mainAppendsToLoadedData: {
          get: () => this.playlistController_.mainAppendsToLoadedData_() || 0,
          enumerable: true
        },
        audioAppendsToLoadedData: {
          get: () => this.playlistController_.audioAppendsToLoadedData_() || 0,
          enumerable: true
        },
        appendsToLoadedData: {
          get: () => this.playlistController_.appendsToLoadedData_() || 0,
          enumerable: true
        },
        timeToLoadedData: {
          get: () => this.playlistController_.timeToLoadedData_() || 0,
          enumerable: true
        },
        buffered: {
          get: () => timeRangesToArray(this.tech_.buffered()),
          enumerable: true
        },
        currentTime: {
          get: () => this.tech_.currentTime(),
          enumerable: true
        },
        currentSource: {
          get: () => this.tech_.currentSource_,
          enumerable: true
        },
        currentTech: {
          get: () => this.tech_.name_,
          enumerable: true
        },
        duration: {
          get: () => this.tech_.duration(),
          enumerable: true
        },
        main: {
          get: () => this.playlists.main,
          enumerable: true
        },
        playerDimensions: {
          get: () => this.tech_.currentDimensions(),
          enumerable: true
        },
        seekable: {
          get: () => timeRangesToArray(this.tech_.seekable()),
          enumerable: true
        },
        timestamp: {
          get: () => Date.now(),
          enumerable: true
        },
        videoPlaybackQuality: {
          get: () => this.tech_.getVideoPlaybackQuality(),
          enumerable: true
        }
      });
      this.tech_.one("canplay", this.playlistController_.setupFirstPlay.bind(this.playlistController_));
      this.tech_.on("bandwidthupdate", () => {
        if (this.options_.useBandwidthFromLocalStorage) {
          updateVhsLocalStorage({
            bandwidth: this.bandwidth,
            throughput: Math.round(this.throughput)
          });
        }
      });
      this.playlistController_.on("selectedinitialmedia", () => {
        renditionSelectionMixin(this);
      });
      this.playlistController_.sourceUpdater_.on("createdsourcebuffers", () => {
        this.setupEme_();
      });
      this.on(this.playlistController_, "progress", function() {
        this.tech_.trigger("progress");
      });
      this.on(this.playlistController_, "firstplay", function() {
        this.ignoreNextSeekingEvent_ = true;
      });
      this.setupQualityLevels_();
      if (!this.tech_.el()) {
        return;
      }
      this.mediaSourceUrl_ = window.URL.createObjectURL(this.playlistController_.mediaSource);
      this.tech_.src(this.mediaSourceUrl_);
    }
    createKeySessions_() {
      const audioPlaylistLoader = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;
      this.logger_("waiting for EME key session creation");
      waitForKeySessionCreation({
        player: this.player_,
        sourceKeySystems: this.source_.keySystems,
        audioMedia: audioPlaylistLoader && audioPlaylistLoader.media(),
        mainPlaylists: this.playlists.main.playlists
      }).then(() => {
        this.logger_("created EME key session");
        this.playlistController_.sourceUpdater_.initializedEme();
      }).catch((err) => {
        this.logger_("error while creating EME key session", err);
        this.player_.error({
          message: "Failed to initialize media keys for EME",
          code: 3
        });
      });
    }
    handleWaitingForKey_() {
      this.logger_("waitingforkey fired, attempting to create any new key sessions");
      this.createKeySessions_();
    }
    /**
     * If necessary and EME is available, sets up EME options and waits for key session
     * creation.
     *
     * This function also updates the source updater so taht it can be used, as for some
     * browsers, EME must be configured before content is appended (if appending unencrypted
     * content before encrypted content).
     */
    setupEme_() {
      const audioPlaylistLoader = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;
      const didSetupEmeOptions = setupEmeOptions({
        player: this.player_,
        sourceKeySystems: this.source_.keySystems,
        media: this.playlists.media(),
        audioMedia: audioPlaylistLoader && audioPlaylistLoader.media()
      });
      this.player_.tech_.on("keystatuschange", (e) => {
        this.playlistController_.updatePlaylistByKeyStatus(e.keyId, e.status);
      });
      this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this);
      this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_);
      if (!didSetupEmeOptions) {
        this.playlistController_.sourceUpdater_.initializedEme();
        return;
      }
      this.createKeySessions_();
    }
    /**
     * Initializes the quality levels and sets listeners to update them.
     *
     * @method setupQualityLevels_
     * @private
     */
    setupQualityLevels_() {
      const player = videojs.players[this.tech_.options_.playerId];
      if (!player || !player.qualityLevels || this.qualityLevels_) {
        return;
      }
      this.qualityLevels_ = player.qualityLevels();
      this.playlistController_.on("selectedinitialmedia", () => {
        handleVhsLoadedMetadata(this.qualityLevels_, this);
      });
      this.playlists.on("mediachange", () => {
        handleVhsMediaChange(this.qualityLevels_, this.playlists);
      });
    }
    /**
     * return the version
     */
    static version() {
      return {
        "@videojs/http-streaming": version$4,
        "mux.js": version$3,
        "mpd-parser": version$2,
        "m3u8-parser": version$1,
        "aes-decrypter": version
      };
    }
    /**
     * return the version
     */
    version() {
      return this.constructor.version();
    }
    canChangeType() {
      return SourceUpdater.canChangeType();
    }
    /**
     * Begin playing the video.
     */
    play() {
      this.playlistController_.play();
    }
    /**
     * a wrapper around the function in PlaylistController
     */
    setCurrentTime(currentTime) {
      this.playlistController_.setCurrentTime(currentTime);
    }
    /**
     * a wrapper around the function in PlaylistController
     */
    duration() {
      return this.playlistController_.duration();
    }
    /**
     * a wrapper around the function in PlaylistController
     */
    seekable() {
      return this.playlistController_.seekable();
    }
    /**
     * Abort all outstanding work and cleanup.
     */
    dispose() {
      if (this.playbackWatcher_) {
        this.playbackWatcher_.dispose();
      }
      if (this.playlistController_) {
        this.playlistController_.dispose();
      }
      if (this.qualityLevels_) {
        this.qualityLevels_.dispose();
      }
      if (this.tech_ && this.tech_.vhs) {
        delete this.tech_.vhs;
      }
      if (this.mediaSourceUrl_ && window.URL.revokeObjectURL) {
        window.URL.revokeObjectURL(this.mediaSourceUrl_);
        this.mediaSourceUrl_ = null;
      }
      if (this.tech_) {
        this.tech_.off("waitingforkey", this.handleWaitingForKey_);
      }
      super.dispose();
    }
    convertToProgramTime(time, callback) {
      return getProgramTime({
        playlist: this.playlistController_.media(),
        time,
        callback
      });
    }
    // the player must be playing before calling this
    seekToProgramTime(programTime, callback, pauseAfterSeek = true, retryCount = 2) {
      return seekToProgramTime({
        programTime,
        playlist: this.playlistController_.media(),
        retryCount,
        pauseAfterSeek,
        seekTo: this.options_.seekTo,
        tech: this.options_.tech,
        callback
      });
    }
    /**
     * Adds the onRequest, onResponse, offRequest and offResponse functions
     * to the VhsHandler xhr Object.
     */
    setupXhrHooks_() {
      this.xhr.onRequest = (callback) => {
        addOnRequestHook(this.xhr, callback);
      };
      this.xhr.onResponse = (callback) => {
        addOnResponseHook(this.xhr, callback);
      };
      this.xhr.offRequest = (callback) => {
        removeOnRequestHook(this.xhr, callback);
      };
      this.xhr.offResponse = (callback) => {
        removeOnResponseHook(this.xhr, callback);
      };
      this.player_.trigger("xhr-hooks-ready");
    }
  }
  const VhsSourceHandler = {
    name: "videojs-http-streaming",
    VERSION: version$4,
    canHandleSource(srcObj, options = {}) {
      const localOptions = merge(videojs.options, options);
      return VhsSourceHandler.canPlayType(srcObj.type, localOptions);
    },
    handleSource(source, tech, options = {}) {
      const localOptions = merge(videojs.options, options);
      tech.vhs = new VhsHandler(source, tech, localOptions);
      tech.vhs.xhr = xhrFactory();
      tech.vhs.setupXhrHooks_();
      tech.vhs.src(source.src, source.type);
      return tech.vhs;
    },
    canPlayType(type, options) {
      const simpleType = simpleTypeFromSourceType(type);
      if (!simpleType) {
        return "";
      }
      const overrideNative = VhsSourceHandler.getOverrideNative(options);
      const supportsTypeNatively = Vhs.supportsTypeNatively(simpleType);
      const canUseMsePlayback = !supportsTypeNatively || overrideNative;
      return canUseMsePlayback ? "maybe" : "";
    },
    getOverrideNative(options = {}) {
      const {
        vhs = {}
      } = options;
      const defaultOverrideNative = !(videojs.browser.IS_ANY_SAFARI || videojs.browser.IS_IOS);
      const {
        overrideNative = defaultOverrideNative
      } = vhs;
      return overrideNative;
    }
  };
  const supportsNativeMediaSources = () => {
    return browserSupportsCodec("avc1.4d400d,mp4a.40.2");
  };
  if (supportsNativeMediaSources()) {
    videojs.getTech("Html5").registerSourceHandler(VhsSourceHandler, 0);
  }
  videojs.VhsHandler = VhsHandler;
  videojs.VhsSourceHandler = VhsSourceHandler;
  videojs.Vhs = Vhs;
  if (!videojs.use) {
    videojs.registerComponent("Vhs", Vhs);
  }
  videojs.options.vhs = videojs.options.vhs || {};
  if (!videojs.getPlugin || !videojs.getPlugin("reloadSourceOnError")) {
    videojs.registerPlugin("reloadSourceOnError", reloadSourceOnError);
  }
  return videojs;
});
(function __HLS_WORKER_BUNDLE__(__IN_WORKER__) {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Hls = factory());
  })(this, function() {
    "use strict";
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread2(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _toPrimitive(t, r) {
      if ("object" != typeof t || !t)
        return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i)
          return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == typeof i ? i : String(i);
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      try {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      } catch (e) {
        return typeof fn === "function";
      }
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it)
        return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        return function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var urlToolkit = { exports: {} };
    (function(module2, exports2) {
      (function(root) {
        var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
        var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
        var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
        var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
        var URLToolkit = {
          // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
          // E.g
          // With opts.alwaysNormalize = false (default, spec compliant)
          // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
          // With opts.alwaysNormalize = true (not spec compliant)
          // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
          buildAbsoluteURL: function(baseURL, relativeURL, opts) {
            opts = opts || {};
            baseURL = baseURL.trim();
            relativeURL = relativeURL.trim();
            if (!relativeURL) {
              if (!opts.alwaysNormalize) {
                return baseURL;
              }
              var basePartsForNormalise = URLToolkit.parseURL(baseURL);
              if (!basePartsForNormalise) {
                throw new Error("Error trying to parse base URL.");
              }
              basePartsForNormalise.path = URLToolkit.normalizePath(
                basePartsForNormalise.path
              );
              return URLToolkit.buildURLFromParts(basePartsForNormalise);
            }
            var relativeParts = URLToolkit.parseURL(relativeURL);
            if (!relativeParts) {
              throw new Error("Error trying to parse relative URL.");
            }
            if (relativeParts.scheme) {
              if (!opts.alwaysNormalize) {
                return relativeURL;
              }
              relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
              return URLToolkit.buildURLFromParts(relativeParts);
            }
            var baseParts = URLToolkit.parseURL(baseURL);
            if (!baseParts) {
              throw new Error("Error trying to parse base URL.");
            }
            if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
              var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
              baseParts.netLoc = pathParts[1];
              baseParts.path = pathParts[2];
            }
            if (baseParts.netLoc && !baseParts.path) {
              baseParts.path = "/";
            }
            var builtParts = {
              // 2c) Otherwise, the embedded URL inherits the scheme of
              // the base URL.
              scheme: baseParts.scheme,
              netLoc: relativeParts.netLoc,
              path: null,
              params: relativeParts.params,
              query: relativeParts.query,
              fragment: relativeParts.fragment
            };
            if (!relativeParts.netLoc) {
              builtParts.netLoc = baseParts.netLoc;
              if (relativeParts.path[0] !== "/") {
                if (!relativeParts.path) {
                  builtParts.path = baseParts.path;
                  if (!relativeParts.params) {
                    builtParts.params = baseParts.params;
                    if (!relativeParts.query) {
                      builtParts.query = baseParts.query;
                    }
                  }
                } else {
                  var baseURLPath = baseParts.path;
                  var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
                  builtParts.path = URLToolkit.normalizePath(newPath);
                }
              }
            }
            if (builtParts.path === null) {
              builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
            }
            return URLToolkit.buildURLFromParts(builtParts);
          },
          parseURL: function(url) {
            var parts = URL_REGEX.exec(url);
            if (!parts) {
              return null;
            }
            return {
              scheme: parts[1] || "",
              netLoc: parts[2] || "",
              path: parts[3] || "",
              params: parts[4] || "",
              query: parts[5] || "",
              fragment: parts[6] || ""
            };
          },
          normalizePath: function(path) {
            path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
            while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) {
            }
            return path.split("").reverse().join("");
          },
          buildURLFromParts: function(parts) {
            return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
          }
        };
        module2.exports = URLToolkit;
      })();
    })(urlToolkit);
    var urlToolkitExports = urlToolkit.exports;
    var isFiniteNumber = Number.isFinite || function(value) {
      return typeof value === "number" && isFinite(value);
    };
    var isSafeInteger = Number.isSafeInteger || function(value) {
      return typeof value === "number" && Math.abs(value) <= MAX_SAFE_INTEGER;
    };
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var Events = /* @__PURE__ */ function(Events2) {
      Events2["MEDIA_ATTACHING"] = "hlsMediaAttaching";
      Events2["MEDIA_ATTACHED"] = "hlsMediaAttached";
      Events2["MEDIA_DETACHING"] = "hlsMediaDetaching";
      Events2["MEDIA_DETACHED"] = "hlsMediaDetached";
      Events2["BUFFER_RESET"] = "hlsBufferReset";
      Events2["BUFFER_CODECS"] = "hlsBufferCodecs";
      Events2["BUFFER_CREATED"] = "hlsBufferCreated";
      Events2["BUFFER_APPENDING"] = "hlsBufferAppending";
      Events2["BUFFER_APPENDED"] = "hlsBufferAppended";
      Events2["BUFFER_EOS"] = "hlsBufferEos";
      Events2["BUFFER_FLUSHING"] = "hlsBufferFlushing";
      Events2["BUFFER_FLUSHED"] = "hlsBufferFlushed";
      Events2["MANIFEST_LOADING"] = "hlsManifestLoading";
      Events2["MANIFEST_LOADED"] = "hlsManifestLoaded";
      Events2["MANIFEST_PARSED"] = "hlsManifestParsed";
      Events2["LEVEL_SWITCHING"] = "hlsLevelSwitching";
      Events2["LEVEL_SWITCHED"] = "hlsLevelSwitched";
      Events2["LEVEL_LOADING"] = "hlsLevelLoading";
      Events2["LEVEL_LOADED"] = "hlsLevelLoaded";
      Events2["LEVEL_UPDATED"] = "hlsLevelUpdated";
      Events2["LEVEL_PTS_UPDATED"] = "hlsLevelPtsUpdated";
      Events2["LEVELS_UPDATED"] = "hlsLevelsUpdated";
      Events2["AUDIO_TRACKS_UPDATED"] = "hlsAudioTracksUpdated";
      Events2["AUDIO_TRACK_SWITCHING"] = "hlsAudioTrackSwitching";
      Events2["AUDIO_TRACK_SWITCHED"] = "hlsAudioTrackSwitched";
      Events2["AUDIO_TRACK_LOADING"] = "hlsAudioTrackLoading";
      Events2["AUDIO_TRACK_LOADED"] = "hlsAudioTrackLoaded";
      Events2["SUBTITLE_TRACKS_UPDATED"] = "hlsSubtitleTracksUpdated";
      Events2["SUBTITLE_TRACKS_CLEARED"] = "hlsSubtitleTracksCleared";
      Events2["SUBTITLE_TRACK_SWITCH"] = "hlsSubtitleTrackSwitch";
      Events2["SUBTITLE_TRACK_LOADING"] = "hlsSubtitleTrackLoading";
      Events2["SUBTITLE_TRACK_LOADED"] = "hlsSubtitleTrackLoaded";
      Events2["SUBTITLE_FRAG_PROCESSED"] = "hlsSubtitleFragProcessed";
      Events2["CUES_PARSED"] = "hlsCuesParsed";
      Events2["NON_NATIVE_TEXT_TRACKS_FOUND"] = "hlsNonNativeTextTracksFound";
      Events2["INIT_PTS_FOUND"] = "hlsInitPtsFound";
      Events2["FRAG_LOADING"] = "hlsFragLoading";
      Events2["FRAG_LOAD_EMERGENCY_ABORTED"] = "hlsFragLoadEmergencyAborted";
      Events2["FRAG_LOADED"] = "hlsFragLoaded";
      Events2["FRAG_DECRYPTED"] = "hlsFragDecrypted";
      Events2["FRAG_PARSING_INIT_SEGMENT"] = "hlsFragParsingInitSegment";
      Events2["FRAG_PARSING_USERDATA"] = "hlsFragParsingUserdata";
      Events2["FRAG_PARSING_METADATA"] = "hlsFragParsingMetadata";
      Events2["FRAG_PARSED"] = "hlsFragParsed";
      Events2["FRAG_BUFFERED"] = "hlsFragBuffered";
      Events2["FRAG_CHANGED"] = "hlsFragChanged";
      Events2["FPS_DROP"] = "hlsFpsDrop";
      Events2["FPS_DROP_LEVEL_CAPPING"] = "hlsFpsDropLevelCapping";
      Events2["MAX_AUTO_LEVEL_UPDATED"] = "hlsMaxAutoLevelUpdated";
      Events2["ERROR"] = "hlsError";
      Events2["DESTROYING"] = "hlsDestroying";
      Events2["KEY_LOADING"] = "hlsKeyLoading";
      Events2["KEY_LOADED"] = "hlsKeyLoaded";
      Events2["LIVE_BACK_BUFFER_REACHED"] = "hlsLiveBackBufferReached";
      Events2["BACK_BUFFER_REACHED"] = "hlsBackBufferReached";
      Events2["STEERING_MANIFEST_LOADED"] = "hlsSteeringManifestLoaded";
      return Events2;
    }({});
    var ErrorTypes = /* @__PURE__ */ function(ErrorTypes2) {
      ErrorTypes2["NETWORK_ERROR"] = "networkError";
      ErrorTypes2["MEDIA_ERROR"] = "mediaError";
      ErrorTypes2["KEY_SYSTEM_ERROR"] = "keySystemError";
      ErrorTypes2["MUX_ERROR"] = "muxError";
      ErrorTypes2["OTHER_ERROR"] = "otherError";
      return ErrorTypes2;
    }({});
    var ErrorDetails = /* @__PURE__ */ function(ErrorDetails2) {
      ErrorDetails2["KEY_SYSTEM_NO_KEYS"] = "keySystemNoKeys";
      ErrorDetails2["KEY_SYSTEM_NO_ACCESS"] = "keySystemNoAccess";
      ErrorDetails2["KEY_SYSTEM_NO_SESSION"] = "keySystemNoSession";
      ErrorDetails2["KEY_SYSTEM_NO_CONFIGURED_LICENSE"] = "keySystemNoConfiguredLicense";
      ErrorDetails2["KEY_SYSTEM_LICENSE_REQUEST_FAILED"] = "keySystemLicenseRequestFailed";
      ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED"] = "keySystemServerCertificateRequestFailed";
      ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED"] = "keySystemServerCertificateUpdateFailed";
      ErrorDetails2["KEY_SYSTEM_SESSION_UPDATE_FAILED"] = "keySystemSessionUpdateFailed";
      ErrorDetails2["KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED"] = "keySystemStatusOutputRestricted";
      ErrorDetails2["KEY_SYSTEM_STATUS_INTERNAL_ERROR"] = "keySystemStatusInternalError";
      ErrorDetails2["MANIFEST_LOAD_ERROR"] = "manifestLoadError";
      ErrorDetails2["MANIFEST_LOAD_TIMEOUT"] = "manifestLoadTimeOut";
      ErrorDetails2["MANIFEST_PARSING_ERROR"] = "manifestParsingError";
      ErrorDetails2["MANIFEST_INCOMPATIBLE_CODECS_ERROR"] = "manifestIncompatibleCodecsError";
      ErrorDetails2["LEVEL_EMPTY_ERROR"] = "levelEmptyError";
      ErrorDetails2["LEVEL_LOAD_ERROR"] = "levelLoadError";
      ErrorDetails2["LEVEL_LOAD_TIMEOUT"] = "levelLoadTimeOut";
      ErrorDetails2["LEVEL_PARSING_ERROR"] = "levelParsingError";
      ErrorDetails2["LEVEL_SWITCH_ERROR"] = "levelSwitchError";
      ErrorDetails2["AUDIO_TRACK_LOAD_ERROR"] = "audioTrackLoadError";
      ErrorDetails2["AUDIO_TRACK_LOAD_TIMEOUT"] = "audioTrackLoadTimeOut";
      ErrorDetails2["SUBTITLE_LOAD_ERROR"] = "subtitleTrackLoadError";
      ErrorDetails2["SUBTITLE_TRACK_LOAD_TIMEOUT"] = "subtitleTrackLoadTimeOut";
      ErrorDetails2["FRAG_LOAD_ERROR"] = "fragLoadError";
      ErrorDetails2["FRAG_LOAD_TIMEOUT"] = "fragLoadTimeOut";
      ErrorDetails2["FRAG_DECRYPT_ERROR"] = "fragDecryptError";
      ErrorDetails2["FRAG_PARSING_ERROR"] = "fragParsingError";
      ErrorDetails2["FRAG_GAP"] = "fragGap";
      ErrorDetails2["REMUX_ALLOC_ERROR"] = "remuxAllocError";
      ErrorDetails2["KEY_LOAD_ERROR"] = "keyLoadError";
      ErrorDetails2["KEY_LOAD_TIMEOUT"] = "keyLoadTimeOut";
      ErrorDetails2["BUFFER_ADD_CODEC_ERROR"] = "bufferAddCodecError";
      ErrorDetails2["BUFFER_INCOMPATIBLE_CODECS_ERROR"] = "bufferIncompatibleCodecsError";
      ErrorDetails2["BUFFER_APPEND_ERROR"] = "bufferAppendError";
      ErrorDetails2["BUFFER_APPENDING_ERROR"] = "bufferAppendingError";
      ErrorDetails2["BUFFER_STALLED_ERROR"] = "bufferStalledError";
      ErrorDetails2["BUFFER_FULL_ERROR"] = "bufferFullError";
      ErrorDetails2["BUFFER_SEEK_OVER_HOLE"] = "bufferSeekOverHole";
      ErrorDetails2["BUFFER_NUDGE_ON_STALL"] = "bufferNudgeOnStall";
      ErrorDetails2["INTERNAL_EXCEPTION"] = "internalException";
      ErrorDetails2["INTERNAL_ABORTED"] = "aborted";
      ErrorDetails2["UNKNOWN"] = "unknown";
      return ErrorDetails2;
    }({});
    var noop = function noop2() {
    };
    var fakeLogger = {
      trace: noop,
      debug: noop,
      log: noop,
      warn: noop,
      info: noop,
      error: noop
    };
    var exportedLogger = fakeLogger;
    function consolePrintFn(type) {
      var func = self.console[type];
      if (func) {
        return func.bind(self.console, "[" + type + "] >");
      }
      return noop;
    }
    function exportLoggerFunctions(debugConfig) {
      for (var _len = arguments.length, functions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        functions[_key - 1] = arguments[_key];
      }
      functions.forEach(function(type) {
        exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
      });
    }
    function enableLogs(debugConfig, id) {
      if (typeof console === "object" && debugConfig === true || typeof debugConfig === "object") {
        exportLoggerFunctions(
          debugConfig,
          // Remove out from list here to hard-disable a log-level
          // 'trace',
          "debug",
          "log",
          "info",
          "warn",
          "error"
        );
        try {
          exportedLogger.log('Debug logs enabled for "' + id + '" in hls.js version 1.5.1');
        } catch (e) {
          exportedLogger = fakeLogger;
        }
      } else {
        exportedLogger = fakeLogger;
      }
    }
    var logger = exportedLogger;
    var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
    var ATTR_LIST_REGEX = /(.+?)=(".*?"|.*?)(?:,|$)/g;
    var AttrList = /* @__PURE__ */ function() {
      function AttrList2(attrs) {
        if (typeof attrs === "string") {
          attrs = AttrList2.parseAttrList(attrs);
        }
        _extends(this, attrs);
      }
      var _proto = AttrList2.prototype;
      _proto.decimalInteger = function decimalInteger(attrName) {
        var intValue = parseInt(this[attrName], 10);
        if (intValue > Number.MAX_SAFE_INTEGER) {
          return Infinity;
        }
        return intValue;
      };
      _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {
        if (this[attrName]) {
          var stringValue = (this[attrName] || "0x").slice(2);
          stringValue = (stringValue.length & 1 ? "0" : "") + stringValue;
          var value = new Uint8Array(stringValue.length / 2);
          for (var i = 0; i < stringValue.length / 2; i++) {
            value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
          }
          return value;
        } else {
          return null;
        }
      };
      _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {
        var intValue = parseInt(this[attrName], 16);
        if (intValue > Number.MAX_SAFE_INTEGER) {
          return Infinity;
        }
        return intValue;
      };
      _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {
        return parseFloat(this[attrName]);
      };
      _proto.optionalFloat = function optionalFloat(attrName, defaultValue) {
        var value = this[attrName];
        return value ? parseFloat(value) : defaultValue;
      };
      _proto.enumeratedString = function enumeratedString(attrName) {
        return this[attrName];
      };
      _proto.bool = function bool(attrName) {
        return this[attrName] === "YES";
      };
      _proto.decimalResolution = function decimalResolution(attrName) {
        var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
        if (res === null) {
          return void 0;
        }
        return {
          width: parseInt(res[1], 10),
          height: parseInt(res[2], 10)
        };
      };
      AttrList2.parseAttrList = function parseAttrList(input) {
        var match;
        var attrs = {};
        var quote = '"';
        ATTR_LIST_REGEX.lastIndex = 0;
        while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
          var value = match[2];
          if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
            value = value.slice(1, -1);
          }
          var name = match[1].trim();
          attrs[name] = value;
        }
        return attrs;
      };
      _createClass(AttrList2, [{
        key: "clientAttrs",
        get: function get() {
          return Object.keys(this).filter(function(attr) {
            return attr.substring(0, 2) === "X-";
          });
        }
      }]);
      return AttrList2;
    }();
    function isDateRangeCueAttribute(attrName) {
      return attrName !== "ID" && attrName !== "CLASS" && attrName !== "START-DATE" && attrName !== "DURATION" && attrName !== "END-DATE" && attrName !== "END-ON-NEXT";
    }
    function isSCTE35Attribute(attrName) {
      return attrName === "SCTE35-OUT" || attrName === "SCTE35-IN";
    }
    var DateRange = /* @__PURE__ */ function() {
      function DateRange2(dateRangeAttr, dateRangeWithSameId) {
        this.attr = void 0;
        this._startDate = void 0;
        this._endDate = void 0;
        this._badValueForSameId = void 0;
        if (dateRangeWithSameId) {
          var previousAttr = dateRangeWithSameId.attr;
          for (var key in previousAttr) {
            if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {
              logger.warn('DATERANGE tag attribute: "' + key + '" does not match for tags with ID: "' + dateRangeAttr.ID + '"');
              this._badValueForSameId = key;
              break;
            }
          }
          dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);
        }
        this.attr = dateRangeAttr;
        this._startDate = new Date(dateRangeAttr["START-DATE"]);
        if ("END-DATE" in this.attr) {
          var endDate = new Date(this.attr["END-DATE"]);
          if (isFiniteNumber(endDate.getTime())) {
            this._endDate = endDate;
          }
        }
      }
      _createClass(DateRange2, [{
        key: "id",
        get: function get() {
          return this.attr.ID;
        }
      }, {
        key: "class",
        get: function get() {
          return this.attr.CLASS;
        }
      }, {
        key: "startDate",
        get: function get() {
          return this._startDate;
        }
      }, {
        key: "endDate",
        get: function get() {
          if (this._endDate) {
            return this._endDate;
          }
          var duration = this.duration;
          if (duration !== null) {
            return new Date(this._startDate.getTime() + duration * 1e3);
          }
          return null;
        }
      }, {
        key: "duration",
        get: function get() {
          if ("DURATION" in this.attr) {
            var duration = this.attr.decimalFloatingPoint("DURATION");
            if (isFiniteNumber(duration)) {
              return duration;
            }
          } else if (this._endDate) {
            return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
          }
          return null;
        }
      }, {
        key: "plannedDuration",
        get: function get() {
          if ("PLANNED-DURATION" in this.attr) {
            return this.attr.decimalFloatingPoint("PLANNED-DURATION");
          }
          return null;
        }
      }, {
        key: "endOnNext",
        get: function get() {
          return this.attr.bool("END-ON-NEXT");
        }
      }, {
        key: "isValid",
        get: function get() {
          return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);
        }
      }]);
      return DateRange2;
    }();
    var LoadStats = function LoadStats2() {
      this.aborted = false;
      this.loaded = 0;
      this.retry = 0;
      this.total = 0;
      this.chunkCount = 0;
      this.bwEstimate = 0;
      this.loading = {
        start: 0,
        first: 0,
        end: 0
      };
      this.parsing = {
        start: 0,
        end: 0
      };
      this.buffering = {
        start: 0,
        first: 0,
        end: 0
      };
    };
    var ElementaryStreamTypes = {
      AUDIO: "audio",
      VIDEO: "video",
      AUDIOVIDEO: "audiovideo"
    };
    var BaseSegment = /* @__PURE__ */ function() {
      function BaseSegment2(baseurl) {
        var _this$elementaryStrea;
        this._byteRange = null;
        this._url = null;
        this.baseurl = void 0;
        this.relurl = void 0;
        this.elementaryStreams = (_this$elementaryStrea = {}, _this$elementaryStrea[ElementaryStreamTypes.AUDIO] = null, _this$elementaryStrea[ElementaryStreamTypes.VIDEO] = null, _this$elementaryStrea[ElementaryStreamTypes.AUDIOVIDEO] = null, _this$elementaryStrea);
        this.baseurl = baseurl;
      }
      var _proto = BaseSegment2.prototype;
      _proto.setByteRange = function setByteRange(value, previous) {
        var params = value.split("@", 2);
        var start;
        if (params.length === 1) {
          start = (previous == null ? void 0 : previous.byteRangeEndOffset) || 0;
        } else {
          start = parseInt(params[1]);
        }
        this._byteRange = [start, parseInt(params[0]) + start];
      };
      _createClass(BaseSegment2, [{
        key: "byteRange",
        get: function get() {
          if (!this._byteRange) {
            return [];
          }
          return this._byteRange;
        }
      }, {
        key: "byteRangeStartOffset",
        get: function get() {
          return this.byteRange[0];
        }
      }, {
        key: "byteRangeEndOffset",
        get: function get() {
          return this.byteRange[1];
        }
      }, {
        key: "url",
        get: function get() {
          if (!this._url && this.baseurl && this.relurl) {
            this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {
              alwaysNormalize: true
            });
          }
          return this._url || "";
        },
        set: function set(value) {
          this._url = value;
        }
      }]);
      return BaseSegment2;
    }();
    var Fragment = /* @__PURE__ */ function(_BaseSegment) {
      _inheritsLoose(Fragment2, _BaseSegment);
      function Fragment2(type, baseurl) {
        var _this;
        _this = _BaseSegment.call(this, baseurl) || this;
        _this._decryptdata = null;
        _this.rawProgramDateTime = null;
        _this.programDateTime = null;
        _this.tagList = [];
        _this.duration = 0;
        _this.sn = 0;
        _this.levelkeys = void 0;
        _this.type = void 0;
        _this.loader = null;
        _this.keyLoader = null;
        _this.level = -1;
        _this.cc = 0;
        _this.startPTS = void 0;
        _this.endPTS = void 0;
        _this.startDTS = void 0;
        _this.endDTS = void 0;
        _this.start = 0;
        _this.deltaPTS = void 0;
        _this.maxStartPTS = void 0;
        _this.minEndPTS = void 0;
        _this.stats = new LoadStats();
        _this.data = void 0;
        _this.bitrateTest = false;
        _this.title = null;
        _this.initSegment = null;
        _this.endList = void 0;
        _this.gap = void 0;
        _this.urlId = 0;
        _this.type = type;
        return _this;
      }
      var _proto2 = Fragment2.prototype;
      _proto2.setKeyFormat = function setKeyFormat(keyFormat) {
        if (this.levelkeys) {
          var _key = this.levelkeys[keyFormat];
          if (_key && !this._decryptdata) {
            this._decryptdata = _key.getDecryptData(this.sn);
          }
        }
      };
      _proto2.abortRequests = function abortRequests() {
        var _this$loader, _this$keyLoader;
        (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();
        (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();
      };
      _proto2.setElementaryStreamInfo = function setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial) {
        if (partial === void 0) {
          partial = false;
        }
        var elementaryStreams = this.elementaryStreams;
        var info = elementaryStreams[type];
        if (!info) {
          elementaryStreams[type] = {
            startPTS,
            endPTS,
            startDTS,
            endDTS,
            partial
          };
          return;
        }
        info.startPTS = Math.min(info.startPTS, startPTS);
        info.endPTS = Math.max(info.endPTS, endPTS);
        info.startDTS = Math.min(info.startDTS, startDTS);
        info.endDTS = Math.max(info.endDTS, endDTS);
      };
      _proto2.clearElementaryStreamInfo = function clearElementaryStreamInfo() {
        var elementaryStreams = this.elementaryStreams;
        elementaryStreams[ElementaryStreamTypes.AUDIO] = null;
        elementaryStreams[ElementaryStreamTypes.VIDEO] = null;
        elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;
      };
      _createClass(Fragment2, [{
        key: "decryptdata",
        get: function get() {
          var levelkeys = this.levelkeys;
          if (!levelkeys && !this._decryptdata) {
            return null;
          }
          if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
            var _key2 = this.levelkeys.identity;
            if (_key2) {
              this._decryptdata = _key2.getDecryptData(this.sn);
            } else {
              var keyFormats = Object.keys(this.levelkeys);
              if (keyFormats.length === 1) {
                return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);
              }
            }
          }
          return this._decryptdata;
        }
      }, {
        key: "end",
        get: function get() {
          return this.start + this.duration;
        }
      }, {
        key: "endProgramDateTime",
        get: function get() {
          if (this.programDateTime === null) {
            return null;
          }
          if (!isFiniteNumber(this.programDateTime)) {
            return null;
          }
          var duration = !isFiniteNumber(this.duration) ? 0 : this.duration;
          return this.programDateTime + duration * 1e3;
        }
      }, {
        key: "encrypted",
        get: function get() {
          var _this$_decryptdata;
          if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {
            return true;
          } else if (this.levelkeys) {
            var keyFormats = Object.keys(this.levelkeys);
            var len = keyFormats.length;
            if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {
              return true;
            }
          }
          return false;
        }
      }]);
      return Fragment2;
    }(BaseSegment);
    var Part = /* @__PURE__ */ function(_BaseSegment2) {
      _inheritsLoose(Part2, _BaseSegment2);
      function Part2(partAttrs, frag, baseurl, index, previous) {
        var _this2;
        _this2 = _BaseSegment2.call(this, baseurl) || this;
        _this2.fragOffset = 0;
        _this2.duration = 0;
        _this2.gap = false;
        _this2.independent = false;
        _this2.relurl = void 0;
        _this2.fragment = void 0;
        _this2.index = void 0;
        _this2.stats = new LoadStats();
        _this2.duration = partAttrs.decimalFloatingPoint("DURATION");
        _this2.gap = partAttrs.bool("GAP");
        _this2.independent = partAttrs.bool("INDEPENDENT");
        _this2.relurl = partAttrs.enumeratedString("URI");
        _this2.fragment = frag;
        _this2.index = index;
        var byteRange = partAttrs.enumeratedString("BYTERANGE");
        if (byteRange) {
          _this2.setByteRange(byteRange, previous);
        }
        if (previous) {
          _this2.fragOffset = previous.fragOffset + previous.duration;
        }
        return _this2;
      }
      _createClass(Part2, [{
        key: "start",
        get: function get() {
          return this.fragment.start + this.fragOffset;
        }
      }, {
        key: "end",
        get: function get() {
          return this.start + this.duration;
        }
      }, {
        key: "loaded",
        get: function get() {
          var elementaryStreams = this.elementaryStreams;
          return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);
        }
      }]);
      return Part2;
    }(BaseSegment);
    var DEFAULT_TARGET_DURATION = 10;
    var LevelDetails = /* @__PURE__ */ function() {
      function LevelDetails2(baseUrl) {
        this.PTSKnown = false;
        this.alignedSliding = false;
        this.averagetargetduration = void 0;
        this.endCC = 0;
        this.endSN = 0;
        this.fragments = void 0;
        this.fragmentHint = void 0;
        this.partList = null;
        this.dateRanges = void 0;
        this.live = true;
        this.ageHeader = 0;
        this.advancedDateTime = void 0;
        this.updated = true;
        this.advanced = true;
        this.availabilityDelay = void 0;
        this.misses = 0;
        this.startCC = 0;
        this.startSN = 0;
        this.startTimeOffset = null;
        this.targetduration = 0;
        this.totalduration = 0;
        this.type = null;
        this.url = void 0;
        this.m3u8 = "";
        this.version = null;
        this.canBlockReload = false;
        this.canSkipUntil = 0;
        this.canSkipDateRanges = false;
        this.skippedSegments = 0;
        this.recentlyRemovedDateranges = void 0;
        this.partHoldBack = 0;
        this.holdBack = 0;
        this.partTarget = 0;
        this.preloadHint = void 0;
        this.renditionReports = void 0;
        this.tuneInGoal = 0;
        this.deltaUpdateFailed = void 0;
        this.driftStartTime = 0;
        this.driftEndTime = 0;
        this.driftStart = 0;
        this.driftEnd = 0;
        this.encryptedFragments = void 0;
        this.playlistParsingError = null;
        this.variableList = null;
        this.hasVariableRefs = false;
        this.fragments = [];
        this.encryptedFragments = [];
        this.dateRanges = {};
        this.url = baseUrl;
      }
      var _proto = LevelDetails2.prototype;
      _proto.reloaded = function reloaded(previous) {
        if (!previous) {
          this.advanced = true;
          this.updated = true;
          return;
        }
        var partSnDiff = this.lastPartSn - previous.lastPartSn;
        var partIndexDiff = this.lastPartIndex - previous.lastPartIndex;
        this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;
        this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;
        if (this.updated || this.advanced) {
          this.misses = Math.floor(previous.misses * 0.6);
        } else {
          this.misses = previous.misses + 1;
        }
        this.availabilityDelay = previous.availabilityDelay;
      };
      _createClass(LevelDetails2, [{
        key: "hasProgramDateTime",
        get: function get() {
          if (this.fragments.length) {
            return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);
          }
          return false;
        }
      }, {
        key: "levelTargetDuration",
        get: function get() {
          return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;
        }
      }, {
        key: "drift",
        get: function get() {
          var runTime = this.driftEndTime - this.driftStartTime;
          if (runTime > 0) {
            var runDuration = this.driftEnd - this.driftStart;
            return runDuration * 1e3 / runTime;
          }
          return 1;
        }
      }, {
        key: "edge",
        get: function get() {
          return this.partEnd || this.fragmentEnd;
        }
      }, {
        key: "partEnd",
        get: function get() {
          var _this$partList;
          if ((_this$partList = this.partList) != null && _this$partList.length) {
            return this.partList[this.partList.length - 1].end;
          }
          return this.fragmentEnd;
        }
      }, {
        key: "fragmentEnd",
        get: function get() {
          var _this$fragments;
          if ((_this$fragments = this.fragments) != null && _this$fragments.length) {
            return this.fragments[this.fragments.length - 1].end;
          }
          return 0;
        }
      }, {
        key: "age",
        get: function get() {
          if (this.advancedDateTime) {
            return Math.max(Date.now() - this.advancedDateTime, 0) / 1e3;
          }
          return 0;
        }
      }, {
        key: "lastPartIndex",
        get: function get() {
          var _this$partList2;
          if ((_this$partList2 = this.partList) != null && _this$partList2.length) {
            return this.partList[this.partList.length - 1].index;
          }
          return -1;
        }
      }, {
        key: "lastPartSn",
        get: function get() {
          var _this$partList3;
          if ((_this$partList3 = this.partList) != null && _this$partList3.length) {
            return this.partList[this.partList.length - 1].fragment.sn;
          }
          return this.endSN;
        }
      }]);
      return LevelDetails2;
    }();
    function base64Decode(base64encodedStr) {
      return Uint8Array.from(atob(base64encodedStr), function(c) {
        return c.charCodeAt(0);
      });
    }
    function getKeyIdBytes(str) {
      var keyIdbytes = strToUtf8array(str).subarray(0, 16);
      var paddedkeyIdbytes = new Uint8Array(16);
      paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);
      return paddedkeyIdbytes;
    }
    function changeEndianness(keyId) {
      var swap = function swap2(array, from, to) {
        var cur = array[from];
        array[from] = array[to];
        array[to] = cur;
      };
      swap(keyId, 0, 3);
      swap(keyId, 1, 2);
      swap(keyId, 4, 5);
      swap(keyId, 6, 7);
    }
    function convertDataUriToArrayBytes(uri) {
      var colonsplit = uri.split(":");
      var keydata = null;
      if (colonsplit[0] === "data" && colonsplit.length === 2) {
        var semicolonsplit = colonsplit[1].split(";");
        var commasplit = semicolonsplit[semicolonsplit.length - 1].split(",");
        if (commasplit.length === 2) {
          var isbase64 = commasplit[0] === "base64";
          var data = commasplit[1];
          if (isbase64) {
            semicolonsplit.splice(-1, 1);
            keydata = base64Decode(data);
          } else {
            keydata = getKeyIdBytes(data);
          }
        }
      }
      return keydata;
    }
    function strToUtf8array(str) {
      return Uint8Array.from(unescape(encodeURIComponent(str)), function(c) {
        return c.charCodeAt(0);
      });
    }
    var optionalSelf = typeof self !== "undefined" ? self : void 0;
    var KeySystems = {
      CLEARKEY: "org.w3.clearkey",
      FAIRPLAY: "com.apple.fps",
      PLAYREADY: "com.microsoft.playready",
      WIDEVINE: "com.widevine.alpha"
    };
    var KeySystemFormats = {
      CLEARKEY: "org.w3.clearkey",
      FAIRPLAY: "com.apple.streamingkeydelivery",
      PLAYREADY: "com.microsoft.playready",
      WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
    };
    function keySystemFormatToKeySystemDomain(format2) {
      switch (format2) {
        case KeySystemFormats.FAIRPLAY:
          return KeySystems.FAIRPLAY;
        case KeySystemFormats.PLAYREADY:
          return KeySystems.PLAYREADY;
        case KeySystemFormats.WIDEVINE:
          return KeySystems.WIDEVINE;
        case KeySystemFormats.CLEARKEY:
          return KeySystems.CLEARKEY;
      }
    }
    var KeySystemIds = {
      WIDEVINE: "edef8ba979d64acea3c827dcd51d21ed"
    };
    function keySystemIdToKeySystemDomain(systemId) {
      if (systemId === KeySystemIds.WIDEVINE) {
        return KeySystems.WIDEVINE;
      }
    }
    function keySystemDomainToKeySystemFormat(keySystem) {
      switch (keySystem) {
        case KeySystems.FAIRPLAY:
          return KeySystemFormats.FAIRPLAY;
        case KeySystems.PLAYREADY:
          return KeySystemFormats.PLAYREADY;
        case KeySystems.WIDEVINE:
          return KeySystemFormats.WIDEVINE;
        case KeySystems.CLEARKEY:
          return KeySystemFormats.CLEARKEY;
      }
    }
    function getKeySystemsForConfig(config) {
      var drmSystems = config.drmSystems, widevineLicenseUrl = config.widevineLicenseUrl;
      var keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter(function(keySystem) {
        return !!drmSystems[keySystem];
      }) : [];
      if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {
        keySystemsToAttempt.push(KeySystems.WIDEVINE);
      }
      return keySystemsToAttempt;
    }
    var requestMediaKeySystemAccess = function(_optionalSelf$navigat) {
      if (optionalSelf != null && (_optionalSelf$navigat = optionalSelf.navigator) != null && _optionalSelf$navigat.requestMediaKeySystemAccess) {
        return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);
      } else {
        return null;
      }
    }();
    function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {
      var initDataTypes;
      switch (keySystem) {
        case KeySystems.FAIRPLAY:
          initDataTypes = ["cenc", "sinf"];
          break;
        case KeySystems.WIDEVINE:
        case KeySystems.PLAYREADY:
          initDataTypes = ["cenc"];
          break;
        case KeySystems.CLEARKEY:
          initDataTypes = ["cenc", "keyids"];
          break;
        default:
          throw new Error("Unknown key-system: " + keySystem);
      }
      return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);
    }
    function createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {
      var baseConfig = {
        initDataTypes,
        persistentState: drmSystemOptions.persistentState || "optional",
        distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || "optional",
        sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || "temporary"],
        audioCapabilities: audioCodecs.map(function(codec) {
          return {
            contentType: 'audio/mp4; codecs="' + codec + '"',
            robustness: drmSystemOptions.audioRobustness || "",
            encryptionScheme: drmSystemOptions.audioEncryptionScheme || null
          };
        }),
        videoCapabilities: videoCodecs.map(function(codec) {
          return {
            contentType: 'video/mp4; codecs="' + codec + '"',
            robustness: drmSystemOptions.videoRobustness || "",
            encryptionScheme: drmSystemOptions.videoEncryptionScheme || null
          };
        })
      };
      return [baseConfig];
    }
    function sliceUint8(array, start, end) {
      return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));
    }
    var isHeader$2 = function isHeader2(data, offset) {
      if (offset + 10 <= data.length) {
        if (data[offset] === 73 && data[offset + 1] === 68 && data[offset + 2] === 51) {
          if (data[offset + 3] < 255 && data[offset + 4] < 255) {
            if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
              return true;
            }
          }
        }
      }
      return false;
    };
    var isFooter = function isFooter2(data, offset) {
      if (offset + 10 <= data.length) {
        if (data[offset] === 51 && data[offset + 1] === 68 && data[offset + 2] === 73) {
          if (data[offset + 3] < 255 && data[offset + 4] < 255) {
            if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
              return true;
            }
          }
        }
      }
      return false;
    };
    var getID3Data = function getID3Data2(data, offset) {
      var front = offset;
      var length = 0;
      while (isHeader$2(data, offset)) {
        length += 10;
        var size = readSize(data, offset + 6);
        length += size;
        if (isFooter(data, offset + 10)) {
          length += 10;
        }
        offset += length;
      }
      if (length > 0) {
        return data.subarray(front, front + length);
      }
      return void 0;
    };
    var readSize = function readSize2(data, offset) {
      var size = 0;
      size = (data[offset] & 127) << 21;
      size |= (data[offset + 1] & 127) << 14;
      size |= (data[offset + 2] & 127) << 7;
      size |= data[offset + 3] & 127;
      return size;
    };
    var canParse$2 = function canParse2(data, offset) {
      return isHeader$2(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;
    };
    var getTimeStamp = function getTimeStamp2(data) {
      var frames = getID3Frames(data);
      for (var i = 0; i < frames.length; i++) {
        var frame = frames[i];
        if (isTimeStampFrame(frame)) {
          return readTimeStamp(frame);
        }
      }
      return void 0;
    };
    var isTimeStampFrame = function isTimeStampFrame2(frame) {
      return frame && frame.key === "PRIV" && frame.info === "com.apple.streaming.transportStreamTimestamp";
    };
    var getFrameData = function getFrameData2(data) {
      var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
      var size = readSize(data, 4);
      var offset = 10;
      return {
        type,
        size,
        data: data.subarray(offset, offset + size)
      };
    };
    var getID3Frames = function getID3Frames2(id3Data) {
      var offset = 0;
      var frames = [];
      while (isHeader$2(id3Data, offset)) {
        var size = readSize(id3Data, offset + 6);
        offset += 10;
        var end = offset + size;
        while (offset + 8 < end) {
          var frameData = getFrameData(id3Data.subarray(offset));
          var frame = decodeFrame(frameData);
          if (frame) {
            frames.push(frame);
          }
          offset += frameData.size + 10;
        }
        if (isFooter(id3Data, offset)) {
          offset += 10;
        }
      }
      return frames;
    };
    var decodeFrame = function decodeFrame2(frame) {
      if (frame.type === "PRIV") {
        return decodePrivFrame(frame);
      } else if (frame.type[0] === "W") {
        return decodeURLFrame(frame);
      }
      return decodeTextFrame(frame);
    };
    var decodePrivFrame = function decodePrivFrame2(frame) {
      if (frame.size < 2) {
        return void 0;
      }
      var owner = utf8ArrayToStr(frame.data, true);
      var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));
      return {
        key: frame.type,
        info: owner,
        data: privateData.buffer
      };
    };
    var decodeTextFrame = function decodeTextFrame2(frame) {
      if (frame.size < 2) {
        return void 0;
      }
      if (frame.type === "TXXX") {
        var index = 1;
        var description = utf8ArrayToStr(frame.data.subarray(index), true);
        index += description.length + 1;
        var value = utf8ArrayToStr(frame.data.subarray(index));
        return {
          key: frame.type,
          info: description,
          data: value
        };
      }
      var text = utf8ArrayToStr(frame.data.subarray(1));
      return {
        key: frame.type,
        data: text
      };
    };
    var decodeURLFrame = function decodeURLFrame2(frame) {
      if (frame.type === "WXXX") {
        if (frame.size < 2) {
          return void 0;
        }
        var index = 1;
        var description = utf8ArrayToStr(frame.data.subarray(index), true);
        index += description.length + 1;
        var value = utf8ArrayToStr(frame.data.subarray(index));
        return {
          key: frame.type,
          info: description,
          data: value
        };
      }
      var url = utf8ArrayToStr(frame.data);
      return {
        key: frame.type,
        data: url
      };
    };
    var readTimeStamp = function readTimeStamp2(timeStampFrame) {
      if (timeStampFrame.data.byteLength === 8) {
        var data = new Uint8Array(timeStampFrame.data);
        var pts33Bit = data[3] & 1;
        var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
        timestamp /= 45;
        if (pts33Bit) {
          timestamp += 4772185884e-2;
        }
        return Math.round(timestamp);
      }
      return void 0;
    };
    var utf8ArrayToStr = function utf8ArrayToStr2(array, exitOnNull) {
      if (exitOnNull === void 0) {
        exitOnNull = false;
      }
      var decoder2 = getTextDecoder();
      if (decoder2) {
        var decoded = decoder2.decode(array);
        if (exitOnNull) {
          var idx = decoded.indexOf("\0");
          return idx !== -1 ? decoded.substring(0, idx) : decoded;
        }
        return decoded.replace(/\0/g, "");
      }
      var len = array.length;
      var c;
      var char2;
      var char3;
      var out = "";
      var i = 0;
      while (i < len) {
        c = array[i++];
        if (c === 0 && exitOnNull) {
          return out;
        } else if (c === 0 || c === 3) {
          continue;
        }
        switch (c >> 4) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            out += String.fromCharCode(c);
            break;
          case 12:
          case 13:
            char2 = array[i++];
            out += String.fromCharCode((c & 31) << 6 | char2 & 63);
            break;
          case 14:
            char2 = array[i++];
            char3 = array[i++];
            out += String.fromCharCode((c & 15) << 12 | (char2 & 63) << 6 | (char3 & 63) << 0);
            break;
        }
      }
      return out;
    };
    var decoder;
    function getTextDecoder() {
      if (navigator.userAgent.includes("PlayStation 4")) {
        return;
      }
      if (!decoder && typeof self.TextDecoder !== "undefined") {
        decoder = new self.TextDecoder("utf-8");
      }
      return decoder;
    }
    var Hex = {
      hexDump: function hexDump(array) {
        var str = "";
        for (var i = 0; i < array.length; i++) {
          var h = array[i].toString(16);
          if (h.length < 2) {
            h = "0" + h;
          }
          str += h;
        }
        return str;
      }
    };
    var UINT32_MAX$1 = Math.pow(2, 32) - 1;
    var push = [].push;
    var RemuxerTrackIdConfig = {
      video: 1,
      audio: 2,
      id3: 3,
      text: 4
    };
    function bin2str(data) {
      return String.fromCharCode.apply(null, data);
    }
    function readUint16(buffer, offset) {
      var val = buffer[offset] << 8 | buffer[offset + 1];
      return val < 0 ? 65536 + val : val;
    }
    function readUint32(buffer, offset) {
      var val = readSint32(buffer, offset);
      return val < 0 ? 4294967296 + val : val;
    }
    function readSint32(buffer, offset) {
      return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
    }
    function writeUint32(buffer, offset, value) {
      buffer[offset] = value >> 24;
      buffer[offset + 1] = value >> 16 & 255;
      buffer[offset + 2] = value >> 8 & 255;
      buffer[offset + 3] = value & 255;
    }
    function hasMoofData(data) {
      var end = data.byteLength;
      for (var i = 0; i < end; ) {
        var size = readUint32(data, i);
        if (size > 8 && data[i + 4] === 109 && data[i + 5] === 111 && data[i + 6] === 111 && data[i + 7] === 102) {
          return true;
        }
        i = size > 1 ? i + size : end;
      }
      return false;
    }
    function findBox(data, path) {
      var results = [];
      if (!path.length) {
        return results;
      }
      var end = data.byteLength;
      for (var i = 0; i < end; ) {
        var size = readUint32(data, i);
        var type = bin2str(data.subarray(i + 4, i + 8));
        var endbox = size > 1 ? i + size : end;
        if (type === path[0]) {
          if (path.length === 1) {
            results.push(data.subarray(i + 8, endbox));
          } else {
            var subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));
            if (subresults.length) {
              push.apply(results, subresults);
            }
          }
        }
        i = endbox;
      }
      return results;
    }
    function parseSegmentIndex(sidx) {
      var references = [];
      var version = sidx[0];
      var index = 8;
      var timescale = readUint32(sidx, index);
      index += 4;
      var earliestPresentationTime = 0;
      var firstOffset = 0;
      if (version === 0) {
        index += 8;
      } else {
        index += 16;
      }
      index += 2;
      var startByte = sidx.length + firstOffset;
      var referencesCount = readUint16(sidx, index);
      index += 2;
      for (var i = 0; i < referencesCount; i++) {
        var referenceIndex = index;
        var referenceInfo = readUint32(sidx, referenceIndex);
        referenceIndex += 4;
        var referenceSize = referenceInfo & 2147483647;
        var referenceType = (referenceInfo & 2147483648) >>> 31;
        if (referenceType === 1) {
          logger.warn("SIDX has hierarchical references (not supported)");
          return null;
        }
        var subsegmentDuration = readUint32(sidx, referenceIndex);
        referenceIndex += 4;
        references.push({
          referenceSize,
          subsegmentDuration,
          // unscaled
          info: {
            duration: subsegmentDuration / timescale,
            start: startByte,
            end: startByte + referenceSize - 1
          }
        });
        startByte += referenceSize;
        referenceIndex += 4;
        index = referenceIndex;
      }
      return {
        earliestPresentationTime,
        timescale,
        version,
        referencesCount,
        references
      };
    }
    function parseInitSegment(initSegment) {
      var result = [];
      var traks = findBox(initSegment, ["moov", "trak"]);
      for (var i = 0; i < traks.length; i++) {
        var trak = traks[i];
        var tkhd = findBox(trak, ["tkhd"])[0];
        if (tkhd) {
          var version = tkhd[0];
          var trackId = readUint32(tkhd, version === 0 ? 12 : 20);
          var mdhd = findBox(trak, ["mdia", "mdhd"])[0];
          if (mdhd) {
            version = mdhd[0];
            var timescale = readUint32(mdhd, version === 0 ? 12 : 20);
            var hdlr = findBox(trak, ["mdia", "hdlr"])[0];
            if (hdlr) {
              var hdlrType = bin2str(hdlr.subarray(8, 12));
              var type = {
                soun: ElementaryStreamTypes.AUDIO,
                vide: ElementaryStreamTypes.VIDEO
              }[hdlrType];
              if (type) {
                var stsd = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
                var stsdData = parseStsd(stsd);
                result[trackId] = {
                  timescale,
                  type
                };
                result[type] = _objectSpread2({
                  timescale,
                  id: trackId
                }, stsdData);
              }
            }
          }
        }
      }
      var trex = findBox(initSegment, ["moov", "mvex", "trex"]);
      trex.forEach(function(trex2) {
        var trackId2 = readUint32(trex2, 4);
        var track = result[trackId2];
        if (track) {
          track.default = {
            duration: readUint32(trex2, 12),
            flags: readUint32(trex2, 20)
          };
        }
      });
      return result;
    }
    function parseStsd(stsd) {
      var sampleEntries = stsd.subarray(8);
      var sampleEntriesEnd = sampleEntries.subarray(8 + 78);
      var fourCC = bin2str(sampleEntries.subarray(4, 8));
      var codec = fourCC;
      var encrypted = fourCC === "enca" || fourCC === "encv";
      if (encrypted) {
        var encBox = findBox(sampleEntries, [fourCC])[0];
        var encBoxChildren = encBox.subarray(fourCC === "enca" ? 28 : 78);
        var sinfs = findBox(encBoxChildren, ["sinf"]);
        sinfs.forEach(function(sinf) {
          var schm = findBox(sinf, ["schm"])[0];
          if (schm) {
            var scheme = bin2str(schm.subarray(4, 8));
            if (scheme === "cbcs" || scheme === "cenc") {
              var frma = findBox(sinf, ["frma"])[0];
              if (frma) {
                codec = bin2str(frma);
              }
            }
          }
        });
      }
      switch (codec) {
        case "avc1":
        case "avc2":
        case "avc3":
        case "avc4": {
          var avcCBox = findBox(sampleEntriesEnd, ["avcC"])[0];
          codec += "." + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);
          break;
        }
        case "mp4a": {
          var codecBox = findBox(sampleEntries, [fourCC])[0];
          var esdsBox = findBox(codecBox.subarray(28), ["esds"])[0];
          if (esdsBox && esdsBox.length > 12) {
            var i = 4;
            if (esdsBox[i++] !== 3) {
              break;
            }
            i = skipBERInteger(esdsBox, i);
            i += 2;
            var flags = esdsBox[i++];
            if (flags & 128) {
              i += 2;
            }
            if (flags & 64) {
              i += esdsBox[i++];
            }
            if (esdsBox[i++] !== 4) {
              break;
            }
            i = skipBERInteger(esdsBox, i);
            var objectType = esdsBox[i++];
            if (objectType === 64) {
              codec += "." + toHex(objectType);
            } else {
              break;
            }
            i += 12;
            if (esdsBox[i++] !== 5) {
              break;
            }
            i = skipBERInteger(esdsBox, i);
            var firstByte = esdsBox[i++];
            var audioObjectType = (firstByte & 248) >> 3;
            if (audioObjectType === 31) {
              audioObjectType += 1 + ((firstByte & 7) << 3) + ((esdsBox[i] & 224) >> 5);
            }
            codec += "." + audioObjectType;
          }
          break;
        }
        case "hvc1":
        case "hev1": {
          var hvcCBox = findBox(sampleEntriesEnd, ["hvcC"])[0];
          var profileByte = hvcCBox[1];
          var profileSpace = ["", "A", "B", "C"][profileByte >> 6];
          var generalProfileIdc = profileByte & 31;
          var profileCompat = readUint32(hvcCBox, 2);
          var tierFlag = (profileByte & 32) >> 5 ? "H" : "L";
          var levelIDC = hvcCBox[12];
          var constraintIndicator = hvcCBox.subarray(6, 12);
          codec += "." + profileSpace + generalProfileIdc;
          codec += "." + profileCompat.toString(16).toUpperCase();
          codec += "." + tierFlag + levelIDC;
          var constraintString = "";
          for (var _i = constraintIndicator.length; _i--; ) {
            var _byte = constraintIndicator[_i];
            if (_byte || constraintString) {
              var encodedByte = _byte.toString(16).toUpperCase();
              constraintString = "." + encodedByte + constraintString;
            }
          }
          codec += constraintString;
          break;
        }
        case "dvh1":
        case "dvhe": {
          var dvcCBox = findBox(sampleEntriesEnd, ["dvcC"])[0];
          var profile = dvcCBox[2] >> 1 & 127;
          var level = dvcCBox[2] << 5 & 32 | dvcCBox[3] >> 3 & 31;
          codec += "." + addLeadingZero(profile) + "." + addLeadingZero(level);
          break;
        }
        case "vp09": {
          var vpcCBox = findBox(sampleEntriesEnd, ["vpcC"])[0];
          var _profile = vpcCBox[4];
          var _level = vpcCBox[5];
          var bitDepth = vpcCBox[6] >> 4 & 15;
          codec += "." + addLeadingZero(_profile) + "." + addLeadingZero(_level) + "." + addLeadingZero(bitDepth);
          break;
        }
        case "av01": {
          var av1CBox = findBox(sampleEntriesEnd, ["av1C"])[0];
          var _profile2 = av1CBox[1] >>> 5;
          var _level2 = av1CBox[1] & 31;
          var _tierFlag = av1CBox[2] >>> 7 ? "H" : "M";
          var highBitDepth = (av1CBox[2] & 64) >> 6;
          var twelveBit = (av1CBox[2] & 32) >> 5;
          var _bitDepth = _profile2 === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;
          var monochrome = (av1CBox[2] & 16) >> 4;
          var chromaSubsamplingX = (av1CBox[2] & 8) >> 3;
          var chromaSubsamplingY = (av1CBox[2] & 4) >> 2;
          var chromaSamplePosition = av1CBox[2] & 3;
          var colorPrimaries = 1;
          var transferCharacteristics = 1;
          var matrixCoefficients = 1;
          var videoFullRangeFlag = 0;
          codec += "." + _profile2 + "." + addLeadingZero(_level2) + _tierFlag + "." + addLeadingZero(_bitDepth) + "." + monochrome + "." + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + "." + addLeadingZero(colorPrimaries) + "." + addLeadingZero(transferCharacteristics) + "." + addLeadingZero(matrixCoefficients) + "." + videoFullRangeFlag;
          break;
        }
      }
      return {
        codec,
        encrypted
      };
    }
    function skipBERInteger(bytes, i) {
      var limit = i + 5;
      while (bytes[i++] & 128 && i < limit) {
      }
      return i;
    }
    function toHex(x) {
      return ("0" + x.toString(16).toUpperCase()).slice(-2);
    }
    function addLeadingZero(num) {
      return (num < 10 ? "0" : "") + num;
    }
    function patchEncyptionData(initSegment, decryptdata) {
      if (!initSegment || !decryptdata) {
        return initSegment;
      }
      var keyId = decryptdata.keyId;
      if (keyId && decryptdata.isCommonEncryption) {
        var traks = findBox(initSegment, ["moov", "trak"]);
        traks.forEach(function(trak) {
          var stsd = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
          var sampleEntries = stsd.subarray(8);
          var encBoxes = findBox(sampleEntries, ["enca"]);
          var isAudio = encBoxes.length > 0;
          if (!isAudio) {
            encBoxes = findBox(sampleEntries, ["encv"]);
          }
          encBoxes.forEach(function(enc) {
            var encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);
            var sinfBoxes = findBox(encBoxChildren, ["sinf"]);
            sinfBoxes.forEach(function(sinf) {
              var tenc = parseSinf(sinf);
              if (tenc) {
                var tencKeyId = tenc.subarray(8, 24);
                if (!tencKeyId.some(function(b) {
                  return b !== 0;
                })) {
                  logger.log("[eme] Patching keyId in 'enc" + (isAudio ? "a" : "v") + ">sinf>>tenc' box: " + Hex.hexDump(tencKeyId) + " -> " + Hex.hexDump(keyId));
                  tenc.set(keyId, 8);
                }
              }
            });
          });
        });
      }
      return initSegment;
    }
    function parseSinf(sinf) {
      var schm = findBox(sinf, ["schm"])[0];
      if (schm) {
        var scheme = bin2str(schm.subarray(4, 8));
        if (scheme === "cbcs" || scheme === "cenc") {
          return findBox(sinf, ["schi", "tenc"])[0];
        }
      }
      logger.error("[eme] missing 'schm' box");
      return null;
    }
    function getStartDTS(initData, fmp4) {
      return findBox(fmp4, ["moof", "traf"]).reduce(function(result, traf) {
        var tfdt = findBox(traf, ["tfdt"])[0];
        var version = tfdt[0];
        var start = findBox(traf, ["tfhd"]).reduce(function(result2, tfhd) {
          var id = readUint32(tfhd, 4);
          var track = initData[id];
          if (track) {
            var baseTime = readUint32(tfdt, 4);
            if (version === 1) {
              if (baseTime === UINT32_MAX$1) {
                logger.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time");
                return result2;
              }
              baseTime *= UINT32_MAX$1 + 1;
              baseTime += readUint32(tfdt, 8);
            }
            var scale = track.timescale || 9e4;
            var startTime = baseTime / scale;
            if (isFiniteNumber(startTime) && (result2 === null || startTime < result2)) {
              return startTime;
            }
          }
          return result2;
        }, null);
        if (start !== null && isFiniteNumber(start) && (result === null || start < result)) {
          return start;
        }
        return result;
      }, null);
    }
    function getDuration(data, initData) {
      var rawDuration = 0;
      var videoDuration = 0;
      var audioDuration = 0;
      var trafs = findBox(data, ["moof", "traf"]);
      for (var i = 0; i < trafs.length; i++) {
        var traf = trafs[i];
        var tfhd = findBox(traf, ["tfhd"])[0];
        var id = readUint32(tfhd, 4);
        var track = initData[id];
        if (!track) {
          continue;
        }
        var trackDefault = track.default;
        var tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);
        var sampleDuration = trackDefault == null ? void 0 : trackDefault.duration;
        if (tfhdFlags & 8) {
          if (tfhdFlags & 2) {
            sampleDuration = readUint32(tfhd, 12);
          } else {
            sampleDuration = readUint32(tfhd, 8);
          }
        }
        var timescale = track.timescale || 9e4;
        var truns = findBox(traf, ["trun"]);
        for (var j = 0; j < truns.length; j++) {
          rawDuration = computeRawDurationFromSamples(truns[j]);
          if (!rawDuration && sampleDuration) {
            var sampleCount = readUint32(truns[j], 4);
            rawDuration = sampleDuration * sampleCount;
          }
          if (track.type === ElementaryStreamTypes.VIDEO) {
            videoDuration += rawDuration / timescale;
          } else if (track.type === ElementaryStreamTypes.AUDIO) {
            audioDuration += rawDuration / timescale;
          }
        }
      }
      if (videoDuration === 0 && audioDuration === 0) {
        var sidxDuration = 0;
        var sidxs = findBox(data, ["sidx"]);
        for (var _i2 = 0; _i2 < sidxs.length; _i2++) {
          var sidx = parseSegmentIndex(sidxs[_i2]);
          if (sidx != null && sidx.references) {
            sidxDuration += sidx.references.reduce(function(dur, ref) {
              return dur + ref.info.duration || 0;
            }, 0);
          }
        }
        return sidxDuration;
      }
      if (videoDuration) {
        return videoDuration;
      }
      return audioDuration;
    }
    function computeRawDurationFromSamples(trun) {
      var flags = readUint32(trun, 0);
      var offset = 8;
      if (flags & 1) {
        offset += 4;
      }
      if (flags & 4) {
        offset += 4;
      }
      var duration = 0;
      var sampleCount = readUint32(trun, 4);
      for (var i = 0; i < sampleCount; i++) {
        if (flags & 256) {
          var sampleDuration = readUint32(trun, offset);
          duration += sampleDuration;
          offset += 4;
        }
        if (flags & 512) {
          offset += 4;
        }
        if (flags & 1024) {
          offset += 4;
        }
        if (flags & 2048) {
          offset += 4;
        }
      }
      return duration;
    }
    function offsetStartDTS(initData, fmp4, timeOffset) {
      findBox(fmp4, ["moof", "traf"]).forEach(function(traf) {
        findBox(traf, ["tfhd"]).forEach(function(tfhd) {
          var id = readUint32(tfhd, 4);
          var track = initData[id];
          if (!track) {
            return;
          }
          var timescale = track.timescale || 9e4;
          findBox(traf, ["tfdt"]).forEach(function(tfdt) {
            var version = tfdt[0];
            var offset = timeOffset * timescale;
            if (offset) {
              var baseMediaDecodeTime = readUint32(tfdt, 4);
              if (version === 0) {
                baseMediaDecodeTime -= offset;
                baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
                writeUint32(tfdt, 4, baseMediaDecodeTime);
              } else {
                baseMediaDecodeTime *= Math.pow(2, 32);
                baseMediaDecodeTime += readUint32(tfdt, 8);
                baseMediaDecodeTime -= offset;
                baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
                var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));
                var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));
                writeUint32(tfdt, 4, upper);
                writeUint32(tfdt, 8, lower);
              }
            }
          });
        });
      });
    }
    function segmentValidRange(data) {
      var segmentedRange = {
        valid: null,
        remainder: null
      };
      var moofs = findBox(data, ["moof"]);
      if (moofs.length < 2) {
        segmentedRange.remainder = data;
        return segmentedRange;
      }
      var last = moofs[moofs.length - 1];
      segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);
      segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);
      return segmentedRange;
    }
    function appendUint8Array(data1, data2) {
      var temp = new Uint8Array(data1.length + data2.length);
      temp.set(data1);
      temp.set(data2, data1.length);
      return temp;
    }
    function parseSamples(timeOffset, track) {
      var seiSamples = [];
      var videoData = track.samples;
      var timescale = track.timescale;
      var trackId = track.id;
      var isHEVCFlavor = false;
      var moofs = findBox(videoData, ["moof"]);
      moofs.map(function(moof) {
        var moofOffset = moof.byteOffset - 8;
        var trafs = findBox(moof, ["traf"]);
        trafs.map(function(traf) {
          var baseTime = findBox(traf, ["tfdt"]).map(function(tfdt) {
            var version = tfdt[0];
            var result = readUint32(tfdt, 4);
            if (version === 1) {
              result *= Math.pow(2, 32);
              result += readUint32(tfdt, 8);
            }
            return result / timescale;
          })[0];
          if (baseTime !== void 0) {
            timeOffset = baseTime;
          }
          return findBox(traf, ["tfhd"]).map(function(tfhd) {
            var id = readUint32(tfhd, 4);
            var tfhdFlags = readUint32(tfhd, 0) & 16777215;
            var baseDataOffsetPresent = (tfhdFlags & 1) !== 0;
            var sampleDescriptionIndexPresent = (tfhdFlags & 2) !== 0;
            var defaultSampleDurationPresent = (tfhdFlags & 8) !== 0;
            var defaultSampleDuration = 0;
            var defaultSampleSizePresent = (tfhdFlags & 16) !== 0;
            var defaultSampleSize = 0;
            var defaultSampleFlagsPresent = (tfhdFlags & 32) !== 0;
            var tfhdOffset = 8;
            if (id === trackId) {
              if (baseDataOffsetPresent) {
                tfhdOffset += 8;
              }
              if (sampleDescriptionIndexPresent) {
                tfhdOffset += 4;
              }
              if (defaultSampleDurationPresent) {
                defaultSampleDuration = readUint32(tfhd, tfhdOffset);
                tfhdOffset += 4;
              }
              if (defaultSampleSizePresent) {
                defaultSampleSize = readUint32(tfhd, tfhdOffset);
                tfhdOffset += 4;
              }
              if (defaultSampleFlagsPresent) {
                tfhdOffset += 4;
              }
              if (track.type === "video") {
                isHEVCFlavor = isHEVC(track.codec);
              }
              findBox(traf, ["trun"]).map(function(trun) {
                var version = trun[0];
                var flags = readUint32(trun, 0) & 16777215;
                var dataOffsetPresent = (flags & 1) !== 0;
                var dataOffset = 0;
                var firstSampleFlagsPresent = (flags & 4) !== 0;
                var sampleDurationPresent = (flags & 256) !== 0;
                var sampleDuration = 0;
                var sampleSizePresent = (flags & 512) !== 0;
                var sampleSize = 0;
                var sampleFlagsPresent = (flags & 1024) !== 0;
                var sampleCompositionOffsetsPresent = (flags & 2048) !== 0;
                var compositionOffset = 0;
                var sampleCount = readUint32(trun, 4);
                var trunOffset = 8;
                if (dataOffsetPresent) {
                  dataOffset = readUint32(trun, trunOffset);
                  trunOffset += 4;
                }
                if (firstSampleFlagsPresent) {
                  trunOffset += 4;
                }
                var sampleOffset = dataOffset + moofOffset;
                for (var ix = 0; ix < sampleCount; ix++) {
                  if (sampleDurationPresent) {
                    sampleDuration = readUint32(trun, trunOffset);
                    trunOffset += 4;
                  } else {
                    sampleDuration = defaultSampleDuration;
                  }
                  if (sampleSizePresent) {
                    sampleSize = readUint32(trun, trunOffset);
                    trunOffset += 4;
                  } else {
                    sampleSize = defaultSampleSize;
                  }
                  if (sampleFlagsPresent) {
                    trunOffset += 4;
                  }
                  if (sampleCompositionOffsetsPresent) {
                    if (version === 0) {
                      compositionOffset = readUint32(trun, trunOffset);
                    } else {
                      compositionOffset = readSint32(trun, trunOffset);
                    }
                    trunOffset += 4;
                  }
                  if (track.type === ElementaryStreamTypes.VIDEO) {
                    var naluTotalSize = 0;
                    while (naluTotalSize < sampleSize) {
                      var naluSize = readUint32(videoData, sampleOffset);
                      sampleOffset += 4;
                      if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {
                        var data = videoData.subarray(sampleOffset, sampleOffset + naluSize);
                        parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);
                      }
                      sampleOffset += naluSize;
                      naluTotalSize += naluSize + 4;
                    }
                  }
                  timeOffset += sampleDuration / timescale;
                }
              });
            }
          });
        });
      });
      return seiSamples;
    }
    function isHEVC(codec) {
      if (!codec) {
        return false;
      }
      var delimit = codec.indexOf(".");
      var baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);
      return baseCodec === "hvc1" || baseCodec === "hev1" || // Dolby Vision
      baseCodec === "dvh1" || baseCodec === "dvhe";
    }
    function isSEIMessage(isHEVCFlavor, naluHeader) {
      if (isHEVCFlavor) {
        var naluType = naluHeader >> 1 & 63;
        return naluType === 39 || naluType === 40;
      } else {
        var _naluType = naluHeader & 31;
        return _naluType === 6;
      }
    }
    function parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {
      var data = discardEPB(unescapedData);
      var seiPtr = 0;
      seiPtr += headerSize;
      var payloadType = 0;
      var payloadSize = 0;
      var b = 0;
      while (seiPtr < data.length) {
        payloadType = 0;
        do {
          if (seiPtr >= data.length) {
            break;
          }
          b = data[seiPtr++];
          payloadType += b;
        } while (b === 255);
        payloadSize = 0;
        do {
          if (seiPtr >= data.length) {
            break;
          }
          b = data[seiPtr++];
          payloadSize += b;
        } while (b === 255);
        var leftOver = data.length - seiPtr;
        var payPtr = seiPtr;
        if (payloadSize < leftOver) {
          seiPtr += payloadSize;
        } else if (payloadSize > leftOver) {
          logger.error("Malformed SEI payload. " + payloadSize + " is too small, only " + leftOver + " bytes left to parse.");
          break;
        }
        if (payloadType === 4) {
          var countryCode = data[payPtr++];
          if (countryCode === 181) {
            var providerCode = readUint16(data, payPtr);
            payPtr += 2;
            if (providerCode === 49) {
              var userStructure = readUint32(data, payPtr);
              payPtr += 4;
              if (userStructure === 1195456820) {
                var userDataType = data[payPtr++];
                if (userDataType === 3) {
                  var firstByte = data[payPtr++];
                  var totalCCs = 31 & firstByte;
                  var enabled = 64 & firstByte;
                  var totalBytes = enabled ? 2 + totalCCs * 3 : 0;
                  var byteArray = new Uint8Array(totalBytes);
                  if (enabled) {
                    byteArray[0] = firstByte;
                    for (var i = 1; i < totalBytes; i++) {
                      byteArray[i] = data[payPtr++];
                    }
                  }
                  samples.push({
                    type: userDataType,
                    payloadType,
                    pts,
                    bytes: byteArray
                  });
                }
              }
            }
          }
        } else if (payloadType === 5) {
          if (payloadSize > 16) {
            var uuidStrArray = [];
            for (var _i3 = 0; _i3 < 16; _i3++) {
              var _b = data[payPtr++].toString(16);
              uuidStrArray.push(_b.length == 1 ? "0" + _b : _b);
              if (_i3 === 3 || _i3 === 5 || _i3 === 7 || _i3 === 9) {
                uuidStrArray.push("-");
              }
            }
            var length = payloadSize - 16;
            var userDataBytes = new Uint8Array(length);
            for (var _i4 = 0; _i4 < length; _i4++) {
              userDataBytes[_i4] = data[payPtr++];
            }
            samples.push({
              payloadType,
              pts,
              uuid: uuidStrArray.join(""),
              userData: utf8ArrayToStr(userDataBytes),
              userDataBytes
            });
          }
        }
      }
    }
    function discardEPB(data) {
      var length = data.byteLength;
      var EPBPositions = [];
      var i = 1;
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
          EPBPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }
      if (EPBPositions.length === 0) {
        return data;
      }
      var newLength = length - EPBPositions.length;
      var newData = new Uint8Array(newLength);
      var sourceIndex = 0;
      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === EPBPositions[0]) {
          sourceIndex++;
          EPBPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    }
    function parseEmsg(data) {
      var version = data[0];
      var schemeIdUri = "";
      var value = "";
      var timeScale = 0;
      var presentationTimeDelta = 0;
      var presentationTime = 0;
      var eventDuration = 0;
      var id = 0;
      var offset = 0;
      if (version === 0) {
        while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
          schemeIdUri += bin2str(data.subarray(offset, offset + 1));
          offset += 1;
        }
        schemeIdUri += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
        while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
          value += bin2str(data.subarray(offset, offset + 1));
          offset += 1;
        }
        value += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
        timeScale = readUint32(data, 12);
        presentationTimeDelta = readUint32(data, 16);
        eventDuration = readUint32(data, 20);
        id = readUint32(data, 24);
        offset = 28;
      } else if (version === 1) {
        offset += 4;
        timeScale = readUint32(data, offset);
        offset += 4;
        var leftPresentationTime = readUint32(data, offset);
        offset += 4;
        var rightPresentationTime = readUint32(data, offset);
        offset += 4;
        presentationTime = Math.pow(2, 32) * leftPresentationTime + rightPresentationTime;
        if (!isSafeInteger(presentationTime)) {
          presentationTime = Number.MAX_SAFE_INTEGER;
          logger.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box");
        }
        eventDuration = readUint32(data, offset);
        offset += 4;
        id = readUint32(data, offset);
        offset += 4;
        while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
          schemeIdUri += bin2str(data.subarray(offset, offset + 1));
          offset += 1;
        }
        schemeIdUri += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
        while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
          value += bin2str(data.subarray(offset, offset + 1));
          offset += 1;
        }
        value += bin2str(data.subarray(offset, offset + 1));
        offset += 1;
      }
      var payload = data.subarray(offset, data.byteLength);
      return {
        schemeIdUri,
        value,
        timeScale,
        presentationTime,
        presentationTimeDelta,
        eventDuration,
        id,
        payload
      };
    }
    function mp4Box(type) {
      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        payload[_key - 1] = arguments[_key];
      }
      var len = payload.length;
      var size = 8;
      var i = len;
      while (i--) {
        size += payload[i].byteLength;
      }
      var result = new Uint8Array(size);
      result[0] = size >> 24 & 255;
      result[1] = size >> 16 & 255;
      result[2] = size >> 8 & 255;
      result[3] = size & 255;
      result.set(type, 4);
      for (i = 0, size = 8; i < len; i++) {
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    }
    function mp4pssh(systemId, keyids, data) {
      if (systemId.byteLength !== 16) {
        throw new RangeError("Invalid system id");
      }
      var version;
      var kids;
      if (keyids) {
        version = 1;
        kids = new Uint8Array(keyids.length * 16);
        for (var ix = 0; ix < keyids.length; ix++) {
          var k = keyids[ix];
          if (k.byteLength !== 16) {
            throw new RangeError("Invalid key");
          }
          kids.set(k, ix * 16);
        }
      } else {
        version = 0;
        kids = new Uint8Array();
      }
      var kidCount;
      if (version > 0) {
        kidCount = new Uint8Array(4);
        if (keyids.length > 0) {
          new DataView(kidCount.buffer).setUint32(0, keyids.length, false);
        }
      } else {
        kidCount = new Uint8Array();
      }
      var dataSize = new Uint8Array(4);
      if (data && data.byteLength > 0) {
        new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);
      }
      return mp4Box(
        [112, 115, 115, 104],
        new Uint8Array([
          version,
          0,
          0,
          0
          // Flags
        ]),
        systemId,
        // 16 bytes
        kidCount,
        kids,
        dataSize,
        data || new Uint8Array()
      );
    }
    function parsePssh(initData) {
      if (!(initData instanceof ArrayBuffer) || initData.byteLength < 32) {
        return null;
      }
      var result = {
        version: 0,
        systemId: "",
        kids: null,
        data: null
      };
      var view = new DataView(initData);
      var boxSize = view.getUint32(0);
      if (initData.byteLength !== boxSize && boxSize > 44) {
        return null;
      }
      var type = view.getUint32(4);
      if (type !== 1886614376) {
        return null;
      }
      result.version = view.getUint32(8) >>> 24;
      if (result.version > 1) {
        return null;
      }
      result.systemId = Hex.hexDump(new Uint8Array(initData, 12, 16));
      var dataSizeOrKidCount = view.getUint32(28);
      if (result.version === 0) {
        if (boxSize - 32 < dataSizeOrKidCount) {
          return null;
        }
        result.data = new Uint8Array(initData, 32, dataSizeOrKidCount);
      } else if (result.version === 1) {
        result.kids = [];
        for (var i = 0; i < dataSizeOrKidCount; i++) {
          result.kids.push(new Uint8Array(initData, 32 + i * 16, 16));
        }
      }
      return result;
    }
    var keyUriToKeyIdMap = {};
    var LevelKey = /* @__PURE__ */ function() {
      LevelKey2.clearKeyUriToKeyIdMap = function clearKeyUriToKeyIdMap() {
        keyUriToKeyIdMap = {};
      };
      function LevelKey2(method, uri, format2, formatversions, iv) {
        if (formatversions === void 0) {
          formatversions = [1];
        }
        if (iv === void 0) {
          iv = null;
        }
        this.uri = void 0;
        this.method = void 0;
        this.keyFormat = void 0;
        this.keyFormatVersions = void 0;
        this.encrypted = void 0;
        this.isCommonEncryption = void 0;
        this.iv = null;
        this.key = null;
        this.keyId = null;
        this.pssh = null;
        this.method = method;
        this.uri = uri;
        this.keyFormat = format2;
        this.keyFormatVersions = formatversions;
        this.iv = iv;
        this.encrypted = method ? method !== "NONE" : false;
        this.isCommonEncryption = this.encrypted && method !== "AES-128";
      }
      var _proto = LevelKey2.prototype;
      _proto.isSupported = function isSupported2() {
        if (this.method) {
          if (this.method === "AES-128" || this.method === "NONE") {
            return true;
          }
          if (this.keyFormat === "identity") {
            return this.method === "SAMPLE-AES";
          } else {
            switch (this.keyFormat) {
              case KeySystemFormats.FAIRPLAY:
              case KeySystemFormats.WIDEVINE:
              case KeySystemFormats.PLAYREADY:
              case KeySystemFormats.CLEARKEY:
                return ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1;
            }
          }
        }
        return false;
      };
      _proto.getDecryptData = function getDecryptData(sn) {
        if (!this.encrypted || !this.uri) {
          return null;
        }
        if (this.method === "AES-128" && this.uri && !this.iv) {
          if (typeof sn !== "number") {
            if (this.method === "AES-128" && !this.iv) {
              logger.warn('missing IV for initialization segment with method="' + this.method + '" - compliance issue');
            }
            sn = 0;
          }
          var iv = createInitializationVector(sn);
          var decryptdata = new LevelKey2(this.method, this.uri, "identity", this.keyFormatVersions, iv);
          return decryptdata;
        }
        var keyBytes = convertDataUriToArrayBytes(this.uri);
        if (keyBytes) {
          switch (this.keyFormat) {
            case KeySystemFormats.WIDEVINE:
              this.pssh = keyBytes;
              if (keyBytes.length >= 22) {
                this.keyId = keyBytes.subarray(keyBytes.length - 22, keyBytes.length - 6);
              }
              break;
            case KeySystemFormats.PLAYREADY: {
              var PlayReadyKeySystemUUID = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
              this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);
              var keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);
              var keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));
              var xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf("<"), keyByteStr.length);
              var parser = new DOMParser();
              var xmlDoc = parser.parseFromString(xmlKeyBytes, "text/xml");
              var keyData = xmlDoc.getElementsByTagName("KID")[0];
              if (keyData) {
                var keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute("VALUE");
                if (keyId) {
                  var keyIdArray = base64Decode(keyId).subarray(0, 16);
                  changeEndianness(keyIdArray);
                  this.keyId = keyIdArray;
                }
              }
              break;
            }
            default: {
              var keydata = keyBytes.subarray(0, 16);
              if (keydata.length !== 16) {
                var padded = new Uint8Array(16);
                padded.set(keydata, 16 - keydata.length);
                keydata = padded;
              }
              this.keyId = keydata;
              break;
            }
          }
        }
        if (!this.keyId || this.keyId.byteLength !== 16) {
          var _keyId = keyUriToKeyIdMap[this.uri];
          if (!_keyId) {
            var val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;
            _keyId = new Uint8Array(16);
            var dv = new DataView(_keyId.buffer, 12, 4);
            dv.setUint32(0, val);
            keyUriToKeyIdMap[this.uri] = _keyId;
          }
          this.keyId = _keyId;
        }
        return this;
      };
      return LevelKey2;
    }();
    function createInitializationVector(segmentNumber) {
      var uint8View = new Uint8Array(16);
      for (var i = 12; i < 16; i++) {
        uint8View[i] = segmentNumber >> 8 * (15 - i) & 255;
      }
      return uint8View;
    }
    var VARIABLE_REPLACEMENT_REGEX = /\{\$([a-zA-Z0-9-_]+)\}/g;
    function hasVariableReferences(str) {
      return VARIABLE_REPLACEMENT_REGEX.test(str);
    }
    function substituteVariablesInAttributes(parsed, attr, attributeNames) {
      if (parsed.variableList !== null || parsed.hasVariableRefs) {
        for (var i = attributeNames.length; i--; ) {
          var name = attributeNames[i];
          var value = attr[name];
          if (value) {
            attr[name] = substituteVariables(parsed, value);
          }
        }
      }
    }
    function substituteVariables(parsed, value) {
      if (parsed.variableList !== null || parsed.hasVariableRefs) {
        var variableList = parsed.variableList;
        return value.replace(VARIABLE_REPLACEMENT_REGEX, function(variableReference) {
          var variableName = variableReference.substring(2, variableReference.length - 1);
          var variableValue = variableList == null ? void 0 : variableList[variableName];
          if (variableValue === void 0) {
            parsed.playlistParsingError || (parsed.playlistParsingError = new Error('Missing preceding EXT-X-DEFINE tag for Variable Reference: "' + variableName + '"'));
            return variableReference;
          }
          return variableValue;
        });
      }
      return value;
    }
    function addVariableDefinition(parsed, attr, parentUrl) {
      var variableList = parsed.variableList;
      if (!variableList) {
        parsed.variableList = variableList = {};
      }
      var NAME;
      var VALUE;
      if ("QUERYPARAM" in attr) {
        NAME = attr.QUERYPARAM;
        try {
          var searchParams = new self.URL(parentUrl).searchParams;
          if (searchParams.has(NAME)) {
            VALUE = searchParams.get(NAME);
          } else {
            throw new Error('"' + NAME + '" does not match any query parameter in URI: "' + parentUrl + '"');
          }
        } catch (error) {
          parsed.playlistParsingError || (parsed.playlistParsingError = new Error("EXT-X-DEFINE QUERYPARAM: " + error.message));
        }
      } else {
        NAME = attr.NAME;
        VALUE = attr.VALUE;
      }
      if (NAME in variableList) {
        parsed.playlistParsingError || (parsed.playlistParsingError = new Error('EXT-X-DEFINE duplicate Variable Name declarations: "' + NAME + '"'));
      } else {
        variableList[NAME] = VALUE || "";
      }
    }
    function importVariableDefinition(parsed, attr, sourceVariableList) {
      var IMPORT = attr.IMPORT;
      if (sourceVariableList && IMPORT in sourceVariableList) {
        var variableList = parsed.variableList;
        if (!variableList) {
          parsed.variableList = variableList = {};
        }
        variableList[IMPORT] = sourceVariableList[IMPORT];
      } else {
        parsed.playlistParsingError || (parsed.playlistParsingError = new Error('EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "' + IMPORT + '"'));
      }
    }
    function getMediaSource(preferManagedMediaSource) {
      if (preferManagedMediaSource === void 0) {
        preferManagedMediaSource = true;
      }
      if (typeof self === "undefined")
        return void 0;
      var mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;
      return mms || self.MediaSource || self.WebKitMediaSource;
    }
    var sampleEntryCodesISO = {
      audio: {
        a3ds: 1,
        "ac-3": 0.95,
        "ac-4": 1,
        alac: 0.9,
        alaw: 1,
        dra1: 1,
        "dts+": 1,
        "dts-": 1,
        dtsc: 1,
        dtse: 1,
        dtsh: 1,
        "ec-3": 0.9,
        enca: 1,
        fLaC: 0.9,
        // MP4-RA listed codec entry for FLAC
        flac: 0.9,
        // legacy browser codec name for FLAC
        FLAC: 0.9,
        // some manifests may list "FLAC" with Apple's tools
        g719: 1,
        g726: 1,
        m4ae: 1,
        mha1: 1,
        mha2: 1,
        mhm1: 1,
        mhm2: 1,
        mlpa: 1,
        mp4a: 1,
        "raw ": 1,
        Opus: 1,
        opus: 1,
        // browsers expect this to be lowercase despite MP4RA says 'Opus'
        samr: 1,
        sawb: 1,
        sawp: 1,
        sevc: 1,
        sqcp: 1,
        ssmv: 1,
        twos: 1,
        ulaw: 1
      },
      video: {
        avc1: 1,
        avc2: 1,
        avc3: 1,
        avc4: 1,
        avcp: 1,
        av01: 0.8,
        drac: 1,
        dva1: 1,
        dvav: 1,
        dvh1: 0.7,
        dvhe: 0.7,
        encv: 1,
        hev1: 0.75,
        hvc1: 0.75,
        mjp2: 1,
        mp4v: 1,
        mvc1: 1,
        mvc2: 1,
        mvc3: 1,
        mvc4: 1,
        resv: 1,
        rv60: 1,
        s263: 1,
        svc1: 1,
        svc2: 1,
        "vc-1": 1,
        vp08: 1,
        vp09: 0.9
      },
      text: {
        stpp: 1,
        wvtt: 1
      }
    };
    function isCodecType(codec, type) {
      var typeCodes = sampleEntryCodesISO[type];
      return !!typeCodes && !!typeCodes[codec.slice(0, 4)];
    }
    function areCodecsMediaSourceSupported(codecs, type, preferManagedMediaSource) {
      if (preferManagedMediaSource === void 0) {
        preferManagedMediaSource = true;
      }
      return !codecs.split(",").some(function(codec) {
        return !isCodecMediaSourceSupported(codec, type, preferManagedMediaSource);
      });
    }
    function isCodecMediaSourceSupported(codec, type, preferManagedMediaSource) {
      var _MediaSource$isTypeSu;
      if (preferManagedMediaSource === void 0) {
        preferManagedMediaSource = true;
      }
      var MediaSource2 = getMediaSource(preferManagedMediaSource);
      return (_MediaSource$isTypeSu = MediaSource2 == null ? void 0 : MediaSource2.isTypeSupported(mimeTypeForCodec(codec, type))) != null ? _MediaSource$isTypeSu : false;
    }
    function mimeTypeForCodec(codec, type) {
      return type + '/mp4;codecs="' + codec + '"';
    }
    function videoCodecPreferenceValue(videoCodec) {
      if (videoCodec) {
        var fourCC = videoCodec.substring(0, 4);
        return sampleEntryCodesISO.video[fourCC];
      }
      return 2;
    }
    function codecsSetSelectionPreferenceValue(codecSet) {
      return codecSet.split(",").reduce(function(num, fourCC) {
        var preferenceValue = sampleEntryCodesISO.video[fourCC];
        if (preferenceValue) {
          return (preferenceValue * 2 + num) / (num ? 3 : 2);
        }
        return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);
      }, 0);
    }
    var CODEC_COMPATIBLE_NAMES = {};
    function getCodecCompatibleNameLower(lowerCaseCodec, preferManagedMediaSource) {
      if (preferManagedMediaSource === void 0) {
        preferManagedMediaSource = true;
      }
      if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {
        return CODEC_COMPATIBLE_NAMES[lowerCaseCodec];
      }
      var codecsToCheck = {
        flac: ["flac", "fLaC", "FLAC"],
        opus: ["opus", "Opus"]
      }[lowerCaseCodec];
      for (var i = 0; i < codecsToCheck.length; i++) {
        if (isCodecMediaSourceSupported(codecsToCheck[i], "audio", preferManagedMediaSource)) {
          CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];
          return codecsToCheck[i];
        }
      }
      return lowerCaseCodec;
    }
    var AUDIO_CODEC_REGEXP = /flac|opus/i;
    function getCodecCompatibleName(codec, preferManagedMediaSource) {
      if (preferManagedMediaSource === void 0) {
        preferManagedMediaSource = true;
      }
      return codec.replace(AUDIO_CODEC_REGEXP, function(m) {
        return getCodecCompatibleNameLower(m.toLowerCase(), preferManagedMediaSource);
      });
    }
    function pickMostCompleteCodecName(parsedCodec, levelCodec) {
      if (parsedCodec && parsedCodec !== "mp4a") {
        return parsedCodec;
      }
      return levelCodec;
    }
    function convertAVC1ToAVCOTI(codec) {
      var avcdata = codec.split(".");
      if (avcdata.length > 2) {
        var result = avcdata.shift() + ".";
        result += parseInt(avcdata.shift()).toString(16);
        result += ("000" + parseInt(avcdata.shift()).toString(16)).slice(-4);
        return result;
      }
      return codec;
    }
    var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g;
    var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
    var IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m;
    var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([
      /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
      // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
      /(?!#) *(\S[\S ]*)/.source,
      // segment URI, group 3 => the URI (note newline is not eaten)
      /#EXT-X-BYTERANGE:*(.+)/.source,
      // next segment's byterange, group 4 => range spec (x@y)
      /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
      // next segment's program date/time group 5 => the datetime spec
      /#.*/.source
      // All other non-segment oriented tags will match with all groups empty
    ].join("|"), "g");
    var LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
    var M3U8Parser = /* @__PURE__ */ function() {
      function M3U8Parser2() {
      }
      M3U8Parser2.findGroup = function findGroup(groups, mediaGroupId) {
        for (var i = 0; i < groups.length; i++) {
          var group = groups[i];
          if (group.id === mediaGroupId) {
            return group;
          }
        }
      };
      M3U8Parser2.resolve = function resolve(url, baseUrl) {
        return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {
          alwaysNormalize: true
        });
      };
      M3U8Parser2.isMediaPlaylist = function isMediaPlaylist(str) {
        return IS_MEDIA_PLAYLIST.test(str);
      };
      M3U8Parser2.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {
        var hasVariableRefs = hasVariableReferences(string);
        var parsed = {
          contentSteering: null,
          levels: [],
          playlistParsingError: null,
          sessionData: null,
          sessionKeys: null,
          startTimeOffset: null,
          variableList: null,
          hasVariableRefs
        };
        var levelsWithKnownCodecs = [];
        MASTER_PLAYLIST_REGEX.lastIndex = 0;
        var result;
        while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
          if (result[1]) {
            var _level$unknownCodecs;
            var attrs = new AttrList(result[1]);
            {
              substituteVariablesInAttributes(parsed, attrs, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]);
            }
            var uri = substituteVariables(parsed, result[2]);
            var level = {
              attrs,
              bitrate: attrs.decimalInteger("BANDWIDTH") || attrs.decimalInteger("AVERAGE-BANDWIDTH"),
              name: attrs.NAME,
              url: M3U8Parser2.resolve(uri, baseurl)
            };
            var resolution = attrs.decimalResolution("RESOLUTION");
            if (resolution) {
              level.width = resolution.width;
              level.height = resolution.height;
            }
            setCodecs(attrs.CODECS, level);
            if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {
              levelsWithKnownCodecs.push(level);
            }
            parsed.levels.push(level);
          } else if (result[3]) {
            var tag = result[3];
            var attributes = result[4];
            switch (tag) {
              case "SESSION-DATA": {
                var sessionAttrs = new AttrList(attributes);
                {
                  substituteVariablesInAttributes(parsed, sessionAttrs, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]);
                }
                var dataId = sessionAttrs["DATA-ID"];
                if (dataId) {
                  if (parsed.sessionData === null) {
                    parsed.sessionData = {};
                  }
                  parsed.sessionData[dataId] = sessionAttrs;
                }
                break;
              }
              case "SESSION-KEY": {
                var sessionKey = parseKey(attributes, baseurl, parsed);
                if (sessionKey.encrypted && sessionKey.isSupported()) {
                  if (parsed.sessionKeys === null) {
                    parsed.sessionKeys = [];
                  }
                  parsed.sessionKeys.push(sessionKey);
                } else {
                  logger.warn('[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "' + attributes + '"');
                }
                break;
              }
              case "DEFINE": {
                {
                  var variableAttributes = new AttrList(attributes);
                  substituteVariablesInAttributes(parsed, variableAttributes, ["NAME", "VALUE", "QUERYPARAM"]);
                  addVariableDefinition(parsed, variableAttributes, baseurl);
                }
                break;
              }
              case "CONTENT-STEERING": {
                var contentSteeringAttributes = new AttrList(attributes);
                {
                  substituteVariablesInAttributes(parsed, contentSteeringAttributes, ["SERVER-URI", "PATHWAY-ID"]);
                }
                parsed.contentSteering = {
                  uri: M3U8Parser2.resolve(contentSteeringAttributes["SERVER-URI"], baseurl),
                  pathwayId: contentSteeringAttributes["PATHWAY-ID"] || "."
                };
                break;
              }
              case "START": {
                parsed.startTimeOffset = parseStartTimeOffset(attributes);
                break;
              }
            }
          }
        }
        var stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;
        parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;
        if (parsed.levels.length === 0) {
          parsed.playlistParsingError = new Error("no levels found in manifest");
        }
        return parsed;
      };
      M3U8Parser2.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, parsed) {
        var result;
        var results = {};
        var levels = parsed.levels;
        var groupsByType = {
          AUDIO: levels.map(function(level) {
            return {
              id: level.attrs.AUDIO,
              audioCodec: level.audioCodec
            };
          }),
          SUBTITLES: levels.map(function(level) {
            return {
              id: level.attrs.SUBTITLES,
              textCodec: level.textCodec
            };
          }),
          "CLOSED-CAPTIONS": []
        };
        var id = 0;
        MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
        while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
          var attrs = new AttrList(result[1]);
          var type = attrs.TYPE;
          if (type) {
            var groups = groupsByType[type];
            var medias = results[type] || [];
            results[type] = medias;
            {
              substituteVariablesInAttributes(parsed, attrs, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]);
            }
            var lang = attrs.LANGUAGE;
            var assocLang = attrs["ASSOC-LANGUAGE"];
            var channels = attrs.CHANNELS;
            var characteristics = attrs.CHARACTERISTICS;
            var instreamId = attrs["INSTREAM-ID"];
            var media = {
              attrs,
              bitrate: 0,
              id: id++,
              groupId: attrs["GROUP-ID"] || "",
              name: attrs.NAME || lang || "",
              type,
              default: attrs.bool("DEFAULT"),
              autoselect: attrs.bool("AUTOSELECT"),
              forced: attrs.bool("FORCED"),
              lang,
              url: attrs.URI ? M3U8Parser2.resolve(attrs.URI, baseurl) : ""
            };
            if (assocLang) {
              media.assocLang = assocLang;
            }
            if (channels) {
              media.channels = channels;
            }
            if (characteristics) {
              media.characteristics = characteristics;
            }
            if (instreamId) {
              media.instreamId = instreamId;
            }
            if (groups != null && groups.length) {
              var groupCodec = M3U8Parser2.findGroup(groups, media.groupId) || groups[0];
              assignCodec(media, groupCodec, "audioCodec");
              assignCodec(media, groupCodec, "textCodec");
            }
            medias.push(media);
          }
        }
        return results;
      };
      M3U8Parser2.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {
        var level = new LevelDetails(baseurl);
        var fragments = level.fragments;
        var currentInitSegment = null;
        var currentSN = 0;
        var currentPart = 0;
        var totalduration = 0;
        var discontinuityCounter = 0;
        var prevFrag = null;
        var frag = new Fragment(type, baseurl);
        var result;
        var i;
        var levelkeys;
        var firstPdtIndex = -1;
        var createNextFrag = false;
        var nextByteRange = null;
        LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
        level.m3u8 = string;
        level.hasVariableRefs = hasVariableReferences(string);
        while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
          if (createNextFrag) {
            createNextFrag = false;
            frag = new Fragment(type, baseurl);
            frag.start = totalduration;
            frag.sn = currentSN;
            frag.cc = discontinuityCounter;
            frag.level = id;
            if (currentInitSegment) {
              frag.initSegment = currentInitSegment;
              frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
              currentInitSegment.rawProgramDateTime = null;
              if (nextByteRange) {
                frag.setByteRange(nextByteRange);
                nextByteRange = null;
              }
            }
          }
          var duration = result[1];
          if (duration) {
            frag.duration = parseFloat(duration);
            var title = (" " + result[2]).slice(1);
            frag.title = title || null;
            frag.tagList.push(title ? ["INF", duration, title] : ["INF", duration]);
          } else if (result[3]) {
            if (isFiniteNumber(frag.duration)) {
              frag.start = totalduration;
              if (levelkeys) {
                setFragLevelKeys(frag, levelkeys, level);
              }
              frag.sn = currentSN;
              frag.level = id;
              frag.cc = discontinuityCounter;
              fragments.push(frag);
              var uri = (" " + result[3]).slice(1);
              frag.relurl = substituteVariables(level, uri);
              assignProgramDateTime(frag, prevFrag);
              prevFrag = frag;
              totalduration += frag.duration;
              currentSN++;
              currentPart = 0;
              createNextFrag = true;
            }
          } else if (result[4]) {
            var data = (" " + result[4]).slice(1);
            if (prevFrag) {
              frag.setByteRange(data, prevFrag);
            } else {
              frag.setByteRange(data);
            }
          } else if (result[5]) {
            frag.rawProgramDateTime = (" " + result[5]).slice(1);
            frag.tagList.push(["PROGRAM-DATE-TIME", frag.rawProgramDateTime]);
            if (firstPdtIndex === -1) {
              firstPdtIndex = fragments.length;
            }
          } else {
            result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
            if (!result) {
              logger.warn("No matches on slow regex match for level playlist!");
              continue;
            }
            for (i = 1; i < result.length; i++) {
              if (typeof result[i] !== "undefined") {
                break;
              }
            }
            var tag = (" " + result[i]).slice(1);
            var value1 = (" " + result[i + 1]).slice(1);
            var value2 = result[i + 2] ? (" " + result[i + 2]).slice(1) : "";
            switch (tag) {
              case "PLAYLIST-TYPE":
                level.type = value1.toUpperCase();
                break;
              case "MEDIA-SEQUENCE":
                currentSN = level.startSN = parseInt(value1);
                break;
              case "SKIP": {
                var skipAttrs = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, skipAttrs, ["RECENTLY-REMOVED-DATERANGES"]);
                }
                var skippedSegments = skipAttrs.decimalInteger("SKIPPED-SEGMENTS");
                if (isFiniteNumber(skippedSegments)) {
                  level.skippedSegments = skippedSegments;
                  for (var _i = skippedSegments; _i--; ) {
                    fragments.unshift(null);
                  }
                  currentSN += skippedSegments;
                }
                var recentlyRemovedDateranges = skipAttrs.enumeratedString("RECENTLY-REMOVED-DATERANGES");
                if (recentlyRemovedDateranges) {
                  level.recentlyRemovedDateranges = recentlyRemovedDateranges.split("	");
                }
                break;
              }
              case "TARGETDURATION":
                level.targetduration = Math.max(parseInt(value1), 1);
                break;
              case "VERSION":
                level.version = parseInt(value1);
                break;
              case "INDEPENDENT-SEGMENTS":
              case "EXTM3U":
                break;
              case "ENDLIST":
                level.live = false;
                break;
              case "#":
                if (value1 || value2) {
                  frag.tagList.push(value2 ? [value1, value2] : [value1]);
                }
                break;
              case "DISCONTINUITY":
                discontinuityCounter++;
                frag.tagList.push(["DIS"]);
                break;
              case "GAP":
                frag.gap = true;
                frag.tagList.push([tag]);
                break;
              case "BITRATE":
                frag.tagList.push([tag, value1]);
                break;
              case "DATERANGE": {
                var dateRangeAttr = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, dateRangeAttr, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]);
                  substituteVariablesInAttributes(level, dateRangeAttr, dateRangeAttr.clientAttrs);
                }
                var dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);
                if (dateRange.isValid || level.skippedSegments) {
                  level.dateRanges[dateRange.id] = dateRange;
                } else {
                  logger.warn('Ignoring invalid DATERANGE tag: "' + value1 + '"');
                }
                frag.tagList.push(["EXT-X-DATERANGE", value1]);
                break;
              }
              case "DEFINE": {
                {
                  var variableAttributes = new AttrList(value1);
                  substituteVariablesInAttributes(level, variableAttributes, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]);
                  if ("IMPORT" in variableAttributes) {
                    importVariableDefinition(level, variableAttributes, multivariantVariableList);
                  } else {
                    addVariableDefinition(level, variableAttributes, baseurl);
                  }
                }
                break;
              }
              case "DISCONTINUITY-SEQUENCE":
                discontinuityCounter = parseInt(value1);
                break;
              case "KEY": {
                var levelKey = parseKey(value1, baseurl, level);
                if (levelKey.isSupported()) {
                  if (levelKey.method === "NONE") {
                    levelkeys = void 0;
                    break;
                  }
                  if (!levelkeys) {
                    levelkeys = {};
                  }
                  if (levelkeys[levelKey.keyFormat]) {
                    levelkeys = _extends({}, levelkeys);
                  }
                  levelkeys[levelKey.keyFormat] = levelKey;
                } else {
                  logger.warn('[Keys] Ignoring invalid EXT-X-KEY tag: "' + value1 + '"');
                }
                break;
              }
              case "START":
                level.startTimeOffset = parseStartTimeOffset(value1);
                break;
              case "MAP": {
                var mapAttrs = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, mapAttrs, ["BYTERANGE", "URI"]);
                }
                if (frag.duration) {
                  var init = new Fragment(type, baseurl);
                  setInitSegment(init, mapAttrs, id, levelkeys);
                  currentInitSegment = init;
                  frag.initSegment = currentInitSegment;
                  if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {
                    frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
                  }
                } else {
                  var end = frag.byteRangeEndOffset;
                  if (end) {
                    var start = frag.byteRangeStartOffset;
                    nextByteRange = end - start + "@" + start;
                  } else {
                    nextByteRange = null;
                  }
                  setInitSegment(frag, mapAttrs, id, levelkeys);
                  currentInitSegment = frag;
                  createNextFrag = true;
                }
                break;
              }
              case "SERVER-CONTROL": {
                var serverControlAttrs = new AttrList(value1);
                level.canBlockReload = serverControlAttrs.bool("CAN-BLOCK-RELOAD");
                level.canSkipUntil = serverControlAttrs.optionalFloat("CAN-SKIP-UNTIL", 0);
                level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool("CAN-SKIP-DATERANGES");
                level.partHoldBack = serverControlAttrs.optionalFloat("PART-HOLD-BACK", 0);
                level.holdBack = serverControlAttrs.optionalFloat("HOLD-BACK", 0);
                break;
              }
              case "PART-INF": {
                var partInfAttrs = new AttrList(value1);
                level.partTarget = partInfAttrs.decimalFloatingPoint("PART-TARGET");
                break;
              }
              case "PART": {
                var partList = level.partList;
                if (!partList) {
                  partList = level.partList = [];
                }
                var previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : void 0;
                var index = currentPart++;
                var partAttrs = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, partAttrs, ["BYTERANGE", "URI"]);
                }
                var part = new Part(partAttrs, frag, baseurl, index, previousFragmentPart);
                partList.push(part);
                frag.duration += part.duration;
                break;
              }
              case "PRELOAD-HINT": {
                var preloadHintAttrs = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, preloadHintAttrs, ["URI"]);
                }
                level.preloadHint = preloadHintAttrs;
                break;
              }
              case "RENDITION-REPORT": {
                var renditionReportAttrs = new AttrList(value1);
                {
                  substituteVariablesInAttributes(level, renditionReportAttrs, ["URI"]);
                }
                level.renditionReports = level.renditionReports || [];
                level.renditionReports.push(renditionReportAttrs);
                break;
              }
              default:
                logger.warn("line parsed but not handled: " + result);
                break;
            }
          }
        }
        if (prevFrag && !prevFrag.relurl) {
          fragments.pop();
          totalduration -= prevFrag.duration;
          if (level.partList) {
            level.fragmentHint = prevFrag;
          }
        } else if (level.partList) {
          assignProgramDateTime(frag, prevFrag);
          frag.cc = discontinuityCounter;
          level.fragmentHint = frag;
          if (levelkeys) {
            setFragLevelKeys(frag, levelkeys, level);
          }
        }
        var fragmentLength = fragments.length;
        var firstFragment = fragments[0];
        var lastFragment = fragments[fragmentLength - 1];
        totalduration += level.skippedSegments * level.targetduration;
        if (totalduration > 0 && fragmentLength && lastFragment) {
          level.averagetargetduration = totalduration / fragmentLength;
          var lastSn = lastFragment.sn;
          level.endSN = lastSn !== "initSegment" ? lastSn : 0;
          if (!level.live) {
            lastFragment.endList = true;
          }
          if (firstFragment) {
            level.startCC = firstFragment.cc;
          }
        } else {
          level.endSN = 0;
          level.startCC = 0;
        }
        if (level.fragmentHint) {
          totalduration += level.fragmentHint.duration;
        }
        level.totalduration = totalduration;
        level.endCC = discontinuityCounter;
        if (firstPdtIndex > 0) {
          backfillProgramDateTimes(fragments, firstPdtIndex);
        }
        return level;
      };
      return M3U8Parser2;
    }();
    function parseKey(keyTagAttributes, baseurl, parsed) {
      var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;
      var keyAttrs = new AttrList(keyTagAttributes);
      {
        substituteVariablesInAttributes(parsed, keyAttrs, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]);
      }
      var decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : "";
      var decrypturi = keyAttrs.URI;
      var decryptiv = keyAttrs.hexadecimalInteger("IV");
      var decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;
      var decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : "identity";
      if (decrypturi && keyAttrs.IV && !decryptiv) {
        logger.error("Invalid IV: " + keyAttrs.IV);
      }
      var resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : "";
      var keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : "1").split("/").map(Number).filter(Number.isFinite);
      return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);
    }
    function parseStartTimeOffset(startAttributes) {
      var startAttrs = new AttrList(startAttributes);
      var startTimeOffset = startAttrs.decimalFloatingPoint("TIME-OFFSET");
      if (isFiniteNumber(startTimeOffset)) {
        return startTimeOffset;
      }
      return null;
    }
    function setCodecs(codecsAttributeValue, level) {
      var codecs = (codecsAttributeValue || "").split(/[ ,]+/).filter(function(c) {
        return c;
      });
      ["video", "audio", "text"].forEach(function(type) {
        var filtered = codecs.filter(function(codec) {
          return isCodecType(codec, type);
        });
        if (filtered.length) {
          level[type + "Codec"] = filtered.join(",");
          codecs = codecs.filter(function(codec) {
            return filtered.indexOf(codec) === -1;
          });
        }
      });
      level.unknownCodecs = codecs;
    }
    function assignCodec(media, groupItem, codecProperty) {
      var codecValue = groupItem[codecProperty];
      if (codecValue) {
        media[codecProperty] = codecValue;
      }
    }
    function backfillProgramDateTimes(fragments, firstPdtIndex) {
      var fragPrev = fragments[firstPdtIndex];
      for (var i = firstPdtIndex; i--; ) {
        var frag = fragments[i];
        if (!frag) {
          return;
        }
        frag.programDateTime = fragPrev.programDateTime - frag.duration * 1e3;
        fragPrev = frag;
      }
    }
    function assignProgramDateTime(frag, prevFrag) {
      if (frag.rawProgramDateTime) {
        frag.programDateTime = Date.parse(frag.rawProgramDateTime);
      } else if (prevFrag != null && prevFrag.programDateTime) {
        frag.programDateTime = prevFrag.endProgramDateTime;
      }
      if (!isFiniteNumber(frag.programDateTime)) {
        frag.programDateTime = null;
        frag.rawProgramDateTime = null;
      }
    }
    function setInitSegment(frag, mapAttrs, id, levelkeys) {
      frag.relurl = mapAttrs.URI;
      if (mapAttrs.BYTERANGE) {
        frag.setByteRange(mapAttrs.BYTERANGE);
      }
      frag.level = id;
      frag.sn = "initSegment";
      if (levelkeys) {
        frag.levelkeys = levelkeys;
      }
      frag.initSegment = null;
    }
    function setFragLevelKeys(frag, levelkeys, level) {
      frag.levelkeys = levelkeys;
      var encryptedFragments = level.encryptedFragments;
      if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(function(format2) {
        return levelkeys[format2].isCommonEncryption;
      })) {
        encryptedFragments.push(frag);
      }
    }
    var PlaylistContextType = {
      MANIFEST: "manifest",
      LEVEL: "level",
      AUDIO_TRACK: "audioTrack",
      SUBTITLE_TRACK: "subtitleTrack"
    };
    var PlaylistLevelType = {
      MAIN: "main",
      AUDIO: "audio",
      SUBTITLE: "subtitle"
    };
    function mapContextToLevelType(context) {
      var type = context.type;
      switch (type) {
        case PlaylistContextType.AUDIO_TRACK:
          return PlaylistLevelType.AUDIO;
        case PlaylistContextType.SUBTITLE_TRACK:
          return PlaylistLevelType.SUBTITLE;
        default:
          return PlaylistLevelType.MAIN;
      }
    }
    function getResponseUrl(response, context) {
      var url = response.url;
      if (url === void 0 || url.indexOf("data:") === 0) {
        url = context.url;
      }
      return url;
    }
    var PlaylistLoader = /* @__PURE__ */ function() {
      function PlaylistLoader2(hls) {
        this.hls = void 0;
        this.loaders = /* @__PURE__ */ Object.create(null);
        this.variableList = null;
        this.hls = hls;
        this.registerListeners();
      }
      var _proto = PlaylistLoader2.prototype;
      _proto.startLoad = function startLoad(startPosition) {
      };
      _proto.stopLoad = function stopLoad() {
        this.destroyInternalLoaders();
      };
      _proto.registerListeners = function registerListeners() {
        var hls = this.hls;
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
        hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
        hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
      };
      _proto.unregisterListeners = function unregisterListeners() {
        var hls = this.hls;
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
        hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
        hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
      };
      _proto.createInternalLoader = function createInternalLoader(context) {
        var config = this.hls.config;
        var PLoader = config.pLoader;
        var Loader = config.loader;
        var InternalLoader = PLoader || Loader;
        var loader = new InternalLoader(config);
        this.loaders[context.type] = loader;
        return loader;
      };
      _proto.getInternalLoader = function getInternalLoader(context) {
        return this.loaders[context.type];
      };
      _proto.resetInternalLoader = function resetInternalLoader(contextType) {
        if (this.loaders[contextType]) {
          delete this.loaders[contextType];
        }
      };
      _proto.destroyInternalLoaders = function destroyInternalLoaders() {
        for (var contextType in this.loaders) {
          var loader = this.loaders[contextType];
          if (loader) {
            loader.destroy();
          }
          this.resetInternalLoader(contextType);
        }
      };
      _proto.destroy = function destroy() {
        this.variableList = null;
        this.unregisterListeners();
        this.destroyInternalLoaders();
      };
      _proto.onManifestLoading = function onManifestLoading(event, data) {
        var url = data.url;
        this.variableList = null;
        this.load({
          id: null,
          level: 0,
          responseType: "text",
          type: PlaylistContextType.MANIFEST,
          url,
          deliveryDirectives: null
        });
      };
      _proto.onLevelLoading = function onLevelLoading(event, data) {
        var id = data.id, level = data.level, pathwayId = data.pathwayId, url = data.url, deliveryDirectives = data.deliveryDirectives;
        this.load({
          id,
          level,
          pathwayId,
          responseType: "text",
          type: PlaylistContextType.LEVEL,
          url,
          deliveryDirectives
        });
      };
      _proto.onAudioTrackLoading = function onAudioTrackLoading(event, data) {
        var id = data.id, groupId = data.groupId, url = data.url, deliveryDirectives = data.deliveryDirectives;
        this.load({
          id,
          groupId,
          level: null,
          responseType: "text",
          type: PlaylistContextType.AUDIO_TRACK,
          url,
          deliveryDirectives
        });
      };
      _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(event, data) {
        var id = data.id, groupId = data.groupId, url = data.url, deliveryDirectives = data.deliveryDirectives;
        this.load({
          id,
          groupId,
          level: null,
          responseType: "text",
          type: PlaylistContextType.SUBTITLE_TRACK,
          url,
          deliveryDirectives
        });
      };
      _proto.load = function load(context) {
        var _context$deliveryDire, _this = this;
        var config = this.hls.config;
        var loader = this.getInternalLoader(context);
        if (loader) {
          var loaderContext = loader.context;
          if (loaderContext && loaderContext.url === context.url && loaderContext.level === context.level) {
            logger.trace("[playlist-loader]: playlist request ongoing");
            return;
          }
          logger.log("[playlist-loader]: aborting previous loader for type: " + context.type);
          loader.abort();
        }
        var loadPolicy;
        if (context.type === PlaylistContextType.MANIFEST) {
          loadPolicy = config.manifestLoadPolicy.default;
        } else {
          loadPolicy = _extends({}, config.playlistLoadPolicy.default, {
            timeoutRetry: null,
            errorRetry: null
          });
        }
        loader = this.createInternalLoader(context);
        if (isFiniteNumber((_context$deliveryDire = context.deliveryDirectives) == null ? void 0 : _context$deliveryDire.part)) {
          var levelDetails;
          if (context.type === PlaylistContextType.LEVEL && context.level !== null) {
            levelDetails = this.hls.levels[context.level].details;
          } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {
            levelDetails = this.hls.audioTracks[context.id].details;
          } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {
            levelDetails = this.hls.subtitleTracks[context.id].details;
          }
          if (levelDetails) {
            var partTarget = levelDetails.partTarget;
            var targetDuration = levelDetails.targetduration;
            if (partTarget && targetDuration) {
              var maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1e3;
              loadPolicy = _extends({}, loadPolicy, {
                maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),
                maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)
              });
            }
          }
        }
        var legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
        var loaderConfig = {
          loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
          retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
          maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
        };
        var loaderCallbacks = {
          onSuccess: function onSuccess(response, stats, context2, networkDetails) {
            var loader2 = _this.getInternalLoader(context2);
            _this.resetInternalLoader(context2.type);
            var string = response.data;
            if (string.indexOf("#EXTM3U") !== 0) {
              _this.handleManifestParsingError(response, context2, new Error("no EXTM3U delimiter"), networkDetails || null, stats);
              return;
            }
            stats.parsing.start = performance.now();
            if (M3U8Parser.isMediaPlaylist(string)) {
              _this.handleTrackOrLevelPlaylist(response, stats, context2, networkDetails || null, loader2);
            } else {
              _this.handleMasterPlaylist(response, stats, context2, networkDetails);
            }
          },
          onError: function onError(response, context2, networkDetails, stats) {
            _this.handleNetworkError(context2, networkDetails, false, response, stats);
          },
          onTimeout: function onTimeout(stats, context2, networkDetails) {
            _this.handleNetworkError(context2, networkDetails, true, void 0, stats);
          }
        };
        loader.load(context, loaderConfig, loaderCallbacks);
      };
      _proto.handleMasterPlaylist = function handleMasterPlaylist(response, stats, context, networkDetails) {
        var hls = this.hls;
        var string = response.data;
        var url = getResponseUrl(response, context);
        var parsedResult = M3U8Parser.parseMasterPlaylist(string, url);
        if (parsedResult.playlistParsingError) {
          this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);
          return;
        }
        var contentSteering = parsedResult.contentSteering, levels = parsedResult.levels, sessionData = parsedResult.sessionData, sessionKeys = parsedResult.sessionKeys, startTimeOffset = parsedResult.startTimeOffset, variableList = parsedResult.variableList;
        this.variableList = variableList;
        var _M3U8Parser$parseMast = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult), _M3U8Parser$parseMast2 = _M3U8Parser$parseMast.AUDIO, audioTracks = _M3U8Parser$parseMast2 === void 0 ? [] : _M3U8Parser$parseMast2, subtitles = _M3U8Parser$parseMast.SUBTITLES, captions = _M3U8Parser$parseMast["CLOSED-CAPTIONS"];
        if (audioTracks.length) {
          var embeddedAudioFound = audioTracks.some(function(audioTrack) {
            return !audioTrack.url;
          });
          if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
            logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one");
            audioTracks.unshift({
              type: "main",
              name: "main",
              groupId: "main",
              default: false,
              autoselect: false,
              forced: false,
              id: -1,
              attrs: new AttrList({}),
              bitrate: 0,
              url: ""
            });
          }
        }
        hls.trigger(Events.MANIFEST_LOADED, {
          levels,
          audioTracks,
          subtitles,
          captions,
          contentSteering,
          url,
          stats,
          networkDetails,
          sessionData,
          sessionKeys,
          startTimeOffset,
          variableList
        });
      };
      _proto.handleTrackOrLevelPlaylist = function handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {
        var hls = this.hls;
        var id = context.id, level = context.level, type = context.type;
        var url = getResponseUrl(response, context);
        var levelUrlId = 0;
        var levelId = isFiniteNumber(level) ? level : isFiniteNumber(id) ? id : 0;
        var levelType = mapContextToLevelType(context);
        var levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId, this.variableList);
        if (type === PlaylistContextType.MANIFEST) {
          var singleLevel = {
            attrs: new AttrList({}),
            bitrate: 0,
            details: levelDetails,
            name: "",
            url
          };
          hls.trigger(Events.MANIFEST_LOADED, {
            levels: [singleLevel],
            audioTracks: [],
            url,
            stats,
            networkDetails,
            sessionData: null,
            sessionKeys: null,
            contentSteering: null,
            startTimeOffset: null,
            variableList: null
          });
        }
        stats.parsing.end = performance.now();
        context.levelDetails = levelDetails;
        this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);
      };
      _proto.handleManifestParsingError = function handleManifestParsingError(response, context, error, networkDetails, stats) {
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.NETWORK_ERROR,
          details: ErrorDetails.MANIFEST_PARSING_ERROR,
          fatal: context.type === PlaylistContextType.MANIFEST,
          url: response.url,
          err: error,
          error,
          reason: error.message,
          response,
          context,
          networkDetails,
          stats
        });
      };
      _proto.handleNetworkError = function handleNetworkError(context, networkDetails, timeout, response, stats) {
        if (timeout === void 0) {
          timeout = false;
        }
        var message = "A network " + (timeout ? "timeout" : "error" + (response ? " (status " + response.code + ")" : "")) + " occurred while loading " + context.type;
        if (context.type === PlaylistContextType.LEVEL) {
          message += ": " + context.level + " id: " + context.id;
        } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {
          message += " id: " + context.id + ' group-id: "' + context.groupId + '"';
        }
        var error = new Error(message);
        logger.warn("[playlist-loader]: " + message);
        var details = ErrorDetails.UNKNOWN;
        var fatal = false;
        var loader = this.getInternalLoader(context);
        switch (context.type) {
          case PlaylistContextType.MANIFEST:
            details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;
            fatal = true;
            break;
          case PlaylistContextType.LEVEL:
            details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;
            fatal = false;
            break;
          case PlaylistContextType.AUDIO_TRACK:
            details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
            fatal = false;
            break;
          case PlaylistContextType.SUBTITLE_TRACK:
            details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;
            fatal = false;
            break;
        }
        if (loader) {
          this.resetInternalLoader(context.type);
        }
        var errorData = {
          type: ErrorTypes.NETWORK_ERROR,
          details,
          fatal,
          url: context.url,
          loader,
          context,
          error,
          networkDetails,
          stats
        };
        if (response) {
          var url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;
          errorData.response = _objectSpread2({
            url,
            data: void 0
          }, response);
        }
        this.hls.trigger(Events.ERROR, errorData);
      };
      _proto.handlePlaylistLoaded = function handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {
        var hls = this.hls;
        var type = context.type, level = context.level, id = context.id, groupId = context.groupId, deliveryDirectives = context.deliveryDirectives;
        var url = getResponseUrl(response, context);
        var parent = mapContextToLevelType(context);
        var levelIndex = typeof context.level === "number" && parent === PlaylistLevelType.MAIN ? level : void 0;
        if (!levelDetails.fragments.length) {
          var _error = new Error("No Segments found in Playlist");
          hls.trigger(Events.ERROR, {
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.LEVEL_EMPTY_ERROR,
            fatal: false,
            url,
            error: _error,
            reason: _error.message,
            response,
            context,
            level: levelIndex,
            parent,
            networkDetails,
            stats
          });
          return;
        }
        if (!levelDetails.targetduration) {
          levelDetails.playlistParsingError = new Error("Missing Target Duration");
        }
        var error = levelDetails.playlistParsingError;
        if (error) {
          hls.trigger(Events.ERROR, {
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.LEVEL_PARSING_ERROR,
            fatal: false,
            url,
            error,
            reason: error.message,
            response,
            context,
            level: levelIndex,
            parent,
            networkDetails,
            stats
          });
          return;
        }
        if (levelDetails.live && loader) {
          if (loader.getCacheAge) {
            levelDetails.ageHeader = loader.getCacheAge() || 0;
          }
          if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {
            levelDetails.ageHeader = 0;
          }
        }
        switch (type) {
          case PlaylistContextType.MANIFEST:
          case PlaylistContextType.LEVEL:
            hls.trigger(Events.LEVEL_LOADED, {
              details: levelDetails,
              level: levelIndex || 0,
              id: id || 0,
              stats,
              networkDetails,
              deliveryDirectives
            });
            break;
          case PlaylistContextType.AUDIO_TRACK:
            hls.trigger(Events.AUDIO_TRACK_LOADED, {
              details: levelDetails,
              id: id || 0,
              groupId: groupId || "",
              stats,
              networkDetails,
              deliveryDirectives
            });
            break;
          case PlaylistContextType.SUBTITLE_TRACK:
            hls.trigger(Events.SUBTITLE_TRACK_LOADED, {
              details: levelDetails,
              id: id || 0,
              groupId: groupId || "",
              stats,
              networkDetails,
              deliveryDirectives
            });
            break;
        }
      };
      return PlaylistLoader2;
    }();
    function sendAddTrackEvent(track, videoEl) {
      var event;
      try {
        event = new Event("addtrack");
      } catch (err) {
        event = document.createEvent("Event");
        event.initEvent("addtrack", false, false);
      }
      event.track = track;
      videoEl.dispatchEvent(event);
    }
    function addCueToTrack(track, cue) {
      var mode = track.mode;
      if (mode === "disabled") {
        track.mode = "hidden";
      }
      if (track.cues && !track.cues.getCueById(cue.id)) {
        try {
          track.addCue(cue);
          if (!track.cues.getCueById(cue.id)) {
            throw new Error("addCue is failed for: " + cue);
          }
        } catch (err) {
          logger.debug("[texttrack-utils]: " + err);
          try {
            var textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);
            textTrackCue.id = cue.id;
            track.addCue(textTrackCue);
          } catch (err2) {
            logger.debug("[texttrack-utils]: Legacy TextTrackCue fallback failed: " + err2);
          }
        }
      }
      if (mode === "disabled") {
        track.mode = mode;
      }
    }
    function clearCurrentCues(track) {
      var mode = track.mode;
      if (mode === "disabled") {
        track.mode = "hidden";
      }
      if (track.cues) {
        for (var i = track.cues.length; i--; ) {
          track.removeCue(track.cues[i]);
        }
      }
      if (mode === "disabled") {
        track.mode = mode;
      }
    }
    function removeCuesInRange(track, start, end, predicate) {
      var mode = track.mode;
      if (mode === "disabled") {
        track.mode = "hidden";
      }
      if (track.cues && track.cues.length > 0) {
        var cues = getCuesInRange(track.cues, start, end);
        for (var i = 0; i < cues.length; i++) {
          if (!predicate || predicate(cues[i])) {
            track.removeCue(cues[i]);
          }
        }
      }
      if (mode === "disabled") {
        track.mode = mode;
      }
    }
    function getFirstCueIndexAfterTime(cues, time) {
      if (time < cues[0].startTime) {
        return 0;
      }
      var len = cues.length - 1;
      if (time > cues[len].endTime) {
        return -1;
      }
      var left = 0;
      var right = len;
      while (left <= right) {
        var mid = Math.floor((right + left) / 2);
        if (time < cues[mid].startTime) {
          right = mid - 1;
        } else if (time > cues[mid].startTime && left < len) {
          left = mid + 1;
        } else {
          return mid;
        }
      }
      return cues[left].startTime - time < time - cues[right].startTime ? left : right;
    }
    function getCuesInRange(cues, start, end) {
      var cuesFound = [];
      var firstCueInRange = getFirstCueIndexAfterTime(cues, start);
      if (firstCueInRange > -1) {
        for (var i = firstCueInRange, len = cues.length; i < len; i++) {
          var _cue = cues[i];
          if (_cue.startTime >= start && _cue.endTime <= end) {
            cuesFound.push(_cue);
          } else if (_cue.startTime > end) {
            return cuesFound;
          }
        }
      }
      return cuesFound;
    }
    function filterSubtitleTracks(textTrackList) {
      var tracks = [];
      for (var i = 0; i < textTrackList.length; i++) {
        var track = textTrackList[i];
        if ((track.kind === "subtitles" || track.kind === "captions") && track.label) {
          tracks.push(textTrackList[i]);
        }
      }
      return tracks;
    }
    var MetadataSchema = {
      audioId3: "org.id3",
      dateRange: "com.apple.quicktime.HLS",
      emsg: "https://aomedia.org/emsg/ID3"
    };
    var MIN_CUE_DURATION = 0.25;
    function getCueClass() {
      if (typeof self === "undefined")
        return void 0;
      return self.VTTCue || self.TextTrackCue;
    }
    function createCueWithDataFields(Cue, startTime, endTime, data, type) {
      var cue = new Cue(startTime, endTime, "");
      try {
        cue.value = data;
        if (type) {
          cue.type = type;
        }
      } catch (e) {
        cue = new Cue(startTime, endTime, JSON.stringify(type ? _objectSpread2({
          type
        }, data) : data));
      }
      return cue;
    }
    var MAX_CUE_ENDTIME = function() {
      var Cue = getCueClass();
      try {
        Cue && new Cue(0, Number.POSITIVE_INFINITY, "");
      } catch (e) {
        return Number.MAX_VALUE;
      }
      return Number.POSITIVE_INFINITY;
    }();
    function dateRangeDateToTimelineSeconds(date, offset) {
      return date.getTime() / 1e3 - offset;
    }
    function hexToArrayBuffer(str) {
      return Uint8Array.from(str.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer;
    }
    var ID3TrackController = /* @__PURE__ */ function() {
      function ID3TrackController2(hls) {
        this.hls = void 0;
        this.id3Track = null;
        this.media = null;
        this.dateRangeCuesAppended = {};
        this.hls = hls;
        this._registerListeners();
      }
      var _proto = ID3TrackController2.prototype;
      _proto.destroy = function destroy() {
        this._unregisterListeners();
        this.id3Track = null;
        this.media = null;
        this.dateRangeCuesAppended = {};
        this.hls = null;
      };
      _proto._registerListeners = function _registerListeners() {
        var hls = this.hls;
        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
      };
      _proto._unregisterListeners = function _unregisterListeners() {
        var hls = this.hls;
        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
      };
      _proto.onMediaAttached = function onMediaAttached(event, data) {
        this.media = data.media;
      };
      _proto.onMediaDetaching = function onMediaDetaching() {
        if (!this.id3Track) {
          return;
        }
        clearCurrentCues(this.id3Track);
        this.id3Track = null;
        this.media = null;
        this.dateRangeCuesAppended = {};
      };
      _proto.onManifestLoading = function onManifestLoading() {
        this.dateRangeCuesAppended = {};
      };
      _proto.createTrack = function createTrack(media) {
        var track = this.getID3Track(media.textTracks);
        track.mode = "hidden";
        return track;
      };
      _proto.getID3Track = function getID3Track(textTracks) {
        if (!this.media) {
          return;
        }
        for (var i = 0; i < textTracks.length; i++) {
          var textTrack = textTracks[i];
          if (textTrack.kind === "metadata" && textTrack.label === "id3") {
            sendAddTrackEvent(textTrack, this.media);
            return textTrack;
          }
        }
        return this.media.addTextTrack("metadata", "id3");
      };
      _proto.onFragParsingMetadata = function onFragParsingMetadata(event, data) {
        if (!this.media) {
          return;
        }
        var _this$hls$config = this.hls.config, enableEmsgMetadataCues = _this$hls$config.enableEmsgMetadataCues, enableID3MetadataCues = _this$hls$config.enableID3MetadataCues;
        if (!enableEmsgMetadataCues && !enableID3MetadataCues) {
          return;
        }
        var samples = data.samples;
        if (!this.id3Track) {
          this.id3Track = this.createTrack(this.media);
        }
        var Cue = getCueClass();
        if (!Cue) {
          return;
        }
        for (var i = 0; i < samples.length; i++) {
          var type = samples[i].type;
          if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {
            continue;
          }
          var frames = getID3Frames(samples[i].data);
          if (frames) {
            var startTime = samples[i].pts;
            var endTime = startTime + samples[i].duration;
            if (endTime > MAX_CUE_ENDTIME) {
              endTime = MAX_CUE_ENDTIME;
            }
            var timeDiff = endTime - startTime;
            if (timeDiff <= 0) {
              endTime = startTime + MIN_CUE_DURATION;
            }
            for (var j = 0; j < frames.length; j++) {
              var frame = frames[j];
              if (!isTimeStampFrame(frame)) {
                this.updateId3CueEnds(startTime, type);
                var cue = createCueWithDataFields(Cue, startTime, endTime, frame, type);
                if (cue) {
                  this.id3Track.addCue(cue);
                }
              }
            }
          }
        }
      };
      _proto.updateId3CueEnds = function updateId3CueEnds(startTime, type) {
        var _this$id3Track;
        var cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;
        if (cues) {
          for (var i = cues.length; i--; ) {
            var cue = cues[i];
            if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {
              cue.endTime = startTime;
            }
          }
        }
      };
      _proto.onBufferFlushing = function onBufferFlushing(event, _ref) {
        var startOffset = _ref.startOffset, endOffset = _ref.endOffset, type = _ref.type;
        var id3Track = this.id3Track, hls = this.hls;
        if (!hls) {
          return;
        }
        var _hls$config = hls.config, enableEmsgMetadataCues = _hls$config.enableEmsgMetadataCues, enableID3MetadataCues = _hls$config.enableID3MetadataCues;
        if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {
          var predicate;
          if (type === "audio") {
            predicate = function predicate2(cue) {
              return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;
            };
          } else if (type === "video") {
            predicate = function predicate2(cue) {
              return cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
            };
          } else {
            predicate = function predicate2(cue) {
              return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
            };
          }
          removeCuesInRange(id3Track, startOffset, endOffset, predicate);
        }
      };
      _proto.onLevelUpdated = function onLevelUpdated(event, _ref2) {
        var _this = this;
        var details = _ref2.details;
        if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {
          return;
        }
        var dateRangeCuesAppended = this.dateRangeCuesAppended, id3Track = this.id3Track;
        var dateRanges = details.dateRanges;
        var ids = Object.keys(dateRanges);
        if (id3Track) {
          var idsToRemove = Object.keys(dateRangeCuesAppended).filter(function(id) {
            return !ids.includes(id);
          });
          var _loop = function _loop3() {
            var id = idsToRemove[i];
            Object.keys(dateRangeCuesAppended[id].cues).forEach(function(key) {
              id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);
            });
            delete dateRangeCuesAppended[id];
          };
          for (var i = idsToRemove.length; i--; ) {
            _loop();
          }
        }
        var lastFragment = details.fragments[details.fragments.length - 1];
        if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {
          return;
        }
        if (!this.id3Track) {
          this.id3Track = this.createTrack(this.media);
        }
        var dateTimeOffset = lastFragment.programDateTime / 1e3 - lastFragment.start;
        var Cue = getCueClass();
        var _loop2 = function _loop22() {
          var id = ids[_i];
          var dateRange = dateRanges[id];
          var startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);
          var appendedDateRangeCues = dateRangeCuesAppended[id];
          var cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};
          var durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;
          var endTime = MAX_CUE_ENDTIME;
          var endDate = dateRange.endDate;
          if (endDate) {
            endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);
            durationKnown = true;
          } else if (dateRange.endOnNext && !durationKnown) {
            var nextDateRangeWithSameClass = ids.reduce(function(candidateDateRange, id2) {
              if (id2 !== dateRange.id) {
                var otherDateRange = dateRanges[id2];
                if (otherDateRange.class === dateRange.class && otherDateRange.startDate > dateRange.startDate && (!candidateDateRange || dateRange.startDate < candidateDateRange.startDate)) {
                  return otherDateRange;
                }
              }
              return candidateDateRange;
            }, null);
            if (nextDateRangeWithSameClass) {
              endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);
              durationKnown = true;
            }
          }
          var attributes = Object.keys(dateRange.attr);
          for (var j = 0; j < attributes.length; j++) {
            var key = attributes[j];
            if (!isDateRangeCueAttribute(key)) {
              continue;
            }
            var cue = cues[key];
            if (cue) {
              if (durationKnown && !appendedDateRangeCues.durationKnown) {
                cue.endTime = endTime;
              }
            } else if (Cue) {
              var data = dateRange.attr[key];
              if (isSCTE35Attribute(key)) {
                data = hexToArrayBuffer(data);
              }
              var _cue = createCueWithDataFields(Cue, startTime, endTime, {
                key,
                data
              }, MetadataSchema.dateRange);
              if (_cue) {
                _cue.id = id;
                _this.id3Track.addCue(_cue);
                cues[key] = _cue;
              }
            }
          }
          dateRangeCuesAppended[id] = {
            cues,
            dateRange,
            durationKnown
          };
        };
        for (var _i = 0; _i < ids.length; _i++) {
          _loop2();
        }
      };
      return ID3TrackController2;
    }();
    var LatencyController = /* @__PURE__ */ function() {
      function LatencyController2(hls) {
        var _this = this;
        this.hls = void 0;
        this.config = void 0;
        this.media = null;
        this.levelDetails = null;
        this.currentTime = 0;
        this.stallCount = 0;
        this._latency = null;
        this.timeupdateHandler = function() {
          return _this.timeupdate();
        };
        this.hls = hls;
        this.config = hls.config;
        this.registerListeners();
      }
      var _proto = LatencyController2.prototype;
      _proto.destroy = function destroy() {
        this.unregisterListeners();
        this.onMediaDetaching();
        this.levelDetails = null;
        this.hls = this.timeupdateHandler = null;
      };
      _proto.registerListeners = function registerListeners() {
        this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        this.hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
        this.hls.on(Events.ERROR, this.onError, this);
      };
      _proto.unregisterListeners = function unregisterListeners() {
        this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        this.hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
        this.hls.off(Events.ERROR, this.onError, this);
      };
      _proto.onMediaAttached = function onMediaAttached(event, data) {
        this.media = data.media;
        this.media.addEventListener("timeupdate", this.timeupdateHandler);
      };
      _proto.onMediaDetaching = function onMediaDetaching() {
        if (this.media) {
          this.media.removeEventListener("timeupdate", this.timeupdateHandler);
          this.media = null;
        }
      };
      _proto.onManifestLoading = function onManifestLoading() {
        this.levelDetails = null;
        this._latency = null;
        this.stallCount = 0;
      };
      _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {
        var details = _ref.details;
        this.levelDetails = details;
        if (details.advanced) {
          this.timeupdate();
        }
        if (!details.live && this.media) {
          this.media.removeEventListener("timeupdate", this.timeupdateHandler);
        }
      };
      _proto.onError = function onError(event, data) {
        var _this$levelDetails;
        if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {
          return;
        }
        this.stallCount++;
        if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {
          logger.warn("[playback-rate-controller]: Stall detected, adjusting target latency");
        }
      };
      _proto.timeupdate = function timeupdate() {
        var media = this.media, levelDetails = this.levelDetails;
        if (!media || !levelDetails) {
          return;
        }
        this.currentTime = media.currentTime;
        var latency = this.computeLatency();
        if (latency === null) {
          return;
        }
        this._latency = latency;
        var _this$config = this.config, lowLatencyMode = _this$config.lowLatencyMode, maxLiveSyncPlaybackRate = _this$config.maxLiveSyncPlaybackRate;
        if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1 || !levelDetails.live) {
          return;
        }
        var targetLatency = this.targetLatency;
        if (targetLatency === null) {
          return;
        }
        var distanceFromTarget = latency - targetLatency;
        var liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);
        var inLiveRange = distanceFromTarget < liveMinLatencyDuration;
        if (inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {
          var max = Math.min(2, Math.max(1, maxLiveSyncPlaybackRate));
          var rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;
          media.playbackRate = Math.min(max, Math.max(1, rate));
        } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {
          media.playbackRate = 1;
        }
      };
      _proto.estimateLiveEdge = function estimateLiveEdge() {
        var levelDetails = this.levelDetails;
        if (levelDetails === null) {
          return null;
        }
        return levelDetails.edge + levelDetails.age;
      };
      _proto.computeLatency = function computeLatency() {
        var liveEdge = this.estimateLiveEdge();
        if (liveEdge === null) {
          return null;
        }
        return liveEdge - this.currentTime;
      };
      _createClass(LatencyController2, [{
        key: "latency",
        get: function get() {
          return this._latency || 0;
        }
      }, {
        key: "maxLatency",
        get: function get() {
          var config = this.config, levelDetails = this.levelDetails;
          if (config.liveMaxLatencyDuration !== void 0) {
            return config.liveMaxLatencyDuration;
          }
          return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;
        }
      }, {
        key: "targetLatency",
        get: function get() {
          var levelDetails = this.levelDetails;
          if (levelDetails === null) {
            return null;
          }
          var holdBack = levelDetails.holdBack, partHoldBack = levelDetails.partHoldBack, targetduration = levelDetails.targetduration;
          var _this$config2 = this.config, liveSyncDuration = _this$config2.liveSyncDuration, liveSyncDurationCount = _this$config2.liveSyncDurationCount, lowLatencyMode = _this$config2.lowLatencyMode;
          var userConfig = this.hls.userConfig;
          var targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;
          if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {
            targetLatency = liveSyncDuration !== void 0 ? liveSyncDuration : liveSyncDurationCount * targetduration;
          }
          var maxLiveSyncOnStallIncrease = targetduration;
          var liveSyncOnStallIncrease = 1;
          return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);
        }
      }, {
        key: "liveSyncPosition",
        get: function get() {
          var liveEdge = this.estimateLiveEdge();
          var targetLatency = this.targetLatency;
          var levelDetails = this.levelDetails;
          if (liveEdge === null || targetLatency === null || levelDetails === null) {
            return null;
          }
          var edge = levelDetails.edge;
          var syncPosition = liveEdge - targetLatency - this.edgeStalled;
          var min = edge - levelDetails.totalduration;
          var max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);
          return Math.min(Math.max(min, syncPosition), max);
        }
      }, {
        key: "drift",
        get: function get() {
          var levelDetails = this.levelDetails;
          if (levelDetails === null) {
            return 1;
          }
          return levelDetails.drift;
        }
      }, {
        key: "edgeStalled",
        get: function get() {
          var levelDetails = this.levelDetails;
          if (levelDetails === null) {
            return 0;
          }
          var maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;
          return Math.max(levelDetails.age - maxLevelUpdateAge, 0);
        }
      }, {
        key: "forwardBufferLength",
        get: function get() {
          var media = this.media, levelDetails = this.levelDetails;
          if (!media || !levelDetails) {
            return 0;
          }
          var bufferedRanges = media.buffered.length;
          return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;
        }
      }]);
      return LatencyController2;
    }();
    var HdcpLevels = ["NONE", "TYPE-0", "TYPE-1", null];
    function isHdcpLevel(value) {
      return HdcpLevels.indexOf(value) > -1;
    }
    var VideoRangeValues = ["SDR", "PQ", "HLG"];
    function isVideoRange(value) {
      return !!value && VideoRangeValues.indexOf(value) > -1;
    }
    var HlsSkip = {
      No: "",
      Yes: "YES",
      v2: "v2"
    };
    function getSkipValue(details, msn) {
      var canSkipUntil = details.canSkipUntil, canSkipDateRanges = details.canSkipDateRanges, endSN = details.endSN;
      var snChangeGoal = msn !== void 0 ? msn - endSN : 0;
      if (canSkipUntil && snChangeGoal < canSkipUntil) {
        if (canSkipDateRanges) {
          return HlsSkip.v2;
        }
        return HlsSkip.Yes;
      }
      return HlsSkip.No;
    }
    var HlsUrlParameters = /* @__PURE__ */ function() {
      function HlsUrlParameters2(msn, part, skip) {
        this.msn = void 0;
        this.part = void 0;
        this.skip = void 0;
        this.msn = msn;
        this.part = part;
        this.skip = skip;
      }
      var _proto = HlsUrlParameters2.prototype;
      _proto.addDirectives = function addDirectives(uri) {
        var url = new self.URL(uri);
        if (this.msn !== void 0) {
          url.searchParams.set("_HLS_msn", this.msn.toString());
        }
        if (this.part !== void 0) {
          url.searchParams.set("_HLS_part", this.part.toString());
        }
        if (this.skip) {
          url.searchParams.set("_HLS_skip", this.skip);
        }
        return url.href;
      };
      return HlsUrlParameters2;
    }();
    var Level = /* @__PURE__ */ function() {
      function Level2(data) {
        this._attrs = void 0;
        this.audioCodec = void 0;
        this.bitrate = void 0;
        this.codecSet = void 0;
        this.url = void 0;
        this.frameRate = void 0;
        this.height = void 0;
        this.id = void 0;
        this.name = void 0;
        this.videoCodec = void 0;
        this.width = void 0;
        this.details = void 0;
        this.fragmentError = 0;
        this.loadError = 0;
        this.loaded = void 0;
        this.realBitrate = 0;
        this.supportedPromise = void 0;
        this.supportedResult = void 0;
        this._avgBitrate = 0;
        this._audioGroups = void 0;
        this._subtitleGroups = void 0;
        this._urlId = 0;
        this.url = [data.url];
        this._attrs = [data.attrs];
        this.bitrate = data.bitrate;
        if (data.details) {
          this.details = data.details;
        }
        this.id = data.id || 0;
        this.name = data.name;
        this.width = data.width || 0;
        this.height = data.height || 0;
        this.frameRate = data.attrs.optionalFloat("FRAME-RATE", 0);
        this._avgBitrate = data.attrs.decimalInteger("AVERAGE-BANDWIDTH");
        this.audioCodec = data.audioCodec;
        this.videoCodec = data.videoCodec;
        this.codecSet = [data.videoCodec, data.audioCodec].filter(function(c) {
          return !!c;
        }).map(function(s) {
          return s.substring(0, 4);
        }).join(",");
        this.addGroupId("audio", data.attrs.AUDIO);
        this.addGroupId("text", data.attrs.SUBTITLES);
      }
      var _proto2 = Level2.prototype;
      _proto2.hasAudioGroup = function hasAudioGroup(groupId) {
        return hasGroup(this._audioGroups, groupId);
      };
      _proto2.hasSubtitleGroup = function hasSubtitleGroup(groupId) {
        return hasGroup(this._subtitleGroups, groupId);
      };
      _proto2.addGroupId = function addGroupId(type, groupId) {
        if (!groupId) {
          return;
        }
        if (type === "audio") {
          var audioGroups = this._audioGroups;
          if (!audioGroups) {
            audioGroups = this._audioGroups = [];
          }
          if (audioGroups.indexOf(groupId) === -1) {
            audioGroups.push(groupId);
          }
        } else if (type === "text") {
          var subtitleGroups = this._subtitleGroups;
          if (!subtitleGroups) {
            subtitleGroups = this._subtitleGroups = [];
          }
          if (subtitleGroups.indexOf(groupId) === -1) {
            subtitleGroups.push(groupId);
          }
        }
      };
      _proto2.addFallback = function addFallback() {
      };
      _createClass(Level2, [{
        key: "maxBitrate",
        get: function get() {
          return Math.max(this.realBitrate, this.bitrate);
        }
      }, {
        key: "averageBitrate",
        get: function get() {
          return this._avgBitrate || this.realBitrate || this.bitrate;
        }
      }, {
        key: "attrs",
        get: function get() {
          return this._attrs[0];
        }
      }, {
        key: "codecs",
        get: function get() {
          return this.attrs.CODECS || "";
        }
      }, {
        key: "pathwayId",
        get: function get() {
          return this.attrs["PATHWAY-ID"] || ".";
        }
      }, {
        key: "videoRange",
        get: function get() {
          return this.attrs["VIDEO-RANGE"] || "SDR";
        }
      }, {
        key: "score",
        get: function get() {
          return this.attrs.optionalFloat("SCORE", 0);
        }
      }, {
        key: "uri",
        get: function get() {
          return this.url[0] || "";
        }
      }, {
        key: "audioGroups",
        get: function get() {
          return this._audioGroups;
        }
      }, {
        key: "subtitleGroups",
        get: function get() {
          return this._subtitleGroups;
        }
      }, {
        key: "urlId",
        get: function get() {
          return 0;
        },
        set: function set(value) {
        }
      }, {
        key: "audioGroupIds",
        get: function get() {
          return this.audioGroups ? [this.audioGroupId] : void 0;
        }
      }, {
        key: "textGroupIds",
        get: function get() {
          return this.subtitleGroups ? [this.textGroupId] : void 0;
        }
      }, {
        key: "audioGroupId",
        get: function get() {
          var _this$audioGroups;
          return (_this$audioGroups = this.audioGroups) == null ? void 0 : _this$audioGroups[0];
        }
      }, {
        key: "textGroupId",
        get: function get() {
          var _this$subtitleGroups;
          return (_this$subtitleGroups = this.subtitleGroups) == null ? void 0 : _this$subtitleGroups[0];
        }
      }]);
      return Level2;
    }();
    function hasGroup(groups, groupId) {
      if (!groupId || !groups) {
        return false;
      }
      return groups.indexOf(groupId) !== -1;
    }
    function updateFromToPTS(fragFrom, fragTo) {
      var fragToPTS = fragTo.startPTS;
      if (isFiniteNumber(fragToPTS)) {
        var duration = 0;
        var frag;
        if (fragTo.sn > fragFrom.sn) {
          duration = fragToPTS - fragFrom.start;
          frag = fragFrom;
        } else {
          duration = fragFrom.start - fragToPTS;
          frag = fragTo;
        }
        if (frag.duration !== duration) {
          frag.duration = duration;
        }
      } else if (fragTo.sn > fragFrom.sn) {
        var contiguous = fragFrom.cc === fragTo.cc;
        if (contiguous && fragFrom.minEndPTS) {
          fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);
        } else {
          fragTo.start = fragFrom.start + fragFrom.duration;
        }
      } else {
        fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
      }
    }
    function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
      var parsedMediaDuration = endPTS - startPTS;
      if (parsedMediaDuration <= 0) {
        logger.warn("Fragment should have a positive duration", frag);
        endPTS = startPTS + frag.duration;
        endDTS = startDTS + frag.duration;
      }
      var maxStartPTS = startPTS;
      var minEndPTS = endPTS;
      var fragStartPts = frag.startPTS;
      var fragEndPts = frag.endPTS;
      if (isFiniteNumber(fragStartPts)) {
        var deltaPTS = Math.abs(fragStartPts - startPTS);
        if (!isFiniteNumber(frag.deltaPTS)) {
          frag.deltaPTS = deltaPTS;
        } else {
          frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
        }
        maxStartPTS = Math.max(startPTS, fragStartPts);
        startPTS = Math.min(startPTS, fragStartPts);
        startDTS = Math.min(startDTS, frag.startDTS);
        minEndPTS = Math.min(endPTS, fragEndPts);
        endPTS = Math.max(endPTS, fragEndPts);
        endDTS = Math.max(endDTS, frag.endDTS);
      }
      var drift = startPTS - frag.start;
      if (frag.start !== 0) {
        frag.start = startPTS;
      }
      frag.duration = endPTS - frag.start;
      frag.startPTS = startPTS;
      frag.maxStartPTS = maxStartPTS;
      frag.startDTS = startDTS;
      frag.endPTS = endPTS;
      frag.minEndPTS = minEndPTS;
      frag.endDTS = endDTS;
      var sn = frag.sn;
      if (!details || sn < details.startSN || sn > details.endSN) {
        return 0;
      }
      var i;
      var fragIdx = sn - details.startSN;
      var fragments = details.fragments;
      fragments[fragIdx] = frag;
      for (i = fragIdx; i > 0; i--) {
        updateFromToPTS(fragments[i], fragments[i - 1]);
      }
      for (i = fragIdx; i < fragments.length - 1; i++) {
        updateFromToPTS(fragments[i], fragments[i + 1]);
      }
      if (details.fragmentHint) {
        updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);
      }
      details.PTSKnown = details.alignedSliding = true;
      return drift;
    }
    function mergeDetails(oldDetails, newDetails) {
      var currentInitSegment = null;
      var oldFragments = oldDetails.fragments;
      for (var i = oldFragments.length - 1; i >= 0; i--) {
        var oldInit = oldFragments[i].initSegment;
        if (oldInit) {
          currentInitSegment = oldInit;
          break;
        }
      }
      if (oldDetails.fragmentHint) {
        delete oldDetails.fragmentHint.endPTS;
      }
      var ccOffset = 0;
      var PTSFrag;
      mapFragmentIntersection(oldDetails, newDetails, function(oldFrag, newFrag) {
        if (oldFrag.relurl) {
          ccOffset = oldFrag.cc - newFrag.cc;
        }
        if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {
          newFrag.start = newFrag.startPTS = oldFrag.startPTS;
          newFrag.startDTS = oldFrag.startDTS;
          newFrag.maxStartPTS = oldFrag.maxStartPTS;
          newFrag.endPTS = oldFrag.endPTS;
          newFrag.endDTS = oldFrag.endDTS;
          newFrag.minEndPTS = oldFrag.minEndPTS;
          newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;
          if (newFrag.duration) {
            PTSFrag = newFrag;
          }
          newDetails.PTSKnown = newDetails.alignedSliding = true;
        }
        newFrag.elementaryStreams = oldFrag.elementaryStreams;
        newFrag.loader = oldFrag.loader;
        newFrag.stats = oldFrag.stats;
        if (oldFrag.initSegment) {
          newFrag.initSegment = oldFrag.initSegment;
          currentInitSegment = oldFrag.initSegment;
        }
      });
      if (currentInitSegment) {
        var fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
        fragmentsToCheck.forEach(function(frag) {
          var _currentInitSegment;
          if (frag && (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl))) {
            frag.initSegment = currentInitSegment;
          }
        });
      }
      if (newDetails.skippedSegments) {
        newDetails.deltaUpdateFailed = newDetails.fragments.some(function(frag) {
          return !frag;
        });
        if (newDetails.deltaUpdateFailed) {
          logger.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
          for (var _i = newDetails.skippedSegments; _i--; ) {
            newDetails.fragments.shift();
          }
          newDetails.startSN = newDetails.fragments[0].sn;
          newDetails.startCC = newDetails.fragments[0].cc;
        } else if (newDetails.canSkipDateRanges) {
          newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);
        }
      }
      var newFragments = newDetails.fragments;
      if (ccOffset) {
        logger.warn("discontinuity sliding from playlist, take drift into account");
        for (var _i2 = 0; _i2 < newFragments.length; _i2++) {
          newFragments[_i2].cc += ccOffset;
        }
      }
      if (newDetails.skippedSegments) {
        newDetails.startCC = newDetails.fragments[0].cc;
      }
      mapPartIntersection(oldDetails.partList, newDetails.partList, function(oldPart, newPart) {
        newPart.elementaryStreams = oldPart.elementaryStreams;
        newPart.stats = oldPart.stats;
      });
      if (PTSFrag) {
        updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
      } else {
        adjustSliding(oldDetails, newDetails);
      }
      if (newFragments.length) {
        newDetails.totalduration = newDetails.edge - newFragments[0].start;
      }
      newDetails.driftStartTime = oldDetails.driftStartTime;
      newDetails.driftStart = oldDetails.driftStart;
      var advancedDateTime = newDetails.advancedDateTime;
      if (newDetails.advanced && advancedDateTime) {
        var edge = newDetails.edge;
        if (!newDetails.driftStart) {
          newDetails.driftStartTime = advancedDateTime;
          newDetails.driftStart = edge;
        }
        newDetails.driftEndTime = advancedDateTime;
        newDetails.driftEnd = edge;
      } else {
        newDetails.driftEndTime = oldDetails.driftEndTime;
        newDetails.driftEnd = oldDetails.driftEnd;
        newDetails.advancedDateTime = oldDetails.advancedDateTime;
      }
    }
    function mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {
      var dateRanges = _extends({}, oldDateRanges);
      if (recentlyRemovedDateranges) {
        recentlyRemovedDateranges.forEach(function(id) {
          delete dateRanges[id];
        });
      }
      Object.keys(deltaDateRanges).forEach(function(id) {
        var dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);
        if (dateRange.isValid) {
          dateRanges[id] = dateRange;
        } else {
          logger.warn('Ignoring invalid Playlist Delta Update DATERANGE tag: "' + JSON.stringify(deltaDateRanges[id].attr) + '"');
        }
      });
      return dateRanges;
    }
    function mapPartIntersection(oldParts, newParts, intersectionFn) {
      if (oldParts && newParts) {
        var delta = 0;
        for (var i = 0, len = oldParts.length; i <= len; i++) {
          var _oldPart = oldParts[i];
          var _newPart = newParts[i + delta];
          if (_oldPart && _newPart && _oldPart.index === _newPart.index && _oldPart.fragment.sn === _newPart.fragment.sn) {
            intersectionFn(_oldPart, _newPart);
          } else {
            delta--;
          }
        }
      }
    }
    function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {
      var skippedSegments = newDetails.skippedSegments;
      var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;
      var end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;
      var delta = newDetails.startSN - oldDetails.startSN;
      var newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
      var oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;
      for (var i = start; i <= end; i++) {
        var _oldFrag = oldFrags[delta + i];
        var _newFrag = newFrags[i];
        if (skippedSegments && !_newFrag && i < skippedSegments) {
          _newFrag = newDetails.fragments[i] = _oldFrag;
        }
        if (_oldFrag && _newFrag) {
          intersectionFn(_oldFrag, _newFrag);
        }
      }
    }
    function adjustSliding(oldDetails, newDetails) {
      var delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;
      var oldFragments = oldDetails.fragments;
      if (delta < 0 || delta >= oldFragments.length) {
        return;
      }
      addSliding(newDetails, oldFragments[delta].start);
    }
    function addSliding(details, start) {
      if (start) {
        var fragments = details.fragments;
        for (var i = details.skippedSegments; i < fragments.length; i++) {
          fragments[i].start += start;
        }
        if (details.fragmentHint) {
          details.fragmentHint.start += start;
        }
      }
    }
    function computeReloadInterval(newDetails, distanceToLiveEdgeMs) {
      if (distanceToLiveEdgeMs === void 0) {
        distanceToLiveEdgeMs = Infinity;
      }
      var reloadInterval = 1e3 * newDetails.targetduration;
      if (newDetails.updated) {
        var fragments = newDetails.fragments;
        var liveEdgeMaxTargetDurations = 4;
        if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {
          var lastSegmentDuration = fragments[fragments.length - 1].duration * 1e3;
          if (lastSegmentDuration < reloadInterval) {
            reloadInterval = lastSegmentDuration;
          }
        }
      } else {
        reloadInterval /= 2;
      }
      return Math.round(reloadInterval);
    }
    function getFragmentWithSN(level, sn, fragCurrent) {
      if (!(level != null && level.details)) {
        return null;
      }
      var levelDetails = level.details;
      var fragment = levelDetails.fragments[sn - levelDetails.startSN];
      if (fragment) {
        return fragment;
      }
      fragment = levelDetails.fragmentHint;
      if (fragment && fragment.sn === sn) {
        return fragment;
      }
      if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {
        return fragCurrent;
      }
      return null;
    }
    function getPartWith(level, sn, partIndex) {
      var _level$details;
      if (!(level != null && level.details)) {
        return null;
      }
      return findPart((_level$details = level.details) == null ? void 0 : _level$details.partList, sn, partIndex);
    }
    function findPart(partList, sn, partIndex) {
      if (partList) {
        for (var i = partList.length; i--; ) {
          var part = partList[i];
          if (part.index === partIndex && part.fragment.sn === sn) {
            return part;
          }
        }
      }
      return null;
    }
    function reassignFragmentLevelIndexes(levels) {
      levels.forEach(function(level, index) {
        var details = level.details;
        if (details != null && details.fragments) {
          details.fragments.forEach(function(fragment) {
            fragment.level = index;
          });
        }
      });
    }
    function isTimeoutError(error) {
      switch (error.details) {
        case ErrorDetails.FRAG_LOAD_TIMEOUT:
        case ErrorDetails.KEY_LOAD_TIMEOUT:
        case ErrorDetails.LEVEL_LOAD_TIMEOUT:
        case ErrorDetails.MANIFEST_LOAD_TIMEOUT:
          return true;
      }
      return false;
    }
    function getRetryConfig(loadPolicy, error) {
      var isTimeout = isTimeoutError(error);
      return loadPolicy.default[(isTimeout ? "timeout" : "error") + "Retry"];
    }
    function getRetryDelay(retryConfig, retryCount) {
      var backoffFactor = retryConfig.backoff === "linear" ? 1 : Math.pow(2, retryCount);
      return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);
    }
    function getLoaderConfigWithoutReties(loderConfig) {
      return _objectSpread2(_objectSpread2({}, loderConfig), {
        errorRetry: null,
        timeoutRetry: null
      });
    }
    function shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse) {
      if (!retryConfig) {
        return false;
      }
      var httpStatus = loaderResponse == null ? void 0 : loaderResponse.code;
      var retry = retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);
      return retryConfig.shouldRetry ? retryConfig.shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse, retry) : retry;
    }
    function retryForHttpStatus(httpStatus) {
      return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);
    }
    var BinarySearch = {
      /**
       * Searches for an item in an array which matches a certain condition.
       * This requires the condition to only match one item in the array,
       * and for the array to be ordered.
       *
       * @param list The array to search.
       * @param comparisonFn
       *      Called and provided a candidate item as the first argument.
       *      Should return:
       *          > -1 if the item should be located at a lower index than the provided item.
       *          > 1 if the item should be located at a higher index than the provided item.
       *          > 0 if the item is the item you're looking for.
       *
       * @returns the object if found, otherwise returns null
       */
      search: function search(list, comparisonFn) {
        var minIndex = 0;
        var maxIndex = list.length - 1;
        var currentIndex = null;
        var currentElement = null;
        while (minIndex <= maxIndex) {
          currentIndex = (minIndex + maxIndex) / 2 | 0;
          currentElement = list[currentIndex];
          var comparisonResult = comparisonFn(currentElement);
          if (comparisonResult > 0) {
            minIndex = currentIndex + 1;
          } else if (comparisonResult < 0) {
            maxIndex = currentIndex - 1;
          } else {
            return currentElement;
          }
        }
        return null;
      }
    };
    function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
      if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {
        return null;
      }
      var startPDT = fragments[0].programDateTime;
      if (PDTValue < (startPDT || 0)) {
        return null;
      }
      var endPDT = fragments[fragments.length - 1].endProgramDateTime;
      if (PDTValue >= (endPDT || 0)) {
        return null;
      }
      maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
      for (var seg = 0; seg < fragments.length; ++seg) {
        var frag = fragments[seg];
        if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
          return frag;
        }
      }
      return null;
    }
    function findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance) {
      if (bufferEnd === void 0) {
        bufferEnd = 0;
      }
      if (maxFragLookUpTolerance === void 0) {
        maxFragLookUpTolerance = 0;
      }
      var fragNext = null;
      if (fragPrevious) {
        fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;
        var bufferEdgeError = fragPrevious.endDTS - bufferEnd;
        if (bufferEdgeError > 0 && bufferEdgeError < 15e-7) {
          bufferEnd += 15e-7;
        }
      } else if (bufferEnd === 0 && fragments[0].start === 0) {
        fragNext = fragments[0];
      }
      if (fragNext && (!fragPrevious || fragPrevious.level === fragNext.level) && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {
        return fragNext;
      }
      var foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
      if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {
        return foundFragment;
      }
      return fragNext;
    }
    function fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {
      if (bufferEnd === void 0) {
        bufferEnd = 0;
      }
      if (maxFragLookUpTolerance === void 0) {
        maxFragLookUpTolerance = 0;
      }
      if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {
        return 0;
      }
      var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
      if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
        return 1;
      } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
        return -1;
      }
      return 0;
    }
    function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
      var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1e3;
      var endProgramDateTime = candidate.endProgramDateTime || 0;
      return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
    }
    function findFragWithCC(fragments, cc) {
      return BinarySearch.search(fragments, function(candidate) {
        if (candidate.cc < cc) {
          return 1;
        } else if (candidate.cc > cc) {
          return -1;
        } else {
          return 0;
        }
      });
    }
    var NetworkErrorAction = {
      DoNothing: 0,
      SendEndCallback: 1,
      SendAlternateToPenaltyBox: 2,
      RemoveAlternatePermanently: 3,
      InsertDiscontinuity: 4,
      RetryRequest: 5
    };
    var ErrorActionFlags = {
      None: 0,
      MoveAllAlternatesMatchingHost: 1,
      MoveAllAlternatesMatchingHDCP: 2,
      SwitchToSDR: 4
    };
    var ErrorController = /* @__PURE__ */ function() {
      function ErrorController2(hls) {
        this.hls = void 0;
        this.playlistError = 0;
        this.penalizedRenditions = {};
        this.log = void 0;
        this.warn = void 0;
        this.error = void 0;
        this.hls = hls;
        this.log = logger.log.bind(logger, "[info]:");
        this.warn = logger.warn.bind(logger, "[warning]:");
        this.error = logger.error.bind(logger, "[error]:");
        this.registerListeners();
      }
      var _proto = ErrorController2.prototype;
      _proto.registerListeners = function registerListeners() {
        var hls = this.hls;
        hls.on(Events.ERROR, this.onError, this);
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
      };
      _proto.unregisterListeners = function unregisterListeners() {
        var hls = this.hls;
        if (!hls) {
          return;
        }
        hls.off(Events.ERROR, this.onError, this);
        hls.off(Events.ERROR, this.onErrorOut, this);
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
      };
      _proto.destroy = function destroy() {
        this.unregisterListeners();
        this.hls = null;
        this.penalizedRenditions = {};
      };
      _proto.startLoad = function startLoad(startPosition) {
      };
      _proto.stopLoad = function stopLoad() {
        this.playlistError = 0;
      };
      _proto.getVariantLevelIndex = function getVariantLevelIndex(frag) {
        return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;
      };
      _proto.onManifestLoading = function onManifestLoading() {
        this.playlistError = 0;
        this.penalizedRenditions = {};
      };
      _proto.onLevelUpdated = function onLevelUpdated() {
        this.playlistError = 0;
      };
      _proto.onError = function onError(event, data) {
        var _data$frag, _data$level;
        if (data.fatal) {
          return;
        }
        var hls = this.hls;
        var context = data.context;
        switch (data.details) {
          case ErrorDetails.FRAG_LOAD_ERROR:
          case ErrorDetails.FRAG_LOAD_TIMEOUT:
          case ErrorDetails.KEY_LOAD_ERROR:
          case ErrorDetails.KEY_LOAD_TIMEOUT:
            data.errorAction = this.getFragRetryOrSwitchAction(data);
            return;
          case ErrorDetails.FRAG_PARSING_ERROR:
            if ((_data$frag = data.frag) != null && _data$frag.gap) {
              data.errorAction = {
                action: NetworkErrorAction.DoNothing,
                flags: ErrorActionFlags.None
              };
              return;
            }
          case ErrorDetails.FRAG_GAP:
          case ErrorDetails.FRAG_DECRYPT_ERROR: {
            data.errorAction = this.getFragRetryOrSwitchAction(data);
            data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
            return;
          }
          case ErrorDetails.LEVEL_EMPTY_ERROR:
          case ErrorDetails.LEVEL_PARSING_ERROR:
            {
              var _data$context, _data$context$levelDe;
              var levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;
              if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {
                data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);
              } else {
                data.levelRetry = false;
                data.errorAction = this.getLevelSwitchAction(data, levelIndex);
              }
            }
            return;
          case ErrorDetails.LEVEL_LOAD_ERROR:
          case ErrorDetails.LEVEL_LOAD_TIMEOUT:
            if (typeof (context == null ? void 0 : context.level) === "number") {
              data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);
            }
            return;
          case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
          case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
          case ErrorDetails.SUBTITLE_LOAD_ERROR:
          case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:
            if (context) {
              var level = hls.levels[hls.loadLevel];
              if (level && (context.type === PlaylistContextType.AUDIO_TRACK && level.hasAudioGroup(context.groupId) || context.type === PlaylistContextType.SUBTITLE_TRACK && level.hasSubtitleGroup(context.groupId))) {
                data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);
                data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
                data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;
                return;
              }
            }
            return;
          case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
            {
              var _level = hls.levels[hls.loadLevel];
              var restrictedHdcpLevel = _level == null ? void 0 : _level.attrs["HDCP-LEVEL"];
              if (restrictedHdcpLevel) {
                data.errorAction = {
                  action: NetworkErrorAction.SendAlternateToPenaltyBox,
                  flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,
                  hdcpLevel: restrictedHdcpLevel
                };
              } else {
                this.keySystemError(data);
              }
            }
            return;
          case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
          case ErrorDetails.REMUX_ALLOC_ERROR:
          case ErrorDetails.BUFFER_APPEND_ERROR:
            data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);
            return;
          case ErrorDetails.INTERNAL_EXCEPTION:
          case ErrorDetails.BUFFER_APPENDING_ERROR:
          case ErrorDetails.BUFFER_FULL_ERROR:
          case ErrorDetails.LEVEL_SWITCH_ERROR:
          case ErrorDetails.BUFFER_STALLED_ERROR:
          case ErrorDetails.BUFFER_SEEK_OVER_HOLE:
          case ErrorDetails.BUFFER_NUDGE_ON_STALL:
            data.errorAction = {
              action: NetworkErrorAction.DoNothing,
              flags: ErrorActionFlags.None
            };
            return;
        }
        if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {
          this.keySystemError(data);
        }
      };
      _proto.keySystemError = function keySystemError(data) {
        var levelIndex = this.getVariantLevelIndex(data.frag);
        data.levelRetry = false;
        data.errorAction = this.getLevelSwitchAction(data, levelIndex);
      };
      _proto.getPlaylistRetryOrSwitchAction = function getPlaylistRetryOrSwitchAction(data, levelIndex) {
        var hls = this.hls;
        var retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);
        var retryCount = this.playlistError++;
        var retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), data.response);
        if (retry) {
          return {
            action: NetworkErrorAction.RetryRequest,
            flags: ErrorActionFlags.None,
            retryConfig,
            retryCount
          };
        }
        var errorAction = this.getLevelSwitchAction(data, levelIndex);
        if (retryConfig) {
          errorAction.retryConfig = retryConfig;
          errorAction.retryCount = retryCount;
        }
        return errorAction;
      };
      _proto.getFragRetryOrSwitchAction = function getFragRetryOrSwitchAction(data) {
        var hls = this.hls;
        var variantLevelIndex = this.getVariantLevelIndex(data.frag);
        var level = hls.levels[variantLevelIndex];
        var _hls$config = hls.config, fragLoadPolicy = _hls$config.fragLoadPolicy, keyLoadPolicy = _hls$config.keyLoadPolicy;
        var retryConfig = getRetryConfig(data.details.startsWith("key") ? keyLoadPolicy : fragLoadPolicy, data);
        var fragmentErrors = hls.levels.reduce(function(acc, level2) {
          return acc + level2.fragmentError;
        }, 0);
        if (level) {
          if (data.details !== ErrorDetails.FRAG_GAP) {
            level.fragmentError++;
          }
          var retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), data.response);
          if (retry) {
            return {
              action: NetworkErrorAction.RetryRequest,
              flags: ErrorActionFlags.None,
              retryConfig,
              retryCount: fragmentErrors
            };
          }
        }
        var errorAction = this.getLevelSwitchAction(data, variantLevelIndex);
        if (retryConfig) {
          errorAction.retryConfig = retryConfig;
          errorAction.retryCount = fragmentErrors;
        }
        return errorAction;
      };
      _proto.getLevelSwitchAction = function getLevelSwitchAction(data, levelIndex) {
        var hls = this.hls;
        if (levelIndex === null || levelIndex === void 0) {
          levelIndex = hls.loadLevel;
        }
        var level = this.hls.levels[levelIndex];
        if (level) {
          var _data$frag2, _data$context2;
          var errorDetails = data.details;
          level.loadError++;
          if (errorDetails === ErrorDetails.BUFFER_APPEND_ERROR) {
            level.fragmentError++;
          }
          var nextLevel = -1;
          var levels = hls.levels, loadLevel = hls.loadLevel, minAutoLevel = hls.minAutoLevel, maxAutoLevel = hls.maxAutoLevel;
          if (!hls.autoLevelEnabled) {
            hls.loadLevel = -1;
          }
          var fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;
          var isAudioCodecError = fragErrorType === PlaylistLevelType.AUDIO && errorDetails === ErrorDetails.FRAG_PARSING_ERROR || data.sourceBufferName === "audio" && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);
          var findAudioCodecAlternate = isAudioCodecError && levels.some(function(_ref) {
            var audioCodec = _ref.audioCodec;
            return level.audioCodec !== audioCodec;
          });
          var isVideoCodecError = data.sourceBufferName === "video" && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);
          var findVideoCodecAlternate = isVideoCodecError && levels.some(function(_ref2) {
            var codecSet = _ref2.codecSet, audioCodec = _ref2.audioCodec;
            return level.codecSet !== codecSet && level.audioCodec === audioCodec;
          });
          var _ref3 = (_data$context2 = data.context) != null ? _data$context2 : {}, playlistErrorType = _ref3.type, playlistErrorGroupId = _ref3.groupId;
          var _loop = function _loop2() {
            var candidate = (i + loadLevel) % levels.length;
            if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {
              var _level$audioGroups, _level$subtitleGroups;
              var levelCandidate = levels[candidate];
              if (errorDetails === ErrorDetails.FRAG_GAP && data.frag) {
                var levelDetails = levels[candidate].details;
                if (levelDetails) {
                  var fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);
                  if (fragCandidate != null && fragCandidate.gap) {
                    return 0;
                  }
                }
              } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && levelCandidate.hasAudioGroup(playlistErrorGroupId) || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && levelCandidate.hasSubtitleGroup(playlistErrorGroupId)) {
                return 0;
              } else if (fragErrorType === PlaylistLevelType.AUDIO && (_level$audioGroups = level.audioGroups) != null && _level$audioGroups.some(function(groupId) {
                return levelCandidate.hasAudioGroup(groupId);
              }) || fragErrorType === PlaylistLevelType.SUBTITLE && (_level$subtitleGroups = level.subtitleGroups) != null && _level$subtitleGroups.some(function(groupId) {
                return levelCandidate.hasSubtitleGroup(groupId);
              }) || findAudioCodecAlternate && level.audioCodec === levelCandidate.audioCodec || !findAudioCodecAlternate && level.audioCodec !== levelCandidate.audioCodec || findVideoCodecAlternate && level.codecSet === levelCandidate.codecSet) {
                return 0;
              }
              nextLevel = candidate;
              return 1;
            }
          }, _ret;
          for (var i = levels.length; i--; ) {
            _ret = _loop();
            if (_ret === 0)
              continue;
            if (_ret === 1)
              break;
          }
          if (nextLevel > -1 && hls.loadLevel !== nextLevel) {
            data.levelRetry = true;
            this.playlistError = 0;
            return {
              action: NetworkErrorAction.SendAlternateToPenaltyBox,
              flags: ErrorActionFlags.None,
              nextAutoLevel: nextLevel
            };
          }
        }
        return {
          action: NetworkErrorAction.SendAlternateToPenaltyBox,
          flags: ErrorActionFlags.MoveAllAlternatesMatchingHost
        };
      };
      _proto.onErrorOut = function onErrorOut(event, data) {
        var _data$errorAction;
        switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {
          case NetworkErrorAction.DoNothing:
            break;
          case NetworkErrorAction.SendAlternateToPenaltyBox:
            this.sendAlternateToPenaltyBox(data);
            if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {
              data.fatal = true;
            } else if (/MediaSource readyState: ended/.test(data.error.message)) {
              this.warn('MediaSource ended after "' + data.sourceBufferName + '" sourceBuffer append error. Attempting to recover from media error.');
              this.hls.recoverMediaError();
            }
            break;
        }
        if (data.fatal) {
          this.hls.stopLoad();
          return;
        }
      };
      _proto.sendAlternateToPenaltyBox = function sendAlternateToPenaltyBox(data) {
        var hls = this.hls;
        var errorAction = data.errorAction;
        if (!errorAction) {
          return;
        }
        var flags = errorAction.flags, hdcpLevel = errorAction.hdcpLevel, nextAutoLevel = errorAction.nextAutoLevel;
        switch (flags) {
          case ErrorActionFlags.None:
            this.switchLevel(data, nextAutoLevel);
            break;
          case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:
            if (hdcpLevel) {
              hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];
              errorAction.resolved = true;
            }
            this.warn('Restricting playback to HDCP-LEVEL of "' + hls.maxHdcpLevel + '" or lower');
            break;
        }
        if (!errorAction.resolved) {
          this.switchLevel(data, nextAutoLevel);
        }
      };
      _proto.switchLevel = function switchLevel(data, levelIndex) {
        if (levelIndex !== void 0 && data.errorAction) {
          this.warn("switching to level " + levelIndex + " after " + data.details);
          this.hls.nextAutoLevel = levelIndex;
          data.errorAction.resolved = true;
          this.hls.nextLoadLevel = this.hls.nextAutoLevel;
        }
      };
      return ErrorController2;
    }();
    var BasePlaylistController = /* @__PURE__ */ function() {
      function BasePlaylistController2(hls, logPrefix) {
        this.hls = void 0;
        this.timer = -1;
        this.requestScheduled = -1;
        this.canLoad = false;
        this.log = void 0;
        this.warn = void 0;
        this.log = logger.log.bind(logger, logPrefix + ":");
        this.warn = logger.warn.bind(logger, logPrefix + ":");
        this.hls = hls;
      }
      var _proto = BasePlaylistController2.prototype;
      _proto.destroy = function destroy() {
        this.clearTimer();
        this.hls = this.log = this.warn = null;
      };
      _proto.clearTimer = function clearTimer() {
        if (this.timer !== -1) {
          self.clearTimeout(this.timer);
          this.timer = -1;
        }
      };
      _proto.startLoad = function startLoad() {
        this.canLoad = true;
        this.requestScheduled = -1;
        this.loadPlaylist();
      };
      _proto.stopLoad = function stopLoad() {
        this.canLoad = false;
        this.clearTimer();
      };
      _proto.switchParams = function switchParams(playlistUri, previous) {
        var renditionReports = previous == null ? void 0 : previous.renditionReports;
        if (renditionReports) {
          var foundIndex = -1;
          for (var i = 0; i < renditionReports.length; i++) {
            var attr = renditionReports[i];
            var uri = void 0;
            try {
              uri = new self.URL(attr.URI, previous.url).href;
            } catch (error) {
              logger.warn("Could not construct new URL for Rendition Report: " + error);
              uri = attr.URI || "";
            }
            if (uri === playlistUri) {
              foundIndex = i;
              break;
            } else if (uri === playlistUri.substring(0, uri.length)) {
              foundIndex = i;
            }
          }
          if (foundIndex !== -1) {
            var _attr = renditionReports[foundIndex];
            var msn = parseInt(_attr["LAST-MSN"]) || (previous == null ? void 0 : previous.lastPartSn);
            var part = parseInt(_attr["LAST-PART"]) || (previous == null ? void 0 : previous.lastPartIndex);
            if (this.hls.config.lowLatencyMode) {
              var currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);
              if (part >= 0 && currentGoal > previous.partTarget) {
                part += 1;
              }
            }
            return new HlsUrlParameters(msn, part >= 0 ? part : void 0, HlsSkip.No);
          }
        }
      };
      _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
        if (this.requestScheduled === -1) {
          this.requestScheduled = self.performance.now();
        }
      };
      _proto.shouldLoadPlaylist = function shouldLoadPlaylist(playlist) {
        return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);
      };
      _proto.shouldReloadPlaylist = function shouldReloadPlaylist(playlist) {
        return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);
      };
      _proto.playlistLoaded = function playlistLoaded(index, data, previousDetails) {
        var _this = this;
        var details = data.details, stats = data.stats;
        var now2 = self.performance.now();
        var elapsed = stats.loading.first ? Math.max(0, now2 - stats.loading.first) : 0;
        details.advancedDateTime = Date.now() - elapsed;
        if (details.live || previousDetails != null && previousDetails.live) {
          details.reloaded(previousDetails);
          if (previousDetails) {
            this.log("live playlist " + index + " " + (details.advanced ? "REFRESHED " + details.lastPartSn + "-" + details.lastPartIndex : details.updated ? "UPDATED" : "MISSED"));
          }
          if (previousDetails && details.fragments.length > 0) {
            mergeDetails(previousDetails, details);
          }
          if (!this.canLoad || !details.live) {
            return;
          }
          var deliveryDirectives;
          var msn = void 0;
          var part = void 0;
          if (details.canBlockReload && details.endSN && details.advanced) {
            var lowLatencyMode = this.hls.config.lowLatencyMode;
            var lastPartSn = details.lastPartSn;
            var endSn = details.endSN;
            var lastPartIndex = details.lastPartIndex;
            var hasParts = lastPartIndex !== -1;
            var lastPart = lastPartSn === endSn;
            var nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;
            if (hasParts) {
              msn = lastPart ? endSn + 1 : lastPartSn;
              part = lastPart ? nextSnStartIndex : lastPartIndex + 1;
            } else {
              msn = endSn + 1;
            }
            var lastAdvanced = details.age;
            var cdnAge = lastAdvanced + details.ageHeader;
            var currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);
            if (currentGoal > 0) {
              if (previousDetails && currentGoal > previousDetails.tuneInGoal) {
                this.warn("CDN Tune-in goal increased from: " + previousDetails.tuneInGoal + " to: " + currentGoal + " with playlist age: " + details.age);
                currentGoal = 0;
              } else {
                var segments = Math.floor(currentGoal / details.targetduration);
                msn += segments;
                if (part !== void 0) {
                  var parts = Math.round(currentGoal % details.targetduration / details.partTarget);
                  part += parts;
                }
                this.log("CDN Tune-in age: " + details.ageHeader + "s last advanced " + lastAdvanced.toFixed(2) + "s goal: " + currentGoal + " skip sn " + segments + " to part " + part);
              }
              details.tuneInGoal = currentGoal;
            }
            deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
            if (lowLatencyMode || !lastPart) {
              this.loadPlaylist(deliveryDirectives);
              return;
            }
          } else if (details.canBlockReload || details.canSkipUntil) {
            deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
          }
          var bufferInfo = this.hls.mainForwardBufferInfo;
          var position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;
          var distanceToLiveEdgeMs = (details.edge - position) * 1e3;
          var reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);
          if (details.updated && now2 > this.requestScheduled + reloadInterval) {
            this.requestScheduled = stats.loading.start;
          }
          if (msn !== void 0 && details.canBlockReload) {
            this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1e3 || 1e3);
          } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now2) {
            this.requestScheduled = now2;
          } else if (this.requestScheduled - now2 <= 0) {
            this.requestScheduled += reloadInterval;
          }
          var estimatedTimeUntilUpdate = this.requestScheduled - now2;
          estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);
          this.log("reload live playlist " + index + " in " + Math.round(estimatedTimeUntilUpdate) + " ms");
          this.timer = self.setTimeout(function() {
            return _this.loadPlaylist(deliveryDirectives);
          }, estimatedTimeUntilUpdate);
        } else {
          this.clearTimer();
        }
      };
      _proto.getDeliveryDirectives = function getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {
        var skip = getSkipValue(details, msn);
        if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {
          msn = previousDeliveryDirectives.msn;
          part = previousDeliveryDirectives.part;
          skip = HlsSkip.No;
        }
        return new HlsUrlParameters(msn, part, skip);
      };
      _proto.checkRetry = function checkRetry(errorEvent) {
        var _this2 = this;
        var errorDetails = errorEvent.details;
        var isTimeout = isTimeoutError(errorEvent);
        var errorAction = errorEvent.errorAction;
        var _ref = errorAction || {}, action = _ref.action, _ref$retryCount = _ref.retryCount, retryCount = _ref$retryCount === void 0 ? 0 : _ref$retryCount, retryConfig = _ref.retryConfig;
        var retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);
        if (retry) {
          var _errorEvent$context;
          this.requestScheduled = -1;
          if (retryCount >= retryConfig.maxNumRetry) {
            return false;
          }
          if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {
            this.warn("Retrying playlist loading " + (retryCount + 1) + "/" + retryConfig.maxNumRetry + ' after "' + errorDetails + '" without delivery-directives');
            this.loadPlaylist();
          } else {
            var delay = getRetryDelay(retryConfig, retryCount);
            this.timer = self.setTimeout(function() {
              return _this2.loadPlaylist();
            }, delay);
            this.warn("Retrying playlist loading " + (retryCount + 1) + "/" + retryConfig.maxNumRetry + ' after "' + errorDetails + '" in ' + delay + "ms");
          }
          errorEvent.levelRetry = true;
          errorAction.resolved = true;
        }
        return retry;
      };
      return BasePlaylistController2;
    }();
    var EWMA = /* @__PURE__ */ function() {
      function EWMA2(halfLife, estimate, weight) {
        if (estimate === void 0) {
          estimate = 0;
        }
        if (weight === void 0) {
          weight = 0;
        }
        this.halfLife = void 0;
        this.alpha_ = void 0;
        this.estimate_ = void 0;
        this.totalWeight_ = void 0;
        this.halfLife = halfLife;
        this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
        this.estimate_ = estimate;
        this.totalWeight_ = weight;
      }
      var _proto = EWMA2.prototype;
      _proto.sample = function sample(weight, value) {
        var adjAlpha = Math.pow(this.alpha_, weight);
        this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
        this.totalWeight_ += weight;
      };
      _proto.getTotalWeight = function getTotalWeight() {
        return this.totalWeight_;
      };
      _proto.getEstimate = function getEstimate() {
        if (this.alpha_) {
          var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
          if (zeroFactor) {
            return this.estimate_ / zeroFactor;
          }
        }
        return this.estimate_;
      };
      return EWMA2;
    }();
    var EwmaBandWidthEstimator = /* @__PURE__ */ function() {
      function EwmaBandWidthEstimator2(slow, fast, defaultEstimate, defaultTTFB) {
        if (defaultTTFB === void 0) {
          defaultTTFB = 100;
        }
        this.defaultEstimate_ = void 0;
        this.minWeight_ = void 0;
        this.minDelayMs_ = void 0;
        this.slow_ = void 0;
        this.fast_ = void 0;
        this.defaultTTFB_ = void 0;
        this.ttfb_ = void 0;
        this.defaultEstimate_ = defaultEstimate;
        this.minWeight_ = 1e-3;
        this.minDelayMs_ = 50;
        this.slow_ = new EWMA(slow);
        this.fast_ = new EWMA(fast);
        this.defaultTTFB_ = defaultTTFB;
        this.ttfb_ = new EWMA(slow);
      }
      var _proto = EwmaBandWidthEstimator2.prototype;
      _proto.update = function update(slow, fast) {
        var slow_ = this.slow_, fast_ = this.fast_, ttfb_ = this.ttfb_;
        if (slow_.halfLife !== slow) {
          this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());
        }
        if (fast_.halfLife !== fast) {
          this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());
        }
        if (ttfb_.halfLife !== slow) {
          this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());
        }
      };
      _proto.sample = function sample(durationMs, numBytes) {
        durationMs = Math.max(durationMs, this.minDelayMs_);
        var numBits = 8 * numBytes;
        var durationS = durationMs / 1e3;
        var bandwidthInBps = numBits / durationS;
        this.fast_.sample(durationS, bandwidthInBps);
        this.slow_.sample(durationS, bandwidthInBps);
      };
      _proto.sampleTTFB = function sampleTTFB(ttfb) {
        var seconds = ttfb / 1e3;
        var weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);
        this.ttfb_.sample(weight, Math.max(ttfb, 5));
      };
      _proto.canEstimate = function canEstimate() {
        return this.fast_.getTotalWeight() >= this.minWeight_;
      };
      _proto.getEstimate = function getEstimate() {
        if (this.canEstimate()) {
          return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
        } else {
          return this.defaultEstimate_;
        }
      };
      _proto.getEstimateTTFB = function getEstimateTTFB() {
        if (this.ttfb_.getTotalWeight() >= this.minWeight_) {
          return this.ttfb_.getEstimate();
        } else {
          return this.defaultTTFB_;
        }
      };
      _proto.destroy = function destroy() {
      };
      return EwmaBandWidthEstimator2;
    }();
    var SUPPORTED_INFO_DEFAULT = {
      supported: true,
      configurations: [],
      decodingInfoResults: [{
        supported: true,
        powerEfficient: true,
        smooth: true
      }]
    };
    var SUPPORTED_INFO_CACHE = {};
    function requiresMediaCapabilitiesDecodingInfo(level, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference) {
      var audioGroups = level.audioCodec ? level.audioGroups : null;
      var audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;
      var channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;
      var maxChannels = channelsPreference ? parseInt(channelsPreference) : audioCodecPreference ? Infinity : 2;
      var audioChannels = null;
      if (audioGroups != null && audioGroups.length) {
        try {
          if (audioGroups.length === 1 && audioGroups[0]) {
            audioChannels = audioTracksByGroup.groups[audioGroups[0]].channels;
          } else {
            audioChannels = audioGroups.reduce(function(acc, groupId) {
              if (groupId) {
                var audioTrackGroup = audioTracksByGroup.groups[groupId];
                if (!audioTrackGroup) {
                  throw new Error("Audio track group " + groupId + " not found");
                }
                Object.keys(audioTrackGroup.channels).forEach(function(key) {
                  acc[key] = (acc[key] || 0) + audioTrackGroup.channels[key];
                });
              }
              return acc;
            }, {
              2: 0
            });
          }
        } catch (error) {
          return true;
        }
      }
      return level.videoCodec !== void 0 && (level.width > 1920 && level.height > 1088 || level.height > 1920 && level.width > 1088 || level.frameRate > Math.max(currentFrameRate, 30) || level.videoRange !== "SDR" && level.videoRange !== currentVideoRange || level.bitrate > Math.max(currentBw, 8e6)) || !!audioChannels && isFiniteNumber(maxChannels) && Object.keys(audioChannels).some(function(channels) {
        return parseInt(channels) > maxChannels;
      });
    }
    function getMediaDecodingInfoPromise(level, audioTracksByGroup, mediaCapabilities) {
      var videoCodecs = level.videoCodec;
      var audioCodecs = level.audioCodec;
      if (!videoCodecs || !audioCodecs || !mediaCapabilities) {
        return Promise.resolve(SUPPORTED_INFO_DEFAULT);
      }
      var baseVideoConfiguration = {
        width: level.width,
        height: level.height,
        bitrate: Math.ceil(Math.max(level.bitrate * 0.9, level.averageBitrate)),
        // Assume a framerate of 30fps since MediaCapabilities will not accept Level default of 0.
        framerate: level.frameRate || 30
      };
      var videoRange = level.videoRange;
      if (videoRange !== "SDR") {
        baseVideoConfiguration.transferFunction = videoRange.toLowerCase();
      }
      var configurations = videoCodecs.split(",").map(function(videoCodec) {
        return {
          type: "media-source",
          video: _objectSpread2(_objectSpread2({}, baseVideoConfiguration), {}, {
            contentType: mimeTypeForCodec(videoCodec, "video")
          })
        };
      });
      if (audioCodecs && level.audioGroups) {
        level.audioGroups.forEach(function(audioGroupId) {
          var _audioTracksByGroup$g;
          if (!audioGroupId) {
            return;
          }
          (_audioTracksByGroup$g = audioTracksByGroup.groups[audioGroupId]) == null ? void 0 : _audioTracksByGroup$g.tracks.forEach(function(audioTrack) {
            if (audioTrack.groupId === audioGroupId) {
              var channels = audioTrack.channels || "";
              var channelsNumber = parseFloat(channels);
              if (isFiniteNumber(channelsNumber) && channelsNumber > 2) {
                configurations.push.apply(configurations, audioCodecs.split(",").map(function(audioCodec) {
                  return {
                    type: "media-source",
                    audio: {
                      contentType: mimeTypeForCodec(audioCodec, "audio"),
                      channels: "" + channelsNumber
                      // spatialRendering:
                      //   audioCodec === 'ec-3' && channels.indexOf('JOC'),
                    }
                  };
                }));
              }
            }
          });
        });
      }
      return Promise.all(configurations.map(function(configuration) {
        var decodingInfoKey = getMediaDecodingInfoKey(configuration);
        return SUPPORTED_INFO_CACHE[decodingInfoKey] || (SUPPORTED_INFO_CACHE[decodingInfoKey] = mediaCapabilities.decodingInfo(configuration));
      })).then(function(decodingInfoResults) {
        return {
          supported: !decodingInfoResults.some(function(info) {
            return !info.supported;
          }),
          configurations,
          decodingInfoResults
        };
      }).catch(function(error) {
        return {
          supported: false,
          configurations,
          decodingInfoResults: [],
          error
        };
      });
    }
    function getMediaDecodingInfoKey(config) {
      var audio = config.audio, video = config.video;
      var mediaConfig = video || audio;
      if (mediaConfig) {
        var codec = mediaConfig.contentType.split('"')[1];
        if (video) {
          return "r" + video.height + "x" + video.width + "f" + Math.ceil(video.framerate) + (video.transferFunction || "sd") + "_" + codec + "_" + Math.ceil(video.bitrate / 1e5);
        }
        if (audio) {
          return "c" + audio.channels + (audio.spatialRendering ? "s" : "n") + "_" + codec;
        }
      }
      return "";
    }
    function isHdrSupported() {
      if (typeof matchMedia === "function") {
        var mediaQueryList = matchMedia("(dynamic-range: high)");
        var badQuery = matchMedia("bad query");
        if (mediaQueryList.media !== badQuery.media) {
          return mediaQueryList.matches === true;
        }
      }
      return false;
    }
    function getVideoSelectionOptions(currentVideoRange, videoPreference) {
      var preferHDR = false;
      var allowedVideoRanges = [];
      if (currentVideoRange) {
        preferHDR = currentVideoRange !== "SDR";
        allowedVideoRanges = [currentVideoRange];
      }
      if (videoPreference) {
        allowedVideoRanges = videoPreference.allowedVideoRanges || VideoRangeValues.slice(0);
        preferHDR = videoPreference.preferHDR !== void 0 ? videoPreference.preferHDR : isHdrSupported();
        if (preferHDR) {
          allowedVideoRanges = allowedVideoRanges.filter(function(range) {
            return range !== "SDR";
          });
        } else {
          allowedVideoRanges = ["SDR"];
        }
      }
      return {
        preferHDR,
        allowedVideoRanges
      };
    }
    function getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference) {
      var codecSets = Object.keys(codecTiers);
      var channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;
      var audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;
      var preferStereo = channelsPreference && parseInt(channelsPreference) === 2;
      var hasStereo = true;
      var hasCurrentVideoRange = false;
      var minHeight = Infinity;
      var minFramerate = Infinity;
      var minBitrate = Infinity;
      var selectedScore = 0;
      var videoRanges = [];
      var _getVideoSelectionOpt = getVideoSelectionOptions(currentVideoRange, videoPreference), preferHDR = _getVideoSelectionOpt.preferHDR, allowedVideoRanges = _getVideoSelectionOpt.allowedVideoRanges;
      var _loop = function _loop2() {
        var tier = codecTiers[codecSets[i]];
        hasStereo = tier.channels[2] > 0;
        minHeight = Math.min(minHeight, tier.minHeight);
        minFramerate = Math.min(minFramerate, tier.minFramerate);
        minBitrate = Math.min(minBitrate, tier.minBitrate);
        var matchingVideoRanges = allowedVideoRanges.filter(function(range) {
          return tier.videoRanges[range] > 0;
        });
        if (matchingVideoRanges.length > 0) {
          hasCurrentVideoRange = true;
          videoRanges = matchingVideoRanges;
        }
      };
      for (var i = codecSets.length; i--; ) {
        _loop();
      }
      minHeight = isFiniteNumber(minHeight) ? minHeight : 0;
      minFramerate = isFiniteNumber(minFramerate) ? minFramerate : 0;
      var maxHeight = Math.max(1080, minHeight);
      var maxFramerate = Math.max(30, minFramerate);
      minBitrate = isFiniteNumber(minBitrate) ? minBitrate : currentBw;
      currentBw = Math.max(minBitrate, currentBw);
      if (!hasCurrentVideoRange) {
        currentVideoRange = void 0;
        videoRanges = [];
      }
      var codecSet = codecSets.reduce(function(selected, candidate) {
        var candidateTier = codecTiers[candidate];
        if (candidate === selected) {
          return selected;
        }
        if (candidateTier.minBitrate > currentBw) {
          logStartCodecCandidateIgnored(candidate, "min bitrate of " + candidateTier.minBitrate + " > current estimate of " + currentBw);
          return selected;
        }
        if (!candidateTier.hasDefaultAudio) {
          logStartCodecCandidateIgnored(candidate, "no renditions with default or auto-select sound found");
          return selected;
        }
        if (audioCodecPreference && candidate.indexOf(audioCodecPreference.substring(0, 4)) % 5 !== 0) {
          logStartCodecCandidateIgnored(candidate, 'audio codec preference "' + audioCodecPreference + '" not found');
          return selected;
        }
        if (channelsPreference && !preferStereo) {
          if (!candidateTier.channels[channelsPreference]) {
            logStartCodecCandidateIgnored(candidate, "no renditions with " + channelsPreference + " channel sound found (channels options: " + Object.keys(candidateTier.channels) + ")");
            return selected;
          }
        } else if ((!audioCodecPreference || preferStereo) && hasStereo && candidateTier.channels["2"] === 0) {
          logStartCodecCandidateIgnored(candidate, "no renditions with stereo sound found");
          return selected;
        }
        if (candidateTier.minHeight > maxHeight) {
          logStartCodecCandidateIgnored(candidate, "min resolution of " + candidateTier.minHeight + " > maximum of " + maxHeight);
          return selected;
        }
        if (candidateTier.minFramerate > maxFramerate) {
          logStartCodecCandidateIgnored(candidate, "min framerate of " + candidateTier.minFramerate + " > maximum of " + maxFramerate);
          return selected;
        }
        if (!videoRanges.some(function(range) {
          return candidateTier.videoRanges[range] > 0;
        })) {
          logStartCodecCandidateIgnored(candidate, "no variants with VIDEO-RANGE of " + JSON.stringify(videoRanges) + " found");
          return selected;
        }
        if (candidateTier.maxScore < selectedScore) {
          logStartCodecCandidateIgnored(candidate, "max score of " + candidateTier.maxScore + " < selected max of " + selectedScore);
          return selected;
        }
        if (selected && (codecsSetSelectionPreferenceValue(candidate) >= codecsSetSelectionPreferenceValue(selected) || candidateTier.fragmentError > codecTiers[selected].fragmentError)) {
          return selected;
        }
        selectedScore = candidateTier.maxScore;
        return candidate;
      }, void 0);
      return {
        codecSet,
        videoRanges,
        preferHDR,
        minFramerate,
        minBitrate
      };
    }
    function logStartCodecCandidateIgnored(codeSet, reason) {
      logger.log('[abr] start candidates with "' + codeSet + '" ignored because ' + reason);
    }
    function getAudioTracksByGroup(allAudioTracks) {
      return allAudioTracks.reduce(function(audioTracksByGroup, track) {
        var trackGroup = audioTracksByGroup.groups[track.groupId];
        if (!trackGroup) {
          trackGroup = audioTracksByGroup.groups[track.groupId] = {
            tracks: [],
            channels: {
              2: 0
            },
            hasDefault: false,
            hasAutoSelect: false
          };
        }
        trackGroup.tracks.push(track);
        var channelsKey = track.channels || "2";
        trackGroup.channels[channelsKey] = (trackGroup.channels[channelsKey] || 0) + 1;
        trackGroup.hasDefault = trackGroup.hasDefault || track.default;
        trackGroup.hasAutoSelect = trackGroup.hasAutoSelect || track.autoselect;
        if (trackGroup.hasDefault) {
          audioTracksByGroup.hasDefaultAudio = true;
        }
        if (trackGroup.hasAutoSelect) {
          audioTracksByGroup.hasAutoSelectAudio = true;
        }
        return audioTracksByGroup;
      }, {
        hasDefaultAudio: false,
        hasAutoSelectAudio: false,
        groups: {}
      });
    }
    function getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel) {
      return levels.slice(minAutoLevel, maxAutoLevel + 1).reduce(function(tiers, level) {
        if (!level.codecSet) {
          return tiers;
        }
        var audioGroups = level.audioGroups;
        var tier = tiers[level.codecSet];
        if (!tier) {
          tiers[level.codecSet] = tier = {
            minBitrate: Infinity,
            minHeight: Infinity,
            minFramerate: Infinity,
            maxScore: 0,
            videoRanges: {
              SDR: 0
            },
            channels: {
              "2": 0
            },
            hasDefaultAudio: !audioGroups,
            fragmentError: 0
          };
        }
        tier.minBitrate = Math.min(tier.minBitrate, level.bitrate);
        var lesserWidthOrHeight = Math.min(level.height, level.width);
        tier.minHeight = Math.min(tier.minHeight, lesserWidthOrHeight);
        tier.minFramerate = Math.min(tier.minFramerate, level.frameRate);
        tier.maxScore = Math.max(tier.maxScore, level.score);
        tier.fragmentError += level.fragmentError;
        tier.videoRanges[level.videoRange] = (tier.videoRanges[level.videoRange] || 0) + 1;
        if (audioGroups) {
          audioGroups.forEach(function(audioGroupId) {
            if (!audioGroupId) {
              return;
            }
            var audioGroup = audioTracksByGroup.groups[audioGroupId];
            tier.hasDefaultAudio = tier.hasDefaultAudio || audioTracksByGroup.hasDefaultAudio ? audioGroup.hasDefault : audioGroup.hasAutoSelect || !audioTracksByGroup.hasDefaultAudio && !audioTracksByGroup.hasAutoSelectAudio;
            Object.keys(audioGroup.channels).forEach(function(channels) {
              tier.channels[channels] = (tier.channels[channels] || 0) + audioGroup.channels[channels];
            });
          });
        }
        return tiers;
      }, {});
    }
    function findMatchingOption(option, tracks, matchPredicate) {
      if ("attrs" in option) {
        var index = tracks.indexOf(option);
        if (index !== -1) {
          return index;
        }
      }
      for (var i = 0; i < tracks.length; i++) {
        var _track = tracks[i];
        if (matchesOption(option, _track, matchPredicate)) {
          return i;
        }
      }
      return -1;
    }
    function matchesOption(option, track, matchPredicate) {
      var groupId = option.groupId, name = option.name, lang = option.lang, assocLang = option.assocLang, characteristics = option.characteristics, isDefault = option.default;
      var forced = option.forced;
      return (groupId === void 0 || track.groupId === groupId) && (name === void 0 || track.name === name) && (lang === void 0 || track.lang === lang) && (lang === void 0 || track.assocLang === assocLang) && (isDefault === void 0 || track.default === isDefault) && (forced === void 0 || track.forced === forced) && (characteristics === void 0 || characteristicsMatch(characteristics, track.characteristics)) && (matchPredicate === void 0 || matchPredicate(option, track));
    }
    function characteristicsMatch(characteristicsA, characteristicsB) {
      if (characteristicsB === void 0) {
        characteristicsB = "";
      }
      var arrA = characteristicsA.split(",");
      var arrB = characteristicsB.split(",");
      return arrA.length === arrB.length && !arrA.some(function(el) {
        return arrB.indexOf(el) === -1;
      });
    }
    function audioMatchPredicate(option, track) {
      var audioCodec = option.audioCodec, channels = option.channels;
      return (audioCodec === void 0 || (track.audioCodec || "").substring(0, 4) === audioCodec.substring(0, 4)) && (channels === void 0 || channels === (track.channels || "2"));
    }
    function findClosestLevelWithAudioGroup(option, levels, allAudioTracks, searchIndex, matchPredicate) {
      var currentLevel = levels[searchIndex];
      var variants = levels.reduce(function(variantMap, level, index) {
        var uri = level.uri;
        var renditions2 = variantMap[uri] || (variantMap[uri] = []);
        renditions2.push(index);
        return variantMap;
      }, {});
      var renditions = variants[currentLevel.uri];
      if (renditions.length > 1) {
        searchIndex = Math.max.apply(Math, renditions);
      }
      var currentVideoRange = currentLevel.videoRange;
      var currentFrameRate = currentLevel.frameRate;
      var currentVideoCodec = currentLevel.codecSet.substring(0, 4);
      var matchingVideo = searchDownAndUpList(levels, searchIndex, function(level) {
        if (level.videoRange !== currentVideoRange || level.frameRate !== currentFrameRate || level.codecSet.substring(0, 4) !== currentVideoCodec) {
          return false;
        }
        var audioGroups = level.audioGroups;
        var tracks = allAudioTracks.filter(function(track) {
          return !audioGroups || audioGroups.indexOf(track.groupId) !== -1;
        });
        return findMatchingOption(option, tracks, matchPredicate) > -1;
      });
      if (matchingVideo > -1) {
        return matchingVideo;
      }
      return searchDownAndUpList(levels, searchIndex, function(level) {
        var audioGroups = level.audioGroups;
        var tracks = allAudioTracks.filter(function(track) {
          return !audioGroups || audioGroups.indexOf(track.groupId) !== -1;
        });
        return findMatchingOption(option, tracks, matchPredicate) > -1;
      });
    }
    function searchDownAndUpList(arr, searchIndex, predicate) {
      for (var i = searchIndex; i; i--) {
        if (predicate(arr[i])) {
          return i;
        }
      }
      for (var _i = searchIndex + 1; _i < arr.length; _i++) {
        if (predicate(arr[_i])) {
          return _i;
        }
      }
      return -1;
    }
    var AbrController = /* @__PURE__ */ function() {
      function AbrController2(_hls) {
        var _this = this;
        this.hls = void 0;
        this.lastLevelLoadSec = 0;
        this.lastLoadedFragLevel = -1;
        this.firstSelection = -1;
        this._nextAutoLevel = -1;
        this.nextAutoLevelKey = "";
        this.audioTracksByGroup = null;
        this.codecTiers = null;
        this.timer = -1;
        this.fragCurrent = null;
        this.partCurrent = null;
        this.bitrateTestDelay = 0;
        this.bwEstimator = void 0;
        this._abandonRulesCheck = function() {
          var frag = _this.fragCurrent, part = _this.partCurrent, hls = _this.hls;
          var autoLevelEnabled = hls.autoLevelEnabled, media = hls.media;
          if (!frag || !media) {
            return;
          }
          var now2 = performance.now();
          var stats = part ? part.stats : frag.stats;
          var duration = part ? part.duration : frag.duration;
          var timeLoading = now2 - stats.loading.start;
          var minAutoLevel = hls.minAutoLevel;
          if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level <= minAutoLevel) {
            _this.clearTimer();
            _this._nextAutoLevel = -1;
            return;
          }
          if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {
            return;
          }
          var bufferInfo = hls.mainForwardBufferInfo;
          if (bufferInfo === null) {
            return;
          }
          var ttfbEstimate = _this.bwEstimator.getEstimateTTFB();
          var playbackRate = Math.abs(media.playbackRate);
          if (timeLoading <= Math.max(ttfbEstimate, 1e3 * (duration / (playbackRate * 2)))) {
            return;
          }
          var bufferStarvationDelay = bufferInfo.len / playbackRate;
          var ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
          var loadedFirstByte = stats.loaded && ttfb > -1;
          var bwEstimate = _this.getBwEstimate();
          var levels = hls.levels;
          var level = levels[frag.level];
          var expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.maxBitrate / 8));
          var timeStreaming = loadedFirstByte ? timeLoading - ttfb : timeLoading;
          if (timeStreaming < 1 && loadedFirstByte) {
            timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);
          }
          var loadRate = loadedFirstByte ? stats.loaded * 1e3 / timeStreaming : 0;
          var fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1e3;
          if (fragLoadedDelay <= bufferStarvationDelay) {
            return;
          }
          var bwe = loadRate ? loadRate * 8 : bwEstimate;
          var fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;
          var nextLoadLevel;
          for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
            var levelNextBitrate = levels[nextLoadLevel].maxBitrate;
            fragLevelNextLoadedDelay = _this.getTimeToLoadFrag(ttfbEstimate / 1e3, bwe, duration * levelNextBitrate, !levels[nextLoadLevel].details);
            if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
              break;
            }
          }
          if (fragLevelNextLoadedDelay >= fragLoadedDelay) {
            return;
          }
          if (fragLevelNextLoadedDelay > duration * 10) {
            return;
          }
          hls.nextLoadLevel = hls.nextAutoLevel = nextLoadLevel;
          if (loadedFirstByte) {
            _this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
          } else {
            _this.bwEstimator.sampleTTFB(timeLoading);
          }
          var nextLoadLevelBitrate = levels[nextLoadLevel].bitrate;
          if (_this.getBwEstimate() * _this.hls.config.abrBandWidthUpFactor > nextLoadLevelBitrate) {
            _this.resetEstimator(nextLoadLevelBitrate);
          }
          _this.clearTimer();
          logger.warn("[abr] Fragment " + frag.sn + (part ? " part " + part.index : "") + " of level " + frag.level + " is loading too slowly;\n      Time to underbuffer: " + bufferStarvationDelay.toFixed(3) + " s\n      Estimated load time for current fragment: " + fragLoadedDelay.toFixed(3) + " s\n      Estimated load time for down switch fragment: " + fragLevelNextLoadedDelay.toFixed(3) + " s\n      TTFB estimate: " + (ttfb | 0) + " ms\n      Current BW estimate: " + (isFiniteNumber(bwEstimate) ? bwEstimate | 0 : "Unknown") + " bps\n      New BW estimate: " + (_this.getBwEstimate() | 0) + " bps\n      Switching to level " + nextLoadLevel + " @ " + (nextLoadLevelBitrate | 0) + " bps");
          hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {
            frag,
            part,
            stats
          });
        };
        this.hls = _hls;
        this.bwEstimator = this.initEstimator();
        this.registerListeners();
      }
      var _proto = AbrController2.prototype;
      _proto.resetEstimator = function resetEstimator(abrEwmaDefaultEstimate) {
        if (abrEwmaDefaultEstimate) {
          logger.log("setting initial bwe to " + abrEwmaDefaultEstimate);
          this.hls.config.abrEwmaDefaultEstimate = abrEwmaDefaultEstimate;
        }
        this.firstSelection = -1;
        this.bwEstimator = this.initEstimator();
      };
      _proto.initEstimator = function initEstimator() {
        var config = this.hls.config;
        return new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);
      };
      _proto.registerListeners = function registerListeners() {
        var hls = this.hls;
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.FRAG_LOADING, this.onFragLoading, this);
        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
        hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
        hls.on(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);
        hls.on(Events.ERROR, this.onError, this);
      };
      _proto.unregisterListeners = function unregisterListeners() {
        var hls = this.hls;
        if (!hls) {
          return;
        }
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.FRAG_LOADING, this.onFragLoading, this);
        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
        hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
        hls.off(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);
        hls.off(Events.ERROR, this.onError, this);
      };
      _proto.destroy = function destroy() {
        this.unregisterListeners();
        this.clearTimer();
        this.hls = this._abandonRulesCheck = null;
        this.fragCurrent = this.partCurrent = null;
      };
      _proto.onManifestLoading = function onManifestLoading(event, data) {
        this.lastLoadedFragLevel = -1;
        this.firstSelection = -1;
        this.lastLevelLoadSec = 0;
        this.fragCurrent = this.partCurrent = null;
        this.onLevelsUpdated();
        this.clearTimer();
      };
      _proto.onLevelsUpdated = function onLevelsUpdated() {
        if (this.lastLoadedFragLevel > -1 && this.fragCurrent) {
          this.lastLoadedFragLevel = this.fragCurrent.level;
        }
        this._nextAutoLevel = -1;
        this.onMaxAutoLevelUpdated();
        this.codecTiers = null;
        this.audioTracksByGroup = null;
      };
      _proto.onMaxAutoLevelUpdated = function onMaxAutoLevelUpdated() {
        this.firstSelection = -1;
        this.nextAutoLevelKey = "";
      };
      _proto.onFragLoading = function onFragLoading(event, data) {
        var frag = data.frag;
        if (this.ignoreFragment(frag)) {
          return;
        }
        if (!frag.bitrateTest) {
          var _data$part;
          this.fragCurrent = frag;
          this.partCurrent = (_data$part = data.part) != null ? _data$part : null;
        }
        this.clearTimer();
        this.timer = self.setInterval(this._abandonRulesCheck, 100);
      };
      _proto.onLevelSwitching = function onLevelSwitching(event, data) {
        this.clearTimer();
      };
      _proto.onError = function onError(event, data) {
        if (data.fatal) {
          return;
        }
        switch (data.details) {
          case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
          case ErrorDetails.BUFFER_APPEND_ERROR:
            this.lastLoadedFragLevel = -1;
            this.firstSelection = -1;
            break;
          case ErrorDetails.FRAG_LOAD_TIMEOUT: {
            var frag = data.frag;
            var fragCurrent = this.fragCurrent, part = this.partCurrent;
            if (frag && fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level) {
              var now2 = performance.now();
              var stats = part ? part.stats : frag.stats;
              var timeLoading = now2 - stats.loading.start;
              var ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
              var loadedFirstByte = stats.loaded && ttfb > -1;
              if (loadedFirstByte) {
                var ttfbEstimate = this.bwEstimator.getEstimateTTFB();
                this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
              } else {
                this.bwEstimator.sampleTTFB(timeLoading);
              }
            }
            break;
          }
        }
      };
      _proto.getTimeToLoadFrag = function getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {
        var fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;
        var playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;
        return fragLoadSec + playlistLoadSec;
      };
      _proto.onLevelLoaded = function onLevelLoaded(event, data) {
        var config = this.hls.config;
        var loading = data.stats.loading;
        var timeLoadingMs = loading.end - loading.start;
        if (isFiniteNumber(timeLoadingMs)) {
          this.lastLevelLoadSec = timeLoadingMs / 1e3;
        }
        if (data.details.live) {
          this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);
        } else {
          this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);
        }
      };
      _proto.onFragLoaded = function onFragLoaded(event, _ref) {
        var frag = _ref.frag, part = _ref.part;
        var stats = part ? part.stats : frag.stats;
        if (frag.type === PlaylistLevelType.MAIN) {
          this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);
        }
        if (this.ignoreFragment(frag)) {
          return;
        }
        this.clearTimer();
        if (frag.level === this._nextAutoLevel) {
          this._nextAutoLevel = -1;
        }
        this.firstSelection = -1;
        if (this.hls.config.abrMaxWithRealBitrate) {
          var duration = part ? part.duration : frag.duration;
          var level = this.hls.levels[frag.level];
          var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;
          var loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;
          level.loaded = {
            bytes: loadedBytes,
            duration: loadedDuration
          };
          level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
        }
        if (frag.bitrateTest) {
          var fragBufferedData = {
            stats,
            frag,
            part,
            id: frag.type
          };
          this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);
          frag.bitrateTest = false;
        } else {
          this.lastLoadedFragLevel = frag.level;
        }
      };
      _proto.onFragBuffered = function onFragBuffered(event, data) {
        var frag = data.frag, part = data.part;
        var stats = part != null && part.stats.loaded ? part.stats : frag.stats;
        if (stats.aborted) {
          return;
        }
        if (this.ignoreFragment(frag)) {
          return;
        }
        var processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());
        this.bwEstimator.sample(processingMs, stats.loaded);
        stats.bwEstimate = this.getBwEstimate();
        if (frag.bitrateTest) {
          this.bitrateTestDelay = processingMs / 1e3;
        } else {
          this.bitrateTestDelay = 0;
        }
      };
      _proto.ignoreFragment = function ignoreFragment(frag) {
        return frag.type !== PlaylistLevelType.MAIN || frag.sn === "initSegment";
      };
      _proto.clearTimer = function clearTimer() {
        if (this.timer > -1) {
          self.clearInterval(this.timer);
          this.timer = -1;
        }
      };
      _proto.getAutoLevelKey = function getAutoLevelKey() {
        var _this$hls$mainForward;
        return this.getBwEstimate() + "_" + ((_this$hls$mainForward = this.hls.mainForwardBufferInfo) == null ? void 0 : _this$hls$mainForward.len);
      };
      _proto.getNextABRAutoLevel = function getNextABRAutoLevel() {
        var fragCurrent = this.fragCurrent, partCurrent = this.partCurrent, hls = this.hls;
        var maxAutoLevel = hls.maxAutoLevel, config = hls.config, minAutoLevel = hls.minAutoLevel, media = hls.media;
        var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
        var playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1;
        var avgbw = this.getBwEstimate();
        var bufferInfo = hls.mainForwardBufferInfo;
        var bufferStarvationDelay = (bufferInfo ? bufferInfo.len : 0) / playbackRate;
        var bwFactor = config.abrBandWidthFactor;
        var bwUpFactor = config.abrBandWidthUpFactor;
        if (bufferStarvationDelay) {
          var _bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, 0, bwFactor, bwUpFactor);
          if (_bestLevel >= 0) {
            return _bestLevel;
          }
        }
        var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;
        if (!bufferStarvationDelay) {
          var bitrateTestDelay = this.bitrateTestDelay;
          if (bitrateTestDelay) {
            var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
            maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
            logger.info("[abr] bitrate test took " + Math.round(1e3 * bitrateTestDelay) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * maxStarvationDelay) + " ms");
            bwFactor = bwUpFactor = 1;
          }
        }
        var bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor);
        logger.info("[abr] " + (bufferStarvationDelay ? "rebuffering expected" : "buffer is empty") + ", optimal quality level " + bestLevel);
        if (bestLevel > -1) {
          return bestLevel;
        }
        var minLevel = hls.levels[minAutoLevel];
        var autoLevel = hls.levels[hls.loadLevel];
        if ((minLevel == null ? void 0 : minLevel.bitrate) < (autoLevel == null ? void 0 : autoLevel.bitrate)) {
          return minAutoLevel;
        }
        return hls.loadLevel;
      };
      _proto.getBwEstimate = function getBwEstimate() {
        return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;
      };
      _proto.findBestLevel = function findBestLevel(currentBw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor) {
        var _level$details, _this2 = this;
        var maxFetchDuration = bufferStarvationDelay + maxStarvationDelay;
        var lastLoadedFragLevel = this.lastLoadedFragLevel;
        var selectionBaseLevel = lastLoadedFragLevel === -1 ? this.hls.firstLevel : lastLoadedFragLevel;
        var fragCurrent = this.fragCurrent, partCurrent = this.partCurrent;
        var _this$hls = this.hls, levels = _this$hls.levels, allAudioTracks = _this$hls.allAudioTracks, loadLevel = _this$hls.loadLevel, config = _this$hls.config;
        if (levels.length === 1) {
          return 0;
        }
        var level = levels[selectionBaseLevel];
        var live = !!(level != null && (_level$details = level.details) != null && _level$details.live);
        var firstSelection = loadLevel === -1 || lastLoadedFragLevel === -1;
        var currentCodecSet;
        var currentVideoRange = "SDR";
        var currentFrameRate = (level == null ? void 0 : level.frameRate) || 0;
        var audioPreference = config.audioPreference, videoPreference = config.videoPreference;
        var audioTracksByGroup = this.audioTracksByGroup || (this.audioTracksByGroup = getAudioTracksByGroup(allAudioTracks));
        if (firstSelection) {
          if (this.firstSelection !== -1) {
            return this.firstSelection;
          }
          var codecTiers = this.codecTiers || (this.codecTiers = getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel));
          var startTier = getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference);
          var codecSet = startTier.codecSet, videoRanges = startTier.videoRanges, minFramerate = startTier.minFramerate, minBitrate = startTier.minBitrate, preferHDR = startTier.preferHDR;
          currentCodecSet = codecSet;
          currentVideoRange = preferHDR ? videoRanges[videoRanges.length - 1] : videoRanges[0];
          currentFrameRate = minFramerate;
          currentBw = Math.max(currentBw, minBitrate);
          logger.log("[abr] picked start tier " + JSON.stringify(startTier));
        } else {
          currentCodecSet = level == null ? void 0 : level.codecSet;
          currentVideoRange = level == null ? void 0 : level.videoRange;
        }
        var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
        var ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1e3;
        var levelsSkipped = [];
        var _loop = function _loop2() {
          var _levelInfo$supportedR, _levelInfo$supportedR2;
          var levelInfo = levels[i];
          var upSwitch = i > selectionBaseLevel;
          if (!levelInfo) {
            return 0;
          }
          if (config.useMediaCapabilities && !levelInfo.supportedResult && !levelInfo.supportedPromise) {
            var mediaCapabilities = navigator.mediaCapabilities;
            if (typeof (mediaCapabilities == null ? void 0 : mediaCapabilities.decodingInfo) === "function" && requiresMediaCapabilitiesDecodingInfo(levelInfo, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference)) {
              levelInfo.supportedPromise = getMediaDecodingInfoPromise(levelInfo, audioTracksByGroup, mediaCapabilities);
              levelInfo.supportedPromise.then(function(decodingInfo) {
                levelInfo.supportedResult = decodingInfo;
                var levels2 = _this2.hls.levels;
                var index = levels2.indexOf(levelInfo);
                if (decodingInfo.error) {
                  logger.warn('[abr] MediaCapabilities decodingInfo error: "' + decodingInfo.error + '" for level ' + index + " " + JSON.stringify(decodingInfo));
                } else if (!decodingInfo.supported) {
                  logger.warn("[abr] Unsupported MediaCapabilities decodingInfo result for level " + index + " " + JSON.stringify(decodingInfo));
                  if (index > -1 && levels2.length > 1) {
                    logger.log("[abr] Removing unsupported level " + index);
                    _this2.hls.removeLevel(index);
                  }
                }
              });
            } else {
              levelInfo.supportedResult = SUPPORTED_INFO_DEFAULT;
            }
          }
          if (currentCodecSet && levelInfo.codecSet !== currentCodecSet || currentVideoRange && levelInfo.videoRange !== currentVideoRange || upSwitch && currentFrameRate > levelInfo.frameRate || !upSwitch && currentFrameRate > 0 && currentFrameRate < levelInfo.frameRate || !((_levelInfo$supportedR = levelInfo.supportedResult) != null && (_levelInfo$supportedR2 = _levelInfo$supportedR.decodingInfoResults) != null && _levelInfo$supportedR2[0].smooth)) {
            levelsSkipped.push(i);
            return 0;
          }
          var levelDetails = levelInfo.details;
          var avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;
          var adjustedbw;
          if (!upSwitch) {
            adjustedbw = bwFactor * currentBw;
          } else {
            adjustedbw = bwUpFactor * currentBw;
          }
          var bitrate = currentFragDuration && bufferStarvationDelay >= currentFragDuration * 2 && maxStarvationDelay === 0 ? levels[i].averageBitrate : levels[i].maxBitrate;
          var fetchDuration = _this2.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === void 0);
          var canSwitchWithinTolerance = (
            // if adjusted bw is greater than level bitrate AND
            adjustedbw >= bitrate && // no level change, or new level has no error history
            (i === lastLoadedFragLevel || levelInfo.loadError === 0 && levelInfo.fragmentError === 0) && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
            // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
            // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1
            (fetchDuration <= ttfbEstimateSec || !isFiniteNumber(fetchDuration) || live && !_this2.bitrateTestDelay || fetchDuration < maxFetchDuration)
          );
          if (canSwitchWithinTolerance) {
            var forcedAutoLevel = _this2.forcedAutoLevel;
            if (i !== loadLevel && (forcedAutoLevel === -1 || forcedAutoLevel !== loadLevel)) {
              if (levelsSkipped.length) {
                logger.trace("[abr] Skipped level(s) " + levelsSkipped.join(",") + " of " + maxAutoLevel + ' max with CODECS and VIDEO-RANGE:"' + levels[levelsSkipped[0]].codecs + '" ' + levels[levelsSkipped[0]].videoRange + '; not compatible with "' + level.codecs + '" ' + currentVideoRange);
              }
              logger.info("[abr] switch candidate:" + selectionBaseLevel + "->" + i + " adjustedbw(" + Math.round(adjustedbw) + ")-bitrate=" + Math.round(adjustedbw - bitrate) + " ttfb:" + ttfbEstimateSec.toFixed(1) + " avgDuration:" + avgDuration.toFixed(1) + " maxFetchDuration:" + maxFetchDuration.toFixed(1) + " fetchDuration:" + fetchDuration.toFixed(1) + " firstSelection:" + firstSelection + " codecSet:" + currentCodecSet + " videoRange:" + currentVideoRange + " hls.loadLevel:" + loadLevel);
            }
            if (firstSelection) {
              _this2.firstSelection = i;
            }
            return {
              v: i
            };
          }
        }, _ret;
        for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
          _ret = _loop();
          if (_ret === 0)
            continue;
          if (_ret)
            return _ret.v;
        }
        return -1;
      };
      _createClass(AbrController2, [{
        key: "firstAutoLevel",
        get: function get() {
          var _this$hls2 = this.hls, maxAutoLevel = _this$hls2.maxAutoLevel, minAutoLevel = _this$hls2.minAutoLevel;
          var bwEstimate = this.getBwEstimate();
          var maxStartDelay = this.hls.config.maxStarvationDelay;
          var abrAutoLevel = this.findBestLevel(bwEstimate, minAutoLevel, maxAutoLevel, 0, maxStartDelay, 1, 1);
          if (abrAutoLevel > -1) {
            return abrAutoLevel;
          }
          var firstLevel = this.hls.firstLevel;
          var clamped = Math.min(Math.max(firstLevel, minAutoLevel), maxAutoLevel);
          logger.warn("[abr] Could not find best starting auto level. Defaulting to first in playlist " + firstLevel + " clamped to " + clamped);
          return clamped;
        }
      }, {
        key: "forcedAutoLevel",
        get: function get() {
          if (this.nextAutoLevelKey) {
            return -1;
          }
          return this._nextAutoLevel;
        }
        // return next auto level
      }, {
        key: "nextAutoLevel",
        get: function get() {
          var forcedAutoLevel = this.forcedAutoLevel;
          var bwEstimator = this.bwEstimator;
          var useEstimate = bwEstimator.canEstimate();
          var loadedFirstFrag = this.lastLoadedFragLevel > -1;
          if (forcedAutoLevel !== -1 && (!useEstimate || !loadedFirstFrag || this.nextAutoLevelKey === this.getAutoLevelKey())) {
            return forcedAutoLevel;
          }
          var nextABRAutoLevel = useEstimate && loadedFirstFrag ? this.getNextABRAutoLevel() : this.firstAutoLevel;
          if (forcedAutoLevel !== -1) {
            var levels = this.hls.levels;
            if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {
              return forcedAutoLevel;
            }
          }
          this._nextAutoLevel = nextABRAutoLevel;
          this.nextAutoLevelKey = this.getAutoLevelKey();
          return nextABRAutoLevel;
        },
        set: function set(nextLevel) {
          var value = Math.max(this.hls.minAutoLevel, nextLevel);
          if (this._nextAutoLevel != value) {
            this.nextAutoLevelKey = "";
            this._nextAutoLevel = value;
          }
        }
      }]);
      return AbrController2;
    }();
    var TaskLoop = /* @__PURE__ */ function() {
      function TaskLoop2() {
        this._boundTick = void 0;
        this._tickTimer = null;
        this._tickInterval = null;
        this._tickCallCount = 0;
        this._boundTick = this.tick.bind(this);
      }
      var _proto = TaskLoop2.prototype;
      _proto.destroy = function destroy() {
        this.onHandlerDestroying();
        this.onHandlerDestroyed();
      };
      _proto.onHandlerDestroying = function onHandlerDestroying() {
        this.clearNextTick();
        this.clearInterval();
      };
      _proto.onHandlerDestroyed = function onHandlerDestroyed() {
      };
      _proto.hasInterval = function hasInterval() {
        return !!this._tickInterval;
      };
      _proto.hasNextTick = function hasNextTick() {
        return !!this._tickTimer;
      };
      _proto.setInterval = function setInterval2(millis) {
        if (!this._tickInterval) {
          this._tickCallCount = 0;
          this._tickInterval = self.setInterval(this._boundTick, millis);
          return true;
        }
        return false;
      };
      _proto.clearInterval = function clearInterval2() {
        if (this._tickInterval) {
          self.clearInterval(this._tickInterval);
          this._tickInterval = null;
          return true;
        }
        return false;
      };
      _proto.clearNextTick = function clearNextTick() {
        if (this._tickTimer) {
          self.clearTimeout(this._tickTimer);
          this._tickTimer = null;
          return true;
        }
        return false;
      };
      _proto.tick = function tick() {
        this._tickCallCount++;
        if (this._tickCallCount === 1) {
          this.doTick();
          if (this._tickCallCount > 1) {
            this.tickImmediate();
          }
          this._tickCallCount = 0;
        }
      };
      _proto.tickImmediate = function tickImmediate() {
        this.clearNextTick();
        this._tickTimer = self.setTimeout(this._boundTick, 0);
      };
      _proto.doTick = function doTick() {
      };
      return TaskLoop2;
    }();
    var FragmentState = {
      NOT_LOADED: "NOT_LOADED",
      APPENDING: "APPENDING",
      PARTIAL: "PARTIAL",
      OK: "OK"
    };
    var FragmentTracker = /* @__PURE__ */ function() {
      function FragmentTracker2(hls) {
        this.activePartLists = /* @__PURE__ */ Object.create(null);
        this.endListFragments = /* @__PURE__ */ Object.create(null);
        this.fragments = /* @__PURE__ */ Object.create(null);
        this.timeRanges = /* @__PURE__ */ Object.create(null);
        this.bufferPadding = 0.2;
        this.hls = void 0;
        this.hasGaps = false;
        this.hls = hls;
        this._registerListeners();
      }
      var _proto = FragmentTracker2.prototype;
      _proto._registerListeners = function _registerListeners() {
        var hls = this.hls;
        hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);
        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
      };
      _proto._unregisterListeners = function _unregisterListeners() {
        var hls = this.hls;
        hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);
        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
      };
      _proto.destroy = function destroy() {
        this._unregisterListeners();
        this.fragments = // @ts-ignore
        this.activePartLists = // @ts-ignore
        this.endListFragments = this.timeRanges = null;
      };
      _proto.getAppendedFrag = function getAppendedFrag(position, levelType) {
        var activeParts = this.activePartLists[levelType];
        if (activeParts) {
          for (var i = activeParts.length; i--; ) {
            var activePart = activeParts[i];
            if (!activePart) {
              break;
            }
            var appendedPTS = activePart.end;
            if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {
              return activePart;
            }
          }
        }
        return this.getBufferedFrag(position, levelType);
      };
      _proto.getBufferedFrag = function getBufferedFrag(position, levelType) {
        var fragments = this.fragments;
        var keys = Object.keys(fragments);
        for (var i = keys.length; i--; ) {
          var fragmentEntity = fragments[keys[i]];
          if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {
            var frag = fragmentEntity.body;
            if (frag.start <= position && position <= frag.end) {
              return frag;
            }
          }
        }
        return null;
      };
      _proto.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {
        var _this = this;
        if (this.timeRanges) {
          this.timeRanges[elementaryStream] = timeRange;
        }
        var appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;
        Object.keys(this.fragments).forEach(function(key) {
          var fragmentEntity = _this.fragments[key];
          if (!fragmentEntity) {
            return;
          }
          if (appendedPartSn >= fragmentEntity.body.sn) {
            return;
          }
          if (!fragmentEntity.buffered && !fragmentEntity.loaded) {
            if (fragmentEntity.body.type === playlistType) {
              _this.removeFragment(fragmentEntity.body);
            }
            return;
          }
          var esData = fragmentEntity.range[elementaryStream];
          if (!esData) {
            return;
          }
          esData.time.some(function(time) {
            var isNotBuffered = !_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);
            if (isNotBuffered) {
              _this.removeFragment(fragmentEntity.body);
            }
            return isNotBuffered;
          });
        });
      };
      _proto.detectPartialFragments = function detectPartialFragments(data) {
        var _this2 = this;
        var timeRanges = this.timeRanges;
        var frag = data.frag, part = data.part;
        if (!timeRanges || frag.sn === "initSegment") {
          return;
        }
        var fragKey = getFragmentKey(frag);
        var fragmentEntity = this.fragments[fragKey];
        if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {
          return;
        }
        var isFragHint = !frag.relurl;
        Object.keys(timeRanges).forEach(function(elementaryStream) {
          var streamInfo = frag.elementaryStreams[elementaryStream];
          if (!streamInfo) {
            return;
          }
          var timeRange = timeRanges[elementaryStream];
          var partial = isFragHint || streamInfo.partial === true;
          fragmentEntity.range[elementaryStream] = _this2.getBufferedTimes(frag, part, partial, timeRange);
        });
        fragmentEntity.loaded = null;
        if (Object.keys(fragmentEntity.range).length) {
          fragmentEntity.buffered = true;
          var endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;
          if (endList) {
            this.endListFragments[fragmentEntity.body.type] = fragmentEntity;
          }
          if (!isPartial(fragmentEntity)) {
            this.removeParts(frag.sn - 1, frag.type);
          }
        } else {
          this.removeFragment(fragmentEntity.body);
        }
      };
      _proto.removeParts = function removeParts(snToKeep, levelType) {
        var activeParts = this.activePartLists[levelType];
        if (!activeParts) {
          return;
        }
        this.activePartLists[levelType] = activeParts.filter(function(part) {
          return part.fragment.sn >= snToKeep;
        });
      };
      _proto.fragBuffered = function fragBuffered(frag, force) {
        var fragKey = getFragmentKey(frag);
        var fragmentEntity = this.fragments[fragKey];
        if (!fragmentEntity && force) {
          fragmentEntity = this.fragments[fragKey] = {
            body: frag,
            appendedPTS: null,
            loaded: null,
            buffered: false,
            range: /* @__PURE__ */ Object.create(null)
          };
          if (frag.gap) {
            this.hasGaps = true;
          }
        }
        if (fragmentEntity) {
          fragmentEntity.loaded = null;
          fragmentEntity.buffered = true;
        }
      };
      _proto.getBufferedTimes = function getBufferedTimes(fragment, part, partial, timeRange) {
        var buffered = {
          time: [],
          partial
        };
        var startPTS = fragment.start;
        var endPTS = fragment.end;
        var minEndPTS = fragment.minEndPTS || endPTS;
        var maxStartPTS = fragment.maxStartPTS || startPTS;
        for (var i = 0; i < timeRange.length; i++) {
          var startTime = timeRange.start(i) - this.bufferPadding;
          var endTime = timeRange.end(i) + this.bufferPadding;
          if (maxStartPTS >= startTime && minEndPTS <= endTime) {
            buffered.time.push({
              startPTS: Math.max(startPTS, timeRange.start(i)),
              endPTS: Math.min(endPTS, timeRange.end(i))
            });
            break;
          } else if (startPTS < endTime && endPTS > startTime) {
            var start = Math.max(startPTS, timeRange.start(i));
            var end = Math.min(endPTS, timeRange.end(i));
            if (end > start) {
              buffered.partial = true;
              buffered.time.push({
                startPTS: start,
                endPTS: end
              });
            }
          } else if (endPTS <= startTime) {
            break;
          }
        }
        return buffered;
      };
      _proto.getPartialFragment = function getPartialFragment(time) {
        var bestFragment = null;
        var timePadding;
        var startTime;
        var endTime;
        var bestOverlap = 0;
        var bufferPadding = this.bufferPadding, fragments = this.fragments;
        Object.keys(fragments).forEach(function(key) {
          var fragmentEntity = fragments[key];
          if (!fragmentEntity) {
            return;
          }
          if (isPartial(fragmentEntity)) {
            startTime = fragmentEntity.body.start - bufferPadding;
            endTime = fragmentEntity.body.end + bufferPadding;
            if (time >= startTime && time <= endTime) {
              timePadding = Math.min(time - startTime, endTime - time);
              if (bestOverlap <= timePadding) {
                bestFragment = fragmentEntity.body;
                bestOverlap = timePadding;
              }
            }
          }
        });
        return bestFragment;
      };
      _proto.isEndListAppended = function isEndListAppended(type) {
        var lastFragmentEntity = this.endListFragments[type];
        return lastFragmentEntity !== void 0 && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));
      };
      _proto.getState = function getState(fragment) {
        var fragKey = getFragmentKey(fragment);
        var fragmentEntity = this.fragments[fragKey];
        if (fragmentEntity) {
          if (!fragmentEntity.buffered) {
            return FragmentState.APPENDING;
          } else if (isPartial(fragmentEntity)) {
            return FragmentState.PARTIAL;
          } else {
            return FragmentState.OK;
          }
        }
        return FragmentState.NOT_LOADED;
      };
      _proto.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {
        var startTime;
        var endTime;
        for (var i = 0; i < timeRange.length; i++) {
          startTime = timeRange.start(i) - this.bufferPadding;
          endTime = timeRange.end(i) + this.bufferPadding;
          if (startPTS >= startTime && endPTS <= endTime) {
            return true;
          }
          if (endPTS <= startTime) {
            return false;
          }
        }
        return false;
      };
      _proto.onFragLoaded = function onFragLoaded(event, data) {
        var frag = data.frag, part = data.part;
        if (frag.sn === "initSegment" || frag.bitrateTest) {
          return;
        }
        var loaded = part ? null : data;
        var fragKey = getFragmentKey(frag);
        this.fragments[fragKey] = {
          body: frag,
          appendedPTS: null,
          loaded,
          buffered: false,
          range: /* @__PURE__ */ Object.create(null)
        };
      };
      _proto.onBufferAppended = function onBufferAppended(event, data) {
        var _this3 = this;
        var frag = data.frag, part = data.part, timeRanges = data.timeRanges;
        if (frag.sn === "initSegment") {
          return;
        }
        var playlistType = frag.type;
        if (part) {
          var activeParts = this.activePartLists[playlistType];
          if (!activeParts) {
            this.activePartLists[playlistType] = activeParts = [];
          }
          activeParts.push(part);
        }
        this.timeRanges = timeRanges;
        Object.keys(timeRanges).forEach(function(elementaryStream) {
          var timeRange = timeRanges[elementaryStream];
          _this3.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);
        });
      };
      _proto.onFragBuffered = function onFragBuffered(event, data) {
        this.detectPartialFragments(data);
      };
      _proto.hasFragment = function hasFragment(fragment) {
        var fragKey = getFragmentKey(fragment);
        return !!this.fragments[fragKey];
      };
      _proto.hasParts = function hasParts(type) {
        var _this$activePartLists;
        return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);
      };
      _proto.removeFragmentsInRange = function removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {
        var _this4 = this;
        if (withGapOnly && !this.hasGaps) {
          return;
        }
        Object.keys(this.fragments).forEach(function(key) {
          var fragmentEntity = _this4.fragments[key];
          if (!fragmentEntity) {
            return;
          }
          var frag = fragmentEntity.body;
          if (frag.type !== playlistType || withGapOnly && !frag.gap) {
            return;
          }
          if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {
            _this4.removeFragment(frag);
          }
        });
      };
      _proto.removeFragment = function removeFragment(fragment) {
        var fragKey = getFragmentKey(fragment);
        fragment.stats.loaded = 0;
        fragment.clearElementaryStreamInfo();
        var activeParts = this.activePartLists[fragment.type];
        if (activeParts) {
          var snToRemove = fragment.sn;
          this.activePartLists[fragment.type] = activeParts.filter(function(part) {
            return part.fragment.sn !== snToRemove;
          });
        }
        delete this.fragments[fragKey];
        if (fragment.endList) {
          delete this.endListFragments[fragment.type];
        }
      };
      _proto.removeAllFragments = function removeAllFragments() {
        this.fragments = /* @__PURE__ */ Object.create(null);
        this.endListFragments = /* @__PURE__ */ Object.create(null);
        this.activePartLists = /* @__PURE__ */ Object.create(null);
        this.hasGaps = false;
      };
      return FragmentTracker2;
    }();
    function isPartial(fragmentEntity) {
      var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;
      return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));
    }
    function getFragmentKey(fragment) {
      return fragment.type + "_" + fragment.level + "_" + fragment.sn;
    }
    var noopBuffered = {
      length: 0,
      start: function start() {
        return 0;
      },
      end: function end() {
        return 0;
      }
    };
    var BufferHelper = /* @__PURE__ */ function() {
      function BufferHelper2() {
      }
      BufferHelper2.isBuffered = function isBuffered(media, position) {
        try {
          if (media) {
            var buffered = BufferHelper2.getBuffered(media);
            for (var i = 0; i < buffered.length; i++) {
              if (position >= buffered.start(i) && position <= buffered.end(i)) {
                return true;
              }
            }
          }
        } catch (error) {
        }
        return false;
      };
      BufferHelper2.bufferInfo = function bufferInfo(media, pos, maxHoleDuration) {
        try {
          if (media) {
            var vbuffered = BufferHelper2.getBuffered(media);
            var buffered = [];
            var i;
            for (i = 0; i < vbuffered.length; i++) {
              buffered.push({
                start: vbuffered.start(i),
                end: vbuffered.end(i)
              });
            }
            return this.bufferedInfo(buffered, pos, maxHoleDuration);
          }
        } catch (error) {
        }
        return {
          len: 0,
          start: pos,
          end: pos,
          nextStart: void 0
        };
      };
      BufferHelper2.bufferedInfo = function bufferedInfo(buffered, pos, maxHoleDuration) {
        pos = Math.max(0, pos);
        buffered.sort(function(a, b) {
          var diff = a.start - b.start;
          if (diff) {
            return diff;
          } else {
            return b.end - a.end;
          }
        });
        var buffered2 = [];
        if (maxHoleDuration) {
          for (var i = 0; i < buffered.length; i++) {
            var buf2len = buffered2.length;
            if (buf2len) {
              var buf2end = buffered2[buf2len - 1].end;
              if (buffered[i].start - buf2end < maxHoleDuration) {
                if (buffered[i].end > buf2end) {
                  buffered2[buf2len - 1].end = buffered[i].end;
                }
              } else {
                buffered2.push(buffered[i]);
              }
            } else {
              buffered2.push(buffered[i]);
            }
          }
        } else {
          buffered2 = buffered;
        }
        var bufferLen = 0;
        var bufferStartNext;
        var bufferStart = pos;
        var bufferEnd = pos;
        for (var _i = 0; _i < buffered2.length; _i++) {
          var start = buffered2[_i].start;
          var end = buffered2[_i].end;
          if (pos + maxHoleDuration >= start && pos < end) {
            bufferStart = start;
            bufferEnd = end;
            bufferLen = bufferEnd - pos;
          } else if (pos + maxHoleDuration < start) {
            bufferStartNext = start;
            break;
          }
        }
        return {
          len: bufferLen,
          start: bufferStart || 0,
          end: bufferEnd || 0,
          nextStart: bufferStartNext
        };
      };
      BufferHelper2.getBuffered = function getBuffered(media) {
        try {
          return media.buffered;
        } catch (e) {
          logger.log("failed to get media.buffered", e);
          return noopBuffered;
        }
      };
      return BufferHelper2;
    }();
    var ChunkMetadata = function ChunkMetadata2(level, sn, id, size, part, partial) {
      if (size === void 0) {
        size = 0;
      }
      if (part === void 0) {
        part = -1;
      }
      if (partial === void 0) {
        partial = false;
      }
      this.level = void 0;
      this.sn = void 0;
      this.part = void 0;
      this.id = void 0;
      this.size = void 0;
      this.partial = void 0;
      this.transmuxing = getNewPerformanceTiming();
      this.buffering = {
        audio: getNewPerformanceTiming(),
        video: getNewPerformanceTiming(),
        audiovideo: getNewPerformanceTiming()
      };
      this.level = level;
      this.sn = sn;
      this.id = id;
      this.size = size;
      this.part = part;
      this.partial = partial;
    };
    function getNewPerformanceTiming() {
      return {
        start: 0,
        executeStart: 0,
        executeEnd: 0,
        end: 0
      };
    }
    function findFirstFragWithCC(fragments, cc) {
      for (var i = 0, len = fragments.length; i < len; i++) {
        var _fragments$i;
        if (((_fragments$i = fragments[i]) == null ? void 0 : _fragments$i.cc) === cc) {
          return fragments[i];
        }
      }
      return null;
    }
    function shouldAlignOnDiscontinuities(lastFrag, switchDetails, details) {
      if (switchDetails) {
        if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
          return true;
        }
      }
      return false;
    }
    function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
      var prevFrags = prevDetails.fragments;
      var curFrags = curDetails.fragments;
      if (!curFrags.length || !prevFrags.length) {
        logger.log("No fragments to align");
        return;
      }
      var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);
      if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
        logger.log("No frag in previous level to align on");
        return;
      }
      return prevStartFrag;
    }
    function adjustFragmentStart(frag, sliding) {
      if (frag) {
        var start = frag.start + sliding;
        frag.start = frag.startPTS = start;
        frag.endPTS = start + frag.duration;
      }
    }
    function adjustSlidingStart(sliding, details) {
      var fragments = details.fragments;
      for (var i = 0, len = fragments.length; i < len; i++) {
        adjustFragmentStart(fragments[i], sliding);
      }
      if (details.fragmentHint) {
        adjustFragmentStart(details.fragmentHint, sliding);
      }
      details.alignedSliding = true;
    }
    function alignStream(lastFrag, switchDetails, details) {
      if (!switchDetails) {
        return;
      }
      alignDiscontinuities(lastFrag, details, switchDetails);
      if (!details.alignedSliding && switchDetails) {
        alignMediaPlaylistByPDT(details, switchDetails);
      }
      if (!details.alignedSliding && switchDetails && !details.skippedSegments) {
        adjustSliding(switchDetails, details);
      }
    }
    function alignDiscontinuities(lastFrag, details, switchDetails) {
      if (shouldAlignOnDiscontinuities(lastFrag, switchDetails, details)) {
        var referenceFrag = findDiscontinuousReferenceFrag(switchDetails, details);
        if (referenceFrag && isFiniteNumber(referenceFrag.start)) {
          logger.log("Adjusting PTS using last level due to CC increase within current level " + details.url);
          adjustSlidingStart(referenceFrag.start, details);
        }
      }
    }
    function alignMediaPlaylistByPDT(details, refDetails) {
      if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {
        return;
      }
      var fragments = details.fragments;
      var refFragments = refDetails.fragments;
      if (!fragments.length || !refFragments.length) {
        return;
      }
      var refFrag;
      var frag;
      var targetCC = Math.min(refDetails.endCC, details.endCC);
      if (refDetails.startCC < targetCC && details.startCC < targetCC) {
        refFrag = findFirstFragWithCC(refFragments, targetCC);
        frag = findFirstFragWithCC(fragments, targetCC);
      }
      if (!refFrag || !frag) {
        refFrag = refFragments[Math.floor(refFragments.length / 2)];
        frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.floor(fragments.length / 2)];
      }
      var refPDT = refFrag.programDateTime;
      var targetPDT = frag.programDateTime;
      if (!refPDT || !targetPDT) {
        return;
      }
      var delta = (targetPDT - refPDT) / 1e3 - (frag.start - refFrag.start);
      adjustSlidingStart(delta, details);
    }
    var MIN_CHUNK_SIZE = Math.pow(2, 17);
    var FragmentLoader = /* @__PURE__ */ function() {
      function FragmentLoader2(config) {
        this.config = void 0;
        this.loader = null;
        this.partLoadTimeout = -1;
        this.config = config;
      }
      var _proto = FragmentLoader2.prototype;
      _proto.destroy = function destroy() {
        if (this.loader) {
          this.loader.destroy();
          this.loader = null;
        }
      };
      _proto.abort = function abort() {
        if (this.loader) {
          this.loader.abort();
        }
      };
      _proto.load = function load(frag, _onProgress) {
        var _this = this;
        var url = frag.url;
        if (!url) {
          return Promise.reject(new LoadError({
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.FRAG_LOAD_ERROR,
            fatal: false,
            frag,
            error: new Error("Fragment does not have a " + (url ? "part list" : "url")),
            networkDetails: null
          }));
        }
        this.abort();
        var config = this.config;
        var FragmentILoader = config.fLoader;
        var DefaultILoader = config.loader;
        return new Promise(function(resolve, reject) {
          if (_this.loader) {
            _this.loader.destroy();
          }
          if (frag.gap) {
            if (frag.tagList.some(function(tags) {
              return tags[0] === "GAP";
            })) {
              reject(createGapLoadError(frag));
              return;
            } else {
              frag.gap = false;
            }
          }
          var loader = _this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
          var loaderContext = createLoaderContext(frag);
          var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
          var loaderConfig = {
            loadPolicy,
            timeout: loadPolicy.maxLoadTimeMs,
            maxRetry: 0,
            retryDelay: 0,
            maxRetryDelay: 0,
            highWaterMark: frag.sn === "initSegment" ? Infinity : MIN_CHUNK_SIZE
          };
          frag.stats = loader.stats;
          loader.load(loaderContext, loaderConfig, {
            onSuccess: function onSuccess(response, stats, context, networkDetails) {
              _this.resetLoader(frag, loader);
              var payload = response.data;
              if (context.resetIV && frag.decryptdata) {
                frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));
                payload = payload.slice(16);
              }
              resolve({
                frag,
                part: null,
                payload,
                networkDetails
              });
            },
            onError: function onError(response, context, networkDetails, stats) {
              _this.resetLoader(frag, loader);
              reject(new LoadError({
                type: ErrorTypes.NETWORK_ERROR,
                details: ErrorDetails.FRAG_LOAD_ERROR,
                fatal: false,
                frag,
                response: _objectSpread2({
                  url,
                  data: void 0
                }, response),
                error: new Error("HTTP Error " + response.code + " " + response.text),
                networkDetails,
                stats
              }));
            },
            onAbort: function onAbort(stats, context, networkDetails) {
              _this.resetLoader(frag, loader);
              reject(new LoadError({
                type: ErrorTypes.NETWORK_ERROR,
                details: ErrorDetails.INTERNAL_ABORTED,
                fatal: false,
                frag,
                error: new Error("Aborted"),
                networkDetails,
                stats
              }));
            },
            onTimeout: function onTimeout(stats, context, networkDetails) {
              _this.resetLoader(frag, loader);
              reject(new LoadError({
                type: ErrorTypes.NETWORK_ERROR,
                details: ErrorDetails.FRAG_LOAD_TIMEOUT,
                fatal: false,
                frag,
                error: new Error("Timeout after " + loaderConfig.timeout + "ms"),
                networkDetails,
                stats
              }));
            },
            onProgress: function onProgress(stats, context, data, networkDetails) {
              if (_onProgress) {
                _onProgress({
                  frag,
                  part: null,
                  payload: data,
                  networkDetails
                });
              }
            }
          });
        });
      };
      _proto.loadPart = function loadPart(frag, part, onProgress) {
        var _this2 = this;
        this.abort();
        var config = this.config;
        var FragmentILoader = config.fLoader;
        var DefaultILoader = config.loader;
        return new Promise(function(resolve, reject) {
          if (_this2.loader) {
            _this2.loader.destroy();
          }
          if (frag.gap || part.gap) {
            reject(createGapLoadError(frag, part));
            return;
          }
          var loader = _this2.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
          var loaderContext = createLoaderContext(frag, part);
          var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
          var loaderConfig = {
            loadPolicy,
            timeout: loadPolicy.maxLoadTimeMs,
            maxRetry: 0,
            retryDelay: 0,
            maxRetryDelay: 0,
            highWaterMark: MIN_CHUNK_SIZE
          };
          part.stats = loader.stats;
          loader.load(loaderContext, loaderConfig, {
            onSuccess: function onSuccess(response, stats, context, networkDetails) {
              _this2.resetLoader(frag, loader);
              _this2.updateStatsFromPart(frag, part);
              var partLoadedData = {
                frag,
                part,
                payload: response.data,
                networkDetails
              };
              onProgress(partLoadedData);
              resolve(partLoadedData);
            },
            onError: function onError(response, context, networkDetails, stats) {
              _this2.resetLoader(frag, loader);
              reject(new LoadError({
                type: ErrorTypes.NETWORK_ERROR,
                details: ErrorDetails.FRAG_LOAD_ERROR,
                fatal: false,
                frag,
                part,
                response: _objectSpread2({
                  url: loaderContext.url,
                  data: void 0
                }, response),
                error: new Error("HTTP Error " + response.code + " " + response.text),
                networkDetails,
                stats
              }));
            },
            onAbort: function onAbort(stats, context, networkDetails) {
              frag.stats.aborted = part.stats.aborted;
              _this2.resetLoader(frag, loader);
              reject(new LoadError({
                type: ErrorTypes.NETWORK_ERROR,
                details: ErrorDetails.INTERNAL_ABORTED,
                fatal: false,
                frag,
                part,
                error: new Error("Aborted"),
                networkDetails,
                stats
              }));
            },
            onTimeout: function onTimeout(stats, context, networkDetails) {
              _this2.resetLoader(frag, loader);
              reject(new LoadError({
                type: ErrorTypes.NETWORK_ERROR,
                details: ErrorDetails.FRAG_LOAD_TIMEOUT,
                fatal: false,
                frag,
                part,
                error: new Error("Timeout after " + loaderConfig.timeout + "ms"),
                networkDetails,
                stats
              }));
            }
          });
        });
      };
      _proto.updateStatsFromPart = function updateStatsFromPart(frag, part) {
        var fragStats = frag.stats;
        var partStats = part.stats;
        var partTotal = partStats.total;
        fragStats.loaded += partStats.loaded;
        if (partTotal) {
          var estTotalParts = Math.round(frag.duration / part.duration);
          var estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);
          var estRemainingParts = estTotalParts - estLoadedParts;
          var estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);
          fragStats.total = fragStats.loaded + estRemainingBytes;
        } else {
          fragStats.total = Math.max(fragStats.loaded, fragStats.total);
        }
        var fragLoading = fragStats.loading;
        var partLoading = partStats.loading;
        if (fragLoading.start) {
          fragLoading.first += partLoading.first - partLoading.start;
        } else {
          fragLoading.start = partLoading.start;
          fragLoading.first = partLoading.first;
        }
        fragLoading.end = partLoading.end;
      };
      _proto.resetLoader = function resetLoader(frag, loader) {
        frag.loader = null;
        if (this.loader === loader) {
          self.clearTimeout(this.partLoadTimeout);
          this.loader = null;
        }
        loader.destroy();
      };
      return FragmentLoader2;
    }();
    function createLoaderContext(frag, part) {
      if (part === void 0) {
        part = null;
      }
      var segment = part || frag;
      var loaderContext = {
        frag,
        part,
        responseType: "arraybuffer",
        url: segment.url,
        headers: {},
        rangeStart: 0,
        rangeEnd: 0
      };
      var start = segment.byteRangeStartOffset;
      var end = segment.byteRangeEndOffset;
      if (isFiniteNumber(start) && isFiniteNumber(end)) {
        var _frag$decryptdata;
        var byteRangeStart = start;
        var byteRangeEnd = end;
        if (frag.sn === "initSegment" && ((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method) === "AES-128") {
          var fragmentLen = end - start;
          if (fragmentLen % 16) {
            byteRangeEnd = end + (16 - fragmentLen % 16);
          }
          if (start !== 0) {
            loaderContext.resetIV = true;
            byteRangeStart = start - 16;
          }
        }
        loaderContext.rangeStart = byteRangeStart;
        loaderContext.rangeEnd = byteRangeEnd;
      }
      return loaderContext;
    }
    function createGapLoadError(frag, part) {
      var error = new Error("GAP " + (frag.gap ? "tag" : "attribute") + " found");
      var errorData = {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.FRAG_GAP,
        fatal: false,
        frag,
        error,
        networkDetails: null
      };
      if (part) {
        errorData.part = part;
      }
      (part ? part : frag).stats.aborted = true;
      return new LoadError(errorData);
    }
    var LoadError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(LoadError2, _Error);
      function LoadError2(data) {
        var _this3;
        _this3 = _Error.call(this, data.error.message) || this;
        _this3.data = void 0;
        _this3.data = data;
        return _this3;
      }
      return LoadError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    var AESCrypto = /* @__PURE__ */ function() {
      function AESCrypto2(subtle, iv) {
        this.subtle = void 0;
        this.aesIV = void 0;
        this.subtle = subtle;
        this.aesIV = iv;
      }
      var _proto = AESCrypto2.prototype;
      _proto.decrypt = function decrypt(data, key) {
        return this.subtle.decrypt({
          name: "AES-CBC",
          iv: this.aesIV
        }, key, data);
      };
      return AESCrypto2;
    }();
    var FastAESKey = /* @__PURE__ */ function() {
      function FastAESKey2(subtle, key) {
        this.subtle = void 0;
        this.key = void 0;
        this.subtle = subtle;
        this.key = key;
      }
      var _proto = FastAESKey2.prototype;
      _proto.expandKey = function expandKey() {
        return this.subtle.importKey("raw", this.key, {
          name: "AES-CBC"
        }, false, ["encrypt", "decrypt"]);
      };
      return FastAESKey2;
    }();
    function removePadding(array) {
      var outputBytes = array.byteLength;
      var paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);
      if (paddingBytes) {
        return sliceUint8(array, 0, outputBytes - paddingBytes);
      }
      return array;
    }
    var AESDecryptor = /* @__PURE__ */ function() {
      function AESDecryptor2() {
        this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
        this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
        this.sBox = new Uint32Array(256);
        this.invSBox = new Uint32Array(256);
        this.key = new Uint32Array(0);
        this.ksRows = 0;
        this.keySize = 0;
        this.keySchedule = void 0;
        this.invKeySchedule = void 0;
        this.initTable();
      }
      var _proto = AESDecryptor2.prototype;
      _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {
        var view = new DataView(arrayBuffer);
        var newArray = new Uint32Array(4);
        for (var i = 0; i < 4; i++) {
          newArray[i] = view.getUint32(i * 4);
        }
        return newArray;
      };
      _proto.initTable = function initTable() {
        var sBox = this.sBox;
        var invSBox = this.invSBox;
        var subMix = this.subMix;
        var subMix0 = subMix[0];
        var subMix1 = subMix[1];
        var subMix2 = subMix[2];
        var subMix3 = subMix[3];
        var invSubMix = this.invSubMix;
        var invSubMix0 = invSubMix[0];
        var invSubMix1 = invSubMix[1];
        var invSubMix2 = invSubMix[2];
        var invSubMix3 = invSubMix[3];
        var d = new Uint32Array(256);
        var x = 0;
        var xi = 0;
        var i = 0;
        for (i = 0; i < 256; i++) {
          if (i < 128) {
            d[i] = i << 1;
          } else {
            d[i] = i << 1 ^ 283;
          }
        }
        for (i = 0; i < 256; i++) {
          var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
          sx = sx >>> 8 ^ sx & 255 ^ 99;
          sBox[x] = sx;
          invSBox[sx] = x;
          var x2 = d[x];
          var x4 = d[x2];
          var x8 = d[x4];
          var t = d[sx] * 257 ^ sx * 16843008;
          subMix0[x] = t << 24 | t >>> 8;
          subMix1[x] = t << 16 | t >>> 16;
          subMix2[x] = t << 8 | t >>> 24;
          subMix3[x] = t;
          t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
          invSubMix0[sx] = t << 24 | t >>> 8;
          invSubMix1[sx] = t << 16 | t >>> 16;
          invSubMix2[sx] = t << 8 | t >>> 24;
          invSubMix3[sx] = t;
          if (!x) {
            x = xi = 1;
          } else {
            x = x2 ^ d[d[d[x8 ^ x2]]];
            xi ^= d[d[xi]];
          }
        }
      };
      _proto.expandKey = function expandKey(keyBuffer) {
        var key = this.uint8ArrayToUint32Array_(keyBuffer);
        var sameKey = true;
        var offset = 0;
        while (offset < key.length && sameKey) {
          sameKey = key[offset] === this.key[offset];
          offset++;
        }
        if (sameKey) {
          return;
        }
        this.key = key;
        var keySize = this.keySize = key.length;
        if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
          throw new Error("Invalid aes key size=" + keySize);
        }
        var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
        var ksRow;
        var invKsRow;
        var keySchedule = this.keySchedule = new Uint32Array(ksRows);
        var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
        var sbox = this.sBox;
        var rcon = this.rcon;
        var invSubMix = this.invSubMix;
        var invSubMix0 = invSubMix[0];
        var invSubMix1 = invSubMix[1];
        var invSubMix2 = invSubMix[2];
        var invSubMix3 = invSubMix[3];
        var prev;
        var t;
        for (ksRow = 0; ksRow < ksRows; ksRow++) {
          if (ksRow < keySize) {
            prev = keySchedule[ksRow] = key[ksRow];
            continue;
          }
          t = prev;
          if (ksRow % keySize === 0) {
            t = t << 8 | t >>> 24;
            t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 255] << 16 | sbox[t >>> 8 & 255] << 8 | sbox[t & 255];
            t ^= rcon[ksRow / keySize | 0] << 24;
          } else if (keySize > 6 && ksRow % keySize === 4) {
            t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 255] << 16 | sbox[t >>> 8 & 255] << 8 | sbox[t & 255];
          }
          keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
        }
        for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
          ksRow = ksRows - invKsRow;
          if (invKsRow & 3) {
            t = keySchedule[ksRow];
          } else {
            t = keySchedule[ksRow - 4];
          }
          if (invKsRow < 4 || ksRow <= 4) {
            invKeySchedule[invKsRow] = t;
          } else {
            invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 255]] ^ invSubMix2[sbox[t >>> 8 & 255]] ^ invSubMix3[sbox[t & 255]];
          }
          invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
        }
      };
      _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {
        return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
      };
      _proto.decrypt = function decrypt(inputArrayBuffer, offset, aesIV) {
        var nRounds = this.keySize + 6;
        var invKeySchedule = this.invKeySchedule;
        var invSBOX = this.invSBox;
        var invSubMix = this.invSubMix;
        var invSubMix0 = invSubMix[0];
        var invSubMix1 = invSubMix[1];
        var invSubMix2 = invSubMix[2];
        var invSubMix3 = invSubMix[3];
        var initVector = this.uint8ArrayToUint32Array_(aesIV);
        var initVector0 = initVector[0];
        var initVector1 = initVector[1];
        var initVector2 = initVector[2];
        var initVector3 = initVector[3];
        var inputInt32 = new Int32Array(inputArrayBuffer);
        var outputInt32 = new Int32Array(inputInt32.length);
        var t0, t1, t2, t3;
        var s0, s1, s2, s3;
        var inputWords0, inputWords1, inputWords2, inputWords3;
        var ksRow, i;
        var swapWord = this.networkToHostOrderSwap;
        while (offset < inputInt32.length) {
          inputWords0 = swapWord(inputInt32[offset]);
          inputWords1 = swapWord(inputInt32[offset + 1]);
          inputWords2 = swapWord(inputInt32[offset + 2]);
          inputWords3 = swapWord(inputInt32[offset + 3]);
          s0 = inputWords0 ^ invKeySchedule[0];
          s1 = inputWords3 ^ invKeySchedule[1];
          s2 = inputWords2 ^ invKeySchedule[2];
          s3 = inputWords1 ^ invKeySchedule[3];
          ksRow = 4;
          for (i = 1; i < nRounds; i++) {
            t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 255] ^ invSubMix2[s2 >> 8 & 255] ^ invSubMix3[s3 & 255] ^ invKeySchedule[ksRow];
            t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 255] ^ invSubMix2[s3 >> 8 & 255] ^ invSubMix3[s0 & 255] ^ invKeySchedule[ksRow + 1];
            t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 255] ^ invSubMix2[s0 >> 8 & 255] ^ invSubMix3[s1 & 255] ^ invKeySchedule[ksRow + 2];
            t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 255] ^ invSubMix2[s1 >> 8 & 255] ^ invSubMix3[s2 & 255] ^ invKeySchedule[ksRow + 3];
            s0 = t0;
            s1 = t1;
            s2 = t2;
            s3 = t3;
            ksRow = ksRow + 4;
          }
          t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 255] << 16 ^ invSBOX[s2 >> 8 & 255] << 8 ^ invSBOX[s3 & 255] ^ invKeySchedule[ksRow];
          t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 255] << 16 ^ invSBOX[s3 >> 8 & 255] << 8 ^ invSBOX[s0 & 255] ^ invKeySchedule[ksRow + 1];
          t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 255] << 16 ^ invSBOX[s0 >> 8 & 255] << 8 ^ invSBOX[s1 & 255] ^ invKeySchedule[ksRow + 2];
          t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 255] << 16 ^ invSBOX[s1 >> 8 & 255] << 8 ^ invSBOX[s2 & 255] ^ invKeySchedule[ksRow + 3];
          outputInt32[offset] = swapWord(t0 ^ initVector0);
          outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
          outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
          outputInt32[offset + 3] = swapWord(t1 ^ initVector3);
          initVector0 = inputWords0;
          initVector1 = inputWords1;
          initVector2 = inputWords2;
          initVector3 = inputWords3;
          offset = offset + 4;
        }
        return outputInt32.buffer;
      };
      return AESDecryptor2;
    }();
    var CHUNK_SIZE = 16;
    var Decrypter = /* @__PURE__ */ function() {
      function Decrypter2(config, _temp) {
        var _ref = _temp === void 0 ? {} : _temp, _ref$removePKCS7Paddi = _ref.removePKCS7Padding, removePKCS7Padding = _ref$removePKCS7Paddi === void 0 ? true : _ref$removePKCS7Paddi;
        this.logEnabled = true;
        this.removePKCS7Padding = void 0;
        this.subtle = null;
        this.softwareDecrypter = null;
        this.key = null;
        this.fastAesKey = null;
        this.remainderData = null;
        this.currentIV = null;
        this.currentResult = null;
        this.useSoftware = void 0;
        this.useSoftware = config.enableSoftwareAES;
        this.removePKCS7Padding = removePKCS7Padding;
        if (removePKCS7Padding) {
          try {
            var browserCrypto = self.crypto;
            if (browserCrypto) {
              this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
            }
          } catch (e) {
          }
        }
        if (this.subtle === null) {
          this.useSoftware = true;
        }
      }
      var _proto = Decrypter2.prototype;
      _proto.destroy = function destroy() {
        this.subtle = null;
        this.softwareDecrypter = null;
        this.key = null;
        this.fastAesKey = null;
        this.remainderData = null;
        this.currentIV = null;
        this.currentResult = null;
      };
      _proto.isSync = function isSync() {
        return this.useSoftware;
      };
      _proto.flush = function flush() {
        var currentResult = this.currentResult, remainderData = this.remainderData;
        if (!currentResult || remainderData) {
          this.reset();
          return null;
        }
        var data = new Uint8Array(currentResult);
        this.reset();
        if (this.removePKCS7Padding) {
          return removePadding(data);
        }
        return data;
      };
      _proto.reset = function reset() {
        this.currentResult = null;
        this.currentIV = null;
        this.remainderData = null;
        if (this.softwareDecrypter) {
          this.softwareDecrypter = null;
        }
      };
      _proto.decrypt = function decrypt(data, key, iv) {
        var _this = this;
        if (this.useSoftware) {
          return new Promise(function(resolve, reject) {
            _this.softwareDecrypt(new Uint8Array(data), key, iv);
            var decryptResult = _this.flush();
            if (decryptResult) {
              resolve(decryptResult.buffer);
            } else {
              reject(new Error("[softwareDecrypt] Failed to decrypt data"));
            }
          });
        }
        return this.webCryptoDecrypt(new Uint8Array(data), key, iv);
      };
      _proto.softwareDecrypt = function softwareDecrypt(data, key, iv) {
        var currentIV = this.currentIV, currentResult = this.currentResult, remainderData = this.remainderData;
        this.logOnce("JS AES decrypt");
        if (remainderData) {
          data = appendUint8Array(remainderData, data);
          this.remainderData = null;
        }
        var currentChunk = this.getValidChunk(data);
        if (!currentChunk.length) {
          return null;
        }
        if (currentIV) {
          iv = currentIV;
        }
        var softwareDecrypter = this.softwareDecrypter;
        if (!softwareDecrypter) {
          softwareDecrypter = this.softwareDecrypter = new AESDecryptor();
        }
        softwareDecrypter.expandKey(key);
        var result = currentResult;
        this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);
        this.currentIV = sliceUint8(currentChunk, -16).buffer;
        if (!result) {
          return null;
        }
        return result;
      };
      _proto.webCryptoDecrypt = function webCryptoDecrypt(data, key, iv) {
        var _this2 = this;
        var subtle = this.subtle;
        if (this.key !== key || !this.fastAesKey) {
          this.key = key;
          this.fastAesKey = new FastAESKey(subtle, key);
        }
        return this.fastAesKey.expandKey().then(function(aesKey) {
          if (!subtle) {
            return Promise.reject(new Error("web crypto not initialized"));
          }
          _this2.logOnce("WebCrypto AES decrypt");
          var crypto2 = new AESCrypto(subtle, new Uint8Array(iv));
          return crypto2.decrypt(data.buffer, aesKey);
        }).catch(function(err) {
          logger.warn("[decrypter]: WebCrypto Error, disable WebCrypto API, " + err.name + ": " + err.message);
          return _this2.onWebCryptoError(data, key, iv);
        });
      };
      _proto.onWebCryptoError = function onWebCryptoError(data, key, iv) {
        this.useSoftware = true;
        this.logEnabled = true;
        this.softwareDecrypt(data, key, iv);
        var decryptResult = this.flush();
        if (decryptResult) {
          return decryptResult.buffer;
        }
        throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data");
      };
      _proto.getValidChunk = function getValidChunk(data) {
        var currentChunk = data;
        var splitPoint = data.length - data.length % CHUNK_SIZE;
        if (splitPoint !== data.length) {
          currentChunk = sliceUint8(data, 0, splitPoint);
          this.remainderData = sliceUint8(data, splitPoint);
        }
        return currentChunk;
      };
      _proto.logOnce = function logOnce(msg) {
        if (!this.logEnabled) {
          return;
        }
        logger.log("[decrypter]: " + msg);
        this.logEnabled = false;
      };
      return Decrypter2;
    }();
    var TimeRanges = {
      toString: function toString(r) {
        var log = "";
        var len = r.length;
        for (var i = 0; i < len; i++) {
          log += "[" + r.start(i).toFixed(3) + "-" + r.end(i).toFixed(3) + "]";
        }
        return log;
      }
    };
    var State = {
      STOPPED: "STOPPED",
      IDLE: "IDLE",
      KEY_LOADING: "KEY_LOADING",
      FRAG_LOADING: "FRAG_LOADING",
      FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
      WAITING_TRACK: "WAITING_TRACK",
      PARSING: "PARSING",
      PARSED: "PARSED",
      ENDED: "ENDED",
      ERROR: "ERROR",
      WAITING_INIT_PTS: "WAITING_INIT_PTS",
      WAITING_LEVEL: "WAITING_LEVEL"
    };
    var BaseStreamController = /* @__PURE__ */ function(_TaskLoop) {
      _inheritsLoose(BaseStreamController2, _TaskLoop);
      function BaseStreamController2(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {
        var _this;
        _this = _TaskLoop.call(this) || this;
        _this.hls = void 0;
        _this.fragPrevious = null;
        _this.fragCurrent = null;
        _this.fragmentTracker = void 0;
        _this.transmuxer = null;
        _this._state = State.STOPPED;
        _this.playlistType = void 0;
        _this.media = null;
        _this.mediaBuffer = null;
        _this.config = void 0;
        _this.bitrateTest = false;
        _this.lastCurrentTime = 0;
        _this.nextLoadPosition = 0;
        _this.startPosition = 0;
        _this.startTimeOffset = null;
        _this.loadedmetadata = false;
        _this.retryDate = 0;
        _this.levels = null;
        _this.fragmentLoader = void 0;
        _this.keyLoader = void 0;
        _this.levelLastLoaded = null;
        _this.startFragRequested = false;
        _this.decrypter = void 0;
        _this.initPTS = [];
        _this.onvseeking = null;
        _this.onvended = null;
        _this.logPrefix = "";
        _this.log = void 0;
        _this.warn = void 0;
        _this.playlistType = playlistType;
        _this.logPrefix = logPrefix;
        _this.log = logger.log.bind(logger, logPrefix + ":");
        _this.warn = logger.warn.bind(logger, logPrefix + ":");
        _this.hls = hls;
        _this.fragmentLoader = new FragmentLoader(hls.config);
        _this.keyLoader = keyLoader;
        _this.fragmentTracker = fragmentTracker;
        _this.config = hls.config;
        _this.decrypter = new Decrypter(hls.config);
        hls.on(Events.MANIFEST_LOADED, _this.onManifestLoaded, _assertThisInitialized(_this));
        return _this;
      }
      var _proto = BaseStreamController2.prototype;
      _proto.doTick = function doTick() {
        this.onTickEnd();
      };
      _proto.onTickEnd = function onTickEnd() {
      };
      _proto.startLoad = function startLoad(startPosition) {
      };
      _proto.stopLoad = function stopLoad() {
        this.fragmentLoader.abort();
        this.keyLoader.abort(this.playlistType);
        var frag = this.fragCurrent;
        if (frag != null && frag.loader) {
          frag.abortRequests();
          this.fragmentTracker.removeFragment(frag);
        }
        this.resetTransmuxer();
        this.fragCurrent = null;
        this.fragPrevious = null;
        this.clearInterval();
        this.clearNextTick();
        this.state = State.STOPPED;
      };
      _proto._streamEnded = function _streamEnded(bufferInfo, levelDetails) {
        if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {
          return false;
        }
        var partList = levelDetails.partList;
        if (partList != null && partList.length) {
          var lastPart = partList[partList.length - 1];
          var lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);
          return lastPartBuffered;
        }
        var playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;
        return this.fragmentTracker.isEndListAppended(playlistType);
      };
      _proto.getLevelDetails = function getLevelDetails() {
        if (this.levels && this.levelLastLoaded !== null) {
          var _this$levelLastLoaded;
          return (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details;
        }
      };
      _proto.onMediaAttached = function onMediaAttached(event, data) {
        var media = this.media = this.mediaBuffer = data.media;
        this.onvseeking = this.onMediaSeeking.bind(this);
        this.onvended = this.onMediaEnded.bind(this);
        media.addEventListener("seeking", this.onvseeking);
        media.addEventListener("ended", this.onvended);
        var config = this.config;
        if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {
          this.startLoad(config.startPosition);
        }
      };
      _proto.onMediaDetaching = function onMediaDetaching() {
        var media = this.media;
        if (media != null && media.ended) {
          this.log("MSE detaching and video ended, reset startPosition");
          this.startPosition = this.lastCurrentTime = 0;
        }
        if (media && this.onvseeking && this.onvended) {
          media.removeEventListener("seeking", this.onvseeking);
          media.removeEventListener("ended", this.onvended);
          this.onvseeking = this.onvended = null;
        }
        if (this.keyLoader) {
          this.keyLoader.detach();
        }
        this.media = this.mediaBuffer = null;
        this.loadedmetadata = false;
        this.fragmentTracker.removeAllFragments();
        this.stopLoad();
      };
      _proto.onMediaSeeking = function onMediaSeeking() {
        var config = this.config, fragCurrent = this.fragCurrent, media = this.media, mediaBuffer = this.mediaBuffer, state = this.state;
        var currentTime = media ? media.currentTime : 0;
        var bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);
        this.log("media seeking to " + (isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime) + ", state: " + state);
        if (this.state === State.ENDED) {
          this.resetLoadingState();
        } else if (fragCurrent) {
          var tolerance = config.maxFragLookUpTolerance;
          var fragStartOffset = fragCurrent.start - tolerance;
          var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
          if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {
            var pastFragment = currentTime > fragEndOffset;
            if (currentTime < fragStartOffset || pastFragment) {
              if (pastFragment && fragCurrent.loader) {
                this.log("seeking outside of buffer while fragment load in progress, cancel fragment load");
                fragCurrent.abortRequests();
                this.resetLoadingState();
              }
              this.fragPrevious = null;
            }
          }
        }
        if (media) {
          this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);
          this.lastCurrentTime = currentTime;
        }
        if (!this.loadedmetadata && !bufferInfo.len) {
          this.nextLoadPosition = this.startPosition = currentTime;
        }
        this.tickImmediate();
      };
      _proto.onMediaEnded = function onMediaEnded() {
        this.startPosition = this.lastCurrentTime = 0;
      };
      _proto.onManifestLoaded = function onManifestLoaded(event, data) {
        this.startTimeOffset = data.startTimeOffset;
        this.initPTS = [];
      };
      _proto.onHandlerDestroying = function onHandlerDestroying() {
        this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
        this.stopLoad();
        _TaskLoop.prototype.onHandlerDestroying.call(this);
        this.hls = null;
      };
      _proto.onHandlerDestroyed = function onHandlerDestroyed() {
        this.state = State.STOPPED;
        if (this.fragmentLoader) {
          this.fragmentLoader.destroy();
        }
        if (this.keyLoader) {
          this.keyLoader.destroy();
        }
        if (this.decrypter) {
          this.decrypter.destroy();
        }
        this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;
        _TaskLoop.prototype.onHandlerDestroyed.call(this);
      };
      _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {
        this._loadFragForPlayback(frag, level, targetBufferTime);
      };
      _proto._loadFragForPlayback = function _loadFragForPlayback(frag, level, targetBufferTime) {
        var _this2 = this;
        var progressCallback = function progressCallback2(data) {
          if (_this2.fragContextChanged(frag)) {
            _this2.warn("Fragment " + frag.sn + (data.part ? " p: " + data.part.index : "") + " of level " + frag.level + " was dropped during download.");
            _this2.fragmentTracker.removeFragment(frag);
            return;
          }
          frag.stats.chunkCount++;
          _this2._handleFragmentLoadProgress(data);
        };
        this._doFragLoad(frag, level, targetBufferTime, progressCallback).then(function(data) {
          if (!data) {
            return;
          }
          var state = _this2.state;
          if (_this2.fragContextChanged(frag)) {
            if (state === State.FRAG_LOADING || !_this2.fragCurrent && state === State.PARSING) {
              _this2.fragmentTracker.removeFragment(frag);
              _this2.state = State.IDLE;
            }
            return;
          }
          if ("payload" in data) {
            _this2.log("Loaded fragment " + frag.sn + " of level " + frag.level);
            _this2.hls.trigger(Events.FRAG_LOADED, data);
          }
          _this2._handleFragmentLoadComplete(data);
        }).catch(function(reason) {
          if (_this2.state === State.STOPPED || _this2.state === State.ERROR) {
            return;
          }
          _this2.warn(reason);
          _this2.resetFragmentLoading(frag);
        });
      };
      _proto.clearTrackerIfNeeded = function clearTrackerIfNeeded(frag) {
        var _this$mediaBuffer;
        var fragmentTracker = this.fragmentTracker;
        var fragState = fragmentTracker.getState(frag);
        if (fragState === FragmentState.APPENDING) {
          var playlistType = frag.type;
          var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
          var minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);
          if (this.reduceMaxBufferLength(minForwardBufferLength)) {
            fragmentTracker.removeFragment(frag);
          }
        } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {
          fragmentTracker.removeAllFragments();
        } else if (fragmentTracker.hasParts(frag.type)) {
          fragmentTracker.detectPartialFragments({
            frag,
            part: null,
            stats: frag.stats,
            id: frag.type
          });
          if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {
            fragmentTracker.removeFragment(frag);
          }
        }
      };
      _proto.checkLiveUpdate = function checkLiveUpdate(details) {
        if (details.updated && !details.live) {
          var lastFragment = details.fragments[details.fragments.length - 1];
          this.fragmentTracker.detectPartialFragments({
            frag: lastFragment,
            part: null,
            stats: lastFragment.stats,
            id: lastFragment.type
          });
        }
        if (!details.fragments[0]) {
          details.deltaUpdateFailed = true;
        }
      };
      _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset, type) {
        if (type === void 0) {
          type = null;
        }
        if (!(startOffset - endOffset)) {
          return;
        }
        var flushScope = {
          startOffset,
          endOffset,
          type
        };
        this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);
      };
      _proto._loadInitSegment = function _loadInitSegment(frag, level) {
        var _this3 = this;
        this._doFragLoad(frag, level).then(function(data) {
          if (!data || _this3.fragContextChanged(frag) || !_this3.levels) {
            throw new Error("init load aborted");
          }
          return data;
        }).then(function(data) {
          var hls = _this3.hls;
          var payload = data.payload;
          var decryptData = frag.decryptdata;
          if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === "AES-128") {
            var startTime = self.performance.now();
            return _this3.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(function(err) {
              hls.trigger(Events.ERROR, {
                type: ErrorTypes.MEDIA_ERROR,
                details: ErrorDetails.FRAG_DECRYPT_ERROR,
                fatal: false,
                error: err,
                reason: err.message,
                frag
              });
              throw err;
            }).then(function(decryptedData) {
              var endTime = self.performance.now();
              hls.trigger(Events.FRAG_DECRYPTED, {
                frag,
                payload: decryptedData,
                stats: {
                  tstart: startTime,
                  tdecrypt: endTime
                }
              });
              data.payload = decryptedData;
              return _this3.completeInitSegmentLoad(data);
            });
          }
          return _this3.completeInitSegmentLoad(data);
        }).catch(function(reason) {
          if (_this3.state === State.STOPPED || _this3.state === State.ERROR) {
            return;
          }
          _this3.warn(reason);
          _this3.resetFragmentLoading(frag);
        });
      };
      _proto.completeInitSegmentLoad = function completeInitSegmentLoad(data) {
        var levels = this.levels;
        if (!levels) {
          throw new Error("init load aborted, missing levels");
        }
        var stats = data.frag.stats;
        this.state = State.IDLE;
        data.frag.data = new Uint8Array(data.payload);
        stats.parsing.start = stats.buffering.start = self.performance.now();
        stats.parsing.end = stats.buffering.end = self.performance.now();
        this.tick();
      };
      _proto.fragContextChanged = function fragContextChanged(frag) {
        var fragCurrent = this.fragCurrent;
        return !frag || !fragCurrent || frag.sn !== fragCurrent.sn || frag.level !== fragCurrent.level;
      };
      _proto.fragBufferedComplete = function fragBufferedComplete(frag, part) {
        var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;
        var media = this.mediaBuffer ? this.mediaBuffer : this.media;
        this.log("Buffered " + frag.type + " sn: " + frag.sn + (part ? " part: " + part.index : "") + " of " + (this.playlistType === PlaylistLevelType.MAIN ? "level" : "track") + " " + frag.level + " (frag:[" + ((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3) + "-" + ((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3) + "] > buffer:" + (media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : "(detached)") + ")");
        if (frag.sn !== "initSegment") {
          var _this$levels;
          if (frag.type !== PlaylistLevelType.SUBTITLE) {
            var el = frag.elementaryStreams;
            if (!Object.keys(el).some(function(type) {
              return !!el[type];
            })) {
              this.state = State.IDLE;
              return;
            }
          }
          var level = (_this$levels = this.levels) == null ? void 0 : _this$levels[frag.level];
          if (level != null && level.fragmentError) {
            this.log("Resetting level fragment error count of " + level.fragmentError + " on frag buffered");
            level.fragmentError = 0;
          }
        }
        this.state = State.IDLE;
        if (!media) {
          return;
        }
        if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? void 0 : _this$fragPrevious.sn)) {
          this.loadedmetadata = true;
          this.seekToStartPos();
        }
        this.tick();
      };
      _proto.seekToStartPos = function seekToStartPos() {
      };
      _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedEndData) {
        var transmuxer = this.transmuxer;
        if (!transmuxer) {
          return;
        }
        var frag = fragLoadedEndData.frag, part = fragLoadedEndData.part, partsLoaded = fragLoadedEndData.partsLoaded;
        var complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(function(fragLoaded) {
          return !fragLoaded;
        });
        var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);
        transmuxer.flush(chunkMeta);
      };
      _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(frag) {
      };
      _proto._doFragLoad = function _doFragLoad(frag, level, targetBufferTime, progressCallback) {
        var _frag$decryptdata, _this4 = this;
        if (targetBufferTime === void 0) {
          targetBufferTime = null;
        }
        var details = level == null ? void 0 : level.details;
        if (!this.levels || !details) {
          throw new Error("frag load aborted, missing level" + (details ? "" : " detail") + "s");
        }
        var keyLoadingPromise = null;
        if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {
          this.log("Loading key for " + frag.sn + " of [" + details.startSN + "-" + details.endSN + "], " + (this.logPrefix === "[stream-controller]" ? "level" : "track") + " " + frag.level);
          this.state = State.KEY_LOADING;
          this.fragCurrent = frag;
          keyLoadingPromise = this.keyLoader.load(frag).then(function(keyLoadedData) {
            if (!_this4.fragContextChanged(keyLoadedData.frag)) {
              _this4.hls.trigger(Events.KEY_LOADED, keyLoadedData);
              if (_this4.state === State.KEY_LOADING) {
                _this4.state = State.IDLE;
              }
              return keyLoadedData;
            }
          });
          this.hls.trigger(Events.KEY_LOADING, {
            frag
          });
          if (this.fragCurrent === null) {
            keyLoadingPromise = Promise.reject(new Error("frag load aborted, context changed in KEY_LOADING"));
          }
        } else if (!frag.encrypted && details.encryptedFragments.length) {
          this.keyLoader.loadClear(frag, details.encryptedFragments);
        }
        targetBufferTime = Math.max(frag.start, targetBufferTime || 0);
        if (this.config.lowLatencyMode && frag.sn !== "initSegment") {
          var partList = details.partList;
          if (partList && progressCallback) {
            if (targetBufferTime > frag.end && details.fragmentHint) {
              frag = details.fragmentHint;
            }
            var partIndex = this.getNextPart(partList, frag, targetBufferTime);
            if (partIndex > -1) {
              var part = partList[partIndex];
              this.log("Loading part sn: " + frag.sn + " p: " + part.index + " cc: " + frag.cc + " of playlist [" + details.startSN + "-" + details.endSN + "] parts [0-" + partIndex + "-" + (partList.length - 1) + "] " + (this.logPrefix === "[stream-controller]" ? "level" : "track") + ": " + frag.level + ", target: " + parseFloat(targetBufferTime.toFixed(3)));
              this.nextLoadPosition = part.start + part.duration;
              this.state = State.FRAG_LOADING;
              var _result;
              if (keyLoadingPromise) {
                _result = keyLoadingPromise.then(function(keyLoadedData) {
                  if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData.frag)) {
                    return null;
                  }
                  return _this4.doFragPartsLoad(frag, part, level, progressCallback);
                }).catch(function(error) {
                  return _this4.handleFragLoadError(error);
                });
              } else {
                _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch(function(error) {
                  return _this4.handleFragLoadError(error);
                });
              }
              this.hls.trigger(Events.FRAG_LOADING, {
                frag,
                part,
                targetBufferTime
              });
              if (this.fragCurrent === null) {
                return Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts"));
              }
              return _result;
            } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {
              return Promise.resolve(null);
            }
          }
        }
        this.log("Loading fragment " + frag.sn + " cc: " + frag.cc + " " + (details ? "of [" + details.startSN + "-" + details.endSN + "] " : "") + (this.logPrefix === "[stream-controller]" ? "level" : "track") + ": " + frag.level + ", target: " + parseFloat(targetBufferTime.toFixed(3)));
        if (isFiniteNumber(frag.sn) && !this.bitrateTest) {
          this.nextLoadPosition = frag.start + frag.duration;
        }
        this.state = State.FRAG_LOADING;
        var dataOnProgress = this.config.progressive;
        var result;
        if (dataOnProgress && keyLoadingPromise) {
          result = keyLoadingPromise.then(function(keyLoadedData) {
            if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {
              return null;
            }
            return _this4.fragmentLoader.load(frag, progressCallback);
          }).catch(function(error) {
            return _this4.handleFragLoadError(error);
          });
        } else {
          result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : void 0), keyLoadingPromise]).then(function(_ref) {
            var fragLoadedData = _ref[0];
            if (!dataOnProgress && fragLoadedData && progressCallback) {
              progressCallback(fragLoadedData);
            }
            return fragLoadedData;
          }).catch(function(error) {
            return _this4.handleFragLoadError(error);
          });
        }
        this.hls.trigger(Events.FRAG_LOADING, {
          frag,
          targetBufferTime
        });
        if (this.fragCurrent === null) {
          return Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING"));
        }
        return result;
      };
      _proto.doFragPartsLoad = function doFragPartsLoad(frag, fromPart, level, progressCallback) {
        var _this5 = this;
        return new Promise(function(resolve, reject) {
          var _level$details;
          var partsLoaded = [];
          var initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;
          var loadPart = function loadPart2(part) {
            _this5.fragmentLoader.loadPart(frag, part, progressCallback).then(function(partLoadedData) {
              partsLoaded[part.index] = partLoadedData;
              var loadedPart = partLoadedData.part;
              _this5.hls.trigger(Events.FRAG_LOADED, partLoadedData);
              var nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);
              if (nextPart) {
                loadPart2(nextPart);
              } else {
                return resolve({
                  frag,
                  part: loadedPart,
                  partsLoaded
                });
              }
            }).catch(reject);
          };
          loadPart(fromPart);
        });
      };
      _proto.handleFragLoadError = function handleFragLoadError(error) {
        if ("data" in error) {
          var data = error.data;
          if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {
            this.handleFragLoadAborted(data.frag, data.part);
          } else {
            this.hls.trigger(Events.ERROR, data);
          }
        } else {
          this.hls.trigger(Events.ERROR, {
            type: ErrorTypes.OTHER_ERROR,
            details: ErrorDetails.INTERNAL_EXCEPTION,
            err: error,
            error,
            fatal: true
          });
        }
        return null;
      };
      _proto._handleTransmuxerFlush = function _handleTransmuxerFlush(chunkMeta) {
        var context = this.getCurrentContext(chunkMeta);
        if (!context || this.state !== State.PARSING) {
          if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {
            this.state = State.IDLE;
          }
          return;
        }
        var frag = context.frag, part = context.part, level = context.level;
        var now2 = self.performance.now();
        frag.stats.parsing.end = now2;
        if (part) {
          part.stats.parsing.end = now2;
        }
        this.updateLevelTiming(frag, part, level, chunkMeta.partial);
      };
      _proto.getCurrentContext = function getCurrentContext(chunkMeta) {
        var levels = this.levels, fragCurrent = this.fragCurrent;
        var levelIndex = chunkMeta.level, sn = chunkMeta.sn, partIndex = chunkMeta.part;
        if (!(levels != null && levels[levelIndex])) {
          this.warn("Levels object was unset while buffering fragment " + sn + " of level " + levelIndex + ". The current chunk will not be buffered.");
          return null;
        }
        var level = levels[levelIndex];
        var part = partIndex > -1 ? getPartWith(level, sn, partIndex) : null;
        var frag = part ? part.fragment : getFragmentWithSN(level, sn, fragCurrent);
        if (!frag) {
          return null;
        }
        if (fragCurrent && fragCurrent !== frag) {
          frag.stats = fragCurrent.stats;
        }
        return {
          frag,
          part,
          level
        };
      };
      _proto.bufferFragmentData = function bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {
        var _buffer;
        if (!data || this.state !== State.PARSING) {
          return;
        }
        var data1 = data.data1, data2 = data.data2;
        var buffer = data1;
        if (data1 && data2) {
          buffer = appendUint8Array(data1, data2);
        }
        if (!((_buffer = buffer) != null && _buffer.length)) {
          return;
        }
        var segment = {
          type: data.type,
          frag,
          part,
          chunkMeta,
          parent: frag.type,
          data: buffer
        };
        this.hls.trigger(Events.BUFFER_APPENDING, segment);
        if (data.dropped && data.independent && !part) {
          if (noBacktracking) {
            return;
          }
          this.flushBufferGap(frag);
        }
      };
      _proto.flushBufferGap = function flushBufferGap(frag) {
        var media = this.media;
        if (!media) {
          return;
        }
        if (!BufferHelper.isBuffered(media, media.currentTime)) {
          this.flushMainBuffer(0, frag.start);
          return;
        }
        var currentTime = media.currentTime;
        var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
        var fragDuration = frag.duration;
        var segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);
        var start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);
        if (frag.start - start > segmentFraction) {
          this.flushMainBuffer(start, frag.start);
        }
      };
      _proto.getFwdBufferInfo = function getFwdBufferInfo(bufferable, type) {
        var pos = this.getLoadPosition();
        if (!isFiniteNumber(pos)) {
          return null;
        }
        return this.getFwdBufferInfoAtPos(bufferable, pos, type);
      };
      _proto.getFwdBufferInfoAtPos = function getFwdBufferInfoAtPos(bufferable, pos, type) {
        var maxBufferHole = this.config.maxBufferHole;
        var bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);
        if (bufferInfo.len === 0 && bufferInfo.nextStart !== void 0) {
          var bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);
          if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {
            return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));
          }
        }
        return bufferInfo;
      };
      _proto.getMaxBufferLength = function getMaxBufferLength(levelBitrate) {
        var config = this.config;
        var maxBufLen;
        if (levelBitrate) {
          maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
        } else {
          maxBufLen = config.maxBufferLength;
        }
        return Math.min(maxBufLen, config.maxMaxBufferLength);
      };
      _proto.reduceMaxBufferLength = function reduceMaxBufferLength(threshold) {
        var config = this.config;
        var minLength = threshold || config.maxBufferLength;
        if (config.maxMaxBufferLength >= minLength) {
          config.maxMaxBufferLength /= 2;
          this.warn("Reduce max buffer length to " + config.maxMaxBufferLength + "s");
          return true;
        }
        return false;
      };
      _proto.getAppendedFrag = function getAppendedFrag(position, playlistType) {
        var fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);
        if (fragOrPart && "fragment" in fragOrPart) {
          return fragOrPart.fragment;
        }
        return fragOrPart;
      };
      _proto.getNextFragment = function getNextFragment(pos, levelDetails) {
        var fragments = levelDetails.fragments;
        var fragLen = fragments.length;
        if (!fragLen) {
          return null;
        }
        var config = this.config;
        var start = fragments[0].start;
        var frag;
        if (levelDetails.live) {
          var initialLiveManifestSize = config.initialLiveManifestSize;
          if (fragLen < initialLiveManifestSize) {
            this.warn("Not enough fragments to start playback (have: " + fragLen + ", need: " + initialLiveManifestSize + ")");
            return null;
          }
          if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1 || pos < start) {
            frag = this.getInitialLiveFragment(levelDetails, fragments);
            this.startPosition = this.nextLoadPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;
          }
        } else if (pos <= start) {
          frag = fragments[0];
        }
        if (!frag) {
          var end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;
          frag = this.getFragmentAtPosition(pos, end, levelDetails);
        }
        return this.mapToInitFragWhenRequired(frag);
      };
      _proto.isLoopLoading = function isLoopLoading(frag, targetBufferTime) {
        var trackerState = this.fragmentTracker.getState(frag);
        return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;
      };
      _proto.getNextFragmentLoopLoading = function getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {
        var gapStart = frag.gap;
        var nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);
        if (nextFragment === null) {
          return nextFragment;
        }
        frag = nextFragment;
        if (gapStart && frag && !frag.gap && bufferInfo.nextStart) {
          var nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType);
          if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {
            this.log('buffer full after gaps in "' + playlistType + '" playlist starting at sn: ' + frag.sn);
            return null;
          }
        }
        return frag;
      };
      _proto.mapToInitFragWhenRequired = function mapToInitFragWhenRequired(frag) {
        if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {
          return frag.initSegment;
        }
        return frag;
      };
      _proto.getNextPart = function getNextPart(partList, frag, targetBufferTime) {
        var nextPart = -1;
        var contiguous = false;
        var independentAttrOmitted = true;
        for (var i = 0, len = partList.length; i < len; i++) {
          var part = partList[i];
          independentAttrOmitted = independentAttrOmitted && !part.independent;
          if (nextPart > -1 && targetBufferTime < part.start) {
            break;
          }
          var loaded = part.loaded;
          if (loaded) {
            nextPart = -1;
          } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {
            nextPart = i;
          }
          contiguous = loaded;
        }
        return nextPart;
      };
      _proto.loadedEndOfParts = function loadedEndOfParts(partList, targetBufferTime) {
        var lastPart = partList[partList.length - 1];
        return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;
      };
      _proto.getInitialLiveFragment = function getInitialLiveFragment(levelDetails, fragments) {
        var fragPrevious = this.fragPrevious;
        var frag = null;
        if (fragPrevious) {
          if (levelDetails.hasProgramDateTime) {
            this.log("Live playlist, switching playlist, load frag with same PDT: " + fragPrevious.programDateTime);
            frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);
          }
          if (!frag) {
            var targetSN = fragPrevious.sn + 1;
            if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
              var fragNext = fragments[targetSN - levelDetails.startSN];
              if (fragPrevious.cc === fragNext.cc) {
                frag = fragNext;
                this.log("Live playlist, switching playlist, load frag with next SN: " + frag.sn);
              }
            }
            if (!frag) {
              frag = findFragWithCC(fragments, fragPrevious.cc);
              if (frag) {
                this.log("Live playlist, switching playlist, load frag with same CC: " + frag.sn);
              }
            }
          }
        } else {
          var liveStart = this.hls.liveSyncPosition;
          if (liveStart !== null) {
            frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);
          }
        }
        return frag;
      };
      _proto.getFragmentAtPosition = function getFragmentAtPosition(bufferEnd, end, levelDetails) {
        var config = this.config;
        var fragPrevious = this.fragPrevious;
        var fragments = levelDetails.fragments, endSN = levelDetails.endSN;
        var fragmentHint = levelDetails.fragmentHint;
        var tolerance = config.maxFragLookUpTolerance;
        var partList = levelDetails.partList;
        var loadingParts = !!(config.lowLatencyMode && partList != null && partList.length && fragmentHint);
        if (loadingParts && fragmentHint && !this.bitrateTest) {
          fragments = fragments.concat(fragmentHint);
          endSN = fragmentHint.sn;
        }
        var frag;
        if (bufferEnd < end) {
          var lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance;
          frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);
        } else {
          frag = fragments[fragments.length - 1];
        }
        if (frag) {
          var curSNIdx = frag.sn - levelDetails.startSN;
          var fragState = this.fragmentTracker.getState(frag);
          if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {
            fragPrevious = frag;
          }
          if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn)) {
            var sameLevel = fragPrevious && frag.level === fragPrevious.level;
            if (sameLevel) {
              var nextFrag = fragments[curSNIdx + 1];
              if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {
                frag = nextFrag;
              } else {
                frag = null;
              }
            }
          }
        }
        return frag;
      };
      _proto.synchronizeToLiveEdge = function synchronizeToLiveEdge(levelDetails) {
        var config = this.config, media = this.media;
        if (!media) {
          return;
        }
        var liveSyncPosition = this.hls.liveSyncPosition;
        var currentTime = media.currentTime;
        var start = levelDetails.fragments[0].start;
        var end = levelDetails.edge;
        var withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;
        if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {
          var maxLatency = config.liveMaxLatencyDuration !== void 0 ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;
          if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {
            if (!this.loadedmetadata) {
              this.nextLoadPosition = liveSyncPosition;
            }
            if (media.readyState) {
              this.warn("Playback: " + currentTime.toFixed(3) + " is located too far from the end of live sliding playlist: " + end + ", reset currentTime to : " + liveSyncPosition.toFixed(3));
              media.currentTime = liveSyncPosition;
            }
          }
        }
      };
      _proto.alignPlaylists = function alignPlaylists(details, previousDetails, switchDetails) {
        var length = details.fragments.length;
        if (!length) {
          this.warn("No fragments in live playlist");
          return 0;
        }
        var slidingStart = details.fragments[0].start;
        var firstLevelLoad = !previousDetails;
        var aligned = details.alignedSliding && isFiniteNumber(slidingStart);
        if (firstLevelLoad || !aligned && !slidingStart) {
          var fragPrevious = this.fragPrevious;
          alignStream(fragPrevious, switchDetails, details);
          var alignedSlidingStart = details.fragments[0].start;
          this.log("Live playlist sliding: " + alignedSlidingStart.toFixed(2) + " start-sn: " + (previousDetails ? previousDetails.startSN : "na") + "->" + details.startSN + " prev-sn: " + (fragPrevious ? fragPrevious.sn : "na") + " fragments: " + length);
          return alignedSlidingStart;
        }
        return slidingStart;
      };
      _proto.waitForCdnTuneIn = function waitForCdnTuneIn(details) {
        var advancePartLimit = 3;
        return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);
      };
      _proto.setStartPosition = function setStartPosition(details, sliding) {
        var startPosition = this.startPosition;
        if (startPosition < sliding) {
          startPosition = -1;
        }
        if (startPosition === -1 || this.lastCurrentTime === -1) {
          var offsetInMultivariantPlaylist = this.startTimeOffset !== null;
          var startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;
          if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {
            startPosition = sliding + startTimeOffset;
            if (startTimeOffset < 0) {
              startPosition += details.totalduration;
            }
            startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);
            this.log("Start time offset " + startTimeOffset + " found in " + (offsetInMultivariantPlaylist ? "multivariant" : "media") + " playlist, adjust startPosition to " + startPosition);
            this.startPosition = startPosition;
          } else if (details.live) {
            startPosition = this.hls.liveSyncPosition || sliding;
          } else {
            this.startPosition = startPosition = 0;
          }
          this.lastCurrentTime = startPosition;
        }
        this.nextLoadPosition = startPosition;
      };
      _proto.getLoadPosition = function getLoadPosition() {
        var media = this.media;
        var pos = 0;
        if (this.loadedmetadata && media) {
          pos = media.currentTime;
        } else if (this.nextLoadPosition) {
          pos = this.nextLoadPosition;
        }
        return pos;
      };
      _proto.handleFragLoadAborted = function handleFragLoadAborted(frag, part) {
        if (this.transmuxer && frag.sn !== "initSegment" && frag.stats.aborted) {
          this.warn("Fragment " + frag.sn + (part ? " part " + part.index : "") + " of level " + frag.level + " was aborted");
          this.resetFragmentLoading(frag);
        }
      };
      _proto.resetFragmentLoading = function resetFragmentLoading(frag) {
        if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {
          this.state = State.IDLE;
        }
      };
      _proto.onFragmentOrKeyLoadError = function onFragmentOrKeyLoadError(filterType, data) {
        if (data.chunkMeta && !data.frag) {
          var context = this.getCurrentContext(data.chunkMeta);
          if (context) {
            data.frag = context.frag;
          }
        }
        var frag = data.frag;
        if (!frag || frag.type !== filterType || !this.levels) {
          return;
        }
        if (this.fragContextChanged(frag)) {
          var _this$fragCurrent2;
          this.warn("Frag load error must match current frag to retry " + frag.url + " > " + ((_this$fragCurrent2 = this.fragCurrent) == null ? void 0 : _this$fragCurrent2.url));
          return;
        }
        var gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;
        if (gapTagEncountered) {
          this.fragmentTracker.fragBuffered(frag, true);
        }
        var errorAction = data.errorAction;
        var _ref2 = errorAction || {}, action = _ref2.action, _ref2$retryCount = _ref2.retryCount, retryCount = _ref2$retryCount === void 0 ? 0 : _ref2$retryCount, retryConfig = _ref2.retryConfig;
        if (errorAction && action === NetworkErrorAction.RetryRequest && retryConfig) {
          this.resetStartWhenNotLoaded(this.levelLastLoaded);
          var delay = getRetryDelay(retryConfig, retryCount);
          this.warn("Fragment " + frag.sn + " of " + filterType + " " + frag.level + " errored with " + data.details + ", retrying loading " + (retryCount + 1) + "/" + retryConfig.maxNumRetry + " in " + delay + "ms");
          errorAction.resolved = true;
          this.retryDate = self.performance.now() + delay;
          this.state = State.FRAG_LOADING_WAITING_RETRY;
        } else if (retryConfig && errorAction) {
          this.resetFragmentErrors(filterType);
          if (retryCount < retryConfig.maxNumRetry) {
            if (!gapTagEncountered && action !== NetworkErrorAction.RemoveAlternatePermanently) {
              errorAction.resolved = true;
            }
          } else {
            logger.warn(data.details + " reached or exceeded max retry (" + retryCount + ")");
            return;
          }
        } else if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox) {
          this.state = State.WAITING_LEVEL;
        } else {
          this.state = State.ERROR;
        }
        this.tickImmediate();
      };
      _proto.reduceLengthAndFlushBuffer = function reduceLengthAndFlushBuffer(data) {
        if (this.state === State.PARSING || this.state === State.PARSED) {
          var playlistType = data.parent;
          var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
          var buffered = bufferedInfo && bufferedInfo.len > 0.5;
          if (buffered) {
            this.reduceMaxBufferLength(bufferedInfo.len);
          }
          var flushBuffer = !buffered;
          if (flushBuffer) {
            this.warn("Buffer full error while media.currentTime is not buffered, flush " + playlistType + " buffer");
          }
          if (data.frag) {
            this.fragmentTracker.removeFragment(data.frag);
            this.nextLoadPosition = data.frag.start;
          }
          this.resetLoadingState();
          return flushBuffer;
        }
        return false;
      };
      _proto.resetFragmentErrors = function resetFragmentErrors(filterType) {
        if (filterType === PlaylistLevelType.AUDIO) {
          this.fragCurrent = null;
        }
        if (!this.loadedmetadata) {
          this.startFragRequested = false;
        }
        if (this.state !== State.STOPPED) {
          this.state = State.IDLE;
        }
      };
      _proto.afterBufferFlushed = function afterBufferFlushed(media, bufferType, playlistType) {
        if (!media) {
          return;
        }
        var bufferedTimeRanges = BufferHelper.getBuffered(media);
        this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);
        if (this.state === State.ENDED) {
          this.resetLoadingState();
        }
      };
      _proto.resetLoadingState = function resetLoadingState() {
        this.log("Reset loading state");
        this.fragCurrent = null;
        this.fragPrevious = null;
        this.state = State.IDLE;
      };
      _proto.resetStartWhenNotLoaded = function resetStartWhenNotLoaded(level) {
        if (!this.loadedmetadata) {
          this.startFragRequested = false;
          var details = level ? level.details : null;
          if (details != null && details.live) {
            this.startPosition = -1;
            this.setStartPosition(details, 0);
            this.resetLoadingState();
          } else {
            this.nextLoadPosition = this.startPosition;
          }
        }
      };
      _proto.resetWhenMissingContext = function resetWhenMissingContext(chunkMeta) {
        this.warn("The loading context changed while buffering fragment " + chunkMeta.sn + " of level " + chunkMeta.level + ". This chunk will not be buffered.");
        this.removeUnbufferedFrags();
        this.resetStartWhenNotLoaded(this.levelLastLoaded);
        this.resetLoadingState();
      };
      _proto.removeUnbufferedFrags = function removeUnbufferedFrags(start) {
        if (start === void 0) {
          start = 0;
        }
        this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);
      };
      _proto.updateLevelTiming = function updateLevelTiming(frag, part, level, partial) {
        var _this6 = this, _this$transmuxer;
        var details = level.details;
        if (!details) {
          this.warn("level.details undefined");
          return;
        }
        var parsed = Object.keys(frag.elementaryStreams).reduce(function(result, type) {
          var info = frag.elementaryStreams[type];
          if (info) {
            var parsedDuration = info.endPTS - info.startPTS;
            if (parsedDuration <= 0) {
              _this6.warn("Could not parse fragment " + frag.sn + " " + type + " duration reliably (" + parsedDuration + ")");
              return result || false;
            }
            var drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);
            _this6.hls.trigger(Events.LEVEL_PTS_UPDATED, {
              details,
              level,
              drift,
              type,
              frag,
              start: info.startPTS,
              end: info.endPTS
            });
            return true;
          }
          return result;
        }, false);
        if (!parsed && ((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {
          var error = new Error("Found no media in fragment " + frag.sn + " of level " + frag.level + " resetting transmuxer to fallback to playlist timing");
          if (level.fragmentError === 0) {
            level.fragmentError++;
            frag.gap = true;
            this.fragmentTracker.removeFragment(frag);
            this.fragmentTracker.fragBuffered(frag, true);
          }
          this.warn(error.message);
          this.hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.FRAG_PARSING_ERROR,
            fatal: false,
            error,
            frag,
            reason: "Found no media in msn " + frag.sn + ' of level "' + level.url + '"'
          });
          if (!this.hls) {
            return;
          }
          this.resetTransmuxer();
        }
        this.state = State.PARSED;
        this.hls.trigger(Events.FRAG_PARSED, {
          frag,
          part
        });
      };
      _proto.resetTransmuxer = function resetTransmuxer() {
        if (this.transmuxer) {
          this.transmuxer.destroy();
          this.transmuxer = null;
        }
      };
      _proto.recoverWorkerError = function recoverWorkerError(data) {
        if (data.event === "demuxerWorker") {
          this.fragmentTracker.removeAllFragments();
          this.resetTransmuxer();
          this.resetStartWhenNotLoaded(this.levelLastLoaded);
          this.resetLoadingState();
        }
      };
      _createClass(BaseStreamController2, [{
        key: "state",
        get: function get() {
          return this._state;
        },
        set: function set(nextState) {
          var previousState = this._state;
          if (previousState !== nextState) {
            this._state = nextState;
            this.log(previousState + "->" + nextState);
          }
        }
      }]);
      return BaseStreamController2;
    }(TaskLoop);
    var ChunkCache = /* @__PURE__ */ function() {
      function ChunkCache2() {
        this.chunks = [];
        this.dataLength = 0;
      }
      var _proto = ChunkCache2.prototype;
      _proto.push = function push2(chunk) {
        this.chunks.push(chunk);
        this.dataLength += chunk.length;
      };
      _proto.flush = function flush() {
        var chunks = this.chunks, dataLength = this.dataLength;
        var result;
        if (!chunks.length) {
          return new Uint8Array(0);
        } else if (chunks.length === 1) {
          result = chunks[0];
        } else {
          result = concatUint8Arrays(chunks, dataLength);
        }
        this.reset();
        return result;
      };
      _proto.reset = function reset() {
        this.chunks.length = 0;
        this.dataLength = 0;
      };
      return ChunkCache2;
    }();
    function concatUint8Arrays(chunks, dataLength) {
      var result = new Uint8Array(dataLength);
      var offset = 0;
      for (var i = 0; i < chunks.length; i++) {
        var chunk = chunks[i];
        result.set(chunk, offset);
        offset += chunk.length;
      }
      return result;
    }
    function dummyTrack(type, inputTimeScale) {
      if (type === void 0) {
        type = "";
      }
      if (inputTimeScale === void 0) {
        inputTimeScale = 9e4;
      }
      return {
        type,
        id: -1,
        pid: -1,
        inputTimeScale,
        sequenceNumber: -1,
        samples: [],
        dropped: 0
      };
    }
    var BaseAudioDemuxer = /* @__PURE__ */ function() {
      function BaseAudioDemuxer2() {
        this._audioTrack = void 0;
        this._id3Track = void 0;
        this.frameIndex = 0;
        this.cachedData = null;
        this.basePTS = null;
        this.initPTS = null;
        this.lastPTS = null;
      }
      var _proto = BaseAudioDemuxer2.prototype;
      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
        this._id3Track = {
          type: "id3",
          id: 3,
          pid: -1,
          inputTimeScale: 9e4,
          sequenceNumber: 0,
          samples: [],
          dropped: 0
        };
      };
      _proto.resetTimeStamp = function resetTimeStamp(deaultTimestamp) {
        this.initPTS = deaultTimestamp;
        this.resetContiguity();
      };
      _proto.resetContiguity = function resetContiguity() {
        this.basePTS = null;
        this.lastPTS = null;
        this.frameIndex = 0;
      };
      _proto.canParse = function canParse2(data, offset) {
        return false;
      };
      _proto.appendFrame = function appendFrame2(track, data, offset) {
      };
      _proto.demux = function demux(data, timeOffset) {
        if (this.cachedData) {
          data = appendUint8Array(this.cachedData, data);
          this.cachedData = null;
        }
        var id3Data = getID3Data(data, 0);
        var offset = id3Data ? id3Data.length : 0;
        var lastDataIndex;
        var track = this._audioTrack;
        var id3Track = this._id3Track;
        var timestamp = id3Data ? getTimeStamp(id3Data) : void 0;
        var length = data.length;
        if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {
          this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);
          this.lastPTS = this.basePTS;
        }
        if (this.lastPTS === null) {
          this.lastPTS = this.basePTS;
        }
        if (id3Data && id3Data.length > 0) {
          id3Track.samples.push({
            pts: this.lastPTS,
            dts: this.lastPTS,
            data: id3Data,
            type: MetadataSchema.audioId3,
            duration: Number.POSITIVE_INFINITY
          });
        }
        while (offset < length) {
          if (this.canParse(data, offset)) {
            var frame = this.appendFrame(track, data, offset);
            if (frame) {
              this.frameIndex++;
              this.lastPTS = frame.sample.pts;
              offset += frame.length;
              lastDataIndex = offset;
            } else {
              offset = length;
            }
          } else if (canParse$2(data, offset)) {
            id3Data = getID3Data(data, offset);
            id3Track.samples.push({
              pts: this.lastPTS,
              dts: this.lastPTS,
              data: id3Data,
              type: MetadataSchema.audioId3,
              duration: Number.POSITIVE_INFINITY
            });
            offset += id3Data.length;
            lastDataIndex = offset;
          } else {
            offset++;
          }
          if (offset === length && lastDataIndex !== length) {
            var partialData = sliceUint8(data, lastDataIndex);
            if (this.cachedData) {
              this.cachedData = appendUint8Array(this.cachedData, partialData);
            } else {
              this.cachedData = partialData;
            }
          }
        }
        return {
          audioTrack: track,
          videoTrack: dummyTrack(),
          id3Track,
          textTrack: dummyTrack()
        };
      };
      _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {
        return Promise.reject(new Error("[" + this + "] This demuxer does not support Sample-AES decryption"));
      };
      _proto.flush = function flush(timeOffset) {
        var cachedData = this.cachedData;
        if (cachedData) {
          this.cachedData = null;
          this.demux(cachedData, 0);
        }
        return {
          audioTrack: this._audioTrack,
          videoTrack: dummyTrack(),
          id3Track: this._id3Track,
          textTrack: dummyTrack()
        };
      };
      _proto.destroy = function destroy() {
      };
      return BaseAudioDemuxer2;
    }();
    var initPTSFn = function initPTSFn2(timestamp, timeOffset, initPTS) {
      if (isFiniteNumber(timestamp)) {
        return timestamp * 90;
      }
      var init90kHz = initPTS ? initPTS.baseTime * 9e4 / initPTS.timescale : 0;
      return timeOffset * 9e4 + init90kHz;
    };
    function getAudioConfig(observer, data, offset, audioCodec) {
      var adtsObjectType;
      var adtsExtensionSamplingIndex;
      var adtsChannelConfig;
      var config;
      var userAgent = navigator.userAgent.toLowerCase();
      var manifestCodec = audioCodec;
      var adtsSamplingRates = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
      adtsObjectType = ((data[offset + 2] & 192) >>> 6) + 1;
      var adtsSamplingIndex = (data[offset + 2] & 60) >>> 2;
      if (adtsSamplingIndex > adtsSamplingRates.length - 1) {
        var error = new Error("invalid ADTS sampling index:" + adtsSamplingIndex);
        observer.emit(Events.ERROR, Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.FRAG_PARSING_ERROR,
          fatal: true,
          error,
          reason: error.message
        });
        return;
      }
      adtsChannelConfig = (data[offset + 2] & 1) << 2;
      adtsChannelConfig |= (data[offset + 3] & 192) >>> 6;
      logger.log("manifest codec:" + audioCodec + ", ADTS type:" + adtsObjectType + ", samplingIndex:" + adtsSamplingIndex);
      if (/firefox/i.test(userAgent)) {
        if (adtsSamplingIndex >= 6) {
          adtsObjectType = 5;
          config = new Array(4);
          adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
        } else {
          adtsObjectType = 2;
          config = new Array(2);
          adtsExtensionSamplingIndex = adtsSamplingIndex;
        }
      } else if (userAgent.indexOf("android") !== -1) {
        adtsObjectType = 2;
        config = new Array(2);
        adtsExtensionSamplingIndex = adtsSamplingIndex;
      } else {
        adtsObjectType = 5;
        config = new Array(4);
        if (audioCodec && (audioCodec.indexOf("mp4a.40.29") !== -1 || audioCodec.indexOf("mp4a.40.5") !== -1) || !audioCodec && adtsSamplingIndex >= 6) {
          adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
        } else {
          if (audioCodec && audioCodec.indexOf("mp4a.40.2") !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {
            adtsObjectType = 2;
            config = new Array(2);
          }
          adtsExtensionSamplingIndex = adtsSamplingIndex;
        }
      }
      config[0] = adtsObjectType << 3;
      config[0] |= (adtsSamplingIndex & 14) >> 1;
      config[1] |= (adtsSamplingIndex & 1) << 7;
      config[1] |= adtsChannelConfig << 3;
      if (adtsObjectType === 5) {
        config[1] |= (adtsExtensionSamplingIndex & 14) >> 1;
        config[2] = (adtsExtensionSamplingIndex & 1) << 7;
        config[2] |= 2 << 2;
        config[3] = 0;
      }
      return {
        config,
        samplerate: adtsSamplingRates[adtsSamplingIndex],
        channelCount: adtsChannelConfig,
        codec: "mp4a.40." + adtsObjectType,
        manifestCodec
      };
    }
    function isHeaderPattern$1(data, offset) {
      return data[offset] === 255 && (data[offset + 1] & 246) === 240;
    }
    function getHeaderLength(data, offset) {
      return data[offset + 1] & 1 ? 7 : 9;
    }
    function getFullFrameLength(data, offset) {
      return (data[offset + 3] & 3) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 224) >>> 5;
    }
    function canGetFrameLength(data, offset) {
      return offset + 5 < data.length;
    }
    function isHeader$1(data, offset) {
      return offset + 1 < data.length && isHeaderPattern$1(data, offset);
    }
    function canParse$1(data, offset) {
      return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;
    }
    function probe$1(data, offset) {
      if (isHeader$1(data, offset)) {
        var headerLength = getHeaderLength(data, offset);
        if (offset + headerLength >= data.length) {
          return false;
        }
        var frameLength = getFullFrameLength(data, offset);
        if (frameLength <= headerLength) {
          return false;
        }
        var newOffset = offset + frameLength;
        return newOffset === data.length || isHeader$1(data, newOffset);
      }
      return false;
    }
    function initTrackConfig(track, observer, data, offset, audioCodec) {
      if (!track.samplerate) {
        var config = getAudioConfig(observer, data, offset, audioCodec);
        if (!config) {
          return;
        }
        track.config = config.config;
        track.samplerate = config.samplerate;
        track.channelCount = config.channelCount;
        track.codec = config.codec;
        track.manifestCodec = config.manifestCodec;
        logger.log("parsed codec:" + track.codec + ", rate:" + config.samplerate + ", channels:" + config.channelCount);
      }
    }
    function getFrameDuration(samplerate) {
      return 1024 * 9e4 / samplerate;
    }
    function parseFrameHeader(data, offset) {
      var headerLength = getHeaderLength(data, offset);
      if (offset + headerLength <= data.length) {
        var frameLength = getFullFrameLength(data, offset) - headerLength;
        if (frameLength > 0) {
          return {
            headerLength,
            frameLength
          };
        }
      }
    }
    function appendFrame$1(track, data, offset, pts, frameIndex) {
      var frameDuration = getFrameDuration(track.samplerate);
      var stamp = pts + frameIndex * frameDuration;
      var header = parseFrameHeader(data, offset);
      var unit;
      if (header) {
        var frameLength = header.frameLength, headerLength = header.headerLength;
        var _length = headerLength + frameLength;
        var missing = Math.max(0, offset + _length - data.length);
        if (missing) {
          unit = new Uint8Array(_length - headerLength);
          unit.set(data.subarray(offset + headerLength, data.length), 0);
        } else {
          unit = data.subarray(offset + headerLength, offset + _length);
        }
        var _sample = {
          unit,
          pts: stamp
        };
        if (!missing) {
          track.samples.push(_sample);
        }
        return {
          sample: _sample,
          length: _length,
          missing
        };
      }
      var length = data.length - offset;
      unit = new Uint8Array(length);
      unit.set(data.subarray(offset, data.length), 0);
      var sample = {
        unit,
        pts: stamp
      };
      return {
        sample,
        length,
        missing: -1
      };
    }
    var chromeVersion$1 = null;
    var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
    var SamplingRateMap = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3];
    var SamplesCoefficients = [
      // MPEG 2.5
      [
        0,
        // Reserved
        72,
        // Layer3
        144,
        // Layer2
        12
        // Layer1
      ],
      // Reserved
      [
        0,
        // Reserved
        0,
        // Layer3
        0,
        // Layer2
        0
        // Layer1
      ],
      // MPEG 2
      [
        0,
        // Reserved
        72,
        // Layer3
        144,
        // Layer2
        12
        // Layer1
      ],
      // MPEG 1
      [
        0,
        // Reserved
        144,
        // Layer3
        144,
        // Layer2
        12
        // Layer1
      ]
    ];
    var BytesInSlot = [
      0,
      // Reserved
      1,
      // Layer3
      1,
      // Layer2
      4
      // Layer1
    ];
    function appendFrame(track, data, offset, pts, frameIndex) {
      if (offset + 24 > data.length) {
        return;
      }
      var header = parseHeader(data, offset);
      if (header && offset + header.frameLength <= data.length) {
        var frameDuration = header.samplesPerFrame * 9e4 / header.sampleRate;
        var stamp = pts + frameIndex * frameDuration;
        var sample = {
          unit: data.subarray(offset, offset + header.frameLength),
          pts: stamp,
          dts: stamp
        };
        track.config = [];
        track.channelCount = header.channelCount;
        track.samplerate = header.sampleRate;
        track.samples.push(sample);
        return {
          sample,
          length: header.frameLength,
          missing: 0
        };
      }
    }
    function parseHeader(data, offset) {
      var mpegVersion = data[offset + 1] >> 3 & 3;
      var mpegLayer = data[offset + 1] >> 1 & 3;
      var bitRateIndex = data[offset + 2] >> 4 & 15;
      var sampleRateIndex = data[offset + 2] >> 2 & 3;
      if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {
        var paddingBit = data[offset + 2] >> 1 & 1;
        var channelMode = data[offset + 3] >> 6;
        var columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;
        var bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1e3;
        var columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;
        var sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];
        var channelCount = channelMode === 3 ? 1 : 2;
        var sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];
        var bytesInSlot = BytesInSlot[mpegLayer];
        var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
        var frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;
        if (chromeVersion$1 === null) {
          var userAgent = navigator.userAgent || "";
          var result = userAgent.match(/Chrome\/(\d+)/i);
          chromeVersion$1 = result ? parseInt(result[1]) : 0;
        }
        var needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;
        if (needChromeFix && mpegLayer === 2 && bitRate >= 224e3 && channelMode === 0) {
          data[offset + 3] = data[offset + 3] | 128;
        }
        return {
          sampleRate,
          channelCount,
          frameLength,
          samplesPerFrame
        };
      }
    }
    function isHeaderPattern(data, offset) {
      return data[offset] === 255 && (data[offset + 1] & 224) === 224 && (data[offset + 1] & 6) !== 0;
    }
    function isHeader(data, offset) {
      return offset + 1 < data.length && isHeaderPattern(data, offset);
    }
    function canParse(data, offset) {
      var headerSize = 4;
      return isHeaderPattern(data, offset) && headerSize <= data.length - offset;
    }
    function probe(data, offset) {
      if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
        var headerLength = 4;
        var header = parseHeader(data, offset);
        var frameLength = headerLength;
        if (header != null && header.frameLength) {
          frameLength = header.frameLength;
        }
        var newOffset = offset + frameLength;
        return newOffset === data.length || isHeader(data, newOffset);
      }
      return false;
    }
    var AACDemuxer = /* @__PURE__ */ function(_BaseAudioDemuxer) {
      _inheritsLoose(AACDemuxer2, _BaseAudioDemuxer);
      function AACDemuxer2(observer, config) {
        var _this;
        _this = _BaseAudioDemuxer.call(this) || this;
        _this.observer = void 0;
        _this.config = void 0;
        _this.observer = observer;
        _this.config = config;
        return _this;
      }
      var _proto = AACDemuxer2.prototype;
      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
        _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);
        this._audioTrack = {
          container: "audio/adts",
          type: "audio",
          id: 2,
          pid: -1,
          sequenceNumber: 0,
          segmentCodec: "aac",
          samples: [],
          manifestCodec: audioCodec,
          duration: trackDuration,
          inputTimeScale: 9e4,
          dropped: 0
        };
      };
      AACDemuxer2.probe = function probe$2(data) {
        if (!data) {
          return false;
        }
        var id3Data = getID3Data(data, 0);
        var offset = (id3Data == null ? void 0 : id3Data.length) || 0;
        if (probe(data, offset)) {
          return false;
        }
        for (var length = data.length; offset < length; offset++) {
          if (probe$1(data, offset)) {
            logger.log("ADTS sync word found !");
            return true;
          }
        }
        return false;
      };
      _proto.canParse = function canParse2(data, offset) {
        return canParse$1(data, offset);
      };
      _proto.appendFrame = function appendFrame2(track, data, offset) {
        initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
        var frame = appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);
        if (frame && frame.missing === 0) {
          return frame;
        }
      };
      return AACDemuxer2;
    }(BaseAudioDemuxer);
    var emsgSchemePattern = /\/emsg[-/]ID3/i;
    var MP4Demuxer = /* @__PURE__ */ function() {
      function MP4Demuxer2(observer, config) {
        this.remainderData = null;
        this.timeOffset = 0;
        this.config = void 0;
        this.videoTrack = void 0;
        this.audioTrack = void 0;
        this.id3Track = void 0;
        this.txtTrack = void 0;
        this.config = config;
      }
      var _proto = MP4Demuxer2.prototype;
      _proto.resetTimeStamp = function resetTimeStamp() {
      };
      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
        var videoTrack = this.videoTrack = dummyTrack("video", 1);
        var audioTrack = this.audioTrack = dummyTrack("audio", 1);
        var captionTrack = this.txtTrack = dummyTrack("text", 1);
        this.id3Track = dummyTrack("id3", 1);
        this.timeOffset = 0;
        if (!(initSegment != null && initSegment.byteLength)) {
          return;
        }
        var initData = parseInitSegment(initSegment);
        if (initData.video) {
          var _initData$video = initData.video, id = _initData$video.id, timescale = _initData$video.timescale, codec = _initData$video.codec;
          videoTrack.id = id;
          videoTrack.timescale = captionTrack.timescale = timescale;
          videoTrack.codec = codec;
        }
        if (initData.audio) {
          var _initData$audio = initData.audio, _id = _initData$audio.id, _timescale = _initData$audio.timescale, _codec = _initData$audio.codec;
          audioTrack.id = _id;
          audioTrack.timescale = _timescale;
          audioTrack.codec = _codec;
        }
        captionTrack.id = RemuxerTrackIdConfig.text;
        videoTrack.sampleDuration = 0;
        videoTrack.duration = audioTrack.duration = trackDuration;
      };
      _proto.resetContiguity = function resetContiguity() {
        this.remainderData = null;
      };
      MP4Demuxer2.probe = function probe2(data) {
        return hasMoofData(data);
      };
      _proto.demux = function demux(data, timeOffset) {
        this.timeOffset = timeOffset;
        var videoSamples = data;
        var videoTrack = this.videoTrack;
        var textTrack = this.txtTrack;
        if (this.config.progressive) {
          if (this.remainderData) {
            videoSamples = appendUint8Array(this.remainderData, data);
          }
          var segmentedData = segmentValidRange(videoSamples);
          this.remainderData = segmentedData.remainder;
          videoTrack.samples = segmentedData.valid || new Uint8Array();
        } else {
          videoTrack.samples = videoSamples;
        }
        var id3Track = this.extractID3Track(videoTrack, timeOffset);
        textTrack.samples = parseSamples(timeOffset, videoTrack);
        return {
          videoTrack,
          audioTrack: this.audioTrack,
          id3Track,
          textTrack: this.txtTrack
        };
      };
      _proto.flush = function flush() {
        var timeOffset = this.timeOffset;
        var videoTrack = this.videoTrack;
        var textTrack = this.txtTrack;
        videoTrack.samples = this.remainderData || new Uint8Array();
        this.remainderData = null;
        var id3Track = this.extractID3Track(videoTrack, this.timeOffset);
        textTrack.samples = parseSamples(timeOffset, videoTrack);
        return {
          videoTrack,
          audioTrack: dummyTrack(),
          id3Track,
          textTrack: dummyTrack()
        };
      };
      _proto.extractID3Track = function extractID3Track(videoTrack, timeOffset) {
        var id3Track = this.id3Track;
        if (videoTrack.samples.length) {
          var emsgs = findBox(videoTrack.samples, ["emsg"]);
          if (emsgs) {
            emsgs.forEach(function(data) {
              var emsgInfo = parseEmsg(data);
              if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {
                var pts = isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;
                var duration = emsgInfo.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;
                if (duration <= 1e-3) {
                  duration = Number.POSITIVE_INFINITY;
                }
                var payload = emsgInfo.payload;
                id3Track.samples.push({
                  data: payload,
                  len: payload.byteLength,
                  dts: pts,
                  pts,
                  type: MetadataSchema.emsg,
                  duration
                });
              }
            });
          }
        }
        return id3Track;
      };
      _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {
        return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
      };
      _proto.destroy = function destroy() {
      };
      return MP4Demuxer2;
    }();
    var getAudioBSID = function getAudioBSID2(data, offset) {
      var bsid = 0;
      var numBits = 5;
      offset += numBits;
      var temp = new Uint32Array(1);
      var mask = new Uint32Array(1);
      var _byte = new Uint8Array(1);
      while (numBits > 0) {
        _byte[0] = data[offset];
        var bits = Math.min(numBits, 8);
        var shift = 8 - bits;
        mask[0] = 4278190080 >>> 24 + shift << shift;
        temp[0] = (_byte[0] & mask[0]) >> shift;
        bsid = !bsid ? temp[0] : bsid << bits | temp[0];
        offset += 1;
        numBits -= bits;
      }
      return bsid;
    };
    var AC3Demuxer = /* @__PURE__ */ function(_BaseAudioDemuxer) {
      _inheritsLoose(AC3Demuxer2, _BaseAudioDemuxer);
      function AC3Demuxer2(observer) {
        var _this;
        _this = _BaseAudioDemuxer.call(this) || this;
        _this.observer = void 0;
        _this.observer = observer;
        return _this;
      }
      var _proto = AC3Demuxer2.prototype;
      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
        _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);
        this._audioTrack = {
          container: "audio/ac-3",
          type: "audio",
          id: 2,
          pid: -1,
          sequenceNumber: 0,
          segmentCodec: "ac3",
          samples: [],
          manifestCodec: audioCodec,
          duration: trackDuration,
          inputTimeScale: 9e4,
          dropped: 0
        };
      };
      _proto.canParse = function canParse2(data, offset) {
        return offset + 64 < data.length;
      };
      _proto.appendFrame = function appendFrame2(track, data, offset) {
        var frameLength = _appendFrame(track, data, offset, this.basePTS, this.frameIndex);
        if (frameLength !== -1) {
          var sample = track.samples[track.samples.length - 1];
          return {
            sample,
            length: frameLength,
            missing: 0
          };
        }
      };
      AC3Demuxer2.probe = function probe2(data) {
        if (!data) {
          return false;
        }
        var id3Data = getID3Data(data, 0);
        if (!id3Data) {
          return false;
        }
        var offset = id3Data.length;
        if (data[offset] === 11 && data[offset + 1] === 119 && getTimeStamp(id3Data) !== void 0 && // check the bsid to confirm ac-3
        getAudioBSID(data, offset) < 16) {
          return true;
        }
        return false;
      };
      return AC3Demuxer2;
    }(BaseAudioDemuxer);
    function _appendFrame(track, data, start, pts, frameIndex) {
      if (start + 8 > data.length) {
        return -1;
      }
      if (data[start] !== 11 || data[start + 1] !== 119) {
        return -1;
      }
      var samplingRateCode = data[start + 4] >> 6;
      if (samplingRateCode >= 3) {
        return -1;
      }
      var samplingRateMap = [48e3, 44100, 32e3];
      var sampleRate = samplingRateMap[samplingRateCode];
      var frameSizeCode = data[start + 4] & 63;
      var frameSizeMap = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920];
      var frameLength = frameSizeMap[frameSizeCode * 3 + samplingRateCode] * 2;
      if (start + frameLength > data.length) {
        return -1;
      }
      var channelMode = data[start + 6] >> 5;
      var skipCount = 0;
      if (channelMode === 2) {
        skipCount += 2;
      } else {
        if (channelMode & 1 && channelMode !== 1) {
          skipCount += 2;
        }
        if (channelMode & 4) {
          skipCount += 2;
        }
      }
      var lfeon = (data[start + 6] << 8 | data[start + 7]) >> 12 - skipCount & 1;
      var channelsMap = [2, 1, 2, 3, 3, 4, 4, 5];
      var channelCount = channelsMap[channelMode] + lfeon;
      var bsid = data[start + 5] >> 3;
      var bsmod = data[start + 5] & 7;
      var config = new Uint8Array([samplingRateCode << 6 | bsid << 1 | bsmod >> 2, (bsmod & 3) << 6 | channelMode << 3 | lfeon << 2 | frameSizeCode >> 4, frameSizeCode << 4 & 224]);
      var frameDuration = 1536 / sampleRate * 9e4;
      var stamp = pts + frameIndex * frameDuration;
      var unit = data.subarray(start, start + frameLength);
      track.config = config;
      track.channelCount = channelCount;
      track.samplerate = sampleRate;
      track.samples.push({
        unit,
        pts: stamp
      });
      return frameLength;
    }
    var BaseVideoParser = /* @__PURE__ */ function() {
      function BaseVideoParser2() {
        this.VideoSample = null;
      }
      var _proto = BaseVideoParser2.prototype;
      _proto.createVideoSample = function createVideoSample(key, pts, dts, debug) {
        return {
          key,
          frame: false,
          pts,
          dts,
          units: [],
          debug,
          length: 0
        };
      };
      _proto.getLastNalUnit = function getLastNalUnit(samples) {
        var _VideoSample;
        var VideoSample = this.VideoSample;
        var lastUnit;
        if (!VideoSample || VideoSample.units.length === 0) {
          VideoSample = samples[samples.length - 1];
        }
        if ((_VideoSample = VideoSample) != null && _VideoSample.units) {
          var units = VideoSample.units;
          lastUnit = units[units.length - 1];
        }
        return lastUnit;
      };
      _proto.pushAccessUnit = function pushAccessUnit(VideoSample, videoTrack) {
        if (VideoSample.units.length && VideoSample.frame) {
          if (VideoSample.pts === void 0) {
            var samples = videoTrack.samples;
            var nbSamples = samples.length;
            if (nbSamples) {
              var lastSample = samples[nbSamples - 1];
              VideoSample.pts = lastSample.pts;
              VideoSample.dts = lastSample.dts;
            } else {
              videoTrack.dropped++;
              return;
            }
          }
          videoTrack.samples.push(VideoSample);
        }
        if (VideoSample.debug.length) {
          logger.log(VideoSample.pts + "/" + VideoSample.dts + ":" + VideoSample.debug);
        }
      };
      return BaseVideoParser2;
    }();
    var ExpGolomb = /* @__PURE__ */ function() {
      function ExpGolomb2(data) {
        this.data = void 0;
        this.bytesAvailable = void 0;
        this.word = void 0;
        this.bitsAvailable = void 0;
        this.data = data;
        this.bytesAvailable = data.byteLength;
        this.word = 0;
        this.bitsAvailable = 0;
      }
      var _proto = ExpGolomb2.prototype;
      _proto.loadWord = function loadWord() {
        var data = this.data;
        var bytesAvailable = this.bytesAvailable;
        var position = data.byteLength - bytesAvailable;
        var workingBytes = new Uint8Array(4);
        var availableBytes = Math.min(4, bytesAvailable);
        if (availableBytes === 0) {
          throw new Error("no bytes available");
        }
        workingBytes.set(data.subarray(position, position + availableBytes));
        this.word = new DataView(workingBytes.buffer).getUint32(0);
        this.bitsAvailable = availableBytes * 8;
        this.bytesAvailable -= availableBytes;
      };
      _proto.skipBits = function skipBits(count) {
        var skipBytes;
        count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);
        if (this.bitsAvailable > count) {
          this.word <<= count;
          this.bitsAvailable -= count;
        } else {
          count -= this.bitsAvailable;
          skipBytes = count >> 3;
          count -= skipBytes << 3;
          this.bytesAvailable -= skipBytes;
          this.loadWord();
          this.word <<= count;
          this.bitsAvailable -= count;
        }
      };
      _proto.readBits = function readBits(size) {
        var bits = Math.min(this.bitsAvailable, size);
        var valu = this.word >>> 32 - bits;
        if (size > 32) {
          logger.error("Cannot read more than 32 bits at a time");
        }
        this.bitsAvailable -= bits;
        if (this.bitsAvailable > 0) {
          this.word <<= bits;
        } else if (this.bytesAvailable > 0) {
          this.loadWord();
        } else {
          throw new Error("no bits available");
        }
        bits = size - bits;
        if (bits > 0 && this.bitsAvailable) {
          return valu << bits | this.readBits(bits);
        } else {
          return valu;
        }
      };
      _proto.skipLZ = function skipLZ() {
        var leadingZeroCount;
        for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
          if ((this.word & 2147483648 >>> leadingZeroCount) !== 0) {
            this.word <<= leadingZeroCount;
            this.bitsAvailable -= leadingZeroCount;
            return leadingZeroCount;
          }
        }
        this.loadWord();
        return leadingZeroCount + this.skipLZ();
      };
      _proto.skipUEG = function skipUEG() {
        this.skipBits(1 + this.skipLZ());
      };
      _proto.skipEG = function skipEG() {
        this.skipBits(1 + this.skipLZ());
      };
      _proto.readUEG = function readUEG() {
        var clz = this.skipLZ();
        return this.readBits(clz + 1) - 1;
      };
      _proto.readEG = function readEG() {
        var valu = this.readUEG();
        if (1 & valu) {
          return 1 + valu >>> 1;
        } else {
          return -1 * (valu >>> 1);
        }
      };
      _proto.readBoolean = function readBoolean() {
        return this.readBits(1) === 1;
      };
      _proto.readUByte = function readUByte() {
        return this.readBits(8);
      };
      _proto.readUShort = function readUShort() {
        return this.readBits(16);
      };
      _proto.readUInt = function readUInt() {
        return this.readBits(32);
      };
      _proto.skipScalingList = function skipScalingList(count) {
        var lastScale = 8;
        var nextScale = 8;
        var deltaScale;
        for (var j = 0; j < count; j++) {
          if (nextScale !== 0) {
            deltaScale = this.readEG();
            nextScale = (lastScale + deltaScale + 256) % 256;
          }
          lastScale = nextScale === 0 ? lastScale : nextScale;
        }
      };
      _proto.readSPS = function readSPS() {
        var frameCropLeftOffset = 0;
        var frameCropRightOffset = 0;
        var frameCropTopOffset = 0;
        var frameCropBottomOffset = 0;
        var numRefFramesInPicOrderCntCycle;
        var scalingListCount;
        var i;
        var readUByte = this.readUByte.bind(this);
        var readBits = this.readBits.bind(this);
        var readUEG = this.readUEG.bind(this);
        var readBoolean = this.readBoolean.bind(this);
        var skipBits = this.skipBits.bind(this);
        var skipEG = this.skipEG.bind(this);
        var skipUEG = this.skipUEG.bind(this);
        var skipScalingList = this.skipScalingList.bind(this);
        readUByte();
        var profileIdc = readUByte();
        readBits(5);
        skipBits(3);
        readUByte();
        skipUEG();
        if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
          var chromaFormatIdc = readUEG();
          if (chromaFormatIdc === 3) {
            skipBits(1);
          }
          skipUEG();
          skipUEG();
          skipBits(1);
          if (readBoolean()) {
            scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
            for (i = 0; i < scalingListCount; i++) {
              if (readBoolean()) {
                if (i < 6) {
                  skipScalingList(16);
                } else {
                  skipScalingList(64);
                }
              }
            }
          }
        }
        skipUEG();
        var picOrderCntType = readUEG();
        if (picOrderCntType === 0) {
          readUEG();
        } else if (picOrderCntType === 1) {
          skipBits(1);
          skipEG();
          skipEG();
          numRefFramesInPicOrderCntCycle = readUEG();
          for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
            skipEG();
          }
        }
        skipUEG();
        skipBits(1);
        var picWidthInMbsMinus1 = readUEG();
        var picHeightInMapUnitsMinus1 = readUEG();
        var frameMbsOnlyFlag = readBits(1);
        if (frameMbsOnlyFlag === 0) {
          skipBits(1);
        }
        skipBits(1);
        if (readBoolean()) {
          frameCropLeftOffset = readUEG();
          frameCropRightOffset = readUEG();
          frameCropTopOffset = readUEG();
          frameCropBottomOffset = readUEG();
        }
        var pixelRatio = [1, 1];
        if (readBoolean()) {
          if (readBoolean()) {
            var aspectRatioIdc = readUByte();
            switch (aspectRatioIdc) {
              case 1:
                pixelRatio = [1, 1];
                break;
              case 2:
                pixelRatio = [12, 11];
                break;
              case 3:
                pixelRatio = [10, 11];
                break;
              case 4:
                pixelRatio = [16, 11];
                break;
              case 5:
                pixelRatio = [40, 33];
                break;
              case 6:
                pixelRatio = [24, 11];
                break;
              case 7:
                pixelRatio = [20, 11];
                break;
              case 8:
                pixelRatio = [32, 11];
                break;
              case 9:
                pixelRatio = [80, 33];
                break;
              case 10:
                pixelRatio = [18, 11];
                break;
              case 11:
                pixelRatio = [15, 11];
                break;
              case 12:
                pixelRatio = [64, 33];
                break;
              case 13:
                pixelRatio = [160, 99];
                break;
              case 14:
                pixelRatio = [4, 3];
                break;
              case 15:
                pixelRatio = [3, 2];
                break;
              case 16:
                pixelRatio = [2, 1];
                break;
              case 255: {
                pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                break;
              }
            }
          }
        }
        return {
          width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
          height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
          pixelRatio
        };
      };
      _proto.readSliceType = function readSliceType() {
        this.readUByte();
        this.readUEG();
        return this.readUEG();
      };
      return ExpGolomb2;
    }();
    var AvcVideoParser = /* @__PURE__ */ function(_BaseVideoParser) {
      _inheritsLoose(AvcVideoParser2, _BaseVideoParser);
      function AvcVideoParser2() {
        return _BaseVideoParser.apply(this, arguments) || this;
      }
      var _proto = AvcVideoParser2.prototype;
      _proto.parseAVCPES = function parseAVCPES(track, textTrack, pes, last, duration) {
        var _this = this;
        var units = this.parseAVCNALu(track, pes.data);
        var VideoSample = this.VideoSample;
        var push2;
        var spsfound = false;
        pes.data = null;
        if (VideoSample && units.length && !track.audFound) {
          this.pushAccessUnit(VideoSample, track);
          VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts, "");
        }
        units.forEach(function(unit) {
          var _VideoSample2;
          switch (unit.type) {
            case 1: {
              var iskey = false;
              push2 = true;
              var data = unit.data;
              if (spsfound && data.length > 4) {
                var sliceType = new ExpGolomb(data).readSliceType();
                if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                  iskey = true;
                }
              }
              if (iskey) {
                var _VideoSample;
                if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {
                  _this.pushAccessUnit(VideoSample, track);
                  VideoSample = _this.VideoSample = null;
                }
              }
              if (!VideoSample) {
                VideoSample = _this.VideoSample = _this.createVideoSample(true, pes.pts, pes.dts, "");
              }
              VideoSample.frame = true;
              VideoSample.key = iskey;
              break;
            }
            case 5:
              push2 = true;
              if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {
                _this.pushAccessUnit(VideoSample, track);
                VideoSample = _this.VideoSample = null;
              }
              if (!VideoSample) {
                VideoSample = _this.VideoSample = _this.createVideoSample(true, pes.pts, pes.dts, "");
              }
              VideoSample.key = true;
              VideoSample.frame = true;
              break;
            case 6: {
              push2 = true;
              parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);
              break;
            }
            case 7: {
              var _track$pixelRatio, _track$pixelRatio2;
              push2 = true;
              spsfound = true;
              var sps = unit.data;
              var expGolombDecoder = new ExpGolomb(sps);
              var config = expGolombDecoder.readSPS();
              if (!track.sps || track.width !== config.width || track.height !== config.height || ((_track$pixelRatio = track.pixelRatio) == null ? void 0 : _track$pixelRatio[0]) !== config.pixelRatio[0] || ((_track$pixelRatio2 = track.pixelRatio) == null ? void 0 : _track$pixelRatio2[1]) !== config.pixelRatio[1]) {
                track.width = config.width;
                track.height = config.height;
                track.pixelRatio = config.pixelRatio;
                track.sps = [sps];
                track.duration = duration;
                var codecarray = sps.subarray(1, 4);
                var codecstring = "avc1.";
                for (var i = 0; i < 3; i++) {
                  var h = codecarray[i].toString(16);
                  if (h.length < 2) {
                    h = "0" + h;
                  }
                  codecstring += h;
                }
                track.codec = codecstring;
              }
              break;
            }
            case 8:
              push2 = true;
              track.pps = [unit.data];
              break;
            case 9:
              push2 = true;
              track.audFound = true;
              if (VideoSample) {
                _this.pushAccessUnit(VideoSample, track);
              }
              VideoSample = _this.VideoSample = _this.createVideoSample(false, pes.pts, pes.dts, "");
              break;
            case 12:
              push2 = true;
              break;
            default:
              push2 = false;
              if (VideoSample) {
                VideoSample.debug += "unknown NAL " + unit.type + " ";
              }
              break;
          }
          if (VideoSample && push2) {
            var _units = VideoSample.units;
            _units.push(unit);
          }
        });
        if (last && VideoSample) {
          this.pushAccessUnit(VideoSample, track);
          this.VideoSample = null;
        }
      };
      _proto.parseAVCNALu = function parseAVCNALu(track, array) {
        var len = array.byteLength;
        var state = track.naluState || 0;
        var lastState = state;
        var units = [];
        var i = 0;
        var value;
        var overflow;
        var unitType;
        var lastUnitStart = -1;
        var lastUnitType = 0;
        if (state === -1) {
          lastUnitStart = 0;
          lastUnitType = array[0] & 31;
          state = 0;
          i = 1;
        }
        while (i < len) {
          value = array[i++];
          if (!state) {
            state = value ? 0 : 1;
            continue;
          }
          if (state === 1) {
            state = value ? 0 : 2;
            continue;
          }
          if (!value) {
            state = 3;
          } else if (value === 1) {
            overflow = i - state - 1;
            if (lastUnitStart >= 0) {
              var unit = {
                data: array.subarray(lastUnitStart, overflow),
                type: lastUnitType
              };
              units.push(unit);
            } else {
              var lastUnit = this.getLastNalUnit(track.samples);
              if (lastUnit) {
                if (lastState && i <= 4 - lastState) {
                  if (lastUnit.state) {
                    lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                  }
                }
                if (overflow > 0) {
                  lastUnit.data = appendUint8Array(lastUnit.data, array.subarray(0, overflow));
                  lastUnit.state = 0;
                }
              }
            }
            if (i < len) {
              unitType = array[i] & 31;
              lastUnitStart = i;
              lastUnitType = unitType;
              state = 0;
            } else {
              state = -1;
            }
          } else {
            state = 0;
          }
        }
        if (lastUnitStart >= 0 && state >= 0) {
          var _unit = {
            data: array.subarray(lastUnitStart, len),
            type: lastUnitType,
            state
          };
          units.push(_unit);
        }
        if (units.length === 0) {
          var _lastUnit = this.getLastNalUnit(track.samples);
          if (_lastUnit) {
            _lastUnit.data = appendUint8Array(_lastUnit.data, array);
          }
        }
        track.naluState = state;
        return units;
      };
      return AvcVideoParser2;
    }(BaseVideoParser);
    var SampleAesDecrypter = /* @__PURE__ */ function() {
      function SampleAesDecrypter2(observer, config, keyData) {
        this.keyData = void 0;
        this.decrypter = void 0;
        this.keyData = keyData;
        this.decrypter = new Decrypter(config, {
          removePKCS7Padding: false
        });
      }
      var _proto = SampleAesDecrypter2.prototype;
      _proto.decryptBuffer = function decryptBuffer(encryptedData) {
        return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);
      };
      _proto.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback) {
        var _this = this;
        var curUnit = samples[sampleIndex].unit;
        if (curUnit.length <= 16) {
          return;
        }
        var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
        var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);
        this.decryptBuffer(encryptedBuffer).then(function(decryptedBuffer) {
          var decryptedData = new Uint8Array(decryptedBuffer);
          curUnit.set(decryptedData, 16);
          if (!_this.decrypter.isSync()) {
            _this.decryptAacSamples(samples, sampleIndex + 1, callback);
          }
        });
      };
      _proto.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {
        for (; ; sampleIndex++) {
          if (sampleIndex >= samples.length) {
            callback();
            return;
          }
          if (samples[sampleIndex].unit.length < 32) {
            continue;
          }
          this.decryptAacSample(samples, sampleIndex, callback);
          if (!this.decrypter.isSync()) {
            return;
          }
        }
      };
      _proto.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {
        var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
        var encryptedData = new Int8Array(encryptedDataLen);
        var outputPos = 0;
        for (var inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {
          encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
        }
        return encryptedData;
      };
      _proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {
        var uint8DecryptedData = new Uint8Array(decryptedData);
        var inputPos = 0;
        for (var outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {
          decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);
        }
        return decodedData;
      };
      _proto.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {
        var _this2 = this;
        var decodedData = discardEPB(curUnit.data);
        var encryptedData = this.getAvcEncryptedData(decodedData);
        this.decryptBuffer(encryptedData.buffer).then(function(decryptedBuffer) {
          curUnit.data = _this2.getAvcDecryptedUnit(decodedData, decryptedBuffer);
          if (!_this2.decrypter.isSync()) {
            _this2.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
          }
        });
      };
      _proto.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
        if (samples instanceof Uint8Array) {
          throw new Error("Cannot decrypt samples of type Uint8Array");
        }
        for (; ; sampleIndex++, unitIndex = 0) {
          if (sampleIndex >= samples.length) {
            callback();
            return;
          }
          var curUnits = samples[sampleIndex].units;
          for (; ; unitIndex++) {
            if (unitIndex >= curUnits.length) {
              break;
            }
            var curUnit = curUnits[unitIndex];
            if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
              continue;
            }
            this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);
            if (!this.decrypter.isSync()) {
              return;
            }
          }
        }
      };
      return SampleAesDecrypter2;
    }();
    var PACKET_LENGTH = 188;
    var TSDemuxer = /* @__PURE__ */ function() {
      function TSDemuxer2(observer, config, typeSupported) {
        this.observer = void 0;
        this.config = void 0;
        this.typeSupported = void 0;
        this.sampleAes = null;
        this.pmtParsed = false;
        this.audioCodec = void 0;
        this.videoCodec = void 0;
        this._duration = 0;
        this._pmtId = -1;
        this._videoTrack = void 0;
        this._audioTrack = void 0;
        this._id3Track = void 0;
        this._txtTrack = void 0;
        this.aacOverFlow = null;
        this.remainderData = null;
        this.videoParser = void 0;
        this.observer = observer;
        this.config = config;
        this.typeSupported = typeSupported;
        this.videoParser = new AvcVideoParser();
      }
      TSDemuxer2.probe = function probe2(data) {
        var syncOffset = TSDemuxer2.syncOffset(data);
        if (syncOffset > 0) {
          logger.warn("MPEG2-TS detected but first sync word found @ offset " + syncOffset);
        }
        return syncOffset !== -1;
      };
      TSDemuxer2.syncOffset = function syncOffset(data) {
        var length = data.length;
        var scanwindow = Math.min(PACKET_LENGTH * 5, length - PACKET_LENGTH) + 1;
        var i = 0;
        while (i < scanwindow) {
          var foundPat = false;
          var packetStart = -1;
          var tsPackets = 0;
          for (var j = i; j < length; j += PACKET_LENGTH) {
            if (data[j] === 71 && (length - j === PACKET_LENGTH || data[j + PACKET_LENGTH] === 71)) {
              tsPackets++;
              if (packetStart === -1) {
                packetStart = j;
                if (packetStart !== 0) {
                  scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;
                }
              }
              if (!foundPat) {
                foundPat = parsePID(data, j) === 0;
              }
              if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {
                return packetStart;
              }
            } else if (tsPackets) {
              return -1;
            } else {
              break;
            }
          }
          i++;
        }
        return -1;
      };
      TSDemuxer2.createTrack = function createTrack(type, duration) {
        return {
          container: type === "video" || type === "audio" ? "video/mp2t" : void 0,
          type,
          id: RemuxerTrackIdConfig[type],
          pid: -1,
          inputTimeScale: 9e4,
          sequenceNumber: 0,
          samples: [],
          dropped: 0,
          duration: type === "audio" ? duration : void 0
        };
      };
      var _proto = TSDemuxer2.prototype;
      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
        this.pmtParsed = false;
        this._pmtId = -1;
        this._videoTrack = TSDemuxer2.createTrack("video");
        this._audioTrack = TSDemuxer2.createTrack("audio", trackDuration);
        this._id3Track = TSDemuxer2.createTrack("id3");
        this._txtTrack = TSDemuxer2.createTrack("text");
        this._audioTrack.segmentCodec = "aac";
        this.aacOverFlow = null;
        this.remainderData = null;
        this.audioCodec = audioCodec;
        this.videoCodec = videoCodec;
        this._duration = trackDuration;
      };
      _proto.resetTimeStamp = function resetTimeStamp() {
      };
      _proto.resetContiguity = function resetContiguity() {
        var _audioTrack = this._audioTrack, _videoTrack = this._videoTrack, _id3Track = this._id3Track;
        if (_audioTrack) {
          _audioTrack.pesData = null;
        }
        if (_videoTrack) {
          _videoTrack.pesData = null;
        }
        if (_id3Track) {
          _id3Track.pesData = null;
        }
        this.aacOverFlow = null;
        this.remainderData = null;
      };
      _proto.demux = function demux(data, timeOffset, isSampleAes, flush) {
        if (isSampleAes === void 0) {
          isSampleAes = false;
        }
        if (flush === void 0) {
          flush = false;
        }
        if (!isSampleAes) {
          this.sampleAes = null;
        }
        var pes;
        var videoTrack = this._videoTrack;
        var audioTrack = this._audioTrack;
        var id3Track = this._id3Track;
        var textTrack = this._txtTrack;
        var videoPid = videoTrack.pid;
        var videoData = videoTrack.pesData;
        var audioPid = audioTrack.pid;
        var id3Pid = id3Track.pid;
        var audioData = audioTrack.pesData;
        var id3Data = id3Track.pesData;
        var unknownPID = null;
        var pmtParsed = this.pmtParsed;
        var pmtId = this._pmtId;
        var len = data.length;
        if (this.remainderData) {
          data = appendUint8Array(this.remainderData, data);
          len = data.length;
          this.remainderData = null;
        }
        if (len < PACKET_LENGTH && !flush) {
          this.remainderData = data;
          return {
            audioTrack,
            videoTrack,
            id3Track,
            textTrack
          };
        }
        var syncOffset = Math.max(0, TSDemuxer2.syncOffset(data));
        len -= (len - syncOffset) % PACKET_LENGTH;
        if (len < data.byteLength && !flush) {
          this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);
        }
        var tsPacketErrors = 0;
        for (var start = syncOffset; start < len; start += PACKET_LENGTH) {
          if (data[start] === 71) {
            var stt = !!(data[start + 1] & 64);
            var pid = parsePID(data, start);
            var atf = (data[start + 3] & 48) >> 4;
            var offset = void 0;
            if (atf > 1) {
              offset = start + 5 + data[start + 4];
              if (offset === start + PACKET_LENGTH) {
                continue;
              }
            } else {
              offset = start + 4;
            }
            switch (pid) {
              case videoPid:
                if (stt) {
                  if (videoData && (pes = parsePES(videoData))) {
                    this.videoParser.parseAVCPES(videoTrack, textTrack, pes, false, this._duration);
                  }
                  videoData = {
                    data: [],
                    size: 0
                  };
                }
                if (videoData) {
                  videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));
                  videoData.size += start + PACKET_LENGTH - offset;
                }
                break;
              case audioPid:
                if (stt) {
                  if (audioData && (pes = parsePES(audioData))) {
                    switch (audioTrack.segmentCodec) {
                      case "aac":
                        this.parseAACPES(audioTrack, pes);
                        break;
                      case "mp3":
                        this.parseMPEGPES(audioTrack, pes);
                        break;
                      case "ac3":
                        {
                          this.parseAC3PES(audioTrack, pes);
                        }
                        break;
                    }
                  }
                  audioData = {
                    data: [],
                    size: 0
                  };
                }
                if (audioData) {
                  audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));
                  audioData.size += start + PACKET_LENGTH - offset;
                }
                break;
              case id3Pid:
                if (stt) {
                  if (id3Data && (pes = parsePES(id3Data))) {
                    this.parseID3PES(id3Track, pes);
                  }
                  id3Data = {
                    data: [],
                    size: 0
                  };
                }
                if (id3Data) {
                  id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));
                  id3Data.size += start + PACKET_LENGTH - offset;
                }
                break;
              case 0:
                if (stt) {
                  offset += data[offset] + 1;
                }
                pmtId = this._pmtId = parsePAT(data, offset);
                break;
              case pmtId: {
                if (stt) {
                  offset += data[offset] + 1;
                }
                var parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes);
                videoPid = parsedPIDs.videoPid;
                if (videoPid > 0) {
                  videoTrack.pid = videoPid;
                  videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;
                }
                audioPid = parsedPIDs.audioPid;
                if (audioPid > 0) {
                  audioTrack.pid = audioPid;
                  audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;
                }
                id3Pid = parsedPIDs.id3Pid;
                if (id3Pid > 0) {
                  id3Track.pid = id3Pid;
                }
                if (unknownPID !== null && !pmtParsed) {
                  logger.warn("MPEG-TS PMT found at " + start + " after unknown PID '" + unknownPID + "'. Backtracking to sync byte @" + syncOffset + " to parse all TS packets.");
                  unknownPID = null;
                  start = syncOffset - 188;
                }
                pmtParsed = this.pmtParsed = true;
                break;
              }
              case 17:
              case 8191:
                break;
              default:
                unknownPID = pid;
                break;
            }
          } else {
            tsPacketErrors++;
          }
        }
        if (tsPacketErrors > 0) {
          var error = new Error("Found " + tsPacketErrors + " TS packet/s that do not start with 0x47");
          this.observer.emit(Events.ERROR, Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.FRAG_PARSING_ERROR,
            fatal: false,
            error,
            reason: error.message
          });
        }
        videoTrack.pesData = videoData;
        audioTrack.pesData = audioData;
        id3Track.pesData = id3Data;
        var demuxResult = {
          audioTrack,
          videoTrack,
          id3Track,
          textTrack
        };
        if (flush) {
          this.extractRemainingSamples(demuxResult);
        }
        return demuxResult;
      };
      _proto.flush = function flush() {
        var remainderData = this.remainderData;
        this.remainderData = null;
        var result;
        if (remainderData) {
          result = this.demux(remainderData, -1, false, true);
        } else {
          result = {
            videoTrack: this._videoTrack,
            audioTrack: this._audioTrack,
            id3Track: this._id3Track,
            textTrack: this._txtTrack
          };
        }
        this.extractRemainingSamples(result);
        if (this.sampleAes) {
          return this.decrypt(result, this.sampleAes);
        }
        return result;
      };
      _proto.extractRemainingSamples = function extractRemainingSamples(demuxResult) {
        var audioTrack = demuxResult.audioTrack, videoTrack = demuxResult.videoTrack, id3Track = demuxResult.id3Track, textTrack = demuxResult.textTrack;
        var videoData = videoTrack.pesData;
        var audioData = audioTrack.pesData;
        var id3Data = id3Track.pesData;
        var pes;
        if (videoData && (pes = parsePES(videoData))) {
          this.videoParser.parseAVCPES(videoTrack, textTrack, pes, true, this._duration);
          videoTrack.pesData = null;
        } else {
          videoTrack.pesData = videoData;
        }
        if (audioData && (pes = parsePES(audioData))) {
          switch (audioTrack.segmentCodec) {
            case "aac":
              this.parseAACPES(audioTrack, pes);
              break;
            case "mp3":
              this.parseMPEGPES(audioTrack, pes);
              break;
            case "ac3":
              {
                this.parseAC3PES(audioTrack, pes);
              }
              break;
          }
          audioTrack.pesData = null;
        } else {
          if (audioData != null && audioData.size) {
            logger.log("last AAC PES packet truncated,might overlap between fragments");
          }
          audioTrack.pesData = audioData;
        }
        if (id3Data && (pes = parsePES(id3Data))) {
          this.parseID3PES(id3Track, pes);
          id3Track.pesData = null;
        } else {
          id3Track.pesData = id3Data;
        }
      };
      _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {
        var demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);
        var sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);
        return this.decrypt(demuxResult, sampleAes);
      };
      _proto.decrypt = function decrypt(demuxResult, sampleAes) {
        return new Promise(function(resolve) {
          var audioTrack = demuxResult.audioTrack, videoTrack = demuxResult.videoTrack;
          if (audioTrack.samples && audioTrack.segmentCodec === "aac") {
            sampleAes.decryptAacSamples(audioTrack.samples, 0, function() {
              if (videoTrack.samples) {
                sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function() {
                  resolve(demuxResult);
                });
              } else {
                resolve(demuxResult);
              }
            });
          } else if (videoTrack.samples) {
            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function() {
              resolve(demuxResult);
            });
          }
        });
      };
      _proto.destroy = function destroy() {
        this._duration = 0;
      };
      _proto.parseAACPES = function parseAACPES(track, pes) {
        var startOffset = 0;
        var aacOverFlow = this.aacOverFlow;
        var data = pes.data;
        if (aacOverFlow) {
          this.aacOverFlow = null;
          var frameMissingBytes = aacOverFlow.missing;
          var sampleLength = aacOverFlow.sample.unit.byteLength;
          if (frameMissingBytes === -1) {
            data = appendUint8Array(aacOverFlow.sample.unit, data);
          } else {
            var frameOverflowBytes = sampleLength - frameMissingBytes;
            aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);
            track.samples.push(aacOverFlow.sample);
            startOffset = aacOverFlow.missing;
          }
        }
        var offset;
        var len;
        for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
          if (isHeader$1(data, offset)) {
            break;
          }
        }
        if (offset !== startOffset) {
          var reason;
          var recoverable = offset < len - 1;
          if (recoverable) {
            reason = "AAC PES did not start with ADTS header,offset:" + offset;
          } else {
            reason = "No ADTS header found in AAC PES";
          }
          var error = new Error(reason);
          logger.warn("parsing error: " + reason);
          this.observer.emit(Events.ERROR, Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.FRAG_PARSING_ERROR,
            fatal: false,
            levelRetry: recoverable,
            error,
            reason
          });
          if (!recoverable) {
            return;
          }
        }
        initTrackConfig(track, this.observer, data, offset, this.audioCodec);
        var pts;
        if (pes.pts !== void 0) {
          pts = pes.pts;
        } else if (aacOverFlow) {
          var frameDuration = getFrameDuration(track.samplerate);
          pts = aacOverFlow.sample.pts + frameDuration;
        } else {
          logger.warn("[tsdemuxer]: AAC PES unknown PTS");
          return;
        }
        var frameIndex = 0;
        var frame;
        while (offset < len) {
          frame = appendFrame$1(track, data, offset, pts, frameIndex);
          offset += frame.length;
          if (!frame.missing) {
            frameIndex++;
            for (; offset < len - 1; offset++) {
              if (isHeader$1(data, offset)) {
                break;
              }
            }
          } else {
            this.aacOverFlow = frame;
            break;
          }
        }
      };
      _proto.parseMPEGPES = function parseMPEGPES(track, pes) {
        var data = pes.data;
        var length = data.length;
        var frameIndex = 0;
        var offset = 0;
        var pts = pes.pts;
        if (pts === void 0) {
          logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
          return;
        }
        while (offset < length) {
          if (isHeader(data, offset)) {
            var frame = appendFrame(track, data, offset, pts, frameIndex);
            if (frame) {
              offset += frame.length;
              frameIndex++;
            } else {
              break;
            }
          } else {
            offset++;
          }
        }
      };
      _proto.parseAC3PES = function parseAC3PES(track, pes) {
        {
          var data = pes.data;
          var pts = pes.pts;
          if (pts === void 0) {
            logger.warn("[tsdemuxer]: AC3 PES unknown PTS");
            return;
          }
          var length = data.length;
          var frameIndex = 0;
          var offset = 0;
          var parsed;
          while (offset < length && (parsed = _appendFrame(track, data, offset, pts, frameIndex++)) > 0) {
            offset += parsed;
          }
        }
      };
      _proto.parseID3PES = function parseID3PES(id3Track, pes) {
        if (pes.pts === void 0) {
          logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
          return;
        }
        var id3Sample = _extends({}, pes, {
          type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,
          duration: Number.POSITIVE_INFINITY
        });
        id3Track.samples.push(id3Sample);
      };
      return TSDemuxer2;
    }();
    function parsePID(data, offset) {
      return ((data[offset + 1] & 31) << 8) + data[offset + 2];
    }
    function parsePAT(data, offset) {
      return (data[offset + 10] & 31) << 8 | data[offset + 11];
    }
    function parsePMT(data, offset, typeSupported, isSampleAes) {
      var result = {
        audioPid: -1,
        videoPid: -1,
        id3Pid: -1,
        segmentVideoCodec: "avc",
        segmentAudioCodec: "aac"
      };
      var sectionLength = (data[offset + 1] & 15) << 8 | data[offset + 2];
      var tableEnd = offset + 3 + sectionLength - 4;
      var programInfoLength = (data[offset + 10] & 15) << 8 | data[offset + 11];
      offset += 12 + programInfoLength;
      while (offset < tableEnd) {
        var pid = parsePID(data, offset);
        var esInfoLength = (data[offset + 3] & 15) << 8 | data[offset + 4];
        switch (data[offset]) {
          case 207:
            if (!isSampleAes) {
              logEncryptedSamplesFoundInUnencryptedStream("ADTS AAC");
              break;
            }
          case 15:
            if (result.audioPid === -1) {
              result.audioPid = pid;
            }
            break;
          case 21:
            if (result.id3Pid === -1) {
              result.id3Pid = pid;
            }
            break;
          case 219:
            if (!isSampleAes) {
              logEncryptedSamplesFoundInUnencryptedStream("H.264");
              break;
            }
          case 27:
            if (result.videoPid === -1) {
              result.videoPid = pid;
              result.segmentVideoCodec = "avc";
            }
            break;
          case 3:
          case 4:
            if (!typeSupported.mpeg && !typeSupported.mp3) {
              logger.log("MPEG audio found, not supported in this browser");
            } else if (result.audioPid === -1) {
              result.audioPid = pid;
              result.segmentAudioCodec = "mp3";
            }
            break;
          case 193:
            if (!isSampleAes) {
              logEncryptedSamplesFoundInUnencryptedStream("AC-3");
              break;
            }
          case 129:
            {
              if (!typeSupported.ac3) {
                logger.log("AC-3 audio found, not supported in this browser");
              } else if (result.audioPid === -1) {
                result.audioPid = pid;
                result.segmentAudioCodec = "ac3";
              }
            }
            break;
          case 6:
            if (result.audioPid === -1 && esInfoLength > 0) {
              var parsePos = offset + 5;
              var remaining = esInfoLength;
              while (remaining > 2) {
                var descriptorId = data[parsePos];
                switch (descriptorId) {
                  case 106:
                    {
                      if (typeSupported.ac3 !== true) {
                        logger.log("AC-3 audio found, not supported in this browser for now");
                      } else {
                        result.audioPid = pid;
                        result.segmentAudioCodec = "ac3";
                      }
                    }
                    break;
                }
                var descriptorLen = data[parsePos + 1] + 2;
                parsePos += descriptorLen;
                remaining -= descriptorLen;
              }
            }
            break;
          case 194:
          case 135:
            logger.warn("Unsupported EC-3 in M2TS found");
            break;
          case 36:
            logger.warn("Unsupported HEVC in M2TS found");
            break;
        }
        offset += esInfoLength + 5;
      }
      return result;
    }
    function logEncryptedSamplesFoundInUnencryptedStream(type) {
      logger.log(type + " with AES-128-CBC encryption found in unencrypted stream");
    }
    function parsePES(stream) {
      var i = 0;
      var frag;
      var pesLen;
      var pesHdrLen;
      var pesPts;
      var pesDts;
      var data = stream.data;
      if (!stream || stream.size === 0) {
        return null;
      }
      while (data[0].length < 19 && data.length > 1) {
        data[0] = appendUint8Array(data[0], data[1]);
        data.splice(1, 1);
      }
      frag = data[0];
      var pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
      if (pesPrefix === 1) {
        pesLen = (frag[4] << 8) + frag[5];
        if (pesLen && pesLen > stream.size - 6) {
          return null;
        }
        var pesFlags = frag[7];
        if (pesFlags & 192) {
          pesPts = (frag[9] & 14) * 536870912 + // 1 << 29
          (frag[10] & 255) * 4194304 + // 1 << 22
          (frag[11] & 254) * 16384 + // 1 << 14
          (frag[12] & 255) * 128 + // 1 << 7
          (frag[13] & 254) / 2;
          if (pesFlags & 64) {
            pesDts = (frag[14] & 14) * 536870912 + // 1 << 29
            (frag[15] & 255) * 4194304 + // 1 << 22
            (frag[16] & 254) * 16384 + // 1 << 14
            (frag[17] & 255) * 128 + // 1 << 7
            (frag[18] & 254) / 2;
            if (pesPts - pesDts > 60 * 9e4) {
              logger.warn(Math.round((pesPts - pesDts) / 9e4) + "s delta between PTS and DTS, align them");
              pesPts = pesDts;
            }
          } else {
            pesDts = pesPts;
          }
        }
        pesHdrLen = frag[8];
        var payloadStartOffset = pesHdrLen + 9;
        if (stream.size <= payloadStartOffset) {
          return null;
        }
        stream.size -= payloadStartOffset;
        var pesData = new Uint8Array(stream.size);
        for (var j = 0, dataLen = data.length; j < dataLen; j++) {
          frag = data[j];
          var len = frag.byteLength;
          if (payloadStartOffset) {
            if (payloadStartOffset > len) {
              payloadStartOffset -= len;
              continue;
            } else {
              frag = frag.subarray(payloadStartOffset);
              len -= payloadStartOffset;
              payloadStartOffset = 0;
            }
          }
          pesData.set(frag, i);
          i += len;
        }
        if (pesLen) {
          pesLen -= pesHdrLen + 3;
        }
        return {
          data: pesData,
          pts: pesPts,
          dts: pesDts,
          len: pesLen
        };
      }
      return null;
    }
    var MP3Demuxer = /* @__PURE__ */ function(_BaseAudioDemuxer) {
      _inheritsLoose(MP3Demuxer2, _BaseAudioDemuxer);
      function MP3Demuxer2() {
        return _BaseAudioDemuxer.apply(this, arguments) || this;
      }
      var _proto = MP3Demuxer2.prototype;
      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
        _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);
        this._audioTrack = {
          container: "audio/mpeg",
          type: "audio",
          id: 2,
          pid: -1,
          sequenceNumber: 0,
          segmentCodec: "mp3",
          samples: [],
          manifestCodec: audioCodec,
          duration: trackDuration,
          inputTimeScale: 9e4,
          dropped: 0
        };
      };
      MP3Demuxer2.probe = function probe$12(data) {
        if (!data) {
          return false;
        }
        var id3Data = getID3Data(data, 0);
        var offset = (id3Data == null ? void 0 : id3Data.length) || 0;
        if (id3Data && data[offset] === 11 && data[offset + 1] === 119 && getTimeStamp(id3Data) !== void 0 && // check the bsid to confirm ac-3 or ec-3 (not mp3)
        getAudioBSID(data, offset) <= 16) {
          return false;
        }
        for (var length = data.length; offset < length; offset++) {
          if (probe(data, offset)) {
            logger.log("MPEG Audio sync word found !");
            return true;
          }
        }
        return false;
      };
      _proto.canParse = function canParse$12(data, offset) {
        return canParse(data, offset);
      };
      _proto.appendFrame = function appendFrame$12(track, data, offset) {
        if (this.basePTS === null) {
          return;
        }
        return appendFrame(track, data, offset, this.basePTS, this.frameIndex);
      };
      return MP3Demuxer2;
    }(BaseAudioDemuxer);
    var AAC = /* @__PURE__ */ function() {
      function AAC2() {
      }
      AAC2.getSilentFrame = function getSilentFrame(codec, channelCount) {
        switch (codec) {
          case "mp4a.40.2":
            if (channelCount === 1) {
              return new Uint8Array([0, 200, 0, 128, 35, 128]);
            } else if (channelCount === 2) {
              return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
            } else if (channelCount === 3) {
              return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
            } else if (channelCount === 4) {
              return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
            } else if (channelCount === 5) {
              return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
            } else if (channelCount === 6) {
              return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
            }
            break;
          default:
            if (channelCount === 1) {
              return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
            } else if (channelCount === 2) {
              return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
            } else if (channelCount === 3) {
              return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
            }
            break;
        }
        return void 0;
      };
      return AAC2;
    }();
    var UINT32_MAX = Math.pow(2, 32) - 1;
    var MP4 = /* @__PURE__ */ function() {
      function MP42() {
      }
      MP42.init = function init() {
        MP42.types = {
          avc1: [],
          // codingname
          avcC: [],
          btrt: [],
          dinf: [],
          dref: [],
          esds: [],
          ftyp: [],
          hdlr: [],
          mdat: [],
          mdhd: [],
          mdia: [],
          mfhd: [],
          minf: [],
          moof: [],
          moov: [],
          mp4a: [],
          ".mp3": [],
          dac3: [],
          "ac-3": [],
          mvex: [],
          mvhd: [],
          pasp: [],
          sdtp: [],
          stbl: [],
          stco: [],
          stsc: [],
          stsd: [],
          stsz: [],
          stts: [],
          tfdt: [],
          tfhd: [],
          traf: [],
          trak: [],
          trun: [],
          trex: [],
          tkhd: [],
          vmhd: [],
          smhd: []
        };
        var i;
        for (i in MP42.types) {
          if (MP42.types.hasOwnProperty(i)) {
            MP42.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
          }
        }
        var videoHdlr = new Uint8Array([
          0,
          // version 0
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          0,
          // pre_defined
          118,
          105,
          100,
          101,
          // handler_type: 'vide'
          0,
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          // reserved
          86,
          105,
          100,
          101,
          111,
          72,
          97,
          110,
          100,
          108,
          101,
          114,
          0
          // name: 'VideoHandler'
        ]);
        var audioHdlr = new Uint8Array([
          0,
          // version 0
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          0,
          // pre_defined
          115,
          111,
          117,
          110,
          // handler_type: 'soun'
          0,
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          // reserved
          83,
          111,
          117,
          110,
          100,
          72,
          97,
          110,
          100,
          108,
          101,
          114,
          0
          // name: 'SoundHandler'
        ]);
        MP42.HDLR_TYPES = {
          video: videoHdlr,
          audio: audioHdlr
        };
        var dref = new Uint8Array([
          0,
          // version 0
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          1,
          // entry_count
          0,
          0,
          0,
          12,
          // entry_size
          117,
          114,
          108,
          32,
          // 'url' type
          0,
          // version 0
          0,
          0,
          1
          // entry_flags
        ]);
        var stco = new Uint8Array([
          0,
          // version
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          0
          // entry_count
        ]);
        MP42.STTS = MP42.STSC = MP42.STCO = stco;
        MP42.STSZ = new Uint8Array([
          0,
          // version
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          0,
          // sample_size
          0,
          0,
          0,
          0
          // sample_count
        ]);
        MP42.VMHD = new Uint8Array([
          0,
          // version
          0,
          0,
          1,
          // flags
          0,
          0,
          // graphicsmode
          0,
          0,
          0,
          0,
          0,
          0
          // opcolor
        ]);
        MP42.SMHD = new Uint8Array([
          0,
          // version
          0,
          0,
          0,
          // flags
          0,
          0,
          // balance
          0,
          0
          // reserved
        ]);
        MP42.STSD = new Uint8Array([
          0,
          // version 0
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          1
        ]);
        var majorBrand = new Uint8Array([105, 115, 111, 109]);
        var avc1Brand = new Uint8Array([97, 118, 99, 49]);
        var minorVersion = new Uint8Array([0, 0, 0, 1]);
        MP42.FTYP = MP42.box(MP42.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
        MP42.DINF = MP42.box(MP42.types.dinf, MP42.box(MP42.types.dref, dref));
      };
      MP42.box = function box(type) {
        var size = 8;
        for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          payload[_key - 1] = arguments[_key];
        }
        var i = payload.length;
        var len = i;
        while (i--) {
          size += payload[i].byteLength;
        }
        var result = new Uint8Array(size);
        result[0] = size >> 24 & 255;
        result[1] = size >> 16 & 255;
        result[2] = size >> 8 & 255;
        result[3] = size & 255;
        result.set(type, 4);
        for (i = 0, size = 8; i < len; i++) {
          result.set(payload[i], size);
          size += payload[i].byteLength;
        }
        return result;
      };
      MP42.hdlr = function hdlr(type) {
        return MP42.box(MP42.types.hdlr, MP42.HDLR_TYPES[type]);
      };
      MP42.mdat = function mdat(data) {
        return MP42.box(MP42.types.mdat, data);
      };
      MP42.mdhd = function mdhd(timescale, duration) {
        duration *= timescale;
        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
        return MP42.box(MP42.types.mdhd, new Uint8Array([
          1,
          // version 1
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          2,
          // creation_time
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          3,
          // modification_time
          timescale >> 24 & 255,
          timescale >> 16 & 255,
          timescale >> 8 & 255,
          timescale & 255,
          // timescale
          upperWordDuration >> 24,
          upperWordDuration >> 16 & 255,
          upperWordDuration >> 8 & 255,
          upperWordDuration & 255,
          lowerWordDuration >> 24,
          lowerWordDuration >> 16 & 255,
          lowerWordDuration >> 8 & 255,
          lowerWordDuration & 255,
          85,
          196,
          // 'und' language (undetermined)
          0,
          0
        ]));
      };
      MP42.mdia = function mdia(track) {
        return MP42.box(MP42.types.mdia, MP42.mdhd(track.timescale, track.duration), MP42.hdlr(track.type), MP42.minf(track));
      };
      MP42.mfhd = function mfhd(sequenceNumber) {
        return MP42.box(MP42.types.mfhd, new Uint8Array([
          0,
          0,
          0,
          0,
          // flags
          sequenceNumber >> 24,
          sequenceNumber >> 16 & 255,
          sequenceNumber >> 8 & 255,
          sequenceNumber & 255
          // sequence_number
        ]));
      };
      MP42.minf = function minf(track) {
        if (track.type === "audio") {
          return MP42.box(MP42.types.minf, MP42.box(MP42.types.smhd, MP42.SMHD), MP42.DINF, MP42.stbl(track));
        } else {
          return MP42.box(MP42.types.minf, MP42.box(MP42.types.vmhd, MP42.VMHD), MP42.DINF, MP42.stbl(track));
        }
      };
      MP42.moof = function moof(sn, baseMediaDecodeTime, track) {
        return MP42.box(MP42.types.moof, MP42.mfhd(sn), MP42.traf(track, baseMediaDecodeTime));
      };
      MP42.moov = function moov(tracks) {
        var i = tracks.length;
        var boxes = [];
        while (i--) {
          boxes[i] = MP42.trak(tracks[i]);
        }
        return MP42.box.apply(null, [MP42.types.moov, MP42.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP42.mvex(tracks)));
      };
      MP42.mvex = function mvex(tracks) {
        var i = tracks.length;
        var boxes = [];
        while (i--) {
          boxes[i] = MP42.trex(tracks[i]);
        }
        return MP42.box.apply(null, [MP42.types.mvex].concat(boxes));
      };
      MP42.mvhd = function mvhd(timescale, duration) {
        duration *= timescale;
        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
        var bytes = new Uint8Array([
          1,
          // version 1
          0,
          0,
          0,
          // flags
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          2,
          // creation_time
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          3,
          // modification_time
          timescale >> 24 & 255,
          timescale >> 16 & 255,
          timescale >> 8 & 255,
          timescale & 255,
          // timescale
          upperWordDuration >> 24,
          upperWordDuration >> 16 & 255,
          upperWordDuration >> 8 & 255,
          upperWordDuration & 255,
          lowerWordDuration >> 24,
          lowerWordDuration >> 16 & 255,
          lowerWordDuration >> 8 & 255,
          lowerWordDuration & 255,
          0,
          1,
          0,
          0,
          // 1.0 rate
          1,
          0,
          // 1.0 volume
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          0,
          // reserved
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          64,
          0,
          0,
          0,
          // transformation: unity matrix
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          // pre_defined
          255,
          255,
          255,
          255
          // next_track_ID
        ]);
        return MP42.box(MP42.types.mvhd, bytes);
      };
      MP42.sdtp = function sdtp(track) {
        var samples = track.samples || [];
        var bytes = new Uint8Array(4 + samples.length);
        var i;
        var flags;
        for (i = 0; i < samples.length; i++) {
          flags = samples[i].flags;
          bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
        }
        return MP42.box(MP42.types.sdtp, bytes);
      };
      MP42.stbl = function stbl(track) {
        return MP42.box(MP42.types.stbl, MP42.stsd(track), MP42.box(MP42.types.stts, MP42.STTS), MP42.box(MP42.types.stsc, MP42.STSC), MP42.box(MP42.types.stsz, MP42.STSZ), MP42.box(MP42.types.stco, MP42.STCO));
      };
      MP42.avc1 = function avc1(track) {
        var sps = [];
        var pps = [];
        var i;
        var data;
        var len;
        for (i = 0; i < track.sps.length; i++) {
          data = track.sps[i];
          len = data.byteLength;
          sps.push(len >>> 8 & 255);
          sps.push(len & 255);
          sps = sps.concat(Array.prototype.slice.call(data));
        }
        for (i = 0; i < track.pps.length; i++) {
          data = track.pps[i];
          len = data.byteLength;
          pps.push(len >>> 8 & 255);
          pps.push(len & 255);
          pps = pps.concat(Array.prototype.slice.call(data));
        }
        var avcc = MP42.box(MP42.types.avcC, new Uint8Array([
          1,
          // version
          sps[3],
          // profile
          sps[4],
          // profile compat
          sps[5],
          // level
          252 | 3,
          // lengthSizeMinusOne, hard-coded to 4 bytes
          224 | track.sps.length
          // 3bit reserved (111) + numOfSequenceParameterSets
        ].concat(sps).concat([
          track.pps.length
          // numOfPictureParameterSets
        ]).concat(pps)));
        var width = track.width;
        var height = track.height;
        var hSpacing = track.pixelRatio[0];
        var vSpacing = track.pixelRatio[1];
        return MP42.box(
          MP42.types.avc1,
          new Uint8Array([
            0,
            0,
            0,
            // reserved
            0,
            0,
            0,
            // reserved
            0,
            1,
            // data_reference_index
            0,
            0,
            // pre_defined
            0,
            0,
            // reserved
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            // pre_defined
            width >> 8 & 255,
            width & 255,
            // width
            height >> 8 & 255,
            height & 255,
            // height
            0,
            72,
            0,
            0,
            // horizresolution
            0,
            72,
            0,
            0,
            // vertresolution
            0,
            0,
            0,
            0,
            // reserved
            0,
            1,
            // frame_count
            18,
            100,
            97,
            105,
            108,
            // dailymotion/hls.js
            121,
            109,
            111,
            116,
            105,
            111,
            110,
            47,
            104,
            108,
            115,
            46,
            106,
            115,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            // compressorname
            0,
            24,
            // depth = 24
            17,
            17
          ]),
          // pre_defined = -1
          avcc,
          MP42.box(MP42.types.btrt, new Uint8Array([
            0,
            28,
            156,
            128,
            // bufferSizeDB
            0,
            45,
            198,
            192,
            // maxBitrate
            0,
            45,
            198,
            192
          ])),
          // avgBitrate
          MP42.box(MP42.types.pasp, new Uint8Array([
            hSpacing >> 24,
            // hSpacing
            hSpacing >> 16 & 255,
            hSpacing >> 8 & 255,
            hSpacing & 255,
            vSpacing >> 24,
            // vSpacing
            vSpacing >> 16 & 255,
            vSpacing >> 8 & 255,
            vSpacing & 255
          ]))
        );
      };
      MP42.esds = function esds(track) {
        var configlen = track.config.length;
        return new Uint8Array([
          0,
          // version 0
          0,
          0,
          0,
          // flags
          3,
          // descriptor_type
          23 + configlen,
          // length
          0,
          1,
          // es_id
          0,
          // stream_priority
          4,
          // descriptor_type
          15 + configlen,
          // length
          64,
          // codec : mpeg4_audio
          21,
          // stream_type
          0,
          0,
          0,
          // buffer_size
          0,
          0,
          0,
          0,
          // maxBitrate
          0,
          0,
          0,
          0,
          // avgBitrate
          5
          // descriptor_type
        ].concat([configlen]).concat(track.config).concat([6, 1, 2]));
      };
      MP42.audioStsd = function audioStsd(track) {
        var samplerate = track.samplerate;
        return new Uint8Array([
          0,
          0,
          0,
          // reserved
          0,
          0,
          0,
          // reserved
          0,
          1,
          // data_reference_index
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          // reserved
          0,
          track.channelCount,
          // channelcount
          0,
          16,
          // sampleSize:16bits
          0,
          0,
          0,
          0,
          // reserved2
          samplerate >> 8 & 255,
          samplerate & 255,
          //
          0,
          0
        ]);
      };
      MP42.mp4a = function mp4a(track) {
        return MP42.box(MP42.types.mp4a, MP42.audioStsd(track), MP42.box(MP42.types.esds, MP42.esds(track)));
      };
      MP42.mp3 = function mp3(track) {
        return MP42.box(MP42.types[".mp3"], MP42.audioStsd(track));
      };
      MP42.ac3 = function ac3(track) {
        return MP42.box(MP42.types["ac-3"], MP42.audioStsd(track), MP42.box(MP42.types.dac3, track.config));
      };
      MP42.stsd = function stsd(track) {
        if (track.type === "audio") {
          if (track.segmentCodec === "mp3" && track.codec === "mp3") {
            return MP42.box(MP42.types.stsd, MP42.STSD, MP42.mp3(track));
          }
          if (track.segmentCodec === "ac3") {
            return MP42.box(MP42.types.stsd, MP42.STSD, MP42.ac3(track));
          }
          return MP42.box(MP42.types.stsd, MP42.STSD, MP42.mp4a(track));
        } else {
          return MP42.box(MP42.types.stsd, MP42.STSD, MP42.avc1(track));
        }
      };
      MP42.tkhd = function tkhd(track) {
        var id = track.id;
        var duration = track.duration * track.timescale;
        var width = track.width;
        var height = track.height;
        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
        return MP42.box(MP42.types.tkhd, new Uint8Array([
          1,
          // version 1
          0,
          0,
          7,
          // flags
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          2,
          // creation_time
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          3,
          // modification_time
          id >> 24 & 255,
          id >> 16 & 255,
          id >> 8 & 255,
          id & 255,
          // track_ID
          0,
          0,
          0,
          0,
          // reserved
          upperWordDuration >> 24,
          upperWordDuration >> 16 & 255,
          upperWordDuration >> 8 & 255,
          upperWordDuration & 255,
          lowerWordDuration >> 24,
          lowerWordDuration >> 16 & 255,
          lowerWordDuration >> 8 & 255,
          lowerWordDuration & 255,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          // reserved
          0,
          0,
          // layer
          0,
          0,
          // alternate_group
          0,
          0,
          // non-audio track volume
          0,
          0,
          // reserved
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          64,
          0,
          0,
          0,
          // transformation: unity matrix
          width >> 8 & 255,
          width & 255,
          0,
          0,
          // width
          height >> 8 & 255,
          height & 255,
          0,
          0
          // height
        ]));
      };
      MP42.traf = function traf(track, baseMediaDecodeTime) {
        var sampleDependencyTable = MP42.sdtp(track);
        var id = track.id;
        var upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
        var lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
        return MP42.box(
          MP42.types.traf,
          MP42.box(MP42.types.tfhd, new Uint8Array([
            0,
            // version 0
            0,
            0,
            0,
            // flags
            id >> 24,
            id >> 16 & 255,
            id >> 8 & 255,
            id & 255
            // track_ID
          ])),
          MP42.box(MP42.types.tfdt, new Uint8Array([
            1,
            // version 1
            0,
            0,
            0,
            // flags
            upperWordBaseMediaDecodeTime >> 24,
            upperWordBaseMediaDecodeTime >> 16 & 255,
            upperWordBaseMediaDecodeTime >> 8 & 255,
            upperWordBaseMediaDecodeTime & 255,
            lowerWordBaseMediaDecodeTime >> 24,
            lowerWordBaseMediaDecodeTime >> 16 & 255,
            lowerWordBaseMediaDecodeTime >> 8 & 255,
            lowerWordBaseMediaDecodeTime & 255
          ])),
          MP42.trun(track, sampleDependencyTable.length + 16 + // tfhd
          20 + // tfdt
          8 + // traf header
          16 + // mfhd
          8 + // moof header
          8),
          // mdat header
          sampleDependencyTable
        );
      };
      MP42.trak = function trak(track) {
        track.duration = track.duration || 4294967295;
        return MP42.box(MP42.types.trak, MP42.tkhd(track), MP42.mdia(track));
      };
      MP42.trex = function trex(track) {
        var id = track.id;
        return MP42.box(MP42.types.trex, new Uint8Array([
          0,
          // version 0
          0,
          0,
          0,
          // flags
          id >> 24,
          id >> 16 & 255,
          id >> 8 & 255,
          id & 255,
          // track_ID
          0,
          0,
          0,
          1,
          // default_sample_description_index
          0,
          0,
          0,
          0,
          // default_sample_duration
          0,
          0,
          0,
          0,
          // default_sample_size
          0,
          1,
          0,
          1
          // default_sample_flags
        ]));
      };
      MP42.trun = function trun(track, offset) {
        var samples = track.samples || [];
        var len = samples.length;
        var arraylen = 12 + 16 * len;
        var array = new Uint8Array(arraylen);
        var i;
        var sample;
        var duration;
        var size;
        var flags;
        var cts;
        offset += 8 + arraylen;
        array.set([
          track.type === "video" ? 1 : 0,
          // version 1 for video with signed-int sample_composition_time_offset
          0,
          15,
          1,
          // flags
          len >>> 24 & 255,
          len >>> 16 & 255,
          len >>> 8 & 255,
          len & 255,
          // sample_count
          offset >>> 24 & 255,
          offset >>> 16 & 255,
          offset >>> 8 & 255,
          offset & 255
          // data_offset
        ], 0);
        for (i = 0; i < len; i++) {
          sample = samples[i];
          duration = sample.duration;
          size = sample.size;
          flags = sample.flags;
          cts = sample.cts;
          array.set([
            duration >>> 24 & 255,
            duration >>> 16 & 255,
            duration >>> 8 & 255,
            duration & 255,
            // sample_duration
            size >>> 24 & 255,
            size >>> 16 & 255,
            size >>> 8 & 255,
            size & 255,
            // sample_size
            flags.isLeading << 2 | flags.dependsOn,
            flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync,
            flags.degradPrio & 240 << 8,
            flags.degradPrio & 15,
            // sample_flags
            cts >>> 24 & 255,
            cts >>> 16 & 255,
            cts >>> 8 & 255,
            cts & 255
            // sample_composition_time_offset
          ], 12 + 16 * i);
        }
        return MP42.box(MP42.types.trun, array);
      };
      MP42.initSegment = function initSegment(tracks) {
        if (!MP42.types) {
          MP42.init();
        }
        var movie = MP42.moov(tracks);
        var result = appendUint8Array(MP42.FTYP, movie);
        return result;
      };
      return MP42;
    }();
    MP4.types = void 0;
    MP4.HDLR_TYPES = void 0;
    MP4.STTS = void 0;
    MP4.STSC = void 0;
    MP4.STCO = void 0;
    MP4.STSZ = void 0;
    MP4.VMHD = void 0;
    MP4.SMHD = void 0;
    MP4.STSD = void 0;
    MP4.FTYP = void 0;
    MP4.DINF = void 0;
    var MPEG_TS_CLOCK_FREQ_HZ = 9e4;
    function toTimescaleFromBase(baseTime, destScale, srcBase, round) {
      if (srcBase === void 0) {
        srcBase = 1;
      }
      if (round === void 0) {
        round = false;
      }
      var result = baseTime * destScale * srcBase;
      return round ? Math.round(result) : result;
    }
    function toTimescaleFromScale(baseTime, destScale, srcScale, round) {
      if (srcScale === void 0) {
        srcScale = 1;
      }
      if (round === void 0) {
        round = false;
      }
      return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);
    }
    function toMsFromMpegTsClock(baseTime, round) {
      if (round === void 0) {
        round = false;
      }
      return toTimescaleFromBase(baseTime, 1e3, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);
    }
    function toMpegTsClockFromTimescale(baseTime, srcScale) {
      if (srcScale === void 0) {
        srcScale = 1;
      }
      return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);
    }
    var MAX_SILENT_FRAME_DURATION = 10 * 1e3;
    var AAC_SAMPLES_PER_FRAME = 1024;
    var MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;
    var AC3_SAMPLES_PER_FRAME = 1536;
    var chromeVersion = null;
    var safariWebkitVersion = null;
    var MP4Remuxer = /* @__PURE__ */ function() {
      function MP4Remuxer2(observer, config, typeSupported, vendor) {
        this.observer = void 0;
        this.config = void 0;
        this.typeSupported = void 0;
        this.ISGenerated = false;
        this._initPTS = null;
        this._initDTS = null;
        this.nextAvcDts = null;
        this.nextAudioPts = null;
        this.videoSampleDuration = null;
        this.isAudioContiguous = false;
        this.isVideoContiguous = false;
        this.videoTrackConfig = void 0;
        this.observer = observer;
        this.config = config;
        this.typeSupported = typeSupported;
        this.ISGenerated = false;
        if (chromeVersion === null) {
          var userAgent = navigator.userAgent || "";
          var result = userAgent.match(/Chrome\/(\d+)/i);
          chromeVersion = result ? parseInt(result[1]) : 0;
        }
        if (safariWebkitVersion === null) {
          var _result = navigator.userAgent.match(/Safari\/(\d+)/i);
          safariWebkitVersion = _result ? parseInt(_result[1]) : 0;
        }
      }
      var _proto = MP4Remuxer2.prototype;
      _proto.destroy = function destroy() {
        this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;
      };
      _proto.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {
        logger.log("[mp4-remuxer]: initPTS & initDTS reset");
        this._initPTS = this._initDTS = defaultTimeStamp;
      };
      _proto.resetNextTimestamp = function resetNextTimestamp() {
        logger.log("[mp4-remuxer]: reset next timestamp");
        this.isVideoContiguous = false;
        this.isAudioContiguous = false;
      };
      _proto.resetInitSegment = function resetInitSegment() {
        logger.log("[mp4-remuxer]: ISGenerated flag reset");
        this.ISGenerated = false;
        this.videoTrackConfig = void 0;
      };
      _proto.getVideoStartPts = function getVideoStartPts(videoSamples) {
        var rolloverDetected = false;
        var startPTS = videoSamples.reduce(function(minPTS, sample) {
          var delta = sample.pts - minPTS;
          if (delta < -4294967296) {
            rolloverDetected = true;
            return normalizePts(minPTS, sample.pts);
          } else if (delta > 0) {
            return minPTS;
          } else {
            return sample.pts;
          }
        }, videoSamples[0].pts);
        if (rolloverDetected) {
          logger.debug("PTS rollover detected");
        }
        return startPTS;
      };
      _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {
        var video;
        var audio;
        var initSegment;
        var text;
        var id3;
        var independent;
        var audioTimeOffset = timeOffset;
        var videoTimeOffset = timeOffset;
        var hasAudio = audioTrack.pid > -1;
        var hasVideo = videoTrack.pid > -1;
        var length = videoTrack.samples.length;
        var enoughAudioSamples = audioTrack.samples.length > 0;
        var enoughVideoSamples = flush && length > 0 || length > 1;
        var canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;
        if (canRemuxAvc) {
          if (this.ISGenerated) {
            var _videoTrack$pixelRati, _config$pixelRatio, _videoTrack$pixelRati2, _config$pixelRatio2;
            var config = this.videoTrackConfig;
            if (config && (videoTrack.width !== config.width || videoTrack.height !== config.height || ((_videoTrack$pixelRati = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati[0]) !== ((_config$pixelRatio = config.pixelRatio) == null ? void 0 : _config$pixelRatio[0]) || ((_videoTrack$pixelRati2 = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati2[1]) !== ((_config$pixelRatio2 = config.pixelRatio) == null ? void 0 : _config$pixelRatio2[1]))) {
              this.resetInitSegment();
            }
          } else {
            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
          }
          var isVideoContiguous = this.isVideoContiguous;
          var firstKeyFrameIndex = -1;
          var firstKeyFramePTS;
          if (enoughVideoSamples) {
            firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);
            if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {
              independent = true;
              if (firstKeyFrameIndex > 0) {
                logger.warn("[mp4-remuxer]: Dropped " + firstKeyFrameIndex + " out of " + length + " video samples due to a missing keyframe");
                var startPTS = this.getVideoStartPts(videoTrack.samples);
                videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);
                videoTrack.dropped += firstKeyFrameIndex;
                videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;
                firstKeyFramePTS = videoTimeOffset;
              } else if (firstKeyFrameIndex === -1) {
                logger.warn("[mp4-remuxer]: No keyframe found out of " + length + " video samples");
                independent = false;
              }
            }
          }
          if (this.ISGenerated) {
            if (enoughAudioSamples && enoughVideoSamples) {
              var _startPTS = this.getVideoStartPts(videoTrack.samples);
              var tsDelta = normalizePts(audioTrack.samples[0].pts, _startPTS) - _startPTS;
              var audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;
              audioTimeOffset += Math.max(0, audiovideoTimestampDelta);
              videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);
            }
            if (enoughAudioSamples) {
              if (!audioTrack.samplerate) {
                logger.warn("[mp4-remuxer]: regenerate InitSegment as audio detected");
                initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
              }
              audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : void 0);
              if (enoughVideoSamples) {
                var audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;
                if (!videoTrack.inputTimeScale) {
                  logger.warn("[mp4-remuxer]: regenerate InitSegment as video detected");
                  initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
                }
                video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);
              }
            } else if (enoughVideoSamples) {
              video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);
            }
            if (video) {
              video.firstKeyFrame = firstKeyFrameIndex;
              video.independent = firstKeyFrameIndex !== -1;
              video.firstKeyFramePTS = firstKeyFramePTS;
            }
          }
        }
        if (this.ISGenerated && this._initPTS && this._initDTS) {
          if (id3Track.samples.length) {
            id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);
          }
          if (textTrack.samples.length) {
            text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);
          }
        }
        return {
          audio,
          video,
          initSegment,
          independent,
          text,
          id3
        };
      };
      _proto.generateIS = function generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {
        var audioSamples = audioTrack.samples;
        var videoSamples = videoTrack.samples;
        var typeSupported = this.typeSupported;
        var tracks = {};
        var _initPTS = this._initPTS;
        var computePTSDTS = !_initPTS || accurateTimeOffset;
        var container = "audio/mp4";
        var initPTS;
        var initDTS;
        var timescale;
        if (computePTSDTS) {
          initPTS = initDTS = Infinity;
        }
        if (audioTrack.config && audioSamples.length) {
          audioTrack.timescale = audioTrack.samplerate;
          switch (audioTrack.segmentCodec) {
            case "mp3":
              if (typeSupported.mpeg) {
                container = "audio/mpeg";
                audioTrack.codec = "";
              } else if (typeSupported.mp3) {
                audioTrack.codec = "mp3";
              }
              break;
            case "ac3":
              audioTrack.codec = "ac-3";
              break;
          }
          tracks.audio = {
            id: "audio",
            container,
            codec: audioTrack.codec,
            initSegment: audioTrack.segmentCodec === "mp3" && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),
            metadata: {
              channelCount: audioTrack.channelCount
            }
          };
          if (computePTSDTS) {
            timescale = audioTrack.inputTimeScale;
            if (!_initPTS || timescale !== _initPTS.timescale) {
              initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);
            } else {
              computePTSDTS = false;
            }
          }
        }
        if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
          videoTrack.timescale = videoTrack.inputTimeScale;
          tracks.video = {
            id: "main",
            container: "video/mp4",
            codec: videoTrack.codec,
            initSegment: MP4.initSegment([videoTrack]),
            metadata: {
              width: videoTrack.width,
              height: videoTrack.height
            }
          };
          if (computePTSDTS) {
            timescale = videoTrack.inputTimeScale;
            if (!_initPTS || timescale !== _initPTS.timescale) {
              var startPTS = this.getVideoStartPts(videoSamples);
              var startOffset = Math.round(timescale * timeOffset);
              initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);
              initPTS = Math.min(initPTS, startPTS - startOffset);
            } else {
              computePTSDTS = false;
            }
          }
          this.videoTrackConfig = {
            width: videoTrack.width,
            height: videoTrack.height,
            pixelRatio: videoTrack.pixelRatio
          };
        }
        if (Object.keys(tracks).length) {
          this.ISGenerated = true;
          if (computePTSDTS) {
            this._initPTS = {
              baseTime: initPTS,
              timescale
            };
            this._initDTS = {
              baseTime: initDTS,
              timescale
            };
          } else {
            initPTS = timescale = void 0;
          }
          return {
            tracks,
            initPTS,
            timescale
          };
        }
      };
      _proto.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
        var timeScale = track.inputTimeScale;
        var inputSamples = track.samples;
        var outputSamples = [];
        var nbSamples = inputSamples.length;
        var initPTS = this._initPTS;
        var nextAvcDts = this.nextAvcDts;
        var offset = 8;
        var mp4SampleDuration = this.videoSampleDuration;
        var firstDTS;
        var lastDTS;
        var minPTS = Number.POSITIVE_INFINITY;
        var maxPTS = Number.NEGATIVE_INFINITY;
        var sortSamples = false;
        if (!contiguous || nextAvcDts === null) {
          var pts = timeOffset * timeScale;
          var cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);
          if (chromeVersion && nextAvcDts !== null && Math.abs(pts - cts - nextAvcDts) < 15e3) {
            contiguous = true;
          } else {
            nextAvcDts = pts - cts;
          }
        }
        var initTime = initPTS.baseTime * timeScale / initPTS.timescale;
        for (var i = 0; i < nbSamples; i++) {
          var sample = inputSamples[i];
          sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);
          sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);
          if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {
            sortSamples = true;
          }
        }
        if (sortSamples) {
          inputSamples.sort(function(a, b) {
            var deltadts = a.dts - b.dts;
            var deltapts = a.pts - b.pts;
            return deltadts || deltapts;
          });
        }
        firstDTS = inputSamples[0].dts;
        lastDTS = inputSamples[inputSamples.length - 1].dts;
        var inputDuration = lastDTS - firstDTS;
        var averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;
        if (contiguous) {
          var delta = firstDTS - nextAvcDts;
          var foundHole = delta > averageSampleDuration;
          var foundOverlap = delta < -1;
          if (foundHole || foundOverlap) {
            if (foundHole) {
              logger.warn("AVC: " + toMsFromMpegTsClock(delta, true) + " ms (" + delta + "dts) hole between fragments detected at " + timeOffset.toFixed(3));
            } else {
              logger.warn("AVC: " + toMsFromMpegTsClock(-delta, true) + " ms (" + delta + "dts) overlapping between fragments detected at " + timeOffset.toFixed(3));
            }
            if (!foundOverlap || nextAvcDts >= inputSamples[0].pts || chromeVersion) {
              firstDTS = nextAvcDts;
              var firstPTS = inputSamples[0].pts - delta;
              if (foundHole) {
                inputSamples[0].dts = firstDTS;
                inputSamples[0].pts = firstPTS;
              } else {
                for (var _i = 0; _i < inputSamples.length; _i++) {
                  if (inputSamples[_i].dts > firstPTS) {
                    break;
                  }
                  inputSamples[_i].dts -= delta;
                  inputSamples[_i].pts -= delta;
                }
              }
              logger.log("Video: Initial PTS/DTS adjusted: " + toMsFromMpegTsClock(firstPTS, true) + "/" + toMsFromMpegTsClock(firstDTS, true) + ", delta: " + toMsFromMpegTsClock(delta, true) + " ms");
            }
          }
        }
        firstDTS = Math.max(0, firstDTS);
        var nbNalu = 0;
        var naluLen = 0;
        var dtsStep = firstDTS;
        for (var _i2 = 0; _i2 < nbSamples; _i2++) {
          var _sample = inputSamples[_i2];
          var units = _sample.units;
          var nbUnits = units.length;
          var sampleLen = 0;
          for (var j = 0; j < nbUnits; j++) {
            sampleLen += units[j].data.length;
          }
          naluLen += sampleLen;
          nbNalu += nbUnits;
          _sample.length = sampleLen;
          if (_sample.dts < dtsStep) {
            _sample.dts = dtsStep;
            dtsStep += averageSampleDuration / 4 | 0 || 1;
          } else {
            dtsStep = _sample.dts;
          }
          minPTS = Math.min(_sample.pts, minPTS);
          maxPTS = Math.max(_sample.pts, maxPTS);
        }
        lastDTS = inputSamples[nbSamples - 1].dts;
        var mdatSize = naluLen + 4 * nbNalu + 8;
        var mdat;
        try {
          mdat = new Uint8Array(mdatSize);
        } catch (err) {
          this.observer.emit(Events.ERROR, Events.ERROR, {
            type: ErrorTypes.MUX_ERROR,
            details: ErrorDetails.REMUX_ALLOC_ERROR,
            fatal: false,
            error: err,
            bytes: mdatSize,
            reason: "fail allocating video mdat " + mdatSize
          });
          return;
        }
        var view = new DataView(mdat.buffer);
        view.setUint32(0, mdatSize);
        mdat.set(MP4.types.mdat, 4);
        var stretchedLastFrame = false;
        var minDtsDelta = Number.POSITIVE_INFINITY;
        var minPtsDelta = Number.POSITIVE_INFINITY;
        var maxDtsDelta = Number.NEGATIVE_INFINITY;
        var maxPtsDelta = Number.NEGATIVE_INFINITY;
        for (var _i3 = 0; _i3 < nbSamples; _i3++) {
          var _VideoSample = inputSamples[_i3];
          var VideoSampleUnits = _VideoSample.units;
          var mp4SampleLength = 0;
          for (var _j = 0, _nbUnits = VideoSampleUnits.length; _j < _nbUnits; _j++) {
            var unit = VideoSampleUnits[_j];
            var unitData = unit.data;
            var unitDataLen = unit.data.byteLength;
            view.setUint32(offset, unitDataLen);
            offset += 4;
            mdat.set(unitData, offset);
            offset += unitDataLen;
            mp4SampleLength += 4 + unitDataLen;
          }
          var ptsDelta = void 0;
          if (_i3 < nbSamples - 1) {
            mp4SampleDuration = inputSamples[_i3 + 1].dts - _VideoSample.dts;
            ptsDelta = inputSamples[_i3 + 1].pts - _VideoSample.pts;
          } else {
            var config = this.config;
            var lastFrameDuration = _i3 > 0 ? _VideoSample.dts - inputSamples[_i3 - 1].dts : averageSampleDuration;
            ptsDelta = _i3 > 0 ? _VideoSample.pts - inputSamples[_i3 - 1].pts : averageSampleDuration;
            if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {
              var gapTolerance = Math.floor(config.maxBufferHole * timeScale);
              var deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - _VideoSample.pts;
              if (deltaToFrameEnd > gapTolerance) {
                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                if (mp4SampleDuration < 0) {
                  mp4SampleDuration = lastFrameDuration;
                } else {
                  stretchedLastFrame = true;
                }
                logger.log("[mp4-remuxer]: It is approximately " + deltaToFrameEnd / 90 + " ms to the next segment; using duration " + mp4SampleDuration / 90 + " ms for the last video frame.");
              } else {
                mp4SampleDuration = lastFrameDuration;
              }
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          }
          var compositionTimeOffset = Math.round(_VideoSample.pts - _VideoSample.dts);
          minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);
          maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);
          minPtsDelta = Math.min(minPtsDelta, ptsDelta);
          maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);
          outputSamples.push(new Mp4Sample(_VideoSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));
        }
        if (outputSamples.length) {
          if (chromeVersion) {
            if (chromeVersion < 70) {
              var flags = outputSamples[0].flags;
              flags.dependsOn = 2;
              flags.isNonSync = 0;
            }
          } else if (safariWebkitVersion) {
            if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {
              logger.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
              var dts = firstDTS;
              for (var _i4 = 0, len = outputSamples.length; _i4 < len; _i4++) {
                var nextDts = dts + outputSamples[_i4].duration;
                var _pts = dts + outputSamples[_i4].cts;
                if (_i4 < len - 1) {
                  var nextPts = nextDts + outputSamples[_i4 + 1].cts;
                  outputSamples[_i4].duration = nextPts - _pts;
                } else {
                  outputSamples[_i4].duration = _i4 ? outputSamples[_i4 - 1].duration : averageSampleDuration;
                }
                outputSamples[_i4].cts = 0;
                dts = nextDts;
              }
            }
          }
        }
        mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;
        this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;
        this.videoSampleDuration = mp4SampleDuration;
        this.isVideoContiguous = true;
        var moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends({}, track, {
          samples: outputSamples
        }));
        var type = "video";
        var data = {
          data1: moof,
          data2: mdat,
          startPTS: minPTS / timeScale,
          endPTS: (maxPTS + mp4SampleDuration) / timeScale,
          startDTS: firstDTS / timeScale,
          endDTS: nextAvcDts / timeScale,
          type,
          hasAudio: false,
          hasVideo: true,
          nb: outputSamples.length,
          dropped: track.dropped
        };
        track.samples = [];
        track.dropped = 0;
        return data;
      };
      _proto.getSamplesPerFrame = function getSamplesPerFrame(track) {
        switch (track.segmentCodec) {
          case "mp3":
            return MPEG_AUDIO_SAMPLE_PER_FRAME;
          case "ac3":
            return AC3_SAMPLES_PER_FRAME;
          default:
            return AAC_SAMPLES_PER_FRAME;
        }
      };
      _proto.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {
        var inputTimeScale = track.inputTimeScale;
        var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
        var scaleFactor = inputTimeScale / mp4timeScale;
        var mp4SampleDuration = this.getSamplesPerFrame(track);
        var inputSampleDuration = mp4SampleDuration * scaleFactor;
        var initPTS = this._initPTS;
        var rawMPEG = track.segmentCodec === "mp3" && this.typeSupported.mpeg;
        var outputSamples = [];
        var alignedWithVideo = videoTimeOffset !== void 0;
        var inputSamples = track.samples;
        var offset = rawMPEG ? 0 : 8;
        var nextAudioPts = this.nextAudioPts || -1;
        var timeOffsetMpegTS = timeOffset * inputTimeScale;
        var initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;
        this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9e3 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);
        inputSamples.forEach(function(sample2) {
          sample2.pts = normalizePts(sample2.pts - initTime, timeOffsetMpegTS);
        });
        if (!contiguous || nextAudioPts < 0) {
          inputSamples = inputSamples.filter(function(sample2) {
            return sample2.pts >= 0;
          });
          if (!inputSamples.length) {
            return;
          }
          if (videoTimeOffset === 0) {
            nextAudioPts = 0;
          } else if (accurateTimeOffset && !alignedWithVideo) {
            nextAudioPts = Math.max(0, timeOffsetMpegTS);
          } else {
            nextAudioPts = inputSamples[0].pts;
          }
        }
        if (track.segmentCodec === "aac") {
          var maxAudioFramesDrift = this.config.maxAudioFramesDrift;
          for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {
            var sample = inputSamples[i];
            var pts = sample.pts;
            var delta = pts - nextPts;
            var duration = Math.abs(1e3 * delta / inputTimeScale);
            if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {
              if (i === 0) {
                logger.warn("Audio frame @ " + (pts / inputTimeScale).toFixed(3) + "s overlaps nextAudioPts by " + Math.round(1e3 * delta / inputTimeScale) + " ms.");
                this.nextAudioPts = nextAudioPts = nextPts = pts;
              }
            } else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {
              var missing = Math.round(delta / inputSampleDuration);
              nextPts = pts - missing * inputSampleDuration;
              if (nextPts < 0) {
                missing--;
                nextPts += inputSampleDuration;
              }
              if (i === 0) {
                this.nextAudioPts = nextAudioPts = nextPts;
              }
              logger.warn("[mp4-remuxer]: Injecting " + missing + " audio frame @ " + (nextPts / inputTimeScale).toFixed(3) + "s due to " + Math.round(1e3 * delta / inputTimeScale) + " ms gap.");
              for (var j = 0; j < missing; j++) {
                var newStamp = Math.max(nextPts, 0);
                var fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                if (!fillFrame) {
                  logger.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.");
                  fillFrame = sample.unit.subarray();
                }
                inputSamples.splice(i, 0, {
                  unit: fillFrame,
                  pts: newStamp
                });
                nextPts += inputSampleDuration;
                i++;
              }
            }
            sample.pts = nextPts;
            nextPts += inputSampleDuration;
          }
        }
        var firstPTS = null;
        var lastPTS = null;
        var mdat;
        var mdatSize = 0;
        var sampleLength = inputSamples.length;
        while (sampleLength--) {
          mdatSize += inputSamples[sampleLength].unit.byteLength;
        }
        for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
          var audioSample = inputSamples[_j2];
          var unit = audioSample.unit;
          var _pts2 = audioSample.pts;
          if (lastPTS !== null) {
            var prevSample = outputSamples[_j2 - 1];
            prevSample.duration = Math.round((_pts2 - lastPTS) / scaleFactor);
          } else {
            if (contiguous && track.segmentCodec === "aac") {
              _pts2 = nextAudioPts;
            }
            firstPTS = _pts2;
            if (mdatSize > 0) {
              mdatSize += offset;
              try {
                mdat = new Uint8Array(mdatSize);
              } catch (err) {
                this.observer.emit(Events.ERROR, Events.ERROR, {
                  type: ErrorTypes.MUX_ERROR,
                  details: ErrorDetails.REMUX_ALLOC_ERROR,
                  fatal: false,
                  error: err,
                  bytes: mdatSize,
                  reason: "fail allocating audio mdat " + mdatSize
                });
                return;
              }
              if (!rawMPEG) {
                var view = new DataView(mdat.buffer);
                view.setUint32(0, mdatSize);
                mdat.set(MP4.types.mdat, 4);
              }
            } else {
              return;
            }
          }
          mdat.set(unit, offset);
          var unitLen = unit.byteLength;
          offset += unitLen;
          outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));
          lastPTS = _pts2;
        }
        var nbSamples = outputSamples.length;
        if (!nbSamples) {
          return;
        }
        var lastSample = outputSamples[outputSamples.length - 1];
        this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;
        var moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {
          samples: outputSamples
        }));
        track.samples = [];
        var start = firstPTS / inputTimeScale;
        var end = nextAudioPts / inputTimeScale;
        var type = "audio";
        var audioData = {
          data1: moof,
          data2: mdat,
          startPTS: start,
          endPTS: end,
          startDTS: start,
          endDTS: end,
          type,
          hasAudio: true,
          hasVideo: false,
          nb: nbSamples
        };
        this.isAudioContiguous = true;
        return audioData;
      };
      _proto.remuxEmptyAudio = function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
        var inputTimeScale = track.inputTimeScale;
        var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
        var scaleFactor = inputTimeScale / mp4timeScale;
        var nextAudioPts = this.nextAudioPts;
        var initDTS = this._initDTS;
        var init90kHz = initDTS.baseTime * 9e4 / initDTS.timescale;
        var startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + init90kHz;
        var endDTS = videoData.endDTS * inputTimeScale + init90kHz;
        var frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;
        var nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);
        var silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
        logger.warn("[mp4-remuxer]: remux empty Audio");
        if (!silentFrame) {
          logger.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
          return;
        }
        var samples = [];
        for (var i = 0; i < nbSamples; i++) {
          var stamp = startDTS + i * frameDuration;
          samples.push({
            unit: silentFrame,
            pts: stamp,
            dts: stamp
          });
        }
        track.samples = samples;
        return this.remuxAudio(track, timeOffset, contiguous, false);
      };
      return MP4Remuxer2;
    }();
    function normalizePts(value, reference) {
      var offset;
      if (reference === null) {
        return value;
      }
      if (reference < value) {
        offset = -8589934592;
      } else {
        offset = 8589934592;
      }
      while (Math.abs(value - reference) > 4294967296) {
        value += offset;
      }
      return value;
    }
    function findKeyframeIndex(samples) {
      for (var i = 0; i < samples.length; i++) {
        if (samples[i].key) {
          return i;
        }
      }
      return -1;
    }
    function flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {
      var length = track.samples.length;
      if (!length) {
        return;
      }
      var inputTimeScale = track.inputTimeScale;
      for (var index = 0; index < length; index++) {
        var sample = track.samples[index];
        sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
        sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
      }
      var samples = track.samples;
      track.samples = [];
      return {
        samples
      };
    }
    function flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {
      var length = track.samples.length;
      if (!length) {
        return;
      }
      var inputTimeScale = track.inputTimeScale;
      for (var index = 0; index < length; index++) {
        var sample = track.samples[index];
        sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
      }
      track.samples.sort(function(a, b) {
        return a.pts - b.pts;
      });
      var samples = track.samples;
      track.samples = [];
      return {
        samples
      };
    }
    var Mp4Sample = function Mp4Sample2(isKeyframe, duration, size, cts) {
      this.size = void 0;
      this.duration = void 0;
      this.cts = void 0;
      this.flags = void 0;
      this.duration = duration;
      this.size = size;
      this.cts = cts;
      this.flags = {
        isLeading: 0,
        isDependedOn: 0,
        hasRedundancy: 0,
        degradPrio: 0,
        dependsOn: isKeyframe ? 2 : 1,
        isNonSync: isKeyframe ? 0 : 1
      };
    };
    var PassThroughRemuxer = /* @__PURE__ */ function() {
      function PassThroughRemuxer2() {
        this.emitInitSegment = false;
        this.audioCodec = void 0;
        this.videoCodec = void 0;
        this.initData = void 0;
        this.initPTS = null;
        this.initTracks = void 0;
        this.lastEndTime = null;
      }
      var _proto = PassThroughRemuxer2.prototype;
      _proto.destroy = function destroy() {
      };
      _proto.resetTimeStamp = function resetTimeStamp(defaultInitPTS) {
        this.initPTS = defaultInitPTS;
        this.lastEndTime = null;
      };
      _proto.resetNextTimestamp = function resetNextTimestamp() {
        this.lastEndTime = null;
      };
      _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {
        this.audioCodec = audioCodec;
        this.videoCodec = videoCodec;
        this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));
        this.emitInitSegment = true;
      };
      _proto.generateInitSegment = function generateInitSegment(initSegment) {
        var audioCodec = this.audioCodec, videoCodec = this.videoCodec;
        if (!(initSegment != null && initSegment.byteLength)) {
          this.initTracks = void 0;
          this.initData = void 0;
          return;
        }
        var initData = this.initData = parseInitSegment(initSegment);
        if (initData.audio) {
          audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);
        }
        if (initData.video) {
          videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);
        }
        var tracks = {};
        if (initData.audio && initData.video) {
          tracks.audiovideo = {
            container: "video/mp4",
            codec: audioCodec + "," + videoCodec,
            initSegment,
            id: "main"
          };
        } else if (initData.audio) {
          tracks.audio = {
            container: "audio/mp4",
            codec: audioCodec,
            initSegment,
            id: "audio"
          };
        } else if (initData.video) {
          tracks.video = {
            container: "video/mp4",
            codec: videoCodec,
            initSegment,
            id: "main"
          };
        } else {
          logger.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.");
        }
        this.initTracks = tracks;
      };
      _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {
        var _initData, _initData2;
        var initPTS = this.initPTS, lastEndTime = this.lastEndTime;
        var result = {
          audio: void 0,
          video: void 0,
          text: textTrack,
          id3: id3Track,
          initSegment: void 0
        };
        if (!isFiniteNumber(lastEndTime)) {
          lastEndTime = this.lastEndTime = timeOffset || 0;
        }
        var data = videoTrack.samples;
        if (!(data != null && data.length)) {
          return result;
        }
        var initSegment = {
          initPTS: void 0,
          timescale: 1
        };
        var initData = this.initData;
        if (!((_initData = initData) != null && _initData.length)) {
          this.generateInitSegment(data);
          initData = this.initData;
        }
        if (!((_initData2 = initData) != null && _initData2.length)) {
          logger.warn("[passthrough-remuxer.ts]: Failed to generate initSegment.");
          return result;
        }
        if (this.emitInitSegment) {
          initSegment.tracks = this.initTracks;
          this.emitInitSegment = false;
        }
        var duration = getDuration(data, initData);
        var startDTS = getStartDTS(initData, data);
        var decodeTime = startDTS === null ? timeOffset : startDTS;
        if (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale && accurateTimeOffset) {
          initSegment.initPTS = decodeTime - timeOffset;
          if (initPTS && initPTS.timescale === 1) {
            logger.warn("Adjusting initPTS by " + (initSegment.initPTS - initPTS.baseTime));
          }
          this.initPTS = initPTS = {
            baseTime: initSegment.initPTS,
            timescale: 1
          };
        }
        var startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;
        var endTime = startTime + duration;
        offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);
        if (duration > 0) {
          this.lastEndTime = endTime;
        } else {
          logger.warn("Duration parsed from mp4 should be greater than zero");
          this.resetNextTimestamp();
        }
        var hasAudio = !!initData.audio;
        var hasVideo = !!initData.video;
        var type = "";
        if (hasAudio) {
          type += "audio";
        }
        if (hasVideo) {
          type += "video";
        }
        var track = {
          data1: data,
          startPTS: startTime,
          startDTS: startTime,
          endPTS: endTime,
          endDTS: endTime,
          type,
          hasAudio,
          hasVideo,
          nb: 1,
          dropped: 0
        };
        result.audio = track.type === "audio" ? track : void 0;
        result.video = track.type !== "audio" ? track : void 0;
        result.initSegment = initSegment;
        result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);
        if (textTrack.samples.length) {
          result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);
        }
        return result;
      };
      return PassThroughRemuxer2;
    }();
    function isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {
      if (initPTS === null) {
        return true;
      }
      var minDuration = Math.max(duration, 1);
      var startTime = startDTS - initPTS.baseTime / initPTS.timescale;
      return Math.abs(startTime - timeOffset) > minDuration;
    }
    function getParsedTrackCodec(track, type) {
      var parsedCodec = track == null ? void 0 : track.codec;
      if (parsedCodec && parsedCodec.length > 4) {
        return parsedCodec;
      }
      if (type === ElementaryStreamTypes.AUDIO) {
        if (parsedCodec === "ec-3" || parsedCodec === "ac-3" || parsedCodec === "alac") {
          return parsedCodec;
        }
        if (parsedCodec === "fLaC" || parsedCodec === "Opus") {
          var preferManagedMediaSource = false;
          return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);
        }
        var result = "mp4a.40.5";
        logger.info('Parsed audio codec "' + parsedCodec + '" or audio object type not handled. Using "' + result + '"');
        return result;
      }
      logger.warn('Unhandled video codec "' + parsedCodec + '"');
      if (parsedCodec === "hvc1" || parsedCodec === "hev1") {
        return "hvc1.1.6.L120.90";
      }
      if (parsedCodec === "av01") {
        return "av01.0.04M.08";
      }
      return "avc1.42e01e";
    }
    var now;
    try {
      now = self.performance.now.bind(self.performance);
    } catch (err) {
      logger.debug("Unable to use Performance API on this environment");
      now = optionalSelf == null ? void 0 : optionalSelf.Date.now;
    }
    var muxConfig = [{
      demux: MP4Demuxer,
      remux: PassThroughRemuxer
    }, {
      demux: TSDemuxer,
      remux: MP4Remuxer
    }, {
      demux: AACDemuxer,
      remux: MP4Remuxer
    }, {
      demux: MP3Demuxer,
      remux: MP4Remuxer
    }];
    {
      muxConfig.splice(2, 0, {
        demux: AC3Demuxer,
        remux: MP4Remuxer
      });
    }
    var Transmuxer = /* @__PURE__ */ function() {
      function Transmuxer2(observer, typeSupported, config, vendor, id) {
        this.async = false;
        this.observer = void 0;
        this.typeSupported = void 0;
        this.config = void 0;
        this.vendor = void 0;
        this.id = void 0;
        this.demuxer = void 0;
        this.remuxer = void 0;
        this.decrypter = void 0;
        this.probe = void 0;
        this.decryptionPromise = null;
        this.transmuxConfig = void 0;
        this.currentTransmuxState = void 0;
        this.observer = observer;
        this.typeSupported = typeSupported;
        this.config = config;
        this.vendor = vendor;
        this.id = id;
      }
      var _proto = Transmuxer2.prototype;
      _proto.configure = function configure(transmuxConfig) {
        this.transmuxConfig = transmuxConfig;
        if (this.decrypter) {
          this.decrypter.reset();
        }
      };
      _proto.push = function push2(data, decryptdata, chunkMeta, state) {
        var _this = this;
        var stats = chunkMeta.transmuxing;
        stats.executeStart = now();
        var uintData = new Uint8Array(data);
        var currentTransmuxState = this.currentTransmuxState, transmuxConfig = this.transmuxConfig;
        if (state) {
          this.currentTransmuxState = state;
        }
        var _ref = state || currentTransmuxState, contiguous = _ref.contiguous, discontinuity = _ref.discontinuity, trackSwitch = _ref.trackSwitch, accurateTimeOffset = _ref.accurateTimeOffset, timeOffset = _ref.timeOffset, initSegmentChange = _ref.initSegmentChange;
        var audioCodec = transmuxConfig.audioCodec, videoCodec = transmuxConfig.videoCodec, defaultInitPts = transmuxConfig.defaultInitPts, duration = transmuxConfig.duration, initSegmentData = transmuxConfig.initSegmentData;
        var keyData = getEncryptionType(uintData, decryptdata);
        if (keyData && keyData.method === "AES-128") {
          var decrypter = this.getDecrypter();
          if (decrypter.isSync()) {
            var decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);
            var loadingParts = chunkMeta.part > -1;
            if (loadingParts) {
              decryptedData = decrypter.flush();
            }
            if (!decryptedData) {
              stats.executeEnd = now();
              return emptyResult(chunkMeta);
            }
            uintData = new Uint8Array(decryptedData);
          } else {
            this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then(function(decryptedData2) {
              var result2 = _this.push(decryptedData2, null, chunkMeta);
              _this.decryptionPromise = null;
              return result2;
            });
            return this.decryptionPromise;
          }
        }
        var resetMuxers = this.needsProbing(discontinuity, trackSwitch);
        if (resetMuxers) {
          var error = this.configureTransmuxer(uintData);
          if (error) {
            logger.warn("[transmuxer] " + error.message);
            this.observer.emit(Events.ERROR, Events.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.FRAG_PARSING_ERROR,
              fatal: false,
              error,
              reason: error.message
            });
            stats.executeEnd = now();
            return emptyResult(chunkMeta);
          }
        }
        if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {
          this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);
        }
        if (discontinuity || initSegmentChange || resetMuxers) {
          this.resetInitialTimestamp(defaultInitPts);
        }
        if (!contiguous) {
          this.resetContiguity();
        }
        var result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);
        var currentState = this.currentTransmuxState;
        currentState.contiguous = true;
        currentState.discontinuity = false;
        currentState.trackSwitch = false;
        stats.executeEnd = now();
        return result;
      };
      _proto.flush = function flush(chunkMeta) {
        var _this2 = this;
        var stats = chunkMeta.transmuxing;
        stats.executeStart = now();
        var decrypter = this.decrypter, currentTransmuxState = this.currentTransmuxState, decryptionPromise = this.decryptionPromise;
        if (decryptionPromise) {
          return decryptionPromise.then(function() {
            return _this2.flush(chunkMeta);
          });
        }
        var transmuxResults = [];
        var timeOffset = currentTransmuxState.timeOffset;
        if (decrypter) {
          var decryptedData = decrypter.flush();
          if (decryptedData) {
            transmuxResults.push(this.push(decryptedData, null, chunkMeta));
          }
        }
        var demuxer = this.demuxer, remuxer = this.remuxer;
        if (!demuxer || !remuxer) {
          stats.executeEnd = now();
          return [emptyResult(chunkMeta)];
        }
        var demuxResultOrPromise = demuxer.flush(timeOffset);
        if (isPromise(demuxResultOrPromise)) {
          return demuxResultOrPromise.then(function(demuxResult) {
            _this2.flushRemux(transmuxResults, demuxResult, chunkMeta);
            return transmuxResults;
          });
        }
        this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);
        return transmuxResults;
      };
      _proto.flushRemux = function flushRemux(transmuxResults, demuxResult, chunkMeta) {
        var audioTrack = demuxResult.audioTrack, videoTrack = demuxResult.videoTrack, id3Track = demuxResult.id3Track, textTrack = demuxResult.textTrack;
        var _this$currentTransmux = this.currentTransmuxState, accurateTimeOffset = _this$currentTransmux.accurateTimeOffset, timeOffset = _this$currentTransmux.timeOffset;
        logger.log("[transmuxer.ts]: Flushed fragment " + chunkMeta.sn + (chunkMeta.part > -1 ? " p: " + chunkMeta.part : "") + " of level " + chunkMeta.level);
        var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);
        transmuxResults.push({
          remuxResult,
          chunkMeta
        });
        chunkMeta.transmuxing.executeEnd = now();
      };
      _proto.resetInitialTimestamp = function resetInitialTimestamp(defaultInitPts) {
        var demuxer = this.demuxer, remuxer = this.remuxer;
        if (!demuxer || !remuxer) {
          return;
        }
        demuxer.resetTimeStamp(defaultInitPts);
        remuxer.resetTimeStamp(defaultInitPts);
      };
      _proto.resetContiguity = function resetContiguity() {
        var demuxer = this.demuxer, remuxer = this.remuxer;
        if (!demuxer || !remuxer) {
          return;
        }
        demuxer.resetContiguity();
        remuxer.resetNextTimestamp();
      };
      _proto.resetInitSegment = function resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {
        var demuxer = this.demuxer, remuxer = this.remuxer;
        if (!demuxer || !remuxer) {
          return;
        }
        demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);
        remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);
      };
      _proto.destroy = function destroy() {
        if (this.demuxer) {
          this.demuxer.destroy();
          this.demuxer = void 0;
        }
        if (this.remuxer) {
          this.remuxer.destroy();
          this.remuxer = void 0;
        }
      };
      _proto.transmux = function transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {
        var result;
        if (keyData && keyData.method === "SAMPLE-AES") {
          result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);
        } else {
          result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);
        }
        return result;
      };
      _proto.transmuxUnencrypted = function transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {
        var _demux = this.demuxer.demux(data, timeOffset, false, !this.config.progressive), audioTrack = _demux.audioTrack, videoTrack = _demux.videoTrack, id3Track = _demux.id3Track, textTrack = _demux.textTrack;
        var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);
        return {
          remuxResult,
          chunkMeta
        };
      };
      _proto.transmuxSampleAes = function transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {
        var _this3 = this;
        return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(function(demuxResult) {
          var remuxResult = _this3.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, _this3.id);
          return {
            remuxResult,
            chunkMeta
          };
        });
      };
      _proto.configureTransmuxer = function configureTransmuxer(data) {
        var config = this.config, observer = this.observer, typeSupported = this.typeSupported, vendor = this.vendor;
        var mux;
        for (var i = 0, len = muxConfig.length; i < len; i++) {
          var _muxConfig$i$demux;
          if ((_muxConfig$i$demux = muxConfig[i].demux) != null && _muxConfig$i$demux.probe(data)) {
            mux = muxConfig[i];
            break;
          }
        }
        if (!mux) {
          return new Error("Failed to find demuxer by probing fragment data");
        }
        var demuxer = this.demuxer;
        var remuxer = this.remuxer;
        var Remuxer = mux.remux;
        var Demuxer = mux.demux;
        if (!remuxer || !(remuxer instanceof Remuxer)) {
          this.remuxer = new Remuxer(observer, config, typeSupported, vendor);
        }
        if (!demuxer || !(demuxer instanceof Demuxer)) {
          this.demuxer = new Demuxer(observer, config, typeSupported);
          this.probe = Demuxer.probe;
        }
      };
      _proto.needsProbing = function needsProbing(discontinuity, trackSwitch) {
        return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;
      };
      _proto.getDecrypter = function getDecrypter() {
        var decrypter = this.decrypter;
        if (!decrypter) {
          decrypter = this.decrypter = new Decrypter(this.config);
        }
        return decrypter;
      };
      return Transmuxer2;
    }();
    function getEncryptionType(data, decryptData) {
      var encryptionType = null;
      if (data.byteLength > 0 && (decryptData == null ? void 0 : decryptData.key) != null && decryptData.iv !== null && decryptData.method != null) {
        encryptionType = decryptData;
      }
      return encryptionType;
    }
    var emptyResult = function emptyResult2(chunkMeta) {
      return {
        remuxResult: {},
        chunkMeta
      };
    };
    function isPromise(p) {
      return "then" in p && p.then instanceof Function;
    }
    var TransmuxConfig = function TransmuxConfig2(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {
      this.audioCodec = void 0;
      this.videoCodec = void 0;
      this.initSegmentData = void 0;
      this.duration = void 0;
      this.defaultInitPts = void 0;
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this.initSegmentData = initSegmentData;
      this.duration = duration;
      this.defaultInitPts = defaultInitPts || null;
    };
    var TransmuxState = function TransmuxState2(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {
      this.discontinuity = void 0;
      this.contiguous = void 0;
      this.accurateTimeOffset = void 0;
      this.trackSwitch = void 0;
      this.timeOffset = void 0;
      this.initSegmentChange = void 0;
      this.discontinuity = discontinuity;
      this.contiguous = contiguous;
      this.accurateTimeOffset = accurateTimeOffset;
      this.trackSwitch = trackSwitch;
      this.timeOffset = timeOffset;
      this.initSegmentChange = initSegmentChange;
    };
    var eventemitter3 = { exports: {} };
    (function(module2) {
      var has = Object.prototype.hasOwnProperty, prefix = "~";
      function Events2() {
      }
      if (Object.create) {
        Events2.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events2().__proto__)
          prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events2();
        else
          delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events2();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once)
              this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events2();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      {
        module2.exports = EventEmitter2;
      }
    })(eventemitter3);
    var eventemitter3Exports = eventemitter3.exports;
    var EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
    if (typeof __IN_WORKER__ !== "undefined" && __IN_WORKER__) {
      startWorker(self);
    }
    function startWorker(self2) {
      var observer = new EventEmitter();
      var forwardMessage = function forwardMessage2(ev, data) {
        self2.postMessage({
          event: ev,
          data
        });
      };
      observer.on(Events.FRAG_DECRYPTED, forwardMessage);
      observer.on(Events.ERROR, forwardMessage);
      var forwardWorkerLogs = function forwardWorkerLogs2() {
        var _loop = function _loop2(logFn2) {
          var func = function func2(message) {
            forwardMessage("workerLog", {
              logType: logFn2,
              message
            });
          };
          logger[logFn2] = func;
        };
        for (var logFn in logger) {
          _loop(logFn);
        }
      };
      self2.addEventListener("message", function(ev) {
        var data = ev.data;
        switch (data.cmd) {
          case "init": {
            var config = JSON.parse(data.config);
            self2.transmuxer = new Transmuxer(observer, data.typeSupported, config, data.vendor, data.id);
            enableLogs(config.debug, data.id);
            forwardWorkerLogs();
            forwardMessage("init", null);
            break;
          }
          case "configure": {
            self2.transmuxer.configure(data.config);
            break;
          }
          case "demux": {
            var transmuxResult = self2.transmuxer.push(data.data, data.decryptdata, data.chunkMeta, data.state);
            if (isPromise(transmuxResult)) {
              self2.transmuxer.async = true;
              transmuxResult.then(function(data2) {
                emitTransmuxComplete(self2, data2);
              }).catch(function(error) {
                forwardMessage(Events.ERROR, {
                  type: ErrorTypes.MEDIA_ERROR,
                  details: ErrorDetails.FRAG_PARSING_ERROR,
                  chunkMeta: data.chunkMeta,
                  fatal: false,
                  error,
                  err: error,
                  reason: "transmuxer-worker push error"
                });
              });
            } else {
              self2.transmuxer.async = false;
              emitTransmuxComplete(self2, transmuxResult);
            }
            break;
          }
          case "flush": {
            var id = data.chunkMeta;
            var _transmuxResult = self2.transmuxer.flush(id);
            var asyncFlush = isPromise(_transmuxResult);
            if (asyncFlush || self2.transmuxer.async) {
              if (!isPromise(_transmuxResult)) {
                _transmuxResult = Promise.resolve(_transmuxResult);
              }
              _transmuxResult.then(function(results) {
                handleFlushResult(self2, results, id);
              }).catch(function(error) {
                forwardMessage(Events.ERROR, {
                  type: ErrorTypes.MEDIA_ERROR,
                  details: ErrorDetails.FRAG_PARSING_ERROR,
                  chunkMeta: data.chunkMeta,
                  fatal: false,
                  error,
                  err: error,
                  reason: "transmuxer-worker flush error"
                });
              });
            } else {
              handleFlushResult(self2, _transmuxResult, id);
            }
            break;
          }
        }
      });
    }
    function emitTransmuxComplete(self2, transmuxResult) {
      if (isEmptyResult(transmuxResult.remuxResult)) {
        return false;
      }
      var transferable = [];
      var _transmuxResult$remux = transmuxResult.remuxResult, audio = _transmuxResult$remux.audio, video = _transmuxResult$remux.video;
      if (audio) {
        addToTransferable(transferable, audio);
      }
      if (video) {
        addToTransferable(transferable, video);
      }
      self2.postMessage({
        event: "transmuxComplete",
        data: transmuxResult
      }, transferable);
      return true;
    }
    function addToTransferable(transferable, track) {
      if (track.data1) {
        transferable.push(track.data1.buffer);
      }
      if (track.data2) {
        transferable.push(track.data2.buffer);
      }
    }
    function handleFlushResult(self2, results, chunkMeta) {
      var parsed = results.reduce(function(parsed2, result) {
        return emitTransmuxComplete(self2, result) || parsed2;
      }, false);
      if (!parsed) {
        self2.postMessage({
          event: "transmuxComplete",
          data: results[0]
        });
      }
      self2.postMessage({
        event: "flush",
        data: chunkMeta
      });
    }
    function isEmptyResult(remuxResult) {
      return !remuxResult.audio && !remuxResult.video && !remuxResult.text && !remuxResult.id3 && !remuxResult.initSegment;
    }
    function hasUMDWorker() {
      return typeof __HLS_WORKER_BUNDLE__ === "function";
    }
    function injectWorker() {
      var blob = new self.Blob(["var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(" + __HLS_WORKER_BUNDLE__.toString() + ")(true);"], {
        type: "text/javascript"
      });
      var objectURL = self.URL.createObjectURL(blob);
      var worker = new self.Worker(objectURL);
      return {
        worker,
        objectURL
      };
    }
    function loadWorker(path) {
      var scriptURL = new self.URL(path, self.location.href).href;
      var worker = new self.Worker(scriptURL);
      return {
        worker,
        scriptURL
      };
    }
    var TransmuxerInterface = /* @__PURE__ */ function() {
      function TransmuxerInterface2(hls, id, onTransmuxComplete, onFlush) {
        var _this = this;
        this.error = null;
        this.hls = void 0;
        this.id = void 0;
        this.observer = void 0;
        this.frag = null;
        this.part = null;
        this.useWorker = void 0;
        this.workerContext = null;
        this.onwmsg = void 0;
        this.transmuxer = null;
        this.onTransmuxComplete = void 0;
        this.onFlush = void 0;
        var config = hls.config;
        this.hls = hls;
        this.id = id;
        this.useWorker = !!config.enableWorker;
        this.onTransmuxComplete = onTransmuxComplete;
        this.onFlush = onFlush;
        var forwardMessage = function forwardMessage2(ev, data) {
          data = data || {};
          data.frag = _this.frag;
          data.id = _this.id;
          if (ev === Events.ERROR) {
            _this.error = data.error;
          }
          _this.hls.trigger(ev, data);
        };
        this.observer = new EventEmitter();
        this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);
        this.observer.on(Events.ERROR, forwardMessage);
        var MediaSource2 = getMediaSource(config.preferManagedMediaSource) || {
          isTypeSupported: function isTypeSupported() {
            return false;
          }
        };
        var m2tsTypeSupported = {
          mpeg: MediaSource2.isTypeSupported("audio/mpeg"),
          mp3: MediaSource2.isTypeSupported('audio/mp4; codecs="mp3"'),
          ac3: MediaSource2.isTypeSupported('audio/mp4; codecs="ac-3"')
        };
        var vendor = navigator.vendor;
        if (this.useWorker && typeof Worker !== "undefined") {
          var canCreateWorker = config.workerPath || hasUMDWorker();
          if (canCreateWorker) {
            try {
              if (config.workerPath) {
                logger.log("loading Web Worker " + config.workerPath + ' for "' + id + '"');
                this.workerContext = loadWorker(config.workerPath);
              } else {
                logger.log('injecting Web Worker for "' + id + '"');
                this.workerContext = injectWorker();
              }
              this.onwmsg = function(ev) {
                return _this.onWorkerMessage(ev);
              };
              var worker = this.workerContext.worker;
              worker.addEventListener("message", this.onwmsg);
              worker.onerror = function(event) {
                var error = new Error(event.message + "  (" + event.filename + ":" + event.lineno + ")");
                config.enableWorker = false;
                logger.warn('Error in "' + id + '" Web Worker, fallback to inline');
                _this.hls.trigger(Events.ERROR, {
                  type: ErrorTypes.OTHER_ERROR,
                  details: ErrorDetails.INTERNAL_EXCEPTION,
                  fatal: false,
                  event: "demuxerWorker",
                  error
                });
              };
              worker.postMessage({
                cmd: "init",
                typeSupported: m2tsTypeSupported,
                vendor,
                id,
                config: JSON.stringify(config)
              });
            } catch (err) {
              logger.warn('Error setting up "' + id + '" Web Worker, fallback to inline', err);
              this.resetWorker();
              this.error = null;
              this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, vendor, id);
            }
            return;
          }
        }
        this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, vendor, id);
      }
      var _proto = TransmuxerInterface2.prototype;
      _proto.resetWorker = function resetWorker() {
        if (this.workerContext) {
          var _this$workerContext = this.workerContext, worker = _this$workerContext.worker, objectURL = _this$workerContext.objectURL;
          if (objectURL) {
            self.URL.revokeObjectURL(objectURL);
          }
          worker.removeEventListener("message", this.onwmsg);
          worker.onerror = null;
          worker.terminate();
          this.workerContext = null;
        }
      };
      _proto.destroy = function destroy() {
        if (this.workerContext) {
          this.resetWorker();
          this.onwmsg = void 0;
        } else {
          var transmuxer = this.transmuxer;
          if (transmuxer) {
            transmuxer.destroy();
            this.transmuxer = null;
          }
        }
        var observer = this.observer;
        if (observer) {
          observer.removeAllListeners();
        }
        this.frag = null;
        this.observer = null;
        this.hls = null;
      };
      _proto.push = function push2(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {
        var _frag$initSegment, _lastFrag$initSegment, _this2 = this;
        chunkMeta.transmuxing.start = self.performance.now();
        var transmuxer = this.transmuxer;
        var timeOffset = part ? part.start : frag.start;
        var decryptdata = frag.decryptdata;
        var lastFrag = this.frag;
        var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
        var trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);
        var snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;
        var partDiff = this.part ? chunkMeta.part - this.part.index : -1;
        var progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);
        var contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));
        var now2 = self.performance.now();
        if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {
          frag.stats.parsing.start = now2;
        }
        if (part && (partDiff || !contiguous)) {
          part.stats.parsing.start = now2;
        }
        var initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));
        var state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);
        if (!contiguous || discontinuity || initSegmentChange) {
          logger.log("[transmuxer-interface, " + frag.type + "]: Starting new transmux session for sn: " + chunkMeta.sn + " p: " + chunkMeta.part + " level: " + chunkMeta.level + " id: " + chunkMeta.id + "\n        discontinuity: " + discontinuity + "\n        trackSwitch: " + trackSwitch + "\n        contiguous: " + contiguous + "\n        accurateTimeOffset: " + accurateTimeOffset + "\n        timeOffset: " + timeOffset + "\n        initSegmentChange: " + initSegmentChange);
          var config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);
          this.configureTransmuxer(config);
        }
        this.frag = frag;
        this.part = part;
        if (this.workerContext) {
          this.workerContext.worker.postMessage({
            cmd: "demux",
            data,
            decryptdata,
            chunkMeta,
            state
          }, data instanceof ArrayBuffer ? [data] : []);
        } else if (transmuxer) {
          var _transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);
          if (isPromise(_transmuxResult)) {
            transmuxer.async = true;
            _transmuxResult.then(function(data2) {
              _this2.handleTransmuxComplete(data2);
            }).catch(function(error) {
              _this2.transmuxerError(error, chunkMeta, "transmuxer-interface push error");
            });
          } else {
            transmuxer.async = false;
            this.handleTransmuxComplete(_transmuxResult);
          }
        }
      };
      _proto.flush = function flush(chunkMeta) {
        var _this3 = this;
        chunkMeta.transmuxing.start = self.performance.now();
        var transmuxer = this.transmuxer;
        if (this.workerContext) {
          this.workerContext.worker.postMessage({
            cmd: "flush",
            chunkMeta
          });
        } else if (transmuxer) {
          var _transmuxResult2 = transmuxer.flush(chunkMeta);
          var asyncFlush = isPromise(_transmuxResult2);
          if (asyncFlush || transmuxer.async) {
            if (!isPromise(_transmuxResult2)) {
              _transmuxResult2 = Promise.resolve(_transmuxResult2);
            }
            _transmuxResult2.then(function(data) {
              _this3.handleFlushResult(data, chunkMeta);
            }).catch(function(error) {
              _this3.transmuxerError(error, chunkMeta, "transmuxer-interface flush error");
            });
          } else {
            this.handleFlushResult(_transmuxResult2, chunkMeta);
          }
        }
      };
      _proto.transmuxerError = function transmuxerError(error, chunkMeta, reason) {
        if (!this.hls) {
          return;
        }
        this.error = error;
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.FRAG_PARSING_ERROR,
          chunkMeta,
          fatal: false,
          error,
          err: error,
          reason
        });
      };
      _proto.handleFlushResult = function handleFlushResult2(results, chunkMeta) {
        var _this4 = this;
        results.forEach(function(result) {
          _this4.handleTransmuxComplete(result);
        });
        this.onFlush(chunkMeta);
      };
      _proto.onWorkerMessage = function onWorkerMessage(ev) {
        var data = ev.data;
        var hls = this.hls;
        switch (data.event) {
          case "init": {
            var _this$workerContext2;
            var objectURL = (_this$workerContext2 = this.workerContext) == null ? void 0 : _this$workerContext2.objectURL;
            if (objectURL) {
              self.URL.revokeObjectURL(objectURL);
            }
            break;
          }
          case "transmuxComplete": {
            this.handleTransmuxComplete(data.data);
            break;
          }
          case "flush": {
            this.onFlush(data.data);
            break;
          }
          case "workerLog":
            if (logger[data.data.logType]) {
              logger[data.data.logType](data.data.message);
            }
            break;
          default: {
            data.data = data.data || {};
            data.data.frag = this.frag;
            data.data.id = this.id;
            hls.trigger(data.event, data.data);
            break;
          }
        }
      };
      _proto.configureTransmuxer = function configureTransmuxer(config) {
        var transmuxer = this.transmuxer;
        if (this.workerContext) {
          this.workerContext.worker.postMessage({
            cmd: "configure",
            config
          });
        } else if (transmuxer) {
          transmuxer.configure(config);
        }
      };
      _proto.handleTransmuxComplete = function handleTransmuxComplete(result) {
        result.chunkMeta.transmuxing.end = self.performance.now();
        this.onTransmuxComplete(result);
      };
      return TransmuxerInterface2;
    }();
    function subtitleOptionsIdentical(trackList1, trackList2) {
      if (trackList1.length !== trackList2.length) {
        return false;
      }
      for (var i = 0; i < trackList1.length; i++) {
        if (!mediaAttributesIdentical(trackList1[i].attrs, trackList2[i].attrs)) {
          return false;
        }
      }
      return true;
    }
    function mediaAttributesIdentical(attrs1, attrs2, customAttributes) {
      var stableRenditionId = attrs1["STABLE-RENDITION-ID"];
      if (stableRenditionId && !customAttributes) {
        return stableRenditionId === attrs2["STABLE-RENDITION-ID"];
      }
      return !(customAttributes || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some(function(subtitleAttribute) {
        return attrs1[subtitleAttribute] !== attrs2[subtitleAttribute];
      });
    }
    function subtitleTrackMatchesTextTrack(subtitleTrack, textTrack) {
      return textTrack.label.toLowerCase() === subtitleTrack.name.toLowerCase() && (!textTrack.language || textTrack.language.toLowerCase() === (subtitleTrack.lang || "").toLowerCase());
    }
    var TICK_INTERVAL$2 = 100;
    var AudioStreamController = /* @__PURE__ */ function(_BaseStreamController) {
      _inheritsLoose(AudioStreamController2, _BaseStreamController);
      function AudioStreamController2(hls, fragmentTracker, keyLoader) {
        var _this;
        _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, "[audio-stream-controller]", PlaylistLevelType.AUDIO) || this;
        _this.videoBuffer = null;
        _this.videoTrackCC = -1;
        _this.waitingVideoCC = -1;
        _this.bufferedTrack = null;
        _this.switchingTrack = null;
        _this.trackId = -1;
        _this.waitingData = null;
        _this.mainDetails = null;
        _this.flushing = false;
        _this.bufferFlushed = false;
        _this.cachedTrackLoadedData = null;
        _this._registerListeners();
        return _this;
      }
      var _proto = AudioStreamController2.prototype;
      _proto.onHandlerDestroying = function onHandlerDestroying() {
        this._unregisterListeners();
        _BaseStreamController.prototype.onHandlerDestroying.call(this);
        this.mainDetails = null;
        this.bufferedTrack = null;
        this.switchingTrack = null;
      };
      _proto._registerListeners = function _registerListeners() {
        var hls = this.hls;
        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
        hls.on(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
        hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
        hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
        hls.on(Events.ERROR, this.onError, this);
        hls.on(Events.BUFFER_RESET, this.onBufferReset, this);
        hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
        hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
        hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      };
      _proto._unregisterListeners = function _unregisterListeners() {
        var hls = this.hls;
        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
        hls.off(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
        hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
        hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
        hls.off(Events.ERROR, this.onError, this);
        hls.off(Events.BUFFER_RESET, this.onBufferReset, this);
        hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
        hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
        hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      };
      _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {
        var frag = _ref.frag, id = _ref.id, initPTS = _ref.initPTS, timescale = _ref.timescale;
        if (id === "main") {
          var cc = frag.cc;
          this.initPTS[frag.cc] = {
            baseTime: initPTS,
            timescale
          };
          this.log("InitPTS for cc: " + cc + " found from main: " + initPTS);
          this.videoTrackCC = cc;
          if (this.state === State.WAITING_INIT_PTS) {
            this.tick();
          }
        }
      };
      _proto.startLoad = function startLoad(startPosition) {
        if (!this.levels) {
          this.startPosition = startPosition;
          this.state = State.STOPPED;
          return;
        }
        var lastCurrentTime = this.lastCurrentTime;
        this.stopLoad();
        this.setInterval(TICK_INTERVAL$2);
        if (lastCurrentTime > 0 && startPosition === -1) {
          this.log("Override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
          startPosition = lastCurrentTime;
          this.state = State.IDLE;
        } else {
          this.loadedmetadata = false;
          this.state = State.WAITING_TRACK;
        }
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
        this.tick();
      };
      _proto.doTick = function doTick() {
        switch (this.state) {
          case State.IDLE:
            this.doTickIdle();
            break;
          case State.WAITING_TRACK: {
            var _levels$trackId;
            var levels = this.levels, trackId = this.trackId;
            var details = levels == null ? void 0 : (_levels$trackId = levels[trackId]) == null ? void 0 : _levels$trackId.details;
            if (details) {
              if (this.waitForCdnTuneIn(details)) {
                break;
              }
              this.state = State.WAITING_INIT_PTS;
            }
            break;
          }
          case State.FRAG_LOADING_WAITING_RETRY: {
            var _this$media;
            var now2 = performance.now();
            var retryDate = this.retryDate;
            if (!retryDate || now2 >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {
              var _levels = this.levels, _trackId = this.trackId;
              this.log("RetryDate reached, switch back to IDLE state");
              this.resetStartWhenNotLoaded((_levels == null ? void 0 : _levels[_trackId]) || null);
              this.state = State.IDLE;
            }
            break;
          }
          case State.WAITING_INIT_PTS: {
            var waitingData = this.waitingData;
            if (waitingData) {
              var frag = waitingData.frag, part = waitingData.part, cache = waitingData.cache, complete = waitingData.complete;
              if (this.initPTS[frag.cc] !== void 0) {
                this.waitingData = null;
                this.waitingVideoCC = -1;
                this.state = State.FRAG_LOADING;
                var payload = cache.flush();
                var data = {
                  frag,
                  part,
                  payload,
                  networkDetails: null
                };
                this._handleFragmentLoadProgress(data);
                if (complete) {
                  _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, data);
                }
              } else if (this.videoTrackCC !== this.waitingVideoCC) {
                this.log("Waiting fragment cc (" + frag.cc + ") cancelled because video is at cc " + this.videoTrackCC);
                this.clearWaitingFragment();
              } else {
                var pos = this.getLoadPosition();
                var bufferInfo = BufferHelper.bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);
                var waitingFragmentAtPosition = fragmentWithinToleranceTest(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);
                if (waitingFragmentAtPosition < 0) {
                  this.log("Waiting fragment cc (" + frag.cc + ") @ " + frag.start + " cancelled because another fragment at " + bufferInfo.end + " is needed");
                  this.clearWaitingFragment();
                }
              }
            } else {
              this.state = State.IDLE;
            }
          }
        }
        this.onTickEnd();
      };
      _proto.clearWaitingFragment = function clearWaitingFragment() {
        var waitingData = this.waitingData;
        if (waitingData) {
          this.fragmentTracker.removeFragment(waitingData.frag);
          this.waitingData = null;
          this.waitingVideoCC = -1;
          this.state = State.IDLE;
        }
      };
      _proto.resetLoadingState = function resetLoadingState() {
        this.clearWaitingFragment();
        _BaseStreamController.prototype.resetLoadingState.call(this);
      };
      _proto.onTickEnd = function onTickEnd() {
        var media = this.media;
        if (!(media != null && media.readyState)) {
          return;
        }
        this.lastCurrentTime = media.currentTime;
      };
      _proto.doTickIdle = function doTickIdle() {
        var hls = this.hls, levels = this.levels, media = this.media, trackId = this.trackId;
        var config = hls.config;
        if (!media && (this.startFragRequested || !config.startFragPrefetch) || !(levels != null && levels[trackId])) {
          return;
        }
        var levelInfo = levels[trackId];
        var trackDetails = levelInfo.details;
        if (!trackDetails || trackDetails.live && this.levelLastLoaded !== levelInfo || this.waitForCdnTuneIn(trackDetails)) {
          this.state = State.WAITING_TRACK;
          return;
        }
        var bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;
        if (this.bufferFlushed && bufferable) {
          this.bufferFlushed = false;
          this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);
        }
        var bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);
        if (bufferInfo === null) {
          return;
        }
        var bufferedTrack = this.bufferedTrack, switchingTrack = this.switchingTrack;
        if (!switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {
          hls.trigger(Events.BUFFER_EOS, {
            type: "audio"
          });
          this.state = State.ENDED;
          return;
        }
        var mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, PlaylistLevelType.MAIN);
        var bufferLen = bufferInfo.len;
        var maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len);
        var fragments = trackDetails.fragments;
        var start = fragments[0].start;
        var targetBufferTime = this.flushing ? this.getLoadPosition() : bufferInfo.end;
        if (switchingTrack && media) {
          var pos = this.getLoadPosition();
          if (bufferedTrack && !mediaAttributesIdentical(switchingTrack.attrs, bufferedTrack.attrs)) {
            targetBufferTime = pos;
          }
          if (trackDetails.PTSKnown && pos < start) {
            if (bufferInfo.end > start || bufferInfo.nextStart) {
              this.log("Alt audio track ahead of main track, seek to start of alt audio track");
              media.currentTime = start + 0.05;
            }
          }
        }
        if (bufferLen >= maxBufLen && !switchingTrack && targetBufferTime < fragments[fragments.length - 1].start) {
          return;
        }
        var frag = this.getNextFragment(targetBufferTime, trackDetails);
        var atGap = false;
        if (frag && this.isLoopLoading(frag, targetBufferTime)) {
          atGap = !!frag.gap;
          frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);
        }
        if (!frag) {
          this.bufferFlushed = true;
          return;
        }
        var atBufferSyncLimit = mainBufferInfo && frag.start > mainBufferInfo.end + trackDetails.targetduration;
        if (atBufferSyncLimit || // Or wait for main buffer after buffing some audio
        !(mainBufferInfo != null && mainBufferInfo.len) && bufferInfo.len) {
          var mainFrag = this.getAppendedFrag(frag.start, PlaylistLevelType.MAIN);
          if (mainFrag === null) {
            return;
          }
          atGap || (atGap = !!mainFrag.gap || !!atBufferSyncLimit && mainBufferInfo.len === 0);
          if (atBufferSyncLimit && !atGap || atGap && bufferInfo.nextStart && bufferInfo.nextStart < mainFrag.end) {
            return;
          }
        }
        this.loadFragment(frag, levelInfo, targetBufferTime);
      };
      _proto.getMaxBufferLength = function getMaxBufferLength(mainBufferLength) {
        var maxConfigBuffer = _BaseStreamController.prototype.getMaxBufferLength.call(this);
        if (!mainBufferLength) {
          return maxConfigBuffer;
        }
        return Math.min(Math.max(maxConfigBuffer, mainBufferLength), this.config.maxMaxBufferLength);
      };
      _proto.onMediaDetaching = function onMediaDetaching() {
        this.videoBuffer = null;
        this.bufferFlushed = this.flushing = false;
        _BaseStreamController.prototype.onMediaDetaching.call(this);
      };
      _proto.onAudioTracksUpdated = function onAudioTracksUpdated(event, _ref2) {
        var audioTracks = _ref2.audioTracks;
        this.resetTransmuxer();
        this.levels = audioTracks.map(function(mediaPlaylist) {
          return new Level(mediaPlaylist);
        });
      };
      _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {
        var altAudio = !!data.url;
        this.trackId = data.id;
        var fragCurrent = this.fragCurrent;
        if (fragCurrent) {
          fragCurrent.abortRequests();
          this.removeUnbufferedFrags(fragCurrent.start);
        }
        this.resetLoadingState();
        if (!altAudio) {
          this.resetTransmuxer();
        } else {
          this.setInterval(TICK_INTERVAL$2);
        }
        if (altAudio) {
          this.switchingTrack = data;
          this.state = State.IDLE;
          this.flushAudioIfNeeded(data);
        } else {
          this.switchingTrack = null;
          this.bufferedTrack = data;
          this.state = State.STOPPED;
        }
        this.tick();
      };
      _proto.onManifestLoading = function onManifestLoading() {
        this.fragmentTracker.removeAllFragments();
        this.startPosition = this.lastCurrentTime = 0;
        this.bufferFlushed = this.flushing = false;
        this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null;
        this.startFragRequested = false;
        this.trackId = this.videoTrackCC = this.waitingVideoCC = -1;
      };
      _proto.onLevelLoaded = function onLevelLoaded(event, data) {
        this.mainDetails = data.details;
        if (this.cachedTrackLoadedData !== null) {
          this.hls.trigger(Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);
          this.cachedTrackLoadedData = null;
        }
      };
      _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {
        var _track$details;
        if (this.mainDetails == null) {
          this.cachedTrackLoadedData = data;
          return;
        }
        var levels = this.levels;
        var newDetails = data.details, trackId = data.id;
        if (!levels) {
          this.warn("Audio tracks were reset while loading level " + trackId);
          return;
        }
        this.log("Audio track " + trackId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "]" + (newDetails.lastPartSn ? "[part-" + newDetails.lastPartSn + "-" + newDetails.lastPartIndex + "]" : "") + ",duration:" + newDetails.totalduration);
        var track = levels[trackId];
        var sliding = 0;
        if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {
          this.checkLiveUpdate(newDetails);
          var mainDetails = this.mainDetails;
          if (newDetails.deltaUpdateFailed || !mainDetails) {
            return;
          }
          if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
            alignMediaPlaylistByPDT(newDetails, mainDetails);
            sliding = newDetails.fragments[0].start;
          } else {
            var _this$levelLastLoaded;
            sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);
          }
        }
        track.details = newDetails;
        this.levelLastLoaded = track;
        if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {
          this.setStartPosition(track.details, sliding);
        }
        if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {
          this.state = State.IDLE;
        }
        this.tick();
      };
      _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {
        var _frag$initSegment;
        var frag = data.frag, part = data.part, payload = data.payload;
        var config = this.config, trackId = this.trackId, levels = this.levels;
        if (!levels) {
          this.warn("Audio tracks were reset while fragment load was in progress. Fragment " + frag.sn + " of level " + frag.level + " will not be buffered");
          return;
        }
        var track = levels[trackId];
        if (!track) {
          this.warn("Audio track is undefined on fragment load progress");
          return;
        }
        var details = track.details;
        if (!details) {
          this.warn("Audio track details undefined on fragment load progress");
          this.removeUnbufferedFrags(frag.start);
          return;
        }
        var audioCodec = config.defaultAudioCodec || track.audioCodec || "mp4a.40.2";
        var transmuxer = this.transmuxer;
        if (!transmuxer) {
          transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
        }
        var initPTS = this.initPTS[frag.cc];
        var initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;
        if (initPTS !== void 0) {
          var accurateTimeOffset = false;
          var partIndex = part ? part.index : -1;
          var partial = partIndex !== -1;
          var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
          transmuxer.push(payload, initSegmentData, audioCodec, "", frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
        } else {
          this.log("Unknown video PTS for cc " + frag.cc + ", waiting for video PTS before demuxing audio frag " + frag.sn + " of [" + details.startSN + " ," + details.endSN + "],track " + trackId);
          var _this$waitingData = this.waitingData = this.waitingData || {
            frag,
            part,
            cache: new ChunkCache(),
            complete: false
          }, cache = _this$waitingData.cache;
          cache.push(new Uint8Array(payload));
          this.waitingVideoCC = this.videoTrackCC;
          this.state = State.WAITING_INIT_PTS;
        }
      };
      _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {
        if (this.waitingData) {
          this.waitingData.complete = true;
          return;
        }
        _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, fragLoadedData);
      };
      _proto.onBufferReset = function onBufferReset() {
        this.mediaBuffer = this.videoBuffer = null;
        this.loadedmetadata = false;
      };
      _proto.onBufferCreated = function onBufferCreated(event, data) {
        var audioTrack = data.tracks.audio;
        if (audioTrack) {
          this.mediaBuffer = audioTrack.buffer || null;
        }
        if (data.tracks.video) {
          this.videoBuffer = data.tracks.video.buffer || null;
        }
      };
      _proto.onFragBuffered = function onFragBuffered(event, data) {
        var frag = data.frag, part = data.part;
        if (frag.type !== PlaylistLevelType.AUDIO) {
          if (!this.loadedmetadata && frag.type === PlaylistLevelType.MAIN) {
            var bufferable = this.videoBuffer || this.media;
            if (bufferable) {
              var bufferedTimeRanges = BufferHelper.getBuffered(bufferable);
              if (bufferedTimeRanges.length) {
                this.loadedmetadata = true;
              }
            }
          }
          return;
        }
        if (this.fragContextChanged(frag)) {
          this.warn("Fragment " + frag.sn + (part ? " p: " + part.index : "") + " of level " + frag.level + " finished buffering, but was aborted. state: " + this.state + ", audioSwitch: " + (this.switchingTrack ? this.switchingTrack.name : "false"));
          return;
        }
        if (frag.sn !== "initSegment") {
          this.fragPrevious = frag;
          var track = this.switchingTrack;
          if (track) {
            this.bufferedTrack = track;
            this.switchingTrack = null;
            this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, track));
          }
        }
        this.fragBufferedComplete(frag, part);
      };
      _proto.onError = function onError(event, data) {
        var _data$context;
        if (data.fatal) {
          this.state = State.ERROR;
          return;
        }
        switch (data.details) {
          case ErrorDetails.FRAG_GAP:
          case ErrorDetails.FRAG_PARSING_ERROR:
          case ErrorDetails.FRAG_DECRYPT_ERROR:
          case ErrorDetails.FRAG_LOAD_ERROR:
          case ErrorDetails.FRAG_LOAD_TIMEOUT:
          case ErrorDetails.KEY_LOAD_ERROR:
          case ErrorDetails.KEY_LOAD_TIMEOUT:
            this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);
            break;
          case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
          case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
          case ErrorDetails.LEVEL_PARSING_ERROR:
            if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {
              this.state = State.IDLE;
            }
            break;
          case ErrorDetails.BUFFER_APPEND_ERROR:
          case ErrorDetails.BUFFER_FULL_ERROR:
            if (!data.parent || data.parent !== "audio") {
              return;
            }
            if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {
              this.resetLoadingState();
              return;
            }
            if (this.reduceLengthAndFlushBuffer(data)) {
              this.bufferedTrack = null;
              _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio");
            }
            break;
          case ErrorDetails.INTERNAL_EXCEPTION:
            this.recoverWorkerError(data);
            break;
        }
      };
      _proto.onBufferFlushing = function onBufferFlushing(event, _ref3) {
        var type = _ref3.type;
        if (type !== ElementaryStreamTypes.VIDEO) {
          this.flushing = true;
        }
      };
      _proto.onBufferFlushed = function onBufferFlushed(event, _ref4) {
        var type = _ref4.type;
        if (type !== ElementaryStreamTypes.VIDEO) {
          this.flushing = false;
          this.bufferFlushed = true;
          if (this.state === State.ENDED) {
            this.state = State.IDLE;
          }
          var mediaBuffer = this.mediaBuffer || this.media;
          if (mediaBuffer) {
            this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.AUDIO);
            this.tick();
          }
        }
      };
      _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {
        var _id3$samples;
        var id = "audio";
        var hls = this.hls;
        var remuxResult = transmuxResult.remuxResult, chunkMeta = transmuxResult.chunkMeta;
        var context = this.getCurrentContext(chunkMeta);
        if (!context) {
          this.resetWhenMissingContext(chunkMeta);
          return;
        }
        var frag = context.frag, part = context.part, level = context.level;
        var details = level.details;
        var audio = remuxResult.audio, text = remuxResult.text, id3 = remuxResult.id3, initSegment = remuxResult.initSegment;
        if (this.fragContextChanged(frag) || !details) {
          this.fragmentTracker.removeFragment(frag);
          return;
        }
        this.state = State.PARSING;
        if (this.switchingTrack && audio) {
          this.completeAudioSwitch(this.switchingTrack);
        }
        if (initSegment != null && initSegment.tracks) {
          var mapFragment = frag.initSegment || frag;
          this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);
          hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {
            frag: mapFragment,
            id,
            tracks: initSegment.tracks
          });
        }
        if (audio) {
          var startPTS = audio.startPTS, endPTS = audio.endPTS, startDTS = audio.startDTS, endDTS = audio.endDTS;
          if (part) {
            part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {
              startPTS,
              endPTS,
              startDTS,
              endDTS
            };
          }
          frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);
          this.bufferFragmentData(audio, frag, part, chunkMeta);
        }
        if (id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {
          var emittedID3 = _extends({
            id,
            frag,
            details
          }, id3);
          hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);
        }
        if (text) {
          var emittedText = _extends({
            id,
            frag,
            details
          }, text);
          hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);
        }
      };
      _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
        if (this.state !== State.PARSING) {
          return;
        }
        if (tracks.video) {
          delete tracks.video;
        }
        var track = tracks.audio;
        if (!track) {
          return;
        }
        track.id = "audio";
        var variantAudioCodecs = currentLevel.audioCodec;
        this.log("Init audio buffer, container:" + track.container + ", codecs[level/parsed]=[" + variantAudioCodecs + "/" + track.codec + "]");
        if (variantAudioCodecs && variantAudioCodecs.split(",").length === 1) {
          track.levelCodec = variantAudioCodecs;
        }
        this.hls.trigger(Events.BUFFER_CODECS, tracks);
        var initSegment = track.initSegment;
        if (initSegment != null && initSegment.byteLength) {
          var segment = {
            type: "audio",
            frag,
            part: null,
            chunkMeta,
            parent: frag.type,
            data: initSegment
          };
          this.hls.trigger(Events.BUFFER_APPENDING, segment);
        }
        this.tickImmediate();
      };
      _proto.loadFragment = function loadFragment(frag, track, targetBufferTime) {
        var fragState = this.fragmentTracker.getState(frag);
        this.fragCurrent = frag;
        if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
          var _track$details2;
          if (frag.sn === "initSegment") {
            this._loadInitSegment(frag, track);
          } else if ((_track$details2 = track.details) != null && _track$details2.live && !this.initPTS[frag.cc]) {
            this.log("Waiting for video PTS in continuity counter " + frag.cc + " of live stream before loading audio fragment " + frag.sn + " of level " + this.trackId);
            this.state = State.WAITING_INIT_PTS;
            var mainDetails = this.mainDetails;
            if (mainDetails && mainDetails.fragments[0].start !== track.details.fragments[0].start) {
              alignMediaPlaylistByPDT(track.details, mainDetails);
            }
          } else {
            this.startFragRequested = true;
            _BaseStreamController.prototype.loadFragment.call(this, frag, track, targetBufferTime);
          }
        } else {
          this.clearTrackerIfNeeded(frag);
        }
      };
      _proto.flushAudioIfNeeded = function flushAudioIfNeeded(switchingTrack) {
        var media = this.media, bufferedTrack = this.bufferedTrack;
        var bufferedAttributes = bufferedTrack == null ? void 0 : bufferedTrack.attrs;
        var switchAttributes = switchingTrack.attrs;
        if (media && bufferedAttributes && (bufferedAttributes.CHANNELS !== switchAttributes.CHANNELS || bufferedTrack.name !== switchingTrack.name || bufferedTrack.lang !== switchingTrack.lang)) {
          this.log("Switching audio track : flushing all audio");
          _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio");
          this.bufferedTrack = null;
        }
      };
      _proto.completeAudioSwitch = function completeAudioSwitch(switchingTrack) {
        var hls = this.hls;
        this.flushAudioIfNeeded(switchingTrack);
        this.bufferedTrack = switchingTrack;
        this.switchingTrack = null;
        hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, switchingTrack));
      };
      return AudioStreamController2;
    }(BaseStreamController);
    var AudioTrackController = /* @__PURE__ */ function(_BasePlaylistControll) {
      _inheritsLoose(AudioTrackController2, _BasePlaylistControll);
      function AudioTrackController2(hls) {
        var _this;
        _this = _BasePlaylistControll.call(this, hls, "[audio-track-controller]") || this;
        _this.tracks = [];
        _this.groupIds = null;
        _this.tracksInGroup = [];
        _this.trackId = -1;
        _this.currentTrack = null;
        _this.selectDefaultTrack = true;
        _this.registerListeners();
        return _this;
      }
      var _proto = AudioTrackController2.prototype;
      _proto.registerListeners = function registerListeners() {
        var hls = this.hls;
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
        hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
        hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
        hls.on(Events.ERROR, this.onError, this);
      };
      _proto.unregisterListeners = function unregisterListeners() {
        var hls = this.hls;
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
        hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
        hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
        hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
        hls.off(Events.ERROR, this.onError, this);
      };
      _proto.destroy = function destroy() {
        this.unregisterListeners();
        this.tracks.length = 0;
        this.tracksInGroup.length = 0;
        this.currentTrack = null;
        _BasePlaylistControll.prototype.destroy.call(this);
      };
      _proto.onManifestLoading = function onManifestLoading() {
        this.tracks = [];
        this.tracksInGroup = [];
        this.groupIds = null;
        this.currentTrack = null;
        this.trackId = -1;
        this.selectDefaultTrack = true;
      };
      _proto.onManifestParsed = function onManifestParsed(event, data) {
        this.tracks = data.audioTracks || [];
      };
      _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {
        var id = data.id, groupId = data.groupId, details = data.details;
        var trackInActiveGroup = this.tracksInGroup[id];
        if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {
          this.warn("Audio track with id:" + id + " and group:" + groupId + " not found in active group " + (trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId));
          return;
        }
        var curDetails = trackInActiveGroup.details;
        trackInActiveGroup.details = data.details;
        this.log("Audio track " + id + ' "' + trackInActiveGroup.name + '" lang:' + trackInActiveGroup.lang + " group:" + groupId + " loaded [" + details.startSN + "-" + details.endSN + "]");
        if (id === this.trackId) {
          this.playlistLoaded(id, data, curDetails);
        }
      };
      _proto.onLevelLoading = function onLevelLoading(event, data) {
        this.switchLevel(data.level);
      };
      _proto.onLevelSwitching = function onLevelSwitching(event, data) {
        this.switchLevel(data.level);
      };
      _proto.switchLevel = function switchLevel(levelIndex) {
        var levelInfo = this.hls.levels[levelIndex];
        if (!levelInfo) {
          return;
        }
        var audioGroups = levelInfo.audioGroups || null;
        var currentGroups = this.groupIds;
        var currentTrack = this.currentTrack;
        if (!audioGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (audioGroups == null ? void 0 : audioGroups.length) || audioGroups != null && audioGroups.some(function(groupId) {
          return (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1;
        })) {
          this.groupIds = audioGroups;
          this.trackId = -1;
          this.currentTrack = null;
          var audioTracks = this.tracks.filter(function(track) {
            return !audioGroups || audioGroups.indexOf(track.groupId) !== -1;
          });
          if (audioTracks.length) {
            if (this.selectDefaultTrack && !audioTracks.some(function(track) {
              return track.default;
            })) {
              this.selectDefaultTrack = false;
            }
            audioTracks.forEach(function(track, i) {
              track.id = i;
            });
          } else if (!currentTrack && !this.tracksInGroup.length) {
            return;
          }
          this.tracksInGroup = audioTracks;
          var audioPreference = this.hls.config.audioPreference;
          if (!currentTrack && audioPreference) {
            var groupIndex = findMatchingOption(audioPreference, audioTracks, audioMatchPredicate);
            if (groupIndex > -1) {
              currentTrack = audioTracks[groupIndex];
            } else {
              var allIndex = findMatchingOption(audioPreference, this.tracks);
              currentTrack = this.tracks[allIndex];
            }
          }
          var trackId = this.findTrackId(currentTrack);
          if (trackId === -1 && currentTrack) {
            trackId = this.findTrackId(null);
          }
          var audioTracksUpdated = {
            audioTracks
          };
          this.log("Updating audio tracks, " + audioTracks.length + " track(s) found in group(s): " + (audioGroups == null ? void 0 : audioGroups.join(",")));
          this.hls.trigger(Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);
          var selectedTrackId = this.trackId;
          if (trackId !== -1 && selectedTrackId === -1) {
            this.setAudioTrack(trackId);
          } else if (audioTracks.length && selectedTrackId === -1) {
            var _this$groupIds;
            var error = new Error("No audio track selected for current audio group-ID(s): " + ((_this$groupIds = this.groupIds) == null ? void 0 : _this$groupIds.join(",")) + " track count: " + audioTracks.length);
            this.warn(error.message);
            this.hls.trigger(Events.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
              fatal: true,
              error
            });
          }
        } else if (this.shouldReloadPlaylist(currentTrack)) {
          this.setAudioTrack(this.trackId);
        }
      };
      _proto.onError = function onError(event, data) {
        if (data.fatal || !data.context) {
          return;
        }
        if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {
          this.requestScheduled = -1;
          this.checkRetry(data);
        }
      };
      _proto.setAudioOption = function setAudioOption(audioOption) {
        var hls = this.hls;
        hls.config.audioPreference = audioOption;
        if (audioOption) {
          var allAudioTracks = this.allAudioTracks;
          this.selectDefaultTrack = false;
          if (allAudioTracks.length) {
            var currentTrack = this.currentTrack;
            if (currentTrack && matchesOption(audioOption, currentTrack, audioMatchPredicate)) {
              return currentTrack;
            }
            var groupIndex = findMatchingOption(audioOption, this.tracksInGroup, audioMatchPredicate);
            if (groupIndex > -1) {
              var track = this.tracksInGroup[groupIndex];
              this.setAudioTrack(groupIndex);
              return track;
            } else if (currentTrack) {
              var searchIndex = hls.loadLevel;
              if (searchIndex === -1) {
                searchIndex = hls.firstAutoLevel;
              }
              var switchIndex = findClosestLevelWithAudioGroup(audioOption, hls.levels, allAudioTracks, searchIndex, audioMatchPredicate);
              if (switchIndex === -1) {
                return null;
              }
              hls.nextLoadLevel = switchIndex;
            }
            if (audioOption.channels || audioOption.audioCodec) {
              var withoutCodecAndChannelsMatch = findMatchingOption(audioOption, allAudioTracks);
              if (withoutCodecAndChannelsMatch > -1) {
                return allAudioTracks[withoutCodecAndChannelsMatch];
              }
            }
          }
        }
        return null;
      };
      _proto.setAudioTrack = function setAudioTrack(newId) {
        var tracks = this.tracksInGroup;
        if (newId < 0 || newId >= tracks.length) {
          this.warn("Invalid audio track id: " + newId);
          return;
        }
        this.clearTimer();
        this.selectDefaultTrack = false;
        var lastTrack = this.currentTrack;
        var track = tracks[newId];
        var trackLoaded = track.details && !track.details.live;
        if (newId === this.trackId && track === lastTrack && trackLoaded) {
          return;
        }
        this.log("Switching to audio-track " + newId + ' "' + track.name + '" lang:' + track.lang + " group:" + track.groupId + " channels:" + track.channels);
        this.trackId = newId;
        this.currentTrack = track;
        this.hls.trigger(Events.AUDIO_TRACK_SWITCHING, _objectSpread2({}, track));
        if (trackLoaded) {
          return;
        }
        var hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details);
        this.loadPlaylist(hlsUrlParameters);
      };
      _proto.findTrackId = function findTrackId(currentTrack) {
        var audioTracks = this.tracksInGroup;
        for (var i = 0; i < audioTracks.length; i++) {
          var track = audioTracks[i];
          if (this.selectDefaultTrack && !track.default) {
            continue;
          }
          if (!currentTrack || matchesOption(currentTrack, track, audioMatchPredicate)) {
            return i;
          }
        }
        if (currentTrack) {
          var name = currentTrack.name, lang = currentTrack.lang, assocLang = currentTrack.assocLang, characteristics = currentTrack.characteristics, audioCodec = currentTrack.audioCodec, channels = currentTrack.channels;
          for (var _i = 0; _i < audioTracks.length; _i++) {
            var _track = audioTracks[_i];
            if (matchesOption({
              name,
              lang,
              assocLang,
              characteristics,
              audioCodec,
              channels
            }, _track, audioMatchPredicate)) {
              return _i;
            }
          }
          for (var _i2 = 0; _i2 < audioTracks.length; _i2++) {
            var _track2 = audioTracks[_i2];
            if (mediaAttributesIdentical(currentTrack.attrs, _track2.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) {
              return _i2;
            }
          }
          for (var _i3 = 0; _i3 < audioTracks.length; _i3++) {
            var _track3 = audioTracks[_i3];
            if (mediaAttributesIdentical(currentTrack.attrs, _track3.attrs, ["LANGUAGE"])) {
              return _i3;
            }
          }
        }
        return -1;
      };
      _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
        var audioTrack = this.currentTrack;
        if (this.shouldLoadPlaylist(audioTrack) && audioTrack) {
          _BasePlaylistControll.prototype.loadPlaylist.call(this);
          var id = audioTrack.id;
          var groupId = audioTrack.groupId;
          var url = audioTrack.url;
          if (hlsUrlParameters) {
            try {
              url = hlsUrlParameters.addDirectives(url);
            } catch (error) {
              this.warn("Could not construct new URL with HLS Delivery Directives: " + error);
            }
          }
          this.log("loading audio-track playlist " + id + ' "' + audioTrack.name + '" lang:' + audioTrack.lang + " group:" + groupId);
          this.clearTimer();
          this.hls.trigger(Events.AUDIO_TRACK_LOADING, {
            url,
            id,
            groupId,
            deliveryDirectives: hlsUrlParameters || null
          });
        }
      };
      _createClass(AudioTrackController2, [{
        key: "allAudioTracks",
        get: function get() {
          return this.tracks;
        }
      }, {
        key: "audioTracks",
        get: function get() {
          return this.tracksInGroup;
        }
      }, {
        key: "audioTrack",
        get: function get() {
          return this.trackId;
        },
        set: function set(newId) {
          this.selectDefaultTrack = false;
          this.setAudioTrack(newId);
        }
      }]);
      return AudioTrackController2;
    }(BasePlaylistController);
    var TICK_INTERVAL$1 = 500;
    var SubtitleStreamController = /* @__PURE__ */ function(_BaseStreamController) {
      _inheritsLoose(SubtitleStreamController2, _BaseStreamController);
      function SubtitleStreamController2(hls, fragmentTracker, keyLoader) {
        var _this;
        _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, "[subtitle-stream-controller]", PlaylistLevelType.SUBTITLE) || this;
        _this.currentTrackId = -1;
        _this.tracksBuffered = [];
        _this.mainDetails = null;
        _this._registerListeners();
        return _this;
      }
      var _proto = SubtitleStreamController2.prototype;
      _proto.onHandlerDestroying = function onHandlerDestroying() {
        this._unregisterListeners();
        _BaseStreamController.prototype.onHandlerDestroying.call(this);
        this.mainDetails = null;
      };
      _proto._registerListeners = function _registerListeners() {
        var hls = this.hls;
        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
        hls.on(Events.ERROR, this.onError, this);
        hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
        hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
        hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
        hls.on(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      };
      _proto._unregisterListeners = function _unregisterListeners() {
        var hls = this.hls;
        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
        hls.off(Events.ERROR, this.onError, this);
        hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
        hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
        hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
        hls.off(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      };
      _proto.startLoad = function startLoad(startPosition) {
        this.stopLoad();
        this.state = State.IDLE;
        this.setInterval(TICK_INTERVAL$1);
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
        this.tick();
      };
      _proto.onManifestLoading = function onManifestLoading() {
        this.mainDetails = null;
        this.fragmentTracker.removeAllFragments();
      };
      _proto.onMediaDetaching = function onMediaDetaching() {
        this.tracksBuffered = [];
        _BaseStreamController.prototype.onMediaDetaching.call(this);
      };
      _proto.onLevelLoaded = function onLevelLoaded(event, data) {
        this.mainDetails = data.details;
      };
      _proto.onSubtitleFragProcessed = function onSubtitleFragProcessed(event, data) {
        var frag = data.frag, success = data.success;
        this.fragPrevious = frag;
        this.state = State.IDLE;
        if (!success) {
          return;
        }
        var buffered = this.tracksBuffered[this.currentTrackId];
        if (!buffered) {
          return;
        }
        var timeRange;
        var fragStart = frag.start;
        for (var i = 0; i < buffered.length; i++) {
          if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {
            timeRange = buffered[i];
            break;
          }
        }
        var fragEnd = frag.start + frag.duration;
        if (timeRange) {
          timeRange.end = fragEnd;
        } else {
          timeRange = {
            start: fragStart,
            end: fragEnd
          };
          buffered.push(timeRange);
        }
        this.fragmentTracker.fragBuffered(frag);
        this.fragBufferedComplete(frag, null);
      };
      _proto.onBufferFlushing = function onBufferFlushing(event, data) {
        var startOffset = data.startOffset, endOffset = data.endOffset;
        if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {
          var endOffsetSubtitles = endOffset - 1;
          if (endOffsetSubtitles <= 0) {
            return;
          }
          data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);
          this.tracksBuffered.forEach(function(buffered) {
            for (var i = 0; i < buffered.length; ) {
              if (buffered[i].end <= endOffsetSubtitles) {
                buffered.shift();
                continue;
              } else if (buffered[i].start < endOffsetSubtitles) {
                buffered[i].start = endOffsetSubtitles;
              } else {
                break;
              }
              i++;
            }
          });
          this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);
        }
      };
      _proto.onFragBuffered = function onFragBuffered(event, data) {
        if (!this.loadedmetadata && data.frag.type === PlaylistLevelType.MAIN) {
          var _this$media;
          if ((_this$media = this.media) != null && _this$media.buffered.length) {
            this.loadedmetadata = true;
          }
        }
      };
      _proto.onError = function onError(event, data) {
        var frag = data.frag;
        if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.SUBTITLE) {
          if (this.fragCurrent) {
            this.fragCurrent.abortRequests();
          }
          if (this.state !== State.STOPPED) {
            this.state = State.IDLE;
          }
        }
      };
      _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, _ref) {
        var _this2 = this;
        var subtitleTracks = _ref.subtitleTracks;
        if (!this.levels || subtitleOptionsIdentical(this.levels, subtitleTracks)) {
          this.levels = subtitleTracks.map(function(mediaPlaylist) {
            return new Level(mediaPlaylist);
          });
          return;
        }
        this.tracksBuffered = [];
        this.levels = subtitleTracks.map(function(mediaPlaylist) {
          var level = new Level(mediaPlaylist);
          _this2.tracksBuffered[level.id] = [];
          return level;
        });
        this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);
        this.fragPrevious = null;
        this.mediaBuffer = null;
      };
      _proto.onSubtitleTrackSwitch = function onSubtitleTrackSwitch(event, data) {
        var _this$levels;
        this.currentTrackId = data.id;
        if (!((_this$levels = this.levels) != null && _this$levels.length) || this.currentTrackId === -1) {
          this.clearInterval();
          return;
        }
        var currentTrack = this.levels[this.currentTrackId];
        if (currentTrack != null && currentTrack.details) {
          this.mediaBuffer = this.mediaBufferTimeRanges;
        } else {
          this.mediaBuffer = null;
        }
        if (currentTrack) {
          this.setInterval(TICK_INTERVAL$1);
        }
      };
      _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {
        var _track$details;
        var currentTrackId = this.currentTrackId, levels = this.levels;
        var newDetails = data.details, trackId = data.id;
        if (!levels) {
          this.warn("Subtitle tracks were reset while loading level " + trackId);
          return;
        }
        var track = levels[currentTrackId];
        if (trackId >= levels.length || trackId !== currentTrackId || !track) {
          return;
        }
        this.log("Subtitle track " + trackId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "]" + (newDetails.lastPartSn ? "[part-" + newDetails.lastPartSn + "-" + newDetails.lastPartIndex + "]" : "") + ",duration:" + newDetails.totalduration);
        this.mediaBuffer = this.mediaBufferTimeRanges;
        var sliding = 0;
        if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {
          var mainDetails = this.mainDetails;
          if (newDetails.deltaUpdateFailed || !mainDetails) {
            return;
          }
          var mainSlidingStartFragment = mainDetails.fragments[0];
          if (!track.details) {
            if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
              alignMediaPlaylistByPDT(newDetails, mainDetails);
              sliding = newDetails.fragments[0].start;
            } else if (mainSlidingStartFragment) {
              sliding = mainSlidingStartFragment.start;
              addSliding(newDetails, sliding);
            }
          } else {
            var _this$levelLastLoaded;
            sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);
            if (sliding === 0 && mainSlidingStartFragment) {
              sliding = mainSlidingStartFragment.start;
              addSliding(newDetails, sliding);
            }
          }
        }
        track.details = newDetails;
        this.levelLastLoaded = track;
        if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {
          this.setStartPosition(track.details, sliding);
        }
        this.tick();
        if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {
          var foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);
          if (!foundFrag) {
            this.warn("Subtitle playlist not aligned with playback");
            track.details = void 0;
          }
        }
      };
      _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {
        var _this3 = this;
        var frag = fragLoadedData.frag, payload = fragLoadedData.payload;
        var decryptData = frag.decryptdata;
        var hls = this.hls;
        if (this.fragContextChanged(frag)) {
          return;
        }
        if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === "AES-128") {
          var startTime = performance.now();
          this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(function(err) {
            hls.trigger(Events.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.FRAG_DECRYPT_ERROR,
              fatal: false,
              error: err,
              reason: err.message,
              frag
            });
            throw err;
          }).then(function(decryptedData) {
            var endTime = performance.now();
            hls.trigger(Events.FRAG_DECRYPTED, {
              frag,
              payload: decryptedData,
              stats: {
                tstart: startTime,
                tdecrypt: endTime
              }
            });
          }).catch(function(err) {
            _this3.warn(err.name + ": " + err.message);
            _this3.state = State.IDLE;
          });
        }
      };
      _proto.doTick = function doTick() {
        if (!this.media) {
          this.state = State.IDLE;
          return;
        }
        if (this.state === State.IDLE) {
          var currentTrackId = this.currentTrackId, levels = this.levels;
          var track = levels == null ? void 0 : levels[currentTrackId];
          if (!track || !levels.length || !track.details) {
            return;
          }
          var config = this.config;
          var currentTime = this.getLoadPosition();
          var bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config.maxBufferHole);
          var targetBufferTime = bufferedInfo.end, bufferLen = bufferedInfo.len;
          var mainBufferInfo = this.getFwdBufferInfo(this.media, PlaylistLevelType.MAIN);
          var trackDetails = track.details;
          var maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len) + trackDetails.levelTargetDuration;
          if (bufferLen > maxBufLen) {
            return;
          }
          var fragments = trackDetails.fragments;
          var fragLen = fragments.length;
          var end = trackDetails.edge;
          var foundFrag = null;
          var fragPrevious = this.fragPrevious;
          if (targetBufferTime < end) {
            var tolerance = config.maxFragLookUpTolerance;
            var lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;
            foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);
            if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {
              foundFrag = fragments[0];
            }
          } else {
            foundFrag = fragments[fragLen - 1];
          }
          if (!foundFrag) {
            return;
          }
          foundFrag = this.mapToInitFragWhenRequired(foundFrag);
          if (foundFrag.sn !== "initSegment") {
            var curSNIdx = foundFrag.sn - trackDetails.startSN;
            var prevFrag = fragments[curSNIdx - 1];
            if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {
              foundFrag = prevFrag;
            }
          }
          if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {
            this.loadFragment(foundFrag, track, targetBufferTime);
          }
        }
      };
      _proto.getMaxBufferLength = function getMaxBufferLength(mainBufferLength) {
        var maxConfigBuffer = _BaseStreamController.prototype.getMaxBufferLength.call(this);
        if (!mainBufferLength) {
          return maxConfigBuffer;
        }
        return Math.max(maxConfigBuffer, mainBufferLength);
      };
      _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {
        this.fragCurrent = frag;
        if (frag.sn === "initSegment") {
          this._loadInitSegment(frag, level);
        } else {
          this.startFragRequested = true;
          _BaseStreamController.prototype.loadFragment.call(this, frag, level, targetBufferTime);
        }
      };
      _createClass(SubtitleStreamController2, [{
        key: "mediaBufferTimeRanges",
        get: function get() {
          return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);
        }
      }]);
      return SubtitleStreamController2;
    }(BaseStreamController);
    var BufferableInstance = function BufferableInstance2(timeranges) {
      this.buffered = void 0;
      var getRange = function getRange2(name, index, length) {
        index = index >>> 0;
        if (index > length - 1) {
          throw new DOMException("Failed to execute '" + name + "' on 'TimeRanges': The index provided (" + index + ") is greater than the maximum bound (" + length + ")");
        }
        return timeranges[index][name];
      };
      this.buffered = {
        get length() {
          return timeranges.length;
        },
        end: function end(index) {
          return getRange("end", index, timeranges.length);
        },
        start: function start(index) {
          return getRange("start", index, timeranges.length);
        }
      };
    };
    var SubtitleTrackController = /* @__PURE__ */ function(_BasePlaylistControll) {
      _inheritsLoose(SubtitleTrackController2, _BasePlaylistControll);
      function SubtitleTrackController2(hls) {
        var _this;
        _this = _BasePlaylistControll.call(this, hls, "[subtitle-track-controller]") || this;
        _this.media = null;
        _this.tracks = [];
        _this.groupIds = null;
        _this.tracksInGroup = [];
        _this.trackId = -1;
        _this.currentTrack = null;
        _this.selectDefaultTrack = true;
        _this.queuedDefaultTrack = -1;
        _this.asyncPollTrackChange = function() {
          return _this.pollTrackChange(0);
        };
        _this.useTextTrackPolling = false;
        _this.subtitlePollingInterval = -1;
        _this._subtitleDisplay = true;
        _this.onTextTracksChanged = function() {
          if (!_this.useTextTrackPolling) {
            self.clearInterval(_this.subtitlePollingInterval);
          }
          if (!_this.media || !_this.hls.config.renderTextTracksNatively) {
            return;
          }
          var textTrack = null;
          var tracks = filterSubtitleTracks(_this.media.textTracks);
          for (var i = 0; i < tracks.length; i++) {
            if (tracks[i].mode === "hidden") {
              textTrack = tracks[i];
            } else if (tracks[i].mode === "showing") {
              textTrack = tracks[i];
              break;
            }
          }
          var trackId = _this.findTrackForTextTrack(textTrack);
          if (_this.subtitleTrack !== trackId) {
            _this.setSubtitleTrack(trackId);
          }
        };
        _this.registerListeners();
        return _this;
      }
      var _proto = SubtitleTrackController2.prototype;
      _proto.destroy = function destroy() {
        this.unregisterListeners();
        this.tracks.length = 0;
        this.tracksInGroup.length = 0;
        this.currentTrack = null;
        this.onTextTracksChanged = this.asyncPollTrackChange = null;
        _BasePlaylistControll.prototype.destroy.call(this);
      };
      _proto.registerListeners = function registerListeners() {
        var hls = this.hls;
        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
        hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
        hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
        hls.on(Events.ERROR, this.onError, this);
      };
      _proto.unregisterListeners = function unregisterListeners() {
        var hls = this.hls;
        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
        hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
        hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
        hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
        hls.off(Events.ERROR, this.onError, this);
      };
      _proto.onMediaAttached = function onMediaAttached(event, data) {
        this.media = data.media;
        if (!this.media) {
          return;
        }
        if (this.queuedDefaultTrack > -1) {
          this.subtitleTrack = this.queuedDefaultTrack;
          this.queuedDefaultTrack = -1;
        }
        this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks);
        if (this.useTextTrackPolling) {
          this.pollTrackChange(500);
        } else {
          this.media.textTracks.addEventListener("change", this.asyncPollTrackChange);
        }
      };
      _proto.pollTrackChange = function pollTrackChange(timeout) {
        self.clearInterval(this.subtitlePollingInterval);
        this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, timeout);
      };
      _proto.onMediaDetaching = function onMediaDetaching() {
        if (!this.media) {
          return;
        }
        self.clearInterval(this.subtitlePollingInterval);
        if (!this.useTextTrackPolling) {
          this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange);
        }
        if (this.trackId > -1) {
          this.queuedDefaultTrack = this.trackId;
        }
        var textTracks = filterSubtitleTracks(this.media.textTracks);
        textTracks.forEach(function(track) {
          clearCurrentCues(track);
        });
        this.subtitleTrack = -1;
        this.media = null;
      };
      _proto.onManifestLoading = function onManifestLoading() {
        this.tracks = [];
        this.groupIds = null;
        this.tracksInGroup = [];
        this.trackId = -1;
        this.currentTrack = null;
        this.selectDefaultTrack = true;
      };
      _proto.onManifestParsed = function onManifestParsed(event, data) {
        this.tracks = data.subtitleTracks;
      };
      _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {
        var id = data.id, groupId = data.groupId, details = data.details;
        var trackInActiveGroup = this.tracksInGroup[id];
        if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {
          this.warn("Subtitle track with id:" + id + " and group:" + groupId + " not found in active group " + (trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId));
          return;
        }
        var curDetails = trackInActiveGroup.details;
        trackInActiveGroup.details = data.details;
        this.log("Subtitle track " + id + ' "' + trackInActiveGroup.name + '" lang:' + trackInActiveGroup.lang + " group:" + groupId + " loaded [" + details.startSN + "-" + details.endSN + "]");
        if (id === this.trackId) {
          this.playlistLoaded(id, data, curDetails);
        }
      };
      _proto.onLevelLoading = function onLevelLoading(event, data) {
        this.switchLevel(data.level);
      };
      _proto.onLevelSwitching = function onLevelSwitching(event, data) {
        this.switchLevel(data.level);
      };
      _proto.switchLevel = function switchLevel(levelIndex) {
        var levelInfo = this.hls.levels[levelIndex];
        if (!levelInfo) {
          return;
        }
        var subtitleGroups = levelInfo.subtitleGroups || null;
        var currentGroups = this.groupIds;
        var currentTrack = this.currentTrack;
        if (!subtitleGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (subtitleGroups == null ? void 0 : subtitleGroups.length) || subtitleGroups != null && subtitleGroups.some(function(groupId) {
          return (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1;
        })) {
          this.groupIds = subtitleGroups;
          this.trackId = -1;
          this.currentTrack = null;
          var subtitleTracks = this.tracks.filter(function(track) {
            return !subtitleGroups || subtitleGroups.indexOf(track.groupId) !== -1;
          });
          if (subtitleTracks.length) {
            if (this.selectDefaultTrack && !subtitleTracks.some(function(track) {
              return track.default;
            })) {
              this.selectDefaultTrack = false;
            }
            subtitleTracks.forEach(function(track, i) {
              track.id = i;
            });
          } else if (!currentTrack && !this.tracksInGroup.length) {
            return;
          }
          this.tracksInGroup = subtitleTracks;
          var subtitlePreference = this.hls.config.subtitlePreference;
          if (!currentTrack && subtitlePreference) {
            this.selectDefaultTrack = false;
            var groupIndex = findMatchingOption(subtitlePreference, subtitleTracks);
            if (groupIndex > -1) {
              currentTrack = subtitleTracks[groupIndex];
            } else {
              var allIndex = findMatchingOption(subtitlePreference, this.tracks);
              currentTrack = this.tracks[allIndex];
            }
          }
          var trackId = this.findTrackId(currentTrack);
          if (trackId === -1 && currentTrack) {
            trackId = this.findTrackId(null);
          }
          var subtitleTracksUpdated = {
            subtitleTracks
          };
          this.log("Updating subtitle tracks, " + subtitleTracks.length + ' track(s) found in "' + (subtitleGroups == null ? void 0 : subtitleGroups.join(",")) + '" group-id');
          this.hls.trigger(Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);
          if (trackId !== -1 && this.trackId === -1) {
            this.setSubtitleTrack(trackId);
          }
        } else if (this.shouldReloadPlaylist(currentTrack)) {
          this.setSubtitleTrack(this.trackId);
        }
      };
      _proto.findTrackId = function findTrackId(currentTrack) {
        var tracks = this.tracksInGroup;
        var selectDefault = this.selectDefaultTrack;
        for (var i = 0; i < tracks.length; i++) {
          var track = tracks[i];
          if (selectDefault && !track.default || !selectDefault && !currentTrack) {
            continue;
          }
          if (!currentTrack || matchesOption(track, currentTrack)) {
            return i;
          }
        }
        if (currentTrack) {
          for (var _i = 0; _i < tracks.length; _i++) {
            var _track = tracks[_i];
            if (mediaAttributesIdentical(currentTrack.attrs, _track.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) {
              return _i;
            }
          }
          for (var _i2 = 0; _i2 < tracks.length; _i2++) {
            var _track2 = tracks[_i2];
            if (mediaAttributesIdentical(currentTrack.attrs, _track2.attrs, ["LANGUAGE"])) {
              return _i2;
            }
          }
        }
        return -1;
      };
      _proto.findTrackForTextTrack = function findTrackForTextTrack(textTrack) {
        if (textTrack) {
          var tracks = this.tracksInGroup;
          for (var i = 0; i < tracks.length; i++) {
            var track = tracks[i];
            if (subtitleTrackMatchesTextTrack(track, textTrack)) {
              return i;
            }
          }
        }
        return -1;
      };
      _proto.onError = function onError(event, data) {
        if (data.fatal || !data.context) {
          return;
        }
        if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {
          this.checkRetry(data);
        }
      };
      _proto.setSubtitleOption = function setSubtitleOption(subtitleOption) {
        this.hls.config.subtitlePreference = subtitleOption;
        if (subtitleOption) {
          var allSubtitleTracks = this.allSubtitleTracks;
          this.selectDefaultTrack = false;
          if (allSubtitleTracks.length) {
            var currentTrack = this.currentTrack;
            if (currentTrack && matchesOption(subtitleOption, currentTrack)) {
              return currentTrack;
            }
            var groupIndex = findMatchingOption(subtitleOption, this.tracksInGroup);
            if (groupIndex > -1) {
              var track = this.tracksInGroup[groupIndex];
              this.setSubtitleTrack(groupIndex);
              return track;
            } else if (currentTrack) {
              return null;
            } else {
              var allIndex = findMatchingOption(subtitleOption, allSubtitleTracks);
              if (allIndex > -1) {
                return allSubtitleTracks[allIndex];
              }
            }
          }
        }
        return null;
      };
      _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
        _BasePlaylistControll.prototype.loadPlaylist.call(this);
        var currentTrack = this.currentTrack;
        if (this.shouldLoadPlaylist(currentTrack) && currentTrack) {
          var id = currentTrack.id;
          var groupId = currentTrack.groupId;
          var url = currentTrack.url;
          if (hlsUrlParameters) {
            try {
              url = hlsUrlParameters.addDirectives(url);
            } catch (error) {
              this.warn("Could not construct new URL with HLS Delivery Directives: " + error);
            }
          }
          this.log("Loading subtitle playlist for id " + id);
          this.hls.trigger(Events.SUBTITLE_TRACK_LOADING, {
            url,
            id,
            groupId,
            deliveryDirectives: hlsUrlParameters || null
          });
        }
      };
      _proto.toggleTrackModes = function toggleTrackModes() {
        var media = this.media;
        if (!media) {
          return;
        }
        var textTracks = filterSubtitleTracks(media.textTracks);
        var currentTrack = this.currentTrack;
        var nextTrack;
        if (currentTrack) {
          nextTrack = textTracks.filter(function(textTrack) {
            return subtitleTrackMatchesTextTrack(currentTrack, textTrack);
          })[0];
          if (!nextTrack) {
            this.warn('Unable to find subtitle TextTrack with name "' + currentTrack.name + '" and language "' + currentTrack.lang + '"');
          }
        }
        [].slice.call(textTracks).forEach(function(track) {
          if (track.mode !== "disabled" && track !== nextTrack) {
            track.mode = "disabled";
          }
        });
        if (nextTrack) {
          var mode = this.subtitleDisplay ? "showing" : "hidden";
          if (nextTrack.mode !== mode) {
            nextTrack.mode = mode;
          }
        }
      };
      _proto.setSubtitleTrack = function setSubtitleTrack(newId) {
        var tracks = this.tracksInGroup;
        if (!this.media) {
          this.queuedDefaultTrack = newId;
          return;
        }
        if (newId < -1 || newId >= tracks.length || !isFiniteNumber(newId)) {
          this.warn("Invalid subtitle track id: " + newId);
          return;
        }
        this.clearTimer();
        this.selectDefaultTrack = false;
        var lastTrack = this.currentTrack;
        var track = tracks[newId] || null;
        this.trackId = newId;
        this.currentTrack = track;
        this.toggleTrackModes();
        if (!track) {
          this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {
            id: newId
          });
          return;
        }
        var trackLoaded = !!track.details && !track.details.live;
        if (newId === this.trackId && track === lastTrack && trackLoaded) {
          return;
        }
        this.log("Switching to subtitle-track " + newId + (track ? ' "' + track.name + '" lang:' + track.lang + " group:" + track.groupId : ""));
        var id = track.id, _track$groupId = track.groupId, groupId = _track$groupId === void 0 ? "" : _track$groupId, name = track.name, type = track.type, url = track.url;
        this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {
          id,
          groupId,
          name,
          type,
          url
        });
        var hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details);
        this.loadPlaylist(hlsUrlParameters);
      };
      _createClass(SubtitleTrackController2, [{
        key: "subtitleDisplay",
        get: function get() {
          return this._subtitleDisplay;
        },
        set: function set(value) {
          this._subtitleDisplay = value;
          if (this.trackId > -1) {
            this.toggleTrackModes();
          }
        }
      }, {
        key: "allSubtitleTracks",
        get: function get() {
          return this.tracks;
        }
        /** get alternate subtitle tracks list from playlist **/
      }, {
        key: "subtitleTracks",
        get: function get() {
          return this.tracksInGroup;
        }
        /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/
      }, {
        key: "subtitleTrack",
        get: function get() {
          return this.trackId;
        },
        set: function set(newId) {
          this.selectDefaultTrack = false;
          this.setSubtitleTrack(newId);
        }
      }]);
      return SubtitleTrackController2;
    }(BasePlaylistController);
    var BufferOperationQueue = /* @__PURE__ */ function() {
      function BufferOperationQueue2(sourceBufferReference) {
        this.buffers = void 0;
        this.queues = {
          video: [],
          audio: [],
          audiovideo: []
        };
        this.buffers = sourceBufferReference;
      }
      var _proto = BufferOperationQueue2.prototype;
      _proto.append = function append(operation, type, pending) {
        var queue = this.queues[type];
        queue.push(operation);
        if (queue.length === 1 && !pending) {
          this.executeNext(type);
        }
      };
      _proto.insertAbort = function insertAbort(operation, type) {
        var queue = this.queues[type];
        queue.unshift(operation);
        this.executeNext(type);
      };
      _proto.appendBlocker = function appendBlocker(type) {
        var execute;
        var promise = new Promise(function(resolve) {
          execute = resolve;
        });
        var operation = {
          execute,
          onStart: function onStart() {
          },
          onComplete: function onComplete() {
          },
          onError: function onError() {
          }
        };
        this.append(operation, type);
        return promise;
      };
      _proto.executeNext = function executeNext(type) {
        var queue = this.queues[type];
        if (queue.length) {
          var operation = queue[0];
          try {
            operation.execute();
          } catch (error) {
            logger.warn('[buffer-operation-queue]: Exception executing "' + type + '" SourceBuffer operation: ' + error);
            operation.onError(error);
            var sb = this.buffers[type];
            if (!(sb != null && sb.updating)) {
              this.shiftAndExecuteNext(type);
            }
          }
        }
      };
      _proto.shiftAndExecuteNext = function shiftAndExecuteNext(type) {
        this.queues[type].shift();
        this.executeNext(type);
      };
      _proto.current = function current(type) {
        return this.queues[type][0];
      };
      return BufferOperationQueue2;
    }();
    var VIDEO_CODEC_PROFILE_REPLACE = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/;
    var BufferController = /* @__PURE__ */ function() {
      function BufferController2(hls) {
        var _this = this;
        this.details = null;
        this._objectUrl = null;
        this.operationQueue = void 0;
        this.listeners = void 0;
        this.hls = void 0;
        this.bufferCodecEventsExpected = 0;
        this._bufferCodecEventsTotal = 0;
        this.media = null;
        this.mediaSource = null;
        this.lastMpegAudioChunk = null;
        this.appendSource = void 0;
        this.appendErrors = {
          audio: 0,
          video: 0,
          audiovideo: 0
        };
        this.tracks = {};
        this.pendingTracks = {};
        this.sourceBuffer = void 0;
        this.log = void 0;
        this.warn = void 0;
        this.error = void 0;
        this._onEndStreaming = function(event) {
          if (!_this.hls) {
            return;
          }
          _this.hls.pauseBuffering();
        };
        this._onStartStreaming = function(event) {
          if (!_this.hls) {
            return;
          }
          _this.hls.resumeBuffering();
        };
        this._onMediaSourceOpen = function() {
          var media = _this.media, mediaSource = _this.mediaSource;
          _this.log("Media source opened");
          if (media) {
            media.removeEventListener("emptied", _this._onMediaEmptied);
            _this.updateMediaElementDuration();
            _this.hls.trigger(Events.MEDIA_ATTACHED, {
              media,
              mediaSource
            });
          }
          if (mediaSource) {
            mediaSource.removeEventListener("sourceopen", _this._onMediaSourceOpen);
          }
          _this.checkPendingTracks();
        };
        this._onMediaSourceClose = function() {
          _this.log("Media source closed");
        };
        this._onMediaSourceEnded = function() {
          _this.log("Media source ended");
        };
        this._onMediaEmptied = function() {
          var mediaSrc = _this.mediaSrc, _objectUrl = _this._objectUrl;
          if (mediaSrc !== _objectUrl) {
            logger.error("Media element src was set while attaching MediaSource (" + _objectUrl + " > " + mediaSrc + ")");
          }
        };
        this.hls = hls;
        var logPrefix = "[buffer-controller]";
        this.appendSource = hls.config.preferManagedMediaSource;
        this.log = logger.log.bind(logger, logPrefix);
        this.warn = logger.warn.bind(logger, logPrefix);
        this.error = logger.error.bind(logger, logPrefix);
        this._initSourceBuffer();
        this.registerListeners();
      }
      var _proto = BufferController2.prototype;
      _proto.hasSourceTypes = function hasSourceTypes() {
        return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;
      };
      _proto.destroy = function destroy() {
        this.unregisterListeners();
        this.details = null;
        this.lastMpegAudioChunk = null;
        this.hls = null;
      };
      _proto.registerListeners = function registerListeners() {
        var hls = this.hls;
        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
        hls.on(Events.BUFFER_RESET, this.onBufferReset, this);
        hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);
        hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);
        hls.on(Events.BUFFER_EOS, this.onBufferEos, this);
        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
        hls.on(Events.FRAG_PARSED, this.onFragParsed, this);
        hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);
      };
      _proto.unregisterListeners = function unregisterListeners() {
        var hls = this.hls;
        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
        hls.off(Events.BUFFER_RESET, this.onBufferReset, this);
        hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);
        hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
        hls.off(Events.BUFFER_EOS, this.onBufferEos, this);
        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
        hls.off(Events.FRAG_PARSED, this.onFragParsed, this);
        hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);
      };
      _proto._initSourceBuffer = function _initSourceBuffer() {
        this.sourceBuffer = {};
        this.operationQueue = new BufferOperationQueue(this.sourceBuffer);
        this.listeners = {
          audio: [],
          video: [],
          audiovideo: []
        };
        this.appendErrors = {
          audio: 0,
          video: 0,
          audiovideo: 0
        };
        this.lastMpegAudioChunk = null;
      };
      _proto.onManifestLoading = function onManifestLoading() {
        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0;
        this.details = null;
      };
      _proto.onManifestParsed = function onManifestParsed(event, data) {
        var codecEvents = 2;
        if (data.audio && !data.video || !data.altAudio || false) {
          codecEvents = 1;
        }
        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;
        this.log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected");
      };
      _proto.onMediaAttaching = function onMediaAttaching(event, data) {
        var media = this.media = data.media;
        var MediaSource2 = getMediaSource(this.appendSource);
        if (media && MediaSource2) {
          var _ms$constructor;
          var ms = this.mediaSource = new MediaSource2();
          this.log("created media source: " + ((_ms$constructor = ms.constructor) == null ? void 0 : _ms$constructor.name));
          ms.addEventListener("sourceopen", this._onMediaSourceOpen);
          ms.addEventListener("sourceended", this._onMediaSourceEnded);
          ms.addEventListener("sourceclose", this._onMediaSourceClose);
          ms.addEventListener("startstreaming", this._onStartStreaming);
          ms.addEventListener("endstreaming", this._onEndStreaming);
          var objectUrl = this._objectUrl = self.URL.createObjectURL(ms);
          if (this.appendSource) {
            try {
              media.removeAttribute("src");
              var MMS = self.ManagedMediaSource;
              media.disableRemotePlayback = media.disableRemotePlayback || MMS && ms instanceof MMS;
              removeSourceChildren(media);
              addSource(media, objectUrl);
              media.load();
            } catch (error) {
              media.src = objectUrl;
            }
          } else {
            media.src = objectUrl;
          }
          media.addEventListener("emptied", this._onMediaEmptied);
        }
      };
      _proto.onMediaDetaching = function onMediaDetaching() {
        var media = this.media, mediaSource = this.mediaSource, _objectUrl = this._objectUrl;
        if (mediaSource) {
          this.log("media source detaching");
          if (mediaSource.readyState === "open") {
            try {
              mediaSource.endOfStream();
            } catch (err) {
              this.warn("onMediaDetaching: " + err.message + " while calling endOfStream");
            }
          }
          this.onBufferReset();
          mediaSource.removeEventListener("sourceopen", this._onMediaSourceOpen);
          mediaSource.removeEventListener("sourceended", this._onMediaSourceEnded);
          mediaSource.removeEventListener("sourceclose", this._onMediaSourceClose);
          mediaSource.removeEventListener("startstreaming", this._onStartStreaming);
          mediaSource.removeEventListener("endstreaming", this._onEndStreaming);
          if (media) {
            media.removeEventListener("emptied", this._onMediaEmptied);
            if (_objectUrl) {
              self.URL.revokeObjectURL(_objectUrl);
            }
            if (this.mediaSrc === _objectUrl) {
              media.removeAttribute("src");
              if (this.appendSource) {
                removeSourceChildren(media);
              }
              media.load();
            } else {
              this.warn("media|source.src was changed by a third party - skip cleanup");
            }
          }
          this.mediaSource = null;
          this.media = null;
          this._objectUrl = null;
          this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;
          this.pendingTracks = {};
          this.tracks = {};
        }
        this.hls.trigger(Events.MEDIA_DETACHED, void 0);
      };
      _proto.onBufferReset = function onBufferReset() {
        var _this2 = this;
        this.getSourceBufferTypes().forEach(function(type) {
          _this2.resetBuffer(type);
        });
        this._initSourceBuffer();
      };
      _proto.resetBuffer = function resetBuffer(type) {
        var sb = this.sourceBuffer[type];
        try {
          if (sb) {
            var _this$mediaSource;
            this.removeBufferListeners(type);
            this.sourceBuffer[type] = void 0;
            if ((_this$mediaSource = this.mediaSource) != null && _this$mediaSource.sourceBuffers.length) {
              this.mediaSource.removeSourceBuffer(sb);
            }
          }
        } catch (err) {
          this.warn("onBufferReset " + type, err);
        }
      };
      _proto.onBufferCodecs = function onBufferCodecs(event, data) {
        var _this3 = this;
        var sourceBufferCount = this.getSourceBufferTypes().length;
        var trackNames = Object.keys(data);
        trackNames.forEach(function(trackName) {
          if (sourceBufferCount) {
            var track = _this3.tracks[trackName];
            if (track && typeof track.buffer.changeType === "function") {
              var _trackCodec;
              var _data$trackName = data[trackName], id = _data$trackName.id, codec = _data$trackName.codec, levelCodec = _data$trackName.levelCodec, container = _data$trackName.container, metadata = _data$trackName.metadata;
              var currentCodecFull = pickMostCompleteCodecName(track.codec, track.levelCodec);
              var currentCodec = currentCodecFull == null ? void 0 : currentCodecFull.replace(VIDEO_CODEC_PROFILE_REPLACE, "$1");
              var trackCodec = pickMostCompleteCodecName(codec, levelCodec);
              var nextCodec = (_trackCodec = trackCodec) == null ? void 0 : _trackCodec.replace(VIDEO_CODEC_PROFILE_REPLACE, "$1");
              if (trackCodec && currentCodec !== nextCodec) {
                if (trackName.slice(0, 5) === "audio") {
                  trackCodec = getCodecCompatibleName(trackCodec, _this3.hls.config.preferManagedMediaSource);
                }
                var mimeType = container + ";codecs=" + trackCodec;
                _this3.appendChangeType(trackName, mimeType);
                _this3.log("switching codec " + currentCodecFull + " to " + trackCodec);
                _this3.tracks[trackName] = {
                  buffer: track.buffer,
                  codec,
                  container,
                  levelCodec,
                  metadata,
                  id
                };
              }
            }
          } else {
            _this3.pendingTracks[trackName] = data[trackName];
          }
        });
        if (sourceBufferCount) {
          return;
        }
        var bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);
        if (this.bufferCodecEventsExpected !== bufferCodecEventsExpected) {
          this.log(bufferCodecEventsExpected + " bufferCodec event(s) expected " + trackNames.join(","));
          this.bufferCodecEventsExpected = bufferCodecEventsExpected;
        }
        if (this.mediaSource && this.mediaSource.readyState === "open") {
          this.checkPendingTracks();
        }
      };
      _proto.appendChangeType = function appendChangeType(type, mimeType) {
        var _this4 = this;
        var operationQueue = this.operationQueue;
        var operation = {
          execute: function execute() {
            var sb = _this4.sourceBuffer[type];
            if (sb) {
              _this4.log("changing " + type + " sourceBuffer type to " + mimeType);
              sb.changeType(mimeType);
            }
            operationQueue.shiftAndExecuteNext(type);
          },
          onStart: function onStart() {
          },
          onComplete: function onComplete() {
          },
          onError: function onError(error) {
            _this4.warn("Failed to change " + type + " SourceBuffer type", error);
          }
        };
        operationQueue.append(operation, type, !!this.pendingTracks[type]);
      };
      _proto.onBufferAppending = function onBufferAppending(event, eventData) {
        var _this5 = this;
        var hls = this.hls, operationQueue = this.operationQueue, tracks = this.tracks;
        var data = eventData.data, type = eventData.type, frag = eventData.frag, part = eventData.part, chunkMeta = eventData.chunkMeta;
        var chunkStats = chunkMeta.buffering[type];
        var bufferAppendingStart = self.performance.now();
        chunkStats.start = bufferAppendingStart;
        var fragBuffering = frag.stats.buffering;
        var partBuffering = part ? part.stats.buffering : null;
        if (fragBuffering.start === 0) {
          fragBuffering.start = bufferAppendingStart;
        }
        if (partBuffering && partBuffering.start === 0) {
          partBuffering.start = bufferAppendingStart;
        }
        var audioTrack = tracks.audio;
        var checkTimestampOffset = false;
        if (type === "audio" && (audioTrack == null ? void 0 : audioTrack.container) === "audio/mpeg") {
          checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;
          this.lastMpegAudioChunk = chunkMeta;
        }
        var fragStart = frag.start;
        var operation = {
          execute: function execute() {
            chunkStats.executeStart = self.performance.now();
            if (checkTimestampOffset) {
              var sb = _this5.sourceBuffer[type];
              if (sb) {
                var delta = fragStart - sb.timestampOffset;
                if (Math.abs(delta) >= 0.1) {
                  _this5.log("Updating audio SourceBuffer timestampOffset to " + fragStart + " (delta: " + delta + ") sn: " + frag.sn + ")");
                  sb.timestampOffset = fragStart;
                }
              }
            }
            _this5.appendExecutor(data, type);
          },
          onStart: function onStart() {
          },
          onComplete: function onComplete() {
            var end = self.performance.now();
            chunkStats.executeEnd = chunkStats.end = end;
            if (fragBuffering.first === 0) {
              fragBuffering.first = end;
            }
            if (partBuffering && partBuffering.first === 0) {
              partBuffering.first = end;
            }
            var sourceBuffer = _this5.sourceBuffer;
            var timeRanges = {};
            for (var _type in sourceBuffer) {
              timeRanges[_type] = BufferHelper.getBuffered(sourceBuffer[_type]);
            }
            _this5.appendErrors[type] = 0;
            if (type === "audio" || type === "video") {
              _this5.appendErrors.audiovideo = 0;
            } else {
              _this5.appendErrors.audio = 0;
              _this5.appendErrors.video = 0;
            }
            _this5.hls.trigger(Events.BUFFER_APPENDED, {
              type,
              frag,
              part,
              chunkMeta,
              parent: frag.type,
              timeRanges
            });
          },
          onError: function onError(error) {
            var event2 = {
              type: ErrorTypes.MEDIA_ERROR,
              parent: frag.type,
              details: ErrorDetails.BUFFER_APPEND_ERROR,
              sourceBufferName: type,
              frag,
              part,
              chunkMeta,
              error,
              err: error,
              fatal: false
            };
            if (error.code === DOMException.QUOTA_EXCEEDED_ERR) {
              event2.details = ErrorDetails.BUFFER_FULL_ERROR;
            } else {
              var appendErrorCount = ++_this5.appendErrors[type];
              event2.details = ErrorDetails.BUFFER_APPEND_ERROR;
              _this5.warn("Failed " + appendErrorCount + "/" + hls.config.appendErrorMaxRetry + ' times to append segment in "' + type + '" sourceBuffer');
              if (appendErrorCount >= hls.config.appendErrorMaxRetry) {
                event2.fatal = true;
              }
            }
            hls.trigger(Events.ERROR, event2);
          }
        };
        operationQueue.append(operation, type, !!this.pendingTracks[type]);
      };
      _proto.onBufferFlushing = function onBufferFlushing(event, data) {
        var _this6 = this;
        var operationQueue = this.operationQueue;
        var flushOperation = function flushOperation2(type) {
          return {
            execute: _this6.removeExecutor.bind(_this6, type, data.startOffset, data.endOffset),
            onStart: function onStart() {
            },
            onComplete: function onComplete() {
              _this6.hls.trigger(Events.BUFFER_FLUSHED, {
                type
              });
            },
            onError: function onError(error) {
              _this6.warn("Failed to remove from " + type + " SourceBuffer", error);
            }
          };
        };
        if (data.type) {
          operationQueue.append(flushOperation(data.type), data.type);
        } else {
          this.getSourceBufferTypes().forEach(function(type) {
            operationQueue.append(flushOperation(type), type);
          });
        }
      };
      _proto.onFragParsed = function onFragParsed(event, data) {
        var _this7 = this;
        var frag = data.frag, part = data.part;
        var buffersAppendedTo = [];
        var elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;
        if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {
          buffersAppendedTo.push("audiovideo");
        } else {
          if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {
            buffersAppendedTo.push("audio");
          }
          if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {
            buffersAppendedTo.push("video");
          }
        }
        var onUnblocked = function onUnblocked2() {
          var now2 = self.performance.now();
          frag.stats.buffering.end = now2;
          if (part) {
            part.stats.buffering.end = now2;
          }
          var stats = part ? part.stats : frag.stats;
          _this7.hls.trigger(Events.FRAG_BUFFERED, {
            frag,
            part,
            stats,
            id: frag.type
          });
        };
        if (buffersAppendedTo.length === 0) {
          this.warn("Fragments must have at least one ElementaryStreamType set. type: " + frag.type + " level: " + frag.level + " sn: " + frag.sn);
        }
        this.blockBuffers(onUnblocked, buffersAppendedTo);
      };
      _proto.onFragChanged = function onFragChanged(event, data) {
        this.trimBuffers();
      };
      _proto.onBufferEos = function onBufferEos(event, data) {
        var _this8 = this;
        var ended = this.getSourceBufferTypes().reduce(function(acc, type) {
          var sb = _this8.sourceBuffer[type];
          if (sb && (!data.type || data.type === type)) {
            sb.ending = true;
            if (!sb.ended) {
              sb.ended = true;
              _this8.log(type + " sourceBuffer now EOS");
            }
          }
          return acc && !!(!sb || sb.ended);
        }, true);
        if (ended) {
          this.log("Queueing mediaSource.endOfStream()");
          this.blockBuffers(function() {
            _this8.getSourceBufferTypes().forEach(function(type) {
              var sb = _this8.sourceBuffer[type];
              if (sb) {
                sb.ending = false;
              }
            });
            var mediaSource = _this8.mediaSource;
            if (!mediaSource || mediaSource.readyState !== "open") {
              if (mediaSource) {
                _this8.log("Could not call mediaSource.endOfStream(). mediaSource.readyState: " + mediaSource.readyState);
              }
              return;
            }
            _this8.log("Calling mediaSource.endOfStream()");
            mediaSource.endOfStream();
          });
        }
      };
      _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {
        var details = _ref.details;
        if (!details.fragments.length) {
          return;
        }
        this.details = details;
        if (this.getSourceBufferTypes().length) {
          this.blockBuffers(this.updateMediaElementDuration.bind(this));
        } else {
          this.updateMediaElementDuration();
        }
      };
      _proto.trimBuffers = function trimBuffers() {
        var hls = this.hls, details = this.details, media = this.media;
        if (!media || details === null) {
          return;
        }
        var sourceBufferTypes = this.getSourceBufferTypes();
        if (!sourceBufferTypes.length) {
          return;
        }
        var config = hls.config;
        var currentTime = media.currentTime;
        var targetDuration = details.levelTargetDuration;
        var backBufferLength = details.live && config.liveBackBufferLength !== null ? config.liveBackBufferLength : config.backBufferLength;
        if (isFiniteNumber(backBufferLength) && backBufferLength > 0) {
          var maxBackBufferLength = Math.max(backBufferLength, targetDuration);
          var targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;
          this.flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition);
        }
        if (isFiniteNumber(config.frontBufferFlushThreshold) && config.frontBufferFlushThreshold > 0) {
          var frontBufferLength = Math.max(config.maxBufferLength, config.frontBufferFlushThreshold);
          var maxFrontBufferLength = Math.max(frontBufferLength, targetDuration);
          var targetFrontBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration + maxFrontBufferLength;
          this.flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition);
        }
      };
      _proto.flushBackBuffer = function flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition) {
        var _this9 = this;
        var details = this.details, sourceBuffer = this.sourceBuffer;
        var sourceBufferTypes = this.getSourceBufferTypes();
        sourceBufferTypes.forEach(function(type) {
          var sb = sourceBuffer[type];
          if (sb) {
            var buffered = BufferHelper.getBuffered(sb);
            if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
              _this9.hls.trigger(Events.BACK_BUFFER_REACHED, {
                bufferEnd: targetBackBufferPosition
              });
              if (details != null && details.live) {
                _this9.hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {
                  bufferEnd: targetBackBufferPosition
                });
              } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {
                _this9.log("Cannot flush " + type + " back buffer while SourceBuffer is in ended state");
                return;
              }
              _this9.hls.trigger(Events.BUFFER_FLUSHING, {
                startOffset: 0,
                endOffset: targetBackBufferPosition,
                type
              });
            }
          }
        });
      };
      _proto.flushFrontBuffer = function flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition) {
        var _this10 = this;
        var sourceBuffer = this.sourceBuffer;
        var sourceBufferTypes = this.getSourceBufferTypes();
        sourceBufferTypes.forEach(function(type) {
          var sb = sourceBuffer[type];
          if (sb) {
            var buffered = BufferHelper.getBuffered(sb);
            var numBufferedRanges = buffered.length;
            if (numBufferedRanges < 2) {
              return;
            }
            var bufferStart = buffered.start(numBufferedRanges - 1);
            var bufferEnd = buffered.end(numBufferedRanges - 1);
            if (targetFrontBufferPosition > bufferStart || currentTime >= bufferStart && currentTime <= bufferEnd) {
              return;
            } else if (sb.ended && currentTime - bufferEnd < 2 * targetDuration) {
              _this10.log("Cannot flush " + type + " front buffer while SourceBuffer is in ended state");
              return;
            }
            _this10.hls.trigger(Events.BUFFER_FLUSHING, {
              startOffset: bufferStart,
              endOffset: Infinity,
              type
            });
          }
        });
      };
      _proto.updateMediaElementDuration = function updateMediaElementDuration() {
        if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== "open") {
          return;
        }
        var details = this.details, hls = this.hls, media = this.media, mediaSource = this.mediaSource;
        var levelDuration = details.fragments[0].start + details.totalduration;
        var mediaDuration = media.duration;
        var msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;
        if (details.live && hls.config.liveDurationInfinity) {
          mediaSource.duration = Infinity;
          this.updateSeekableRange(details);
        } else if (levelDuration > msDuration && levelDuration > mediaDuration || !isFiniteNumber(mediaDuration)) {
          this.log("Updating Media Source duration to " + levelDuration.toFixed(3));
          mediaSource.duration = levelDuration;
        }
      };
      _proto.updateSeekableRange = function updateSeekableRange(levelDetails) {
        var mediaSource = this.mediaSource;
        var fragments = levelDetails.fragments;
        var len = fragments.length;
        if (len && levelDetails.live && mediaSource != null && mediaSource.setLiveSeekableRange) {
          var start = Math.max(0, fragments[0].start);
          var end = Math.max(start, start + levelDetails.totalduration);
          this.log("Media Source duration is set to " + mediaSource.duration + ". Setting seekable range to " + start + "-" + end + ".");
          mediaSource.setLiveSeekableRange(start, end);
        }
      };
      _proto.checkPendingTracks = function checkPendingTracks() {
        var bufferCodecEventsExpected = this.bufferCodecEventsExpected, operationQueue = this.operationQueue, pendingTracks = this.pendingTracks;
        var pendingTracksCount = Object.keys(pendingTracks).length;
        if (pendingTracksCount && (!bufferCodecEventsExpected || pendingTracksCount === 2 || "audiovideo" in pendingTracks)) {
          this.createSourceBuffers(pendingTracks);
          this.pendingTracks = {};
          var buffers = this.getSourceBufferTypes();
          if (buffers.length) {
            this.hls.trigger(Events.BUFFER_CREATED, {
              tracks: this.tracks
            });
            buffers.forEach(function(type) {
              operationQueue.executeNext(type);
            });
          } else {
            var error = new Error("could not create source buffer for media codec(s)");
            this.hls.trigger(Events.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,
              fatal: true,
              error,
              reason: error.message
            });
          }
        }
      };
      _proto.createSourceBuffers = function createSourceBuffers(tracks) {
        var _this11 = this;
        var sourceBuffer = this.sourceBuffer, mediaSource = this.mediaSource;
        if (!mediaSource) {
          throw Error("createSourceBuffers called when mediaSource was null");
        }
        var _loop = function _loop2(trackName2) {
          if (!sourceBuffer[trackName2]) {
            var track = tracks[trackName2];
            if (!track) {
              throw Error("source buffer exists for track " + trackName2 + ", however track does not");
            }
            var codec = track.levelCodec || track.codec;
            if (codec) {
              if (trackName2.slice(0, 5) === "audio") {
                codec = getCodecCompatibleName(codec, _this11.hls.config.preferManagedMediaSource);
              }
            }
            var mimeType = track.container + ";codecs=" + codec;
            _this11.log("creating sourceBuffer(" + mimeType + ")");
            try {
              var sb = sourceBuffer[trackName2] = mediaSource.addSourceBuffer(mimeType);
              var sbName = trackName2;
              _this11.addBufferListener(sbName, "updatestart", _this11._onSBUpdateStart);
              _this11.addBufferListener(sbName, "updateend", _this11._onSBUpdateEnd);
              _this11.addBufferListener(sbName, "error", _this11._onSBUpdateError);
              _this11.addBufferListener(sbName, "bufferedchange", function(type, event) {
                var removedRanges = event.removedRanges;
                if (removedRanges != null && removedRanges.length) {
                  _this11.hls.trigger(Events.BUFFER_FLUSHED, {
                    type: trackName2
                  });
                }
              });
              _this11.tracks[trackName2] = {
                buffer: sb,
                codec,
                container: track.container,
                levelCodec: track.levelCodec,
                metadata: track.metadata,
                id: track.id
              };
            } catch (err) {
              _this11.error("error while trying to add sourceBuffer: " + err.message);
              _this11.hls.trigger(Events.ERROR, {
                type: ErrorTypes.MEDIA_ERROR,
                details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,
                fatal: false,
                error: err,
                sourceBufferName: trackName2,
                mimeType
              });
            }
          }
        };
        for (var trackName in tracks) {
          _loop(trackName);
        }
      };
      _proto._onSBUpdateStart = function _onSBUpdateStart(type) {
        var operationQueue = this.operationQueue;
        var operation = operationQueue.current(type);
        operation.onStart();
      };
      _proto._onSBUpdateEnd = function _onSBUpdateEnd(type) {
        var _this$mediaSource2;
        if (((_this$mediaSource2 = this.mediaSource) == null ? void 0 : _this$mediaSource2.readyState) === "closed") {
          this.resetBuffer(type);
          return;
        }
        var operationQueue = this.operationQueue;
        var operation = operationQueue.current(type);
        operation.onComplete();
        operationQueue.shiftAndExecuteNext(type);
      };
      _proto._onSBUpdateError = function _onSBUpdateError(type, event) {
        var _this$mediaSource3;
        var error = new Error(type + " SourceBuffer error. MediaSource readyState: " + ((_this$mediaSource3 = this.mediaSource) == null ? void 0 : _this$mediaSource3.readyState));
        this.error("" + error, event);
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.BUFFER_APPENDING_ERROR,
          sourceBufferName: type,
          error,
          fatal: false
        });
        var operation = this.operationQueue.current(type);
        if (operation) {
          operation.onError(error);
        }
      };
      _proto.removeExecutor = function removeExecutor(type, startOffset, endOffset) {
        var media = this.media, mediaSource = this.mediaSource, operationQueue = this.operationQueue, sourceBuffer = this.sourceBuffer;
        var sb = sourceBuffer[type];
        if (!media || !mediaSource || !sb) {
          this.warn("Attempting to remove from the " + type + " SourceBuffer, but it does not exist");
          operationQueue.shiftAndExecuteNext(type);
          return;
        }
        var mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;
        var msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;
        var removeStart = Math.max(0, startOffset);
        var removeEnd = Math.min(endOffset, mediaDuration, msDuration);
        if (removeEnd > removeStart && (!sb.ending || sb.ended)) {
          sb.ended = false;
          this.log("Removing [" + removeStart + "," + removeEnd + "] from the " + type + " SourceBuffer");
          sb.remove(removeStart, removeEnd);
        } else {
          operationQueue.shiftAndExecuteNext(type);
        }
      };
      _proto.appendExecutor = function appendExecutor(data, type) {
        var sb = this.sourceBuffer[type];
        if (!sb) {
          if (!this.pendingTracks[type]) {
            throw new Error("Attempting to append to the " + type + " SourceBuffer, but it does not exist");
          }
          return;
        }
        sb.ended = false;
        sb.appendBuffer(data);
      };
      _proto.blockBuffers = function blockBuffers(onUnblocked, buffers) {
        var _this12 = this;
        if (buffers === void 0) {
          buffers = this.getSourceBufferTypes();
        }
        if (!buffers.length) {
          this.log("Blocking operation requested, but no SourceBuffers exist");
          Promise.resolve().then(onUnblocked);
          return;
        }
        var operationQueue = this.operationQueue;
        var blockingOperations = buffers.map(function(type) {
          return operationQueue.appendBlocker(type);
        });
        Promise.all(blockingOperations).then(function() {
          onUnblocked();
          buffers.forEach(function(type) {
            var sb = _this12.sourceBuffer[type];
            if (!(sb != null && sb.updating)) {
              operationQueue.shiftAndExecuteNext(type);
            }
          });
        });
      };
      _proto.getSourceBufferTypes = function getSourceBufferTypes() {
        return Object.keys(this.sourceBuffer);
      };
      _proto.addBufferListener = function addBufferListener(type, event, fn) {
        var buffer = this.sourceBuffer[type];
        if (!buffer) {
          return;
        }
        var listener = fn.bind(this, type);
        this.listeners[type].push({
          event,
          listener
        });
        buffer.addEventListener(event, listener);
      };
      _proto.removeBufferListeners = function removeBufferListeners(type) {
        var buffer = this.sourceBuffer[type];
        if (!buffer) {
          return;
        }
        this.listeners[type].forEach(function(l) {
          buffer.removeEventListener(l.event, l.listener);
        });
      };
      _createClass(BufferController2, [{
        key: "mediaSrc",
        get: function get() {
          var _this$media;
          var media = ((_this$media = this.media) == null ? void 0 : _this$media.firstChild) || this.media;
          return media == null ? void 0 : media.src;
        }
      }]);
      return BufferController2;
    }();
    function removeSourceChildren(node) {
      var sourceChildren = node.querySelectorAll("source");
      [].slice.call(sourceChildren).forEach(function(source) {
        node.removeChild(source);
      });
    }
    function addSource(media, url) {
      var source = self.document.createElement("source");
      source.type = "video/mp4";
      source.src = url;
      media.appendChild(source);
    }
    var specialCea608CharsCodes = {
      42: 225,
      // lowercase a, acute accent
      92: 233,
      // lowercase e, acute accent
      94: 237,
      // lowercase i, acute accent
      95: 243,
      // lowercase o, acute accent
      96: 250,
      // lowercase u, acute accent
      123: 231,
      // lowercase c with cedilla
      124: 247,
      // division symbol
      125: 209,
      // uppercase N tilde
      126: 241,
      // lowercase n tilde
      127: 9608,
      // Full block
      // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
      // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
      // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
      128: 174,
      // Registered symbol (R)
      129: 176,
      // degree sign
      130: 189,
      // 1/2 symbol
      131: 191,
      // Inverted (open) question mark
      132: 8482,
      // Trademark symbol (TM)
      133: 162,
      // Cents symbol
      134: 163,
      // Pounds sterling
      135: 9834,
      // Music 8'th note
      136: 224,
      // lowercase a, grave accent
      137: 32,
      // transparent space (regular)
      138: 232,
      // lowercase e, grave accent
      139: 226,
      // lowercase a, circumflex accent
      140: 234,
      // lowercase e, circumflex accent
      141: 238,
      // lowercase i, circumflex accent
      142: 244,
      // lowercase o, circumflex accent
      143: 251,
      // lowercase u, circumflex accent
      // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
      // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
      144: 193,
      // capital letter A with acute
      145: 201,
      // capital letter E with acute
      146: 211,
      // capital letter O with acute
      147: 218,
      // capital letter U with acute
      148: 220,
      // capital letter U with diaresis
      149: 252,
      // lowercase letter U with diaeresis
      150: 8216,
      // opening single quote
      151: 161,
      // inverted exclamation mark
      152: 42,
      // asterisk
      153: 8217,
      // closing single quote
      154: 9473,
      // box drawings heavy horizontal
      155: 169,
      // copyright sign
      156: 8480,
      // Service mark
      157: 8226,
      // (round) bullet
      158: 8220,
      // Left double quotation mark
      159: 8221,
      // Right double quotation mark
      160: 192,
      // uppercase A, grave accent
      161: 194,
      // uppercase A, circumflex
      162: 199,
      // uppercase C with cedilla
      163: 200,
      // uppercase E, grave accent
      164: 202,
      // uppercase E, circumflex
      165: 203,
      // capital letter E with diaresis
      166: 235,
      // lowercase letter e with diaresis
      167: 206,
      // uppercase I, circumflex
      168: 207,
      // uppercase I, with diaresis
      169: 239,
      // lowercase i, with diaresis
      170: 212,
      // uppercase O, circumflex
      171: 217,
      // uppercase U, grave accent
      172: 249,
      // lowercase u, grave accent
      173: 219,
      // uppercase U, circumflex
      174: 171,
      // left-pointing double angle quotation mark
      175: 187,
      // right-pointing double angle quotation mark
      // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
      // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
      176: 195,
      // Uppercase A, tilde
      177: 227,
      // Lowercase a, tilde
      178: 205,
      // Uppercase I, acute accent
      179: 204,
      // Uppercase I, grave accent
      180: 236,
      // Lowercase i, grave accent
      181: 210,
      // Uppercase O, grave accent
      182: 242,
      // Lowercase o, grave accent
      183: 213,
      // Uppercase O, tilde
      184: 245,
      // Lowercase o, tilde
      185: 123,
      // Open curly brace
      186: 125,
      // Closing curly brace
      187: 92,
      // Backslash
      188: 94,
      // Caret
      189: 95,
      // Underscore
      190: 124,
      // Pipe (vertical line)
      191: 8764,
      // Tilde operator
      192: 196,
      // Uppercase A, umlaut
      193: 228,
      // Lowercase A, umlaut
      194: 214,
      // Uppercase O, umlaut
      195: 246,
      // Lowercase o, umlaut
      196: 223,
      // Esszett (sharp S)
      197: 165,
      // Yen symbol
      198: 164,
      // Generic currency sign
      199: 9475,
      // Box drawings heavy vertical
      200: 197,
      // Uppercase A, ring
      201: 229,
      // Lowercase A, ring
      202: 216,
      // Uppercase O, stroke
      203: 248,
      // Lowercase o, strok
      204: 9487,
      // Box drawings heavy down and right
      205: 9491,
      // Box drawings heavy down and left
      206: 9495,
      // Box drawings heavy up and right
      207: 9499
      // Box drawings heavy up and left
    };
    var getCharForByte = function getCharForByte2(_byte) {
      var charCode = _byte;
      if (specialCea608CharsCodes.hasOwnProperty(_byte)) {
        charCode = specialCea608CharsCodes[_byte];
      }
      return String.fromCharCode(charCode);
    };
    var NR_ROWS = 15;
    var NR_COLS = 100;
    var rowsLowCh1 = {
      17: 1,
      18: 3,
      21: 5,
      22: 7,
      23: 9,
      16: 11,
      19: 12,
      20: 14
    };
    var rowsHighCh1 = {
      17: 2,
      18: 4,
      21: 6,
      22: 8,
      23: 10,
      19: 13,
      20: 15
    };
    var rowsLowCh2 = {
      25: 1,
      26: 3,
      29: 5,
      30: 7,
      31: 9,
      24: 11,
      27: 12,
      28: 14
    };
    var rowsHighCh2 = {
      25: 2,
      26: 4,
      29: 6,
      30: 8,
      31: 10,
      27: 13,
      28: 15
    };
    var backgroundColors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
    var CaptionsLogger = /* @__PURE__ */ function() {
      function CaptionsLogger2() {
        this.time = null;
        this.verboseLevel = 0;
      }
      var _proto = CaptionsLogger2.prototype;
      _proto.log = function log(severity, msg) {
        if (this.verboseLevel >= severity) {
          var m = typeof msg === "function" ? msg() : msg;
          logger.log(this.time + " [" + severity + "] " + m);
        }
      };
      return CaptionsLogger2;
    }();
    var numArrayToHexArray = function numArrayToHexArray2(numArray) {
      var hexArray = [];
      for (var j = 0; j < numArray.length; j++) {
        hexArray.push(numArray[j].toString(16));
      }
      return hexArray;
    };
    var PenState = /* @__PURE__ */ function() {
      function PenState2() {
        this.foreground = "white";
        this.underline = false;
        this.italics = false;
        this.background = "black";
        this.flash = false;
      }
      var _proto2 = PenState2.prototype;
      _proto2.reset = function reset() {
        this.foreground = "white";
        this.underline = false;
        this.italics = false;
        this.background = "black";
        this.flash = false;
      };
      _proto2.setStyles = function setStyles(styles) {
        var attribs = ["foreground", "underline", "italics", "background", "flash"];
        for (var i = 0; i < attribs.length; i++) {
          var style = attribs[i];
          if (styles.hasOwnProperty(style)) {
            this[style] = styles[style];
          }
        }
      };
      _proto2.isDefault = function isDefault() {
        return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
      };
      _proto2.equals = function equals(other) {
        return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
      };
      _proto2.copy = function copy(newPenState) {
        this.foreground = newPenState.foreground;
        this.underline = newPenState.underline;
        this.italics = newPenState.italics;
        this.background = newPenState.background;
        this.flash = newPenState.flash;
      };
      _proto2.toString = function toString() {
        return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
      };
      return PenState2;
    }();
    var StyledUnicodeChar = /* @__PURE__ */ function() {
      function StyledUnicodeChar2() {
        this.uchar = " ";
        this.penState = new PenState();
      }
      var _proto3 = StyledUnicodeChar2.prototype;
      _proto3.reset = function reset() {
        this.uchar = " ";
        this.penState.reset();
      };
      _proto3.setChar = function setChar(uchar, newPenState) {
        this.uchar = uchar;
        this.penState.copy(newPenState);
      };
      _proto3.setPenState = function setPenState(newPenState) {
        this.penState.copy(newPenState);
      };
      _proto3.equals = function equals(other) {
        return this.uchar === other.uchar && this.penState.equals(other.penState);
      };
      _proto3.copy = function copy(newChar) {
        this.uchar = newChar.uchar;
        this.penState.copy(newChar.penState);
      };
      _proto3.isEmpty = function isEmpty() {
        return this.uchar === " " && this.penState.isDefault();
      };
      return StyledUnicodeChar2;
    }();
    var Row = /* @__PURE__ */ function() {
      function Row2(logger2) {
        this.chars = [];
        this.pos = 0;
        this.currPenState = new PenState();
        this.cueStartTime = null;
        this.logger = void 0;
        for (var i = 0; i < NR_COLS; i++) {
          this.chars.push(new StyledUnicodeChar());
        }
        this.logger = logger2;
      }
      var _proto4 = Row2.prototype;
      _proto4.equals = function equals(other) {
        for (var i = 0; i < NR_COLS; i++) {
          if (!this.chars[i].equals(other.chars[i])) {
            return false;
          }
        }
        return true;
      };
      _proto4.copy = function copy(other) {
        for (var i = 0; i < NR_COLS; i++) {
          this.chars[i].copy(other.chars[i]);
        }
      };
      _proto4.isEmpty = function isEmpty() {
        var empty = true;
        for (var i = 0; i < NR_COLS; i++) {
          if (!this.chars[i].isEmpty()) {
            empty = false;
            break;
          }
        }
        return empty;
      };
      _proto4.setCursor = function setCursor(absPos) {
        if (this.pos !== absPos) {
          this.pos = absPos;
        }
        if (this.pos < 0) {
          this.logger.log(3, "Negative cursor position " + this.pos);
          this.pos = 0;
        } else if (this.pos > NR_COLS) {
          this.logger.log(3, "Too large cursor position " + this.pos);
          this.pos = NR_COLS;
        }
      };
      _proto4.moveCursor = function moveCursor(relPos) {
        var newPos = this.pos + relPos;
        if (relPos > 1) {
          for (var i = this.pos + 1; i < newPos + 1; i++) {
            this.chars[i].setPenState(this.currPenState);
          }
        }
        this.setCursor(newPos);
      };
      _proto4.backSpace = function backSpace() {
        this.moveCursor(-1);
        this.chars[this.pos].setChar(" ", this.currPenState);
      };
      _proto4.insertChar = function insertChar(_byte2) {
        var _this = this;
        if (_byte2 >= 144) {
          this.backSpace();
        }
        var _char = getCharForByte(_byte2);
        if (this.pos >= NR_COLS) {
          this.logger.log(0, function() {
            return "Cannot insert " + _byte2.toString(16) + " (" + _char + ") at position " + _this.pos + ". Skipping it!";
          });
          return;
        }
        this.chars[this.pos].setChar(_char, this.currPenState);
        this.moveCursor(1);
      };
      _proto4.clearFromPos = function clearFromPos(startPos) {
        var i;
        for (i = startPos; i < NR_COLS; i++) {
          this.chars[i].reset();
        }
      };
      _proto4.clear = function clear() {
        this.clearFromPos(0);
        this.pos = 0;
        this.currPenState.reset();
      };
      _proto4.clearToEndOfRow = function clearToEndOfRow() {
        this.clearFromPos(this.pos);
      };
      _proto4.getTextString = function getTextString() {
        var chars = [];
        var empty = true;
        for (var i = 0; i < NR_COLS; i++) {
          var _char2 = this.chars[i].uchar;
          if (_char2 !== " ") {
            empty = false;
          }
          chars.push(_char2);
        }
        if (empty) {
          return "";
        } else {
          return chars.join("");
        }
      };
      _proto4.setPenStyles = function setPenStyles(styles) {
        this.currPenState.setStyles(styles);
        var currChar = this.chars[this.pos];
        currChar.setPenState(this.currPenState);
      };
      return Row2;
    }();
    var CaptionScreen = /* @__PURE__ */ function() {
      function CaptionScreen2(logger2) {
        this.rows = [];
        this.currRow = NR_ROWS - 1;
        this.nrRollUpRows = null;
        this.lastOutputScreen = null;
        this.logger = void 0;
        for (var i = 0; i < NR_ROWS; i++) {
          this.rows.push(new Row(logger2));
        }
        this.logger = logger2;
      }
      var _proto5 = CaptionScreen2.prototype;
      _proto5.reset = function reset() {
        for (var i = 0; i < NR_ROWS; i++) {
          this.rows[i].clear();
        }
        this.currRow = NR_ROWS - 1;
      };
      _proto5.equals = function equals(other) {
        var equal = true;
        for (var i = 0; i < NR_ROWS; i++) {
          if (!this.rows[i].equals(other.rows[i])) {
            equal = false;
            break;
          }
        }
        return equal;
      };
      _proto5.copy = function copy(other) {
        for (var i = 0; i < NR_ROWS; i++) {
          this.rows[i].copy(other.rows[i]);
        }
      };
      _proto5.isEmpty = function isEmpty() {
        var empty = true;
        for (var i = 0; i < NR_ROWS; i++) {
          if (!this.rows[i].isEmpty()) {
            empty = false;
            break;
          }
        }
        return empty;
      };
      _proto5.backSpace = function backSpace() {
        var row = this.rows[this.currRow];
        row.backSpace();
      };
      _proto5.clearToEndOfRow = function clearToEndOfRow() {
        var row = this.rows[this.currRow];
        row.clearToEndOfRow();
      };
      _proto5.insertChar = function insertChar(_char3) {
        var row = this.rows[this.currRow];
        row.insertChar(_char3);
      };
      _proto5.setPen = function setPen(styles) {
        var row = this.rows[this.currRow];
        row.setPenStyles(styles);
      };
      _proto5.moveCursor = function moveCursor(relPos) {
        var row = this.rows[this.currRow];
        row.moveCursor(relPos);
      };
      _proto5.setCursor = function setCursor(absPos) {
        this.logger.log(2, "setCursor: " + absPos);
        var row = this.rows[this.currRow];
        row.setCursor(absPos);
      };
      _proto5.setPAC = function setPAC(pacData) {
        this.logger.log(2, function() {
          return "pacData = " + JSON.stringify(pacData);
        });
        var newRow = pacData.row - 1;
        if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
          newRow = this.nrRollUpRows - 1;
        }
        if (this.nrRollUpRows && this.currRow !== newRow) {
          for (var i = 0; i < NR_ROWS; i++) {
            this.rows[i].clear();
          }
          var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
          var lastOutputScreen = this.lastOutputScreen;
          if (lastOutputScreen) {
            var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
            var time = this.logger.time;
            if (prevLineTime !== null && time !== null && prevLineTime < time) {
              for (var _i = 0; _i < this.nrRollUpRows; _i++) {
                this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
              }
            }
          }
        }
        this.currRow = newRow;
        var row = this.rows[this.currRow];
        if (pacData.indent !== null) {
          var indent = pacData.indent;
          var prevPos = Math.max(indent - 1, 0);
          row.setCursor(pacData.indent);
          pacData.color = row.chars[prevPos].penState.foreground;
        }
        var styles = {
          foreground: pacData.color,
          underline: pacData.underline,
          italics: pacData.italics,
          background: "black",
          flash: false
        };
        this.setPen(styles);
      };
      _proto5.setBkgData = function setBkgData(bkgData) {
        this.logger.log(2, function() {
          return "bkgData = " + JSON.stringify(bkgData);
        });
        this.backSpace();
        this.setPen(bkgData);
        this.insertChar(32);
      };
      _proto5.setRollUpRows = function setRollUpRows(nrRows) {
        this.nrRollUpRows = nrRows;
      };
      _proto5.rollUp = function rollUp() {
        var _this2 = this;
        if (this.nrRollUpRows === null) {
          this.logger.log(3, "roll_up but nrRollUpRows not set yet");
          return;
        }
        this.logger.log(1, function() {
          return _this2.getDisplayText();
        });
        var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
        var topRow = this.rows.splice(topRowIndex, 1)[0];
        topRow.clear();
        this.rows.splice(this.currRow, 0, topRow);
        this.logger.log(2, "Rolling up");
      };
      _proto5.getDisplayText = function getDisplayText(asOneRow) {
        asOneRow = asOneRow || false;
        var displayText = [];
        var text = "";
        var rowNr = -1;
        for (var i = 0; i < NR_ROWS; i++) {
          var rowText = this.rows[i].getTextString();
          if (rowText) {
            rowNr = i + 1;
            if (asOneRow) {
              displayText.push("Row " + rowNr + ": '" + rowText + "'");
            } else {
              displayText.push(rowText.trim());
            }
          }
        }
        if (displayText.length > 0) {
          if (asOneRow) {
            text = "[" + displayText.join(" | ") + "]";
          } else {
            text = displayText.join("\n");
          }
        }
        return text;
      };
      _proto5.getTextAndFormat = function getTextAndFormat() {
        return this.rows;
      };
      return CaptionScreen2;
    }();
    var Cea608Channel = /* @__PURE__ */ function() {
      function Cea608Channel2(channelNumber, outputFilter, logger2) {
        this.chNr = void 0;
        this.outputFilter = void 0;
        this.mode = void 0;
        this.verbose = void 0;
        this.displayedMemory = void 0;
        this.nonDisplayedMemory = void 0;
        this.lastOutputScreen = void 0;
        this.currRollUpRow = void 0;
        this.writeScreen = void 0;
        this.cueStartTime = void 0;
        this.logger = void 0;
        this.chNr = channelNumber;
        this.outputFilter = outputFilter;
        this.mode = null;
        this.verbose = 0;
        this.displayedMemory = new CaptionScreen(logger2);
        this.nonDisplayedMemory = new CaptionScreen(logger2);
        this.lastOutputScreen = new CaptionScreen(logger2);
        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
        this.writeScreen = this.displayedMemory;
        this.mode = null;
        this.cueStartTime = null;
        this.logger = logger2;
      }
      var _proto6 = Cea608Channel2.prototype;
      _proto6.reset = function reset() {
        this.mode = null;
        this.displayedMemory.reset();
        this.nonDisplayedMemory.reset();
        this.lastOutputScreen.reset();
        this.outputFilter.reset();
        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
        this.writeScreen = this.displayedMemory;
        this.mode = null;
        this.cueStartTime = null;
      };
      _proto6.getHandler = function getHandler() {
        return this.outputFilter;
      };
      _proto6.setHandler = function setHandler(newHandler) {
        this.outputFilter = newHandler;
      };
      _proto6.setPAC = function setPAC(pacData) {
        this.writeScreen.setPAC(pacData);
      };
      _proto6.setBkgData = function setBkgData(bkgData) {
        this.writeScreen.setBkgData(bkgData);
      };
      _proto6.setMode = function setMode(newMode) {
        if (newMode === this.mode) {
          return;
        }
        this.mode = newMode;
        this.logger.log(2, function() {
          return "MODE=" + newMode;
        });
        if (this.mode === "MODE_POP-ON") {
          this.writeScreen = this.nonDisplayedMemory;
        } else {
          this.writeScreen = this.displayedMemory;
          this.writeScreen.reset();
        }
        if (this.mode !== "MODE_ROLL-UP") {
          this.displayedMemory.nrRollUpRows = null;
          this.nonDisplayedMemory.nrRollUpRows = null;
        }
        this.mode = newMode;
      };
      _proto6.insertChars = function insertChars(chars) {
        var _this3 = this;
        for (var i = 0; i < chars.length; i++) {
          this.writeScreen.insertChar(chars[i]);
        }
        var screen = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
        this.logger.log(2, function() {
          return screen + ": " + _this3.writeScreen.getDisplayText(true);
        });
        if (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") {
          this.logger.log(1, function() {
            return "DISPLAYED: " + _this3.displayedMemory.getDisplayText(true);
          });
          this.outputDataUpdate();
        }
      };
      _proto6.ccRCL = function ccRCL() {
        this.logger.log(2, "RCL - Resume Caption Loading");
        this.setMode("MODE_POP-ON");
      };
      _proto6.ccBS = function ccBS() {
        this.logger.log(2, "BS - BackSpace");
        if (this.mode === "MODE_TEXT") {
          return;
        }
        this.writeScreen.backSpace();
        if (this.writeScreen === this.displayedMemory) {
          this.outputDataUpdate();
        }
      };
      _proto6.ccAOF = function ccAOF() {
      };
      _proto6.ccAON = function ccAON() {
      };
      _proto6.ccDER = function ccDER() {
        this.logger.log(2, "DER- Delete to End of Row");
        this.writeScreen.clearToEndOfRow();
        this.outputDataUpdate();
      };
      _proto6.ccRU = function ccRU(nrRows) {
        this.logger.log(2, "RU(" + nrRows + ") - Roll Up");
        this.writeScreen = this.displayedMemory;
        this.setMode("MODE_ROLL-UP");
        this.writeScreen.setRollUpRows(nrRows);
      };
      _proto6.ccFON = function ccFON() {
        this.logger.log(2, "FON - Flash On");
        this.writeScreen.setPen({
          flash: true
        });
      };
      _proto6.ccRDC = function ccRDC() {
        this.logger.log(2, "RDC - Resume Direct Captioning");
        this.setMode("MODE_PAINT-ON");
      };
      _proto6.ccTR = function ccTR() {
        this.logger.log(2, "TR");
        this.setMode("MODE_TEXT");
      };
      _proto6.ccRTD = function ccRTD() {
        this.logger.log(2, "RTD");
        this.setMode("MODE_TEXT");
      };
      _proto6.ccEDM = function ccEDM() {
        this.logger.log(2, "EDM - Erase Displayed Memory");
        this.displayedMemory.reset();
        this.outputDataUpdate(true);
      };
      _proto6.ccCR = function ccCR() {
        this.logger.log(2, "CR - Carriage Return");
        this.writeScreen.rollUp();
        this.outputDataUpdate(true);
      };
      _proto6.ccENM = function ccENM() {
        this.logger.log(2, "ENM - Erase Non-displayed Memory");
        this.nonDisplayedMemory.reset();
      };
      _proto6.ccEOC = function ccEOC() {
        var _this4 = this;
        this.logger.log(2, "EOC - End Of Caption");
        if (this.mode === "MODE_POP-ON") {
          var tmp = this.displayedMemory;
          this.displayedMemory = this.nonDisplayedMemory;
          this.nonDisplayedMemory = tmp;
          this.writeScreen = this.nonDisplayedMemory;
          this.logger.log(1, function() {
            return "DISP: " + _this4.displayedMemory.getDisplayText();
          });
        }
        this.outputDataUpdate(true);
      };
      _proto6.ccTO = function ccTO(nrCols) {
        this.logger.log(2, "TO(" + nrCols + ") - Tab Offset");
        this.writeScreen.moveCursor(nrCols);
      };
      _proto6.ccMIDROW = function ccMIDROW(secondByte) {
        var styles = {
          flash: false
        };
        styles.underline = secondByte % 2 === 1;
        styles.italics = secondByte >= 46;
        if (!styles.italics) {
          var colorIndex = Math.floor(secondByte / 2) - 16;
          var colors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
          styles.foreground = colors[colorIndex];
        } else {
          styles.foreground = "white";
        }
        this.logger.log(2, "MIDROW: " + JSON.stringify(styles));
        this.writeScreen.setPen(styles);
      };
      _proto6.outputDataUpdate = function outputDataUpdate(dispatch) {
        if (dispatch === void 0) {
          dispatch = false;
        }
        var time = this.logger.time;
        if (time === null) {
          return;
        }
        if (this.outputFilter) {
          if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
            this.cueStartTime = time;
          } else {
            if (!this.displayedMemory.equals(this.lastOutputScreen)) {
              this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);
              if (dispatch && this.outputFilter.dispatchCue) {
                this.outputFilter.dispatchCue();
              }
              this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;
            }
          }
          this.lastOutputScreen.copy(this.displayedMemory);
        }
      };
      _proto6.cueSplitAtTime = function cueSplitAtTime(t) {
        if (this.outputFilter) {
          if (!this.displayedMemory.isEmpty()) {
            if (this.outputFilter.newCue) {
              this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
            }
            this.cueStartTime = t;
          }
        }
      };
      return Cea608Channel2;
    }();
    var Cea608Parser = /* @__PURE__ */ function() {
      function Cea608Parser2(field, out1, out2) {
        this.channels = void 0;
        this.currentChannel = 0;
        this.cmdHistory = createCmdHistory();
        this.logger = void 0;
        var logger2 = this.logger = new CaptionsLogger();
        this.channels = [null, new Cea608Channel(field, out1, logger2), new Cea608Channel(field + 1, out2, logger2)];
      }
      var _proto7 = Cea608Parser2.prototype;
      _proto7.getHandler = function getHandler(channel) {
        return this.channels[channel].getHandler();
      };
      _proto7.setHandler = function setHandler(channel, newHandler) {
        this.channels[channel].setHandler(newHandler);
      };
      _proto7.addData = function addData(time, byteList) {
        var cmdFound;
        var a;
        var b;
        var charsFound = false;
        this.logger.time = time;
        for (var i = 0; i < byteList.length; i += 2) {
          a = byteList[i] & 127;
          b = byteList[i + 1] & 127;
          if (a === 0 && b === 0) {
            continue;
          } else {
            this.logger.log(3, "[" + numArrayToHexArray([byteList[i], byteList[i + 1]]) + "] -> (" + numArrayToHexArray([a, b]) + ")");
          }
          cmdFound = this.parseCmd(a, b);
          if (!cmdFound) {
            cmdFound = this.parseMidrow(a, b);
          }
          if (!cmdFound) {
            cmdFound = this.parsePAC(a, b);
          }
          if (!cmdFound) {
            cmdFound = this.parseBackgroundAttributes(a, b);
          }
          if (!cmdFound) {
            charsFound = this.parseChars(a, b);
            if (charsFound) {
              var currChNr = this.currentChannel;
              if (currChNr && currChNr > 0) {
                var channel = this.channels[currChNr];
                channel.insertChars(charsFound);
              } else {
                this.logger.log(2, "No channel found yet. TEXT-MODE?");
              }
            }
          }
          if (!cmdFound && !charsFound) {
            this.logger.log(2, "Couldn't parse cleaned data " + numArrayToHexArray([a, b]) + " orig: " + numArrayToHexArray([byteList[i], byteList[i + 1]]));
          }
        }
      };
      _proto7.parseCmd = function parseCmd(a, b) {
        var cmdHistory = this.cmdHistory;
        var cond1 = (a === 20 || a === 28 || a === 21 || a === 29) && b >= 32 && b <= 47;
        var cond2 = (a === 23 || a === 31) && b >= 33 && b <= 35;
        if (!(cond1 || cond2)) {
          return false;
        }
        if (hasCmdRepeated(a, b, cmdHistory)) {
          setLastCmd(null, null, cmdHistory);
          this.logger.log(3, "Repeated command (" + numArrayToHexArray([a, b]) + ") is dropped");
          return true;
        }
        var chNr = a === 20 || a === 21 || a === 23 ? 1 : 2;
        var channel = this.channels[chNr];
        if (a === 20 || a === 21 || a === 28 || a === 29) {
          if (b === 32) {
            channel.ccRCL();
          } else if (b === 33) {
            channel.ccBS();
          } else if (b === 34) {
            channel.ccAOF();
          } else if (b === 35) {
            channel.ccAON();
          } else if (b === 36) {
            channel.ccDER();
          } else if (b === 37) {
            channel.ccRU(2);
          } else if (b === 38) {
            channel.ccRU(3);
          } else if (b === 39) {
            channel.ccRU(4);
          } else if (b === 40) {
            channel.ccFON();
          } else if (b === 41) {
            channel.ccRDC();
          } else if (b === 42) {
            channel.ccTR();
          } else if (b === 43) {
            channel.ccRTD();
          } else if (b === 44) {
            channel.ccEDM();
          } else if (b === 45) {
            channel.ccCR();
          } else if (b === 46) {
            channel.ccENM();
          } else if (b === 47) {
            channel.ccEOC();
          }
        } else {
          channel.ccTO(b - 32);
        }
        setLastCmd(a, b, cmdHistory);
        this.currentChannel = chNr;
        return true;
      };
      _proto7.parseMidrow = function parseMidrow(a, b) {
        var chNr = 0;
        if ((a === 17 || a === 25) && b >= 32 && b <= 47) {
          if (a === 17) {
            chNr = 1;
          } else {
            chNr = 2;
          }
          if (chNr !== this.currentChannel) {
            this.logger.log(0, "Mismatch channel in midrow parsing");
            return false;
          }
          var channel = this.channels[chNr];
          if (!channel) {
            return false;
          }
          channel.ccMIDROW(b);
          this.logger.log(3, "MIDROW (" + numArrayToHexArray([a, b]) + ")");
          return true;
        }
        return false;
      };
      _proto7.parsePAC = function parsePAC(a, b) {
        var row;
        var cmdHistory = this.cmdHistory;
        var case1 = (a >= 17 && a <= 23 || a >= 25 && a <= 31) && b >= 64 && b <= 127;
        var case2 = (a === 16 || a === 24) && b >= 64 && b <= 95;
        if (!(case1 || case2)) {
          return false;
        }
        if (hasCmdRepeated(a, b, cmdHistory)) {
          setLastCmd(null, null, cmdHistory);
          return true;
        }
        var chNr = a <= 23 ? 1 : 2;
        if (b >= 64 && b <= 95) {
          row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
        } else {
          row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
        }
        var channel = this.channels[chNr];
        if (!channel) {
          return false;
        }
        channel.setPAC(this.interpretPAC(row, b));
        setLastCmd(a, b, cmdHistory);
        this.currentChannel = chNr;
        return true;
      };
      _proto7.interpretPAC = function interpretPAC(row, _byte3) {
        var pacIndex;
        var pacData = {
          color: null,
          italics: false,
          indent: null,
          underline: false,
          row
        };
        if (_byte3 > 95) {
          pacIndex = _byte3 - 96;
        } else {
          pacIndex = _byte3 - 64;
        }
        pacData.underline = (pacIndex & 1) === 1;
        if (pacIndex <= 13) {
          pacData.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(pacIndex / 2)];
        } else if (pacIndex <= 15) {
          pacData.italics = true;
          pacData.color = "white";
        } else {
          pacData.indent = Math.floor((pacIndex - 16) / 2) * 4;
        }
        return pacData;
      };
      _proto7.parseChars = function parseChars(a, b) {
        var channelNr;
        var charCodes = null;
        var charCode1 = null;
        if (a >= 25) {
          channelNr = 2;
          charCode1 = a - 8;
        } else {
          channelNr = 1;
          charCode1 = a;
        }
        if (charCode1 >= 17 && charCode1 <= 19) {
          var oneCode;
          if (charCode1 === 17) {
            oneCode = b + 80;
          } else if (charCode1 === 18) {
            oneCode = b + 112;
          } else {
            oneCode = b + 144;
          }
          this.logger.log(2, "Special char '" + getCharForByte(oneCode) + "' in channel " + channelNr);
          charCodes = [oneCode];
        } else if (a >= 32 && a <= 127) {
          charCodes = b === 0 ? [a] : [a, b];
        }
        if (charCodes) {
          var hexCodes = numArrayToHexArray(charCodes);
          this.logger.log(3, "Char codes =  " + hexCodes.join(","));
          setLastCmd(a, b, this.cmdHistory);
        }
        return charCodes;
      };
      _proto7.parseBackgroundAttributes = function parseBackgroundAttributes(a, b) {
        var case1 = (a === 16 || a === 24) && b >= 32 && b <= 47;
        var case2 = (a === 23 || a === 31) && b >= 45 && b <= 47;
        if (!(case1 || case2)) {
          return false;
        }
        var index;
        var bkgData = {};
        if (a === 16 || a === 24) {
          index = Math.floor((b - 32) / 2);
          bkgData.background = backgroundColors[index];
          if (b % 2 === 1) {
            bkgData.background = bkgData.background + "_semi";
          }
        } else if (b === 45) {
          bkgData.background = "transparent";
        } else {
          bkgData.foreground = "black";
          if (b === 47) {
            bkgData.underline = true;
          }
        }
        var chNr = a <= 23 ? 1 : 2;
        var channel = this.channels[chNr];
        channel.setBkgData(bkgData);
        setLastCmd(a, b, this.cmdHistory);
        return true;
      };
      _proto7.reset = function reset() {
        for (var i = 0; i < Object.keys(this.channels).length; i++) {
          var channel = this.channels[i];
          if (channel) {
            channel.reset();
          }
        }
        this.cmdHistory = createCmdHistory();
      };
      _proto7.cueSplitAtTime = function cueSplitAtTime(t) {
        for (var i = 0; i < this.channels.length; i++) {
          var channel = this.channels[i];
          if (channel) {
            channel.cueSplitAtTime(t);
          }
        }
      };
      return Cea608Parser2;
    }();
    function setLastCmd(a, b, cmdHistory) {
      cmdHistory.a = a;
      cmdHistory.b = b;
    }
    function hasCmdRepeated(a, b, cmdHistory) {
      return cmdHistory.a === a && cmdHistory.b === b;
    }
    function createCmdHistory() {
      return {
        a: null,
        b: null
      };
    }
    var OutputFilter = /* @__PURE__ */ function() {
      function OutputFilter2(timelineController, trackName) {
        this.timelineController = void 0;
        this.cueRanges = [];
        this.trackName = void 0;
        this.startTime = null;
        this.endTime = null;
        this.screen = null;
        this.timelineController = timelineController;
        this.trackName = trackName;
      }
      var _proto = OutputFilter2.prototype;
      _proto.dispatchCue = function dispatchCue() {
        if (this.startTime === null) {
          return;
        }
        this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);
        this.startTime = null;
      };
      _proto.newCue = function newCue(startTime, endTime, screen) {
        if (this.startTime === null || this.startTime > startTime) {
          this.startTime = startTime;
        }
        this.endTime = endTime;
        this.screen = screen;
        this.timelineController.createCaptionsTrack(this.trackName);
      };
      _proto.reset = function reset() {
        this.cueRanges = [];
        this.startTime = null;
      };
      return OutputFilter2;
    }();
    var VTTCue = function() {
      if (optionalSelf != null && optionalSelf.VTTCue) {
        return self.VTTCue;
      }
      var AllowedDirections = ["", "lr", "rl"];
      var AllowedAlignments = ["start", "middle", "end", "left", "right"];
      function isAllowedValue(allowed, value) {
        if (typeof value !== "string") {
          return false;
        }
        if (!Array.isArray(allowed)) {
          return false;
        }
        var lcValue = value.toLowerCase();
        if (~allowed.indexOf(lcValue)) {
          return lcValue;
        }
        return false;
      }
      function findDirectionSetting(value) {
        return isAllowedValue(AllowedDirections, value);
      }
      function findAlignSetting(value) {
        return isAllowedValue(AllowedAlignments, value);
      }
      function extend(obj) {
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }
        var i = 1;
        for (; i < arguments.length; i++) {
          var cobj = arguments[i];
          for (var p in cobj) {
            obj[p] = cobj[p];
          }
        }
        return obj;
      }
      function VTTCue2(startTime, endTime, text) {
        var cue = this;
        var baseObj = {
          enumerable: true
        };
        cue.hasBeenReset = false;
        var _id = "";
        var _pauseOnExit = false;
        var _startTime = startTime;
        var _endTime = endTime;
        var _text = text;
        var _region = null;
        var _vertical = "";
        var _snapToLines = true;
        var _line = "auto";
        var _lineAlign = "start";
        var _position = 50;
        var _positionAlign = "middle";
        var _size = 50;
        var _align = "middle";
        Object.defineProperty(cue, "id", extend({}, baseObj, {
          get: function get() {
            return _id;
          },
          set: function set(value) {
            _id = "" + value;
          }
        }));
        Object.defineProperty(cue, "pauseOnExit", extend({}, baseObj, {
          get: function get() {
            return _pauseOnExit;
          },
          set: function set(value) {
            _pauseOnExit = !!value;
          }
        }));
        Object.defineProperty(cue, "startTime", extend({}, baseObj, {
          get: function get() {
            return _startTime;
          },
          set: function set(value) {
            if (typeof value !== "number") {
              throw new TypeError("Start time must be set to a number.");
            }
            _startTime = value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "endTime", extend({}, baseObj, {
          get: function get() {
            return _endTime;
          },
          set: function set(value) {
            if (typeof value !== "number") {
              throw new TypeError("End time must be set to a number.");
            }
            _endTime = value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "text", extend({}, baseObj, {
          get: function get() {
            return _text;
          },
          set: function set(value) {
            _text = "" + value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "region", extend({}, baseObj, {
          get: function get() {
            return _region;
          },
          set: function set(value) {
            _region = value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "vertical", extend({}, baseObj, {
          get: function get() {
            return _vertical;
          },
          set: function set(value) {
            var setting = findDirectionSetting(value);
            if (setting === false) {
              throw new SyntaxError("An invalid or illegal string was specified.");
            }
            _vertical = setting;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "snapToLines", extend({}, baseObj, {
          get: function get() {
            return _snapToLines;
          },
          set: function set(value) {
            _snapToLines = !!value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "line", extend({}, baseObj, {
          get: function get() {
            return _line;
          },
          set: function set(value) {
            if (typeof value !== "number" && value !== "auto") {
              throw new SyntaxError("An invalid number or illegal string was specified.");
            }
            _line = value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "lineAlign", extend({}, baseObj, {
          get: function get() {
            return _lineAlign;
          },
          set: function set(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              throw new SyntaxError("An invalid or illegal string was specified.");
            }
            _lineAlign = setting;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "position", extend({}, baseObj, {
          get: function get() {
            return _position;
          },
          set: function set(value) {
            if (value < 0 || value > 100) {
              throw new Error("Position must be between 0 and 100.");
            }
            _position = value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "positionAlign", extend({}, baseObj, {
          get: function get() {
            return _positionAlign;
          },
          set: function set(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              throw new SyntaxError("An invalid or illegal string was specified.");
            }
            _positionAlign = setting;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "size", extend({}, baseObj, {
          get: function get() {
            return _size;
          },
          set: function set(value) {
            if (value < 0 || value > 100) {
              throw new Error("Size must be between 0 and 100.");
            }
            _size = value;
            this.hasBeenReset = true;
          }
        }));
        Object.defineProperty(cue, "align", extend({}, baseObj, {
          get: function get() {
            return _align;
          },
          set: function set(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              throw new SyntaxError("An invalid or illegal string was specified.");
            }
            _align = setting;
            this.hasBeenReset = true;
          }
        }));
        cue.displayState = void 0;
      }
      VTTCue2.prototype.getCueAsHTML = function() {
        var WebVTT2 = self.WebVTT;
        return WebVTT2.convertCueToDOMTree(self, this.text);
      };
      return VTTCue2;
    }();
    var StringDecoder = /* @__PURE__ */ function() {
      function StringDecoder2() {
      }
      var _proto = StringDecoder2.prototype;
      _proto.decode = function decode(data, options) {
        if (!data) {
          return "";
        }
        if (typeof data !== "string") {
          throw new Error("Error - expected string data.");
        }
        return decodeURIComponent(encodeURIComponent(data));
      };
      return StringDecoder2;
    }();
    function parseTimeStamp(input) {
      function computeSeconds(h, m2, s, f) {
        return (h | 0) * 3600 + (m2 | 0) * 60 + (s | 0) + parseFloat(f || 0);
      }
      var m = input.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
      if (!m) {
        return null;
      }
      if (parseFloat(m[2]) > 59) {
        return computeSeconds(m[2], m[3], 0, m[4]);
      }
      return computeSeconds(m[1], m[2], m[3], m[4]);
    }
    var Settings = /* @__PURE__ */ function() {
      function Settings2() {
        this.values = /* @__PURE__ */ Object.create(null);
      }
      var _proto2 = Settings2.prototype;
      _proto2.set = function set(k, v) {
        if (!this.get(k) && v !== "") {
          this.values[k] = v;
        }
      };
      _proto2.get = function get(k, dflt, defaultKey) {
        if (defaultKey) {
          return this.has(k) ? this.values[k] : dflt[defaultKey];
        }
        return this.has(k) ? this.values[k] : dflt;
      };
      _proto2.has = function has(k) {
        return k in this.values;
      };
      _proto2.alt = function alt(k, v, a) {
        for (var n = 0; n < a.length; ++n) {
          if (v === a[n]) {
            this.set(k, v);
            break;
          }
        }
      };
      _proto2.integer = function integer(k, v) {
        if (/^-?\d+$/.test(v)) {
          this.set(k, parseInt(v, 10));
        }
      };
      _proto2.percent = function percent(k, v) {
        if (/^([\d]{1,3})(\.[\d]*)?%$/.test(v)) {
          var percent2 = parseFloat(v);
          if (percent2 >= 0 && percent2 <= 100) {
            this.set(k, percent2);
            return true;
          }
        }
        return false;
      };
      return Settings2;
    }();
    function parseOptions(input, callback, keyValueDelim, groupDelim) {
      var groups = groupDelim ? input.split(groupDelim) : [input];
      for (var i in groups) {
        if (typeof groups[i] !== "string") {
          continue;
        }
        var kv = groups[i].split(keyValueDelim);
        if (kv.length !== 2) {
          continue;
        }
        var _k = kv[0];
        var _v = kv[1];
        callback(_k, _v);
      }
    }
    var defaults = new VTTCue(0, 0, "");
    var center = defaults.align === "middle" ? "middle" : "center";
    function parseCue(input, cue, regionList) {
      var oInput = input;
      function consumeTimeStamp() {
        var ts = parseTimeStamp(input);
        if (ts === null) {
          throw new Error("Malformed timestamp: " + oInput);
        }
        input = input.replace(/^[^\sa-zA-Z-]+/, "");
        return ts;
      }
      function consumeCueSettings(input2, cue2) {
        var settings = new Settings();
        parseOptions(input2, function(k, v) {
          var vals;
          switch (k) {
            case "region":
              for (var i = regionList.length - 1; i >= 0; i--) {
                if (regionList[i].id === v) {
                  settings.set(k, regionList[i].region);
                  break;
                }
              }
              break;
            case "vertical":
              settings.alt(k, v, ["rl", "lr"]);
              break;
            case "line":
              vals = v.split(",");
              settings.integer(k, vals[0]);
              if (settings.percent(k, vals[0])) {
                settings.set("snapToLines", false);
              }
              settings.alt(k, vals[0], ["auto"]);
              if (vals.length === 2) {
                settings.alt("lineAlign", vals[1], ["start", center, "end"]);
              }
              break;
            case "position":
              vals = v.split(",");
              settings.percent(k, vals[0]);
              if (vals.length === 2) {
                settings.alt("positionAlign", vals[1], ["start", center, "end", "line-left", "line-right", "auto"]);
              }
              break;
            case "size":
              settings.percent(k, v);
              break;
            case "align":
              settings.alt(k, v, ["start", center, "end", "left", "right"]);
              break;
          }
        }, /:/, /\s/);
        cue2.region = settings.get("region", null);
        cue2.vertical = settings.get("vertical", "");
        var line = settings.get("line", "auto");
        if (line === "auto" && defaults.line === -1) {
          line = -1;
        }
        cue2.line = line;
        cue2.lineAlign = settings.get("lineAlign", "start");
        cue2.snapToLines = settings.get("snapToLines", true);
        cue2.size = settings.get("size", 100);
        cue2.align = settings.get("align", center);
        var position = settings.get("position", "auto");
        if (position === "auto" && defaults.position === 50) {
          position = cue2.align === "start" || cue2.align === "left" ? 0 : cue2.align === "end" || cue2.align === "right" ? 100 : 50;
        }
        cue2.position = position;
      }
      function skipWhitespace() {
        input = input.replace(/^\s+/, "");
      }
      skipWhitespace();
      cue.startTime = consumeTimeStamp();
      skipWhitespace();
      if (input.slice(0, 3) !== "-->") {
        throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + oInput);
      }
      input = input.slice(3);
      skipWhitespace();
      cue.endTime = consumeTimeStamp();
      skipWhitespace();
      consumeCueSettings(input, cue);
    }
    function fixLineBreaks(input) {
      return input.replace(/<br(?: \/)?>/gi, "\n");
    }
    var VTTParser = /* @__PURE__ */ function() {
      function VTTParser2() {
        this.state = "INITIAL";
        this.buffer = "";
        this.decoder = new StringDecoder();
        this.regionList = [];
        this.cue = null;
        this.oncue = void 0;
        this.onparsingerror = void 0;
        this.onflush = void 0;
      }
      var _proto3 = VTTParser2.prototype;
      _proto3.parse = function parse(data) {
        var _this = this;
        if (data) {
          _this.buffer += _this.decoder.decode(data, {
            stream: true
          });
        }
        function collectNextLine() {
          var buffer = _this.buffer;
          var pos = 0;
          buffer = fixLineBreaks(buffer);
          while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") {
            ++pos;
          }
          var line2 = buffer.slice(0, pos);
          if (buffer[pos] === "\r") {
            ++pos;
          }
          if (buffer[pos] === "\n") {
            ++pos;
          }
          _this.buffer = buffer.slice(pos);
          return line2;
        }
        function parseHeader2(input) {
          parseOptions(input, function(k, v) {
          }, /:/);
        }
        try {
          var line = "";
          if (_this.state === "INITIAL") {
            if (!/\r\n|\n/.test(_this.buffer)) {
              return this;
            }
            line = collectNextLine();
            var m = line.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
            if (!(m != null && m[0])) {
              throw new Error("Malformed WebVTT signature.");
            }
            _this.state = "HEADER";
          }
          var alreadyCollectedLine = false;
          while (_this.buffer) {
            if (!/\r\n|\n/.test(_this.buffer)) {
              return this;
            }
            if (!alreadyCollectedLine) {
              line = collectNextLine();
            } else {
              alreadyCollectedLine = false;
            }
            switch (_this.state) {
              case "HEADER":
                if (/:/.test(line)) {
                  parseHeader2(line);
                } else if (!line) {
                  _this.state = "ID";
                }
                continue;
              case "NOTE":
                if (!line) {
                  _this.state = "ID";
                }
                continue;
              case "ID":
                if (/^NOTE($|[ \t])/.test(line)) {
                  _this.state = "NOTE";
                  break;
                }
                if (!line) {
                  continue;
                }
                _this.cue = new VTTCue(0, 0, "");
                _this.state = "CUE";
                if (line.indexOf("-->") === -1) {
                  _this.cue.id = line;
                  continue;
                }
              case "CUE":
                if (!_this.cue) {
                  _this.state = "BADCUE";
                  continue;
                }
                try {
                  parseCue(line, _this.cue, _this.regionList);
                } catch (e) {
                  _this.cue = null;
                  _this.state = "BADCUE";
                  continue;
                }
                _this.state = "CUETEXT";
                continue;
              case "CUETEXT":
                {
                  var hasSubstring = line.indexOf("-->") !== -1;
                  if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                    if (_this.oncue && _this.cue) {
                      _this.oncue(_this.cue);
                    }
                    _this.cue = null;
                    _this.state = "ID";
                    continue;
                  }
                  if (_this.cue === null) {
                    continue;
                  }
                  if (_this.cue.text) {
                    _this.cue.text += "\n";
                  }
                  _this.cue.text += line;
                }
                continue;
              case "BADCUE":
                if (!line) {
                  _this.state = "ID";
                }
            }
          }
        } catch (e) {
          if (_this.state === "CUETEXT" && _this.cue && _this.oncue) {
            _this.oncue(_this.cue);
          }
          _this.cue = null;
          _this.state = _this.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
        }
        return this;
      };
      _proto3.flush = function flush() {
        var _this = this;
        try {
          if (_this.cue || _this.state === "HEADER") {
            _this.buffer += "\n\n";
            _this.parse();
          }
          if (_this.state === "INITIAL" || _this.state === "BADWEBVTT") {
            throw new Error("Malformed WebVTT signature.");
          }
        } catch (e) {
          if (_this.onparsingerror) {
            _this.onparsingerror(e);
          }
        }
        if (_this.onflush) {
          _this.onflush();
        }
        return this;
      };
      return VTTParser2;
    }();
    var LINEBREAKS = /\r\n|\n\r|\n|\r/g;
    var startsWith = function startsWith2(inputString, searchString, position) {
      if (position === void 0) {
        position = 0;
      }
      return inputString.slice(position, position + searchString.length) === searchString;
    };
    var cueString2millis = function cueString2millis2(timeString) {
      var ts = parseInt(timeString.slice(-3));
      var secs = parseInt(timeString.slice(-6, -4));
      var mins = parseInt(timeString.slice(-9, -7));
      var hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(":"))) : 0;
      if (!isFiniteNumber(ts) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {
        throw Error("Malformed X-TIMESTAMP-MAP: Local:" + timeString);
      }
      ts += 1e3 * secs;
      ts += 60 * 1e3 * mins;
      ts += 60 * 60 * 1e3 * hours;
      return ts;
    };
    var hash = function hash2(text) {
      var hash3 = 5381;
      var i = text.length;
      while (i) {
        hash3 = hash3 * 33 ^ text.charCodeAt(--i);
      }
      return (hash3 >>> 0).toString();
    };
    function generateCueId(startTime, endTime, text) {
      return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);
    }
    var calculateOffset = function calculateOffset2(vttCCs, cc, presentationTime) {
      var currCC = vttCCs[cc];
      var prevCC = vttCCs[currCC.prevCC];
      if (!prevCC || !prevCC.new && currCC.new) {
        vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
        currCC.new = false;
        return;
      }
      while ((_prevCC = prevCC) != null && _prevCC.new) {
        var _prevCC;
        vttCCs.ccOffset += currCC.start - prevCC.start;
        currCC.new = false;
        currCC = prevCC;
        prevCC = vttCCs[currCC.prevCC];
      }
      vttCCs.presentationOffset = presentationTime;
    };
    function parseWebVTT(vttByteArray, initPTS, vttCCs, cc, timeOffset, callBack, errorCallBack) {
      var parser = new VTTParser();
      var vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, "\n").split("\n");
      var cues = [];
      var init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;
      var cueTime = "00:00.000";
      var timestampMapMPEGTS = 0;
      var timestampMapLOCAL = 0;
      var parsingError;
      var inHeader = true;
      parser.oncue = function(cue) {
        var currCC = vttCCs[cc];
        var cueOffset = vttCCs.ccOffset;
        var webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 9e4;
        if (currCC != null && currCC.new) {
          if (timestampMapLOCAL !== void 0) {
            cueOffset = vttCCs.ccOffset = currCC.start;
          } else {
            calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);
          }
        }
        if (webVttMpegTsMapOffset) {
          if (!initPTS) {
            parsingError = new Error("Missing initPTS for VTT MPEGTS");
            return;
          }
          cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;
        }
        var duration = cue.endTime - cue.startTime;
        var startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 9e4, timeOffset * 9e4) / 9e4;
        cue.startTime = Math.max(startTime, 0);
        cue.endTime = Math.max(startTime + duration, 0);
        var text = cue.text.trim();
        cue.text = decodeURIComponent(encodeURIComponent(text));
        if (!cue.id) {
          cue.id = generateCueId(cue.startTime, cue.endTime, text);
        }
        if (cue.endTime > 0) {
          cues.push(cue);
        }
      };
      parser.onparsingerror = function(error) {
        parsingError = error;
      };
      parser.onflush = function() {
        if (parsingError) {
          errorCallBack(parsingError);
          return;
        }
        callBack(cues);
      };
      vttLines.forEach(function(line) {
        if (inHeader) {
          if (startsWith(line, "X-TIMESTAMP-MAP=")) {
            inHeader = false;
            line.slice(16).split(",").forEach(function(timestamp) {
              if (startsWith(timestamp, "LOCAL:")) {
                cueTime = timestamp.slice(6);
              } else if (startsWith(timestamp, "MPEGTS:")) {
                timestampMapMPEGTS = parseInt(timestamp.slice(7));
              }
            });
            try {
              timestampMapLOCAL = cueString2millis(cueTime) / 1e3;
            } catch (error) {
              parsingError = error;
            }
            return;
          } else if (line === "") {
            inHeader = false;
          }
        }
        parser.parse(line + "\n");
      });
      parser.flush();
    }
    var IMSC1_CODEC = "stpp.ttml.im1t";
    var HMSF_REGEX = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;
    var TIME_UNIT_REGEX = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/;
    var textAlignToLineAlign = {
      left: "start",
      center: "center",
      right: "end",
      start: "start",
      end: "end"
    };
    function parseIMSC1(payload, initPTS, callBack, errorCallBack) {
      var results = findBox(new Uint8Array(payload), ["mdat"]);
      if (results.length === 0) {
        errorCallBack(new Error("Could not parse IMSC1 mdat"));
        return;
      }
      var ttmlList = results.map(function(mdat) {
        return utf8ArrayToStr(mdat);
      });
      var syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);
      try {
        ttmlList.forEach(function(ttml) {
          return callBack(parseTTML(ttml, syncTime));
        });
      } catch (error) {
        errorCallBack(error);
      }
    }
    function parseTTML(ttml, syncTime) {
      var parser = new DOMParser();
      var xmlDoc = parser.parseFromString(ttml, "text/xml");
      var tt = xmlDoc.getElementsByTagName("tt")[0];
      if (!tt) {
        throw new Error("Invalid ttml");
      }
      var defaultRateInfo = {
        frameRate: 30,
        subFrameRate: 1,
        frameRateMultiplier: 0,
        tickRate: 0
      };
      var rateInfo = Object.keys(defaultRateInfo).reduce(function(result, key) {
        result[key] = tt.getAttribute("ttp:" + key) || defaultRateInfo[key];
        return result;
      }, {});
      var trim = tt.getAttribute("xml:space") !== "preserve";
      var styleElements = collectionToDictionary(getElementCollection(tt, "styling", "style"));
      var regionElements = collectionToDictionary(getElementCollection(tt, "layout", "region"));
      var cueElements = getElementCollection(tt, "body", "[begin]");
      return [].map.call(cueElements, function(cueElement) {
        var cueText = getTextContent(cueElement, trim);
        if (!cueText || !cueElement.hasAttribute("begin")) {
          return null;
        }
        var startTime = parseTtmlTime(cueElement.getAttribute("begin"), rateInfo);
        var duration = parseTtmlTime(cueElement.getAttribute("dur"), rateInfo);
        var endTime = parseTtmlTime(cueElement.getAttribute("end"), rateInfo);
        if (startTime === null) {
          throw timestampParsingError(cueElement);
        }
        if (endTime === null) {
          if (duration === null) {
            throw timestampParsingError(cueElement);
          }
          endTime = startTime + duration;
        }
        var cue = new VTTCue(startTime - syncTime, endTime - syncTime, cueText);
        cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);
        var region = regionElements[cueElement.getAttribute("region")];
        var style = styleElements[cueElement.getAttribute("style")];
        var styles = getTtmlStyles(region, style, styleElements);
        var textAlign = styles.textAlign;
        if (textAlign) {
          var lineAlign = textAlignToLineAlign[textAlign];
          if (lineAlign) {
            cue.lineAlign = lineAlign;
          }
          cue.align = textAlign;
        }
        _extends(cue, styles);
        return cue;
      }).filter(function(cue) {
        return cue !== null;
      });
    }
    function getElementCollection(fromElement, parentName, childName) {
      var parent = fromElement.getElementsByTagName(parentName)[0];
      if (parent) {
        return [].slice.call(parent.querySelectorAll(childName));
      }
      return [];
    }
    function collectionToDictionary(elementsWithId) {
      return elementsWithId.reduce(function(dict, element) {
        var id = element.getAttribute("xml:id");
        if (id) {
          dict[id] = element;
        }
        return dict;
      }, {});
    }
    function getTextContent(element, trim) {
      return [].slice.call(element.childNodes).reduce(function(str, node, i) {
        var _node$childNodes;
        if (node.nodeName === "br" && i) {
          return str + "\n";
        }
        if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {
          return getTextContent(node, trim);
        } else if (trim) {
          return str + node.textContent.trim().replace(/\s+/g, " ");
        }
        return str + node.textContent;
      }, "");
    }
    function getTtmlStyles(region, style, styleElements) {
      var ttsNs = "http://www.w3.org/ns/ttml#styling";
      var regionStyle = null;
      var styleAttributes = [
        "displayAlign",
        "textAlign",
        "color",
        "backgroundColor",
        "fontSize",
        "fontFamily"
        // 'fontWeight',
        // 'lineHeight',
        // 'wrapOption',
        // 'fontStyle',
        // 'direction',
        // 'writingMode'
      ];
      var regionStyleName = region != null && region.hasAttribute("style") ? region.getAttribute("style") : null;
      if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {
        regionStyle = styleElements[regionStyleName];
      }
      return styleAttributes.reduce(function(styles, name) {
        var value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);
        if (value) {
          styles[name] = value;
        }
        return styles;
      }, {});
    }
    function getAttributeNS(element, ns, name) {
      if (!element) {
        return null;
      }
      return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;
    }
    function timestampParsingError(node) {
      return new Error("Could not parse ttml timestamp " + node);
    }
    function parseTtmlTime(timeAttributeValue, rateInfo) {
      if (!timeAttributeValue) {
        return null;
      }
      var seconds = parseTimeStamp(timeAttributeValue);
      if (seconds === null) {
        if (HMSF_REGEX.test(timeAttributeValue)) {
          seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);
        } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {
          seconds = parseTimeUnits(timeAttributeValue, rateInfo);
        }
      }
      return seconds;
    }
    function parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {
      var m = HMSF_REGEX.exec(timeAttributeValue);
      var frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;
      return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;
    }
    function parseTimeUnits(timeAttributeValue, rateInfo) {
      var m = TIME_UNIT_REGEX.exec(timeAttributeValue);
      var value = Number(m[1]);
      var unit = m[2];
      switch (unit) {
        case "h":
          return value * 3600;
        case "m":
          return value * 60;
        case "ms":
          return value * 1e3;
        case "f":
          return value / rateInfo.frameRate;
        case "t":
          return value / rateInfo.tickRate;
      }
      return value;
    }
    var TimelineController = /* @__PURE__ */ function() {
      function TimelineController2(hls) {
        this.hls = void 0;
        this.media = null;
        this.config = void 0;
        this.enabled = true;
        this.Cues = void 0;
        this.textTracks = [];
        this.tracks = [];
        this.initPTS = [];
        this.unparsedVttFrags = [];
        this.captionsTracks = {};
        this.nonNativeCaptionsTracks = {};
        this.cea608Parser1 = void 0;
        this.cea608Parser2 = void 0;
        this.lastCc = -1;
        this.lastSn = -1;
        this.lastPartIndex = -1;
        this.prevCC = -1;
        this.vttCCs = newVTTCCs();
        this.captionsProperties = void 0;
        this.hls = hls;
        this.config = hls.config;
        this.Cues = hls.config.cueHandler;
        this.captionsProperties = {
          textTrack1: {
            label: this.config.captionsTextTrack1Label,
            languageCode: this.config.captionsTextTrack1LanguageCode
          },
          textTrack2: {
            label: this.config.captionsTextTrack2Label,
            languageCode: this.config.captionsTextTrack2LanguageCode
          },
          textTrack3: {
            label: this.config.captionsTextTrack3Label,
            languageCode: this.config.captionsTextTrack3LanguageCode
          },
          textTrack4: {
            label: this.config.captionsTextTrack4Label,
            languageCode: this.config.captionsTextTrack4LanguageCode
          }
        };
        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
        hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
        hls.on(Events.FRAG_LOADING, this.onFragLoading, this);
        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
        hls.on(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
        hls.on(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);
        hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
        hls.on(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
      }
      var _proto = TimelineController2.prototype;
      _proto.destroy = function destroy() {
        var hls = this.hls;
        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
        hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
        hls.off(Events.FRAG_LOADING, this.onFragLoading, this);
        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
        hls.off(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
        hls.off(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);
        hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
        hls.off(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
        this.hls = this.config = null;
        this.cea608Parser1 = this.cea608Parser2 = void 0;
      };
      _proto.initCea608Parsers = function initCea608Parsers() {
        if (this.config.enableCEA708Captions && (!this.cea608Parser1 || !this.cea608Parser2)) {
          var channel1 = new OutputFilter(this, "textTrack1");
          var channel2 = new OutputFilter(this, "textTrack2");
          var channel3 = new OutputFilter(this, "textTrack3");
          var channel4 = new OutputFilter(this, "textTrack4");
          this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);
          this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);
        }
      };
      _proto.addCues = function addCues(trackName, startTime, endTime, screen, cueRanges) {
        var merged = false;
        for (var i = cueRanges.length; i--; ) {
          var cueRange = cueRanges[i];
          var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
          if (overlap >= 0) {
            cueRange[0] = Math.min(cueRange[0], startTime);
            cueRange[1] = Math.max(cueRange[1], endTime);
            merged = true;
            if (overlap / (endTime - startTime) > 0.5) {
              return;
            }
          }
        }
        if (!merged) {
          cueRanges.push([startTime, endTime]);
        }
        if (this.config.renderTextTracksNatively) {
          var track = this.captionsTracks[trackName];
          this.Cues.newCue(track, startTime, endTime, screen);
        } else {
          var cues = this.Cues.newCue(null, startTime, endTime, screen);
          this.hls.trigger(Events.CUES_PARSED, {
            type: "captions",
            cues,
            track: trackName
          });
        }
      };
      _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {
        var _this = this;
        var frag = _ref.frag, id = _ref.id, initPTS = _ref.initPTS, timescale = _ref.timescale;
        var unparsedVttFrags = this.unparsedVttFrags;
        if (id === "main") {
          this.initPTS[frag.cc] = {
            baseTime: initPTS,
            timescale
          };
        }
        if (unparsedVttFrags.length) {
          this.unparsedVttFrags = [];
          unparsedVttFrags.forEach(function(frag2) {
            _this.onFragLoaded(Events.FRAG_LOADED, frag2);
          });
        }
      };
      _proto.getExistingTrack = function getExistingTrack(label, language) {
        var media = this.media;
        if (media) {
          for (var i = 0; i < media.textTracks.length; i++) {
            var textTrack = media.textTracks[i];
            if (canReuseVttTextTrack(textTrack, {
              name: label,
              lang: language,
              attrs: {}
            })) {
              return textTrack;
            }
          }
        }
        return null;
      };
      _proto.createCaptionsTrack = function createCaptionsTrack(trackName) {
        if (this.config.renderTextTracksNatively) {
          this.createNativeTrack(trackName);
        } else {
          this.createNonNativeTrack(trackName);
        }
      };
      _proto.createNativeTrack = function createNativeTrack(trackName) {
        if (this.captionsTracks[trackName]) {
          return;
        }
        var captionsProperties = this.captionsProperties, captionsTracks = this.captionsTracks, media = this.media;
        var _captionsProperties$t = captionsProperties[trackName], label = _captionsProperties$t.label, languageCode = _captionsProperties$t.languageCode;
        var existingTrack = this.getExistingTrack(label, languageCode);
        if (!existingTrack) {
          var textTrack = this.createTextTrack("captions", label, languageCode);
          if (textTrack) {
            textTrack[trackName] = true;
            captionsTracks[trackName] = textTrack;
          }
        } else {
          captionsTracks[trackName] = existingTrack;
          clearCurrentCues(captionsTracks[trackName]);
          sendAddTrackEvent(captionsTracks[trackName], media);
        }
      };
      _proto.createNonNativeTrack = function createNonNativeTrack(trackName) {
        if (this.nonNativeCaptionsTracks[trackName]) {
          return;
        }
        var trackProperties = this.captionsProperties[trackName];
        if (!trackProperties) {
          return;
        }
        var label = trackProperties.label;
        var track = {
          _id: trackName,
          label,
          kind: "captions",
          default: trackProperties.media ? !!trackProperties.media.default : false,
          closedCaptions: trackProperties.media
        };
        this.nonNativeCaptionsTracks[trackName] = track;
        this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
          tracks: [track]
        });
      };
      _proto.createTextTrack = function createTextTrack(kind, label, lang) {
        var media = this.media;
        if (!media) {
          return;
        }
        return media.addTextTrack(kind, label, lang);
      };
      _proto.onMediaAttaching = function onMediaAttaching(event, data) {
        this.media = data.media;
        this._cleanTracks();
      };
      _proto.onMediaDetaching = function onMediaDetaching() {
        var captionsTracks = this.captionsTracks;
        Object.keys(captionsTracks).forEach(function(trackName) {
          clearCurrentCues(captionsTracks[trackName]);
          delete captionsTracks[trackName];
        });
        this.nonNativeCaptionsTracks = {};
      };
      _proto.onManifestLoading = function onManifestLoading() {
        this.lastCc = -1;
        this.lastSn = -1;
        this.lastPartIndex = -1;
        this.prevCC = -1;
        this.vttCCs = newVTTCCs();
        this._cleanTracks();
        this.tracks = [];
        this.captionsTracks = {};
        this.nonNativeCaptionsTracks = {};
        this.textTracks = [];
        this.unparsedVttFrags = [];
        this.initPTS = [];
        if (this.cea608Parser1 && this.cea608Parser2) {
          this.cea608Parser1.reset();
          this.cea608Parser2.reset();
        }
      };
      _proto._cleanTracks = function _cleanTracks() {
        var media = this.media;
        if (!media) {
          return;
        }
        var textTracks = media.textTracks;
        if (textTracks) {
          for (var i = 0; i < textTracks.length; i++) {
            clearCurrentCues(textTracks[i]);
          }
        }
      };
      _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, data) {
        var _this2 = this;
        var tracks = data.subtitleTracks || [];
        var hasIMSC1 = tracks.some(function(track) {
          return track.textCodec === IMSC1_CODEC;
        });
        if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {
          var listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);
          if (listIsIdentical) {
            this.tracks = tracks;
            return;
          }
          this.textTracks = [];
          this.tracks = tracks;
          if (this.config.renderTextTracksNatively) {
            var media = this.media;
            var inUseTracks = media ? filterSubtitleTracks(media.textTracks) : null;
            this.tracks.forEach(function(track, index) {
              var textTrack;
              if (inUseTracks) {
                var inUseTrack = null;
                for (var i = 0; i < inUseTracks.length; i++) {
                  if (inUseTracks[i] && canReuseVttTextTrack(inUseTracks[i], track)) {
                    inUseTrack = inUseTracks[i];
                    inUseTracks[i] = null;
                    break;
                  }
                }
                if (inUseTrack) {
                  textTrack = inUseTrack;
                }
              }
              if (textTrack) {
                clearCurrentCues(textTrack);
              } else {
                var textTrackKind = captionsOrSubtitlesFromCharacteristics(track);
                textTrack = _this2.createTextTrack(textTrackKind, track.name, track.lang);
                if (textTrack) {
                  textTrack.mode = "disabled";
                }
              }
              if (textTrack) {
                _this2.textTracks.push(textTrack);
              }
            });
            if (inUseTracks != null && inUseTracks.length) {
              var unusedTextTracks = inUseTracks.filter(function(t) {
                return t !== null;
              }).map(function(t) {
                return t.label;
              });
              if (unusedTextTracks.length) {
                logger.warn("Media element contains unused subtitle tracks: " + unusedTextTracks.join(", ") + ". Replace media element for each source to clear TextTracks and captions menu.");
              }
            }
          } else if (this.tracks.length) {
            var tracksList = this.tracks.map(function(track) {
              return {
                label: track.name,
                kind: track.type.toLowerCase(),
                default: track.default,
                subtitleTrack: track
              };
            });
            this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
              tracks: tracksList
            });
          }
        }
      };
      _proto.onManifestLoaded = function onManifestLoaded(event, data) {
        var _this3 = this;
        if (this.config.enableCEA708Captions && data.captions) {
          data.captions.forEach(function(captionsTrack) {
            var instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);
            if (!instreamIdMatch) {
              return;
            }
            var trackName = "textTrack" + instreamIdMatch[1];
            var trackProperties = _this3.captionsProperties[trackName];
            if (!trackProperties) {
              return;
            }
            trackProperties.label = captionsTrack.name;
            if (captionsTrack.lang) {
              trackProperties.languageCode = captionsTrack.lang;
            }
            trackProperties.media = captionsTrack;
          });
        }
      };
      _proto.closedCaptionsForLevel = function closedCaptionsForLevel(frag) {
        var level = this.hls.levels[frag.level];
        return level == null ? void 0 : level.attrs["CLOSED-CAPTIONS"];
      };
      _proto.onFragLoading = function onFragLoading(event, data) {
        this.initCea608Parsers();
        var cea608Parser1 = this.cea608Parser1, cea608Parser2 = this.cea608Parser2, lastCc = this.lastCc, lastSn = this.lastSn, lastPartIndex = this.lastPartIndex;
        if (!this.enabled || !cea608Parser1 || !cea608Parser2) {
          return;
        }
        if (data.frag.type === PlaylistLevelType.MAIN) {
          var _data$part$index, _data$part;
          var _data$frag = data.frag, cc = _data$frag.cc, sn = _data$frag.sn;
          var partIndex = (_data$part$index = data == null ? void 0 : (_data$part = data.part) == null ? void 0 : _data$part.index) != null ? _data$part$index : -1;
          if (!(sn === lastSn + 1 || sn === lastSn && partIndex === lastPartIndex + 1 || cc === lastCc)) {
            cea608Parser1.reset();
            cea608Parser2.reset();
          }
          this.lastCc = cc;
          this.lastSn = sn;
          this.lastPartIndex = partIndex;
        }
      };
      _proto.onFragLoaded = function onFragLoaded(event, data) {
        var frag = data.frag, payload = data.payload;
        if (frag.type === PlaylistLevelType.SUBTITLE) {
          if (payload.byteLength) {
            var decryptData = frag.decryptdata;
            var decrypted = "stats" in data;
            if (decryptData == null || !decryptData.encrypted || decrypted) {
              var trackPlaylistMedia = this.tracks[frag.level];
              var vttCCs = this.vttCCs;
              if (!vttCCs[frag.cc]) {
                vttCCs[frag.cc] = {
                  start: frag.start,
                  prevCC: this.prevCC,
                  new: true
                };
                this.prevCC = frag.cc;
              }
              if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {
                this._parseIMSC1(frag, payload);
              } else {
                this._parseVTTs(data);
              }
            }
          } else {
            this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
              success: false,
              frag,
              error: new Error("Empty subtitle payload")
            });
          }
        }
      };
      _proto._parseIMSC1 = function _parseIMSC1(frag, payload) {
        var _this4 = this;
        var hls = this.hls;
        parseIMSC1(payload, this.initPTS[frag.cc], function(cues) {
          _this4._appendCues(cues, frag.level);
          hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
            success: true,
            frag
          });
        }, function(error) {
          logger.log("Failed to parse IMSC1: " + error);
          hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
            success: false,
            frag,
            error
          });
        });
      };
      _proto._parseVTTs = function _parseVTTs(data) {
        var _frag$initSegment, _this5 = this;
        var frag = data.frag, payload = data.payload;
        var initPTS = this.initPTS, unparsedVttFrags = this.unparsedVttFrags;
        var maxAvCC = initPTS.length - 1;
        if (!initPTS[frag.cc] && maxAvCC === -1) {
          unparsedVttFrags.push(data);
          return;
        }
        var hls = this.hls;
        var payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)) : payload;
        parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, function(cues) {
          _this5._appendCues(cues, frag.level);
          hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
            success: true,
            frag
          });
        }, function(error) {
          var missingInitPTS = error.message === "Missing initPTS for VTT MPEGTS";
          if (missingInitPTS) {
            unparsedVttFrags.push(data);
          } else {
            _this5._fallbackToIMSC1(frag, payload);
          }
          logger.log("Failed to parse VTT cue: " + error);
          if (missingInitPTS && maxAvCC > frag.cc) {
            return;
          }
          hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
            success: false,
            frag,
            error
          });
        });
      };
      _proto._fallbackToIMSC1 = function _fallbackToIMSC1(frag, payload) {
        var _this6 = this;
        var trackPlaylistMedia = this.tracks[frag.level];
        if (!trackPlaylistMedia.textCodec) {
          parseIMSC1(payload, this.initPTS[frag.cc], function() {
            trackPlaylistMedia.textCodec = IMSC1_CODEC;
            _this6._parseIMSC1(frag, payload);
          }, function() {
            trackPlaylistMedia.textCodec = "wvtt";
          });
        }
      };
      _proto._appendCues = function _appendCues(cues, fragLevel) {
        var hls = this.hls;
        if (this.config.renderTextTracksNatively) {
          var textTrack = this.textTracks[fragLevel];
          if (!textTrack || textTrack.mode === "disabled") {
            return;
          }
          cues.forEach(function(cue) {
            return addCueToTrack(textTrack, cue);
          });
        } else {
          var currentTrack = this.tracks[fragLevel];
          if (!currentTrack) {
            return;
          }
          var track = currentTrack.default ? "default" : "subtitles" + fragLevel;
          hls.trigger(Events.CUES_PARSED, {
            type: "subtitles",
            cues,
            track
          });
        }
      };
      _proto.onFragDecrypted = function onFragDecrypted(event, data) {
        var frag = data.frag;
        if (frag.type === PlaylistLevelType.SUBTITLE) {
          this.onFragLoaded(Events.FRAG_LOADED, data);
        }
      };
      _proto.onSubtitleTracksCleared = function onSubtitleTracksCleared() {
        this.tracks = [];
        this.captionsTracks = {};
      };
      _proto.onFragParsingUserdata = function onFragParsingUserdata(event, data) {
        this.initCea608Parsers();
        var cea608Parser1 = this.cea608Parser1, cea608Parser2 = this.cea608Parser2;
        if (!this.enabled || !cea608Parser1 || !cea608Parser2) {
          return;
        }
        var frag = data.frag, samples = data.samples;
        if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === "NONE") {
          return;
        }
        for (var i = 0; i < samples.length; i++) {
          var ccBytes = samples[i].bytes;
          if (ccBytes) {
            var ccdatas = this.extractCea608Data(ccBytes);
            cea608Parser1.addData(samples[i].pts, ccdatas[0]);
            cea608Parser2.addData(samples[i].pts, ccdatas[1]);
          }
        }
      };
      _proto.onBufferFlushing = function onBufferFlushing(event, _ref2) {
        var startOffset = _ref2.startOffset, endOffset = _ref2.endOffset, endOffsetSubtitles = _ref2.endOffsetSubtitles, type = _ref2.type;
        var media = this.media;
        if (!media || media.currentTime < endOffset) {
          return;
        }
        if (!type || type === "video") {
          var captionsTracks = this.captionsTracks;
          Object.keys(captionsTracks).forEach(function(trackName) {
            return removeCuesInRange(captionsTracks[trackName], startOffset, endOffset);
          });
        }
        if (this.config.renderTextTracksNatively) {
          if (startOffset === 0 && endOffsetSubtitles !== void 0) {
            var textTracks = this.textTracks;
            Object.keys(textTracks).forEach(function(trackName) {
              return removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles);
            });
          }
        }
      };
      _proto.extractCea608Data = function extractCea608Data(byteArray) {
        var actualCCBytes = [[], []];
        var count = byteArray[0] & 31;
        var position = 2;
        for (var j = 0; j < count; j++) {
          var tmpByte = byteArray[position++];
          var ccbyte1 = 127 & byteArray[position++];
          var ccbyte2 = 127 & byteArray[position++];
          if (ccbyte1 === 0 && ccbyte2 === 0) {
            continue;
          }
          var ccValid = (4 & tmpByte) !== 0;
          if (ccValid) {
            var ccType = 3 & tmpByte;
            if (0 === ccType || 1 === ccType) {
              actualCCBytes[ccType].push(ccbyte1);
              actualCCBytes[ccType].push(ccbyte2);
            }
          }
        }
        return actualCCBytes;
      };
      return TimelineController2;
    }();
    function captionsOrSubtitlesFromCharacteristics(track) {
      if (track.characteristics) {
        if (/transcribes-spoken-dialog/gi.test(track.characteristics) && /describes-music-and-sound/gi.test(track.characteristics)) {
          return "captions";
        }
      }
      return "subtitles";
    }
    function canReuseVttTextTrack(inUseTrack, manifestTrack) {
      return !!inUseTrack && inUseTrack.kind === captionsOrSubtitlesFromCharacteristics(manifestTrack) && subtitleTrackMatchesTextTrack(manifestTrack, inUseTrack);
    }
    function intersection(x1, x2, y1, y2) {
      return Math.min(x2, y2) - Math.max(x1, y1);
    }
    function newVTTCCs() {
      return {
        ccOffset: 0,
        presentationOffset: 0,
        0: {
          start: 0,
          prevCC: -1,
          new: true
        }
      };
    }
    var CapLevelController = /* @__PURE__ */ function() {
      function CapLevelController2(hls) {
        this.hls = void 0;
        this.autoLevelCapping = void 0;
        this.firstLevel = void 0;
        this.media = void 0;
        this.restrictedLevels = void 0;
        this.timer = void 0;
        this.clientRect = void 0;
        this.streamController = void 0;
        this.hls = hls;
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        this.firstLevel = -1;
        this.media = null;
        this.restrictedLevels = [];
        this.timer = void 0;
        this.clientRect = null;
        this.registerListeners();
      }
      var _proto = CapLevelController2.prototype;
      _proto.setStreamController = function setStreamController(streamController) {
        this.streamController = streamController;
      };
      _proto.destroy = function destroy() {
        if (this.hls) {
          this.unregisterListener();
        }
        if (this.timer) {
          this.stopCapping();
        }
        this.media = null;
        this.clientRect = null;
        this.hls = this.streamController = null;
      };
      _proto.registerListeners = function registerListeners() {
        var hls = this.hls;
        hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
        hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);
        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      };
      _proto.unregisterListener = function unregisterListener() {
        var hls = this.hls;
        hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
        hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      };
      _proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(event, data) {
        var level = this.hls.levels[data.droppedLevel];
        if (this.isLevelAllowed(level)) {
          this.restrictedLevels.push({
            bitrate: level.bitrate,
            height: level.height,
            width: level.width
          });
        }
      };
      _proto.onMediaAttaching = function onMediaAttaching(event, data) {
        this.media = data.media instanceof HTMLVideoElement ? data.media : null;
        this.clientRect = null;
        if (this.timer && this.hls.levels.length) {
          this.detectPlayerSize();
        }
      };
      _proto.onManifestParsed = function onManifestParsed(event, data) {
        var hls = this.hls;
        this.restrictedLevels = [];
        this.firstLevel = data.firstLevel;
        if (hls.config.capLevelToPlayerSize && data.video) {
          this.startCapping();
        }
      };
      _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {
        if (this.timer && isFiniteNumber(this.autoLevelCapping)) {
          this.detectPlayerSize();
        }
      };
      _proto.onBufferCodecs = function onBufferCodecs(event, data) {
        var hls = this.hls;
        if (hls.config.capLevelToPlayerSize && data.video) {
          this.startCapping();
        }
      };
      _proto.onMediaDetaching = function onMediaDetaching() {
        this.stopCapping();
      };
      _proto.detectPlayerSize = function detectPlayerSize() {
        if (this.media) {
          if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {
            this.clientRect = null;
            return;
          }
          var levels = this.hls.levels;
          if (levels.length) {
            var hls = this.hls;
            var maxLevel = this.getMaxLevel(levels.length - 1);
            if (maxLevel !== this.autoLevelCapping) {
              logger.log("Setting autoLevelCapping to " + maxLevel + ": " + levels[maxLevel].height + "p@" + levels[maxLevel].bitrate + " for media " + this.mediaWidth + "x" + this.mediaHeight);
            }
            hls.autoLevelCapping = maxLevel;
            if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {
              this.streamController.nextLevelSwitch();
            }
            this.autoLevelCapping = hls.autoLevelCapping;
          }
        }
      };
      _proto.getMaxLevel = function getMaxLevel(capLevelIndex) {
        var _this = this;
        var levels = this.hls.levels;
        if (!levels.length) {
          return -1;
        }
        var validLevels = levels.filter(function(level, index) {
          return _this.isLevelAllowed(level) && index <= capLevelIndex;
        });
        this.clientRect = null;
        return CapLevelController2.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
      };
      _proto.startCapping = function startCapping() {
        if (this.timer) {
          return;
        }
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        self.clearInterval(this.timer);
        this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3);
        this.detectPlayerSize();
      };
      _proto.stopCapping = function stopCapping() {
        this.restrictedLevels = [];
        this.firstLevel = -1;
        this.autoLevelCapping = Number.POSITIVE_INFINITY;
        if (this.timer) {
          self.clearInterval(this.timer);
          this.timer = void 0;
        }
      };
      _proto.getDimensions = function getDimensions() {
        if (this.clientRect) {
          return this.clientRect;
        }
        var media = this.media;
        var boundsRect = {
          width: 0,
          height: 0
        };
        if (media) {
          var clientRect = media.getBoundingClientRect();
          boundsRect.width = clientRect.width;
          boundsRect.height = clientRect.height;
          if (!boundsRect.width && !boundsRect.height) {
            boundsRect.width = clientRect.right - clientRect.left || media.width || 0;
            boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;
          }
        }
        this.clientRect = boundsRect;
        return boundsRect;
      };
      _proto.isLevelAllowed = function isLevelAllowed(level) {
        var restrictedLevels = this.restrictedLevels;
        return !restrictedLevels.some(function(restrictedLevel) {
          return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;
        });
      };
      CapLevelController2.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {
        if (!(levels != null && levels.length)) {
          return -1;
        }
        var atGreatestBandwidth = function atGreatestBandwidth2(curLevel, nextLevel) {
          if (!nextLevel) {
            return true;
          }
          return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
        };
        var maxLevelIndex = levels.length - 1;
        var squareSize = Math.max(width, height);
        for (var i = 0; i < levels.length; i += 1) {
          var level = levels[i];
          if ((level.width >= squareSize || level.height >= squareSize) && atGreatestBandwidth(level, levels[i + 1])) {
            maxLevelIndex = i;
            break;
          }
        }
        return maxLevelIndex;
      };
      _createClass(CapLevelController2, [{
        key: "mediaWidth",
        get: function get() {
          return this.getDimensions().width * this.contentScaleFactor;
        }
      }, {
        key: "mediaHeight",
        get: function get() {
          return this.getDimensions().height * this.contentScaleFactor;
        }
      }, {
        key: "contentScaleFactor",
        get: function get() {
          var pixelRatio = 1;
          if (!this.hls.config.ignoreDevicePixelRatio) {
            try {
              pixelRatio = self.devicePixelRatio;
            } catch (e) {
            }
          }
          return pixelRatio;
        }
      }]);
      return CapLevelController2;
    }();
    var FPSController = /* @__PURE__ */ function() {
      function FPSController2(hls) {
        this.hls = void 0;
        this.isVideoPlaybackQualityAvailable = false;
        this.timer = void 0;
        this.media = null;
        this.lastTime = void 0;
        this.lastDroppedFrames = 0;
        this.lastDecodedFrames = 0;
        this.streamController = void 0;
        this.hls = hls;
        this.registerListeners();
      }
      var _proto = FPSController2.prototype;
      _proto.setStreamController = function setStreamController(streamController) {
        this.streamController = streamController;
      };
      _proto.registerListeners = function registerListeners() {
        this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      };
      _proto.unregisterListeners = function unregisterListeners() {
        this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      };
      _proto.destroy = function destroy() {
        if (this.timer) {
          clearInterval(this.timer);
        }
        this.unregisterListeners();
        this.isVideoPlaybackQualityAvailable = false;
        this.media = null;
      };
      _proto.onMediaAttaching = function onMediaAttaching(event, data) {
        var config = this.hls.config;
        if (config.capLevelOnFPSDrop) {
          var media = data.media instanceof self.HTMLVideoElement ? data.media : null;
          this.media = media;
          if (media && typeof media.getVideoPlaybackQuality === "function") {
            this.isVideoPlaybackQualityAvailable = true;
          }
          self.clearInterval(this.timer);
          this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
        }
      };
      _proto.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {
        var currentTime = performance.now();
        if (decodedFrames) {
          if (this.lastTime) {
            var currentPeriod = currentTime - this.lastTime;
            var currentDropped = droppedFrames - this.lastDroppedFrames;
            var currentDecoded = decodedFrames - this.lastDecodedFrames;
            var droppedFPS = 1e3 * currentDropped / currentPeriod;
            var hls = this.hls;
            hls.trigger(Events.FPS_DROP, {
              currentDropped,
              currentDecoded,
              totalDroppedFrames: droppedFrames
            });
            if (droppedFPS > 0) {
              if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
                var currentLevel = hls.currentLevel;
                logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + currentLevel);
                if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                  currentLevel = currentLevel - 1;
                  hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {
                    level: currentLevel,
                    droppedLevel: hls.currentLevel
                  });
                  hls.autoLevelCapping = currentLevel;
                  this.streamController.nextLevelSwitch();
                }
              }
            }
          }
          this.lastTime = currentTime;
          this.lastDroppedFrames = droppedFrames;
          this.lastDecodedFrames = decodedFrames;
        }
      };
      _proto.checkFPSInterval = function checkFPSInterval() {
        var video = this.media;
        if (video) {
          if (this.isVideoPlaybackQualityAvailable) {
            var videoPlaybackQuality = video.getVideoPlaybackQuality();
            this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
          } else {
            this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
          }
        }
      };
      return FPSController2;
    }();
    var LOGGER_PREFIX = "[eme]";
    var EMEController = /* @__PURE__ */ function() {
      function EMEController2(hls) {
        this.hls = void 0;
        this.config = void 0;
        this.media = null;
        this.keyFormatPromise = null;
        this.keySystemAccessPromises = {};
        this._requestLicenseFailureCount = 0;
        this.mediaKeySessions = [];
        this.keyIdToKeySessionPromise = {};
        this.setMediaKeysQueue = EMEController2.CDMCleanupPromise ? [EMEController2.CDMCleanupPromise] : [];
        this.onMediaEncrypted = this._onMediaEncrypted.bind(this);
        this.onWaitingForKey = this._onWaitingForKey.bind(this);
        this.debug = logger.debug.bind(logger, LOGGER_PREFIX);
        this.log = logger.log.bind(logger, LOGGER_PREFIX);
        this.warn = logger.warn.bind(logger, LOGGER_PREFIX);
        this.error = logger.error.bind(logger, LOGGER_PREFIX);
        this.hls = hls;
        this.config = hls.config;
        this.registerListeners();
      }
      var _proto = EMEController2.prototype;
      _proto.destroy = function destroy() {
        this.unregisterListeners();
        this.onMediaDetached();
        var config = this.config;
        config.requestMediaKeySystemAccessFunc = null;
        config.licenseXhrSetup = config.licenseResponseCallback = void 0;
        config.drmSystems = config.drmSystemOptions = {};
        this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null;
        this.config = null;
      };
      _proto.registerListeners = function registerListeners() {
        this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        this.hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);
        this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        this.hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      };
      _proto.unregisterListeners = function unregisterListeners() {
        this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        this.hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);
        this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      };
      _proto.getLicenseServerUrl = function getLicenseServerUrl(keySystem) {
        var _this$config = this.config, drmSystems = _this$config.drmSystems, widevineLicenseUrl = _this$config.widevineLicenseUrl;
        var keySystemConfiguration = drmSystems[keySystem];
        if (keySystemConfiguration) {
          return keySystemConfiguration.licenseUrl;
        }
        if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {
          return widevineLicenseUrl;
        }
        throw new Error('no license server URL configured for key-system "' + keySystem + '"');
      };
      _proto.getServerCertificateUrl = function getServerCertificateUrl(keySystem) {
        var drmSystems = this.config.drmSystems;
        var keySystemConfiguration = drmSystems[keySystem];
        if (keySystemConfiguration) {
          return keySystemConfiguration.serverCertificateUrl;
        } else {
          this.log('No Server Certificate in config.drmSystems["' + keySystem + '"]');
        }
      };
      _proto.attemptKeySystemAccess = function attemptKeySystemAccess(keySystemsToAttempt) {
        var _this = this;
        var levels = this.hls.levels;
        var uniqueCodec = function uniqueCodec2(value, i, a) {
          return !!value && a.indexOf(value) === i;
        };
        var audioCodecs = levels.map(function(level) {
          return level.audioCodec;
        }).filter(uniqueCodec);
        var videoCodecs = levels.map(function(level) {
          return level.videoCodec;
        }).filter(uniqueCodec);
        if (audioCodecs.length + videoCodecs.length === 0) {
          videoCodecs.push("avc1.42e01e");
        }
        return new Promise(function(resolve, reject) {
          var attempt = function attempt2(keySystems) {
            var keySystem = keySystems.shift();
            _this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then(function(mediaKeys) {
              return resolve({
                keySystem,
                mediaKeys
              });
            }).catch(function(error) {
              if (keySystems.length) {
                attempt2(keySystems);
              } else if (error instanceof EMEKeyError) {
                reject(error);
              } else {
                reject(new EMEKeyError({
                  type: ErrorTypes.KEY_SYSTEM_ERROR,
                  details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,
                  error,
                  fatal: true
                }, error.message));
              }
            });
          };
          attempt(keySystemsToAttempt);
        });
      };
      _proto.requestMediaKeySystemAccess = function requestMediaKeySystemAccess$1(keySystem, supportedConfigurations) {
        var requestMediaKeySystemAccessFunc = this.config.requestMediaKeySystemAccessFunc;
        if (!(typeof requestMediaKeySystemAccessFunc === "function")) {
          var errMessage = "Configured requestMediaKeySystemAccess is not a function " + requestMediaKeySystemAccessFunc;
          if (requestMediaKeySystemAccess === null && self.location.protocol === "http:") {
            errMessage = "navigator.requestMediaKeySystemAccess is not available over insecure protocol " + location.protocol;
          }
          return Promise.reject(new Error(errMessage));
        }
        return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);
      };
      _proto.getMediaKeysPromise = function getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {
        var _this2 = this;
        var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);
        var keySystemAccessPromises = this.keySystemAccessPromises[keySystem];
        var keySystemAccess = keySystemAccessPromises == null ? void 0 : keySystemAccessPromises.keySystemAccess;
        if (!keySystemAccess) {
          this.log('Requesting encrypted media "' + keySystem + '" key-system access with config: ' + JSON.stringify(mediaKeySystemConfigs));
          keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);
          var _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {
            keySystemAccess
          };
          keySystemAccess.catch(function(error) {
            _this2.log('Failed to obtain access to key-system "' + keySystem + '": ' + error);
          });
          return keySystemAccess.then(function(mediaKeySystemAccess) {
            _this2.log('Access for key-system "' + mediaKeySystemAccess.keySystem + '" obtained');
            var certificateRequest = _this2.fetchServerCertificate(keySystem);
            _this2.log('Create media-keys for "' + keySystem + '"');
            _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then(function(mediaKeys) {
              _this2.log('Media-keys created for "' + keySystem + '"');
              return certificateRequest.then(function(certificate) {
                if (certificate) {
                  return _this2.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);
                }
                return mediaKeys;
              });
            });
            _keySystemAccessPromises.mediaKeys.catch(function(error) {
              _this2.error('Failed to create media-keys for "' + keySystem + '"}: ' + error);
            });
            return _keySystemAccessPromises.mediaKeys;
          });
        }
        return keySystemAccess.then(function() {
          return keySystemAccessPromises.mediaKeys;
        });
      };
      _proto.createMediaKeySessionContext = function createMediaKeySessionContext(_ref) {
        var decryptdata = _ref.decryptdata, keySystem = _ref.keySystem, mediaKeys = _ref.mediaKeys;
        this.log('Creating key-system session "' + keySystem + '" keyId: ' + Hex.hexDump(decryptdata.keyId || []));
        var mediaKeysSession = mediaKeys.createSession();
        var mediaKeySessionContext = {
          decryptdata,
          keySystem,
          mediaKeys,
          mediaKeysSession,
          keyStatus: "status-pending"
        };
        this.mediaKeySessions.push(mediaKeySessionContext);
        return mediaKeySessionContext;
      };
      _proto.renewKeySession = function renewKeySession(mediaKeySessionContext) {
        var decryptdata = mediaKeySessionContext.decryptdata;
        if (decryptdata.pssh) {
          var keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);
          var _keyId = this.getKeyIdString(decryptdata);
          var scheme = "cenc";
          this.keyIdToKeySessionPromise[_keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, "expired");
        } else {
          this.warn("Could not renew expired session. Missing pssh initData.");
        }
        this.removeSession(mediaKeySessionContext);
      };
      _proto.getKeyIdString = function getKeyIdString(decryptdata) {
        if (!decryptdata) {
          throw new Error("Could not read keyId of undefined decryptdata");
        }
        if (decryptdata.keyId === null) {
          throw new Error("keyId is null");
        }
        return Hex.hexDump(decryptdata.keyId);
      };
      _proto.updateKeySession = function updateKeySession(mediaKeySessionContext, data) {
        var _mediaKeySessionConte;
        var keySession = mediaKeySessionContext.mediaKeysSession;
        this.log('Updating key-session "' + keySession.sessionId + '" for keyID ' + Hex.hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) == null ? void 0 : _mediaKeySessionConte.keyId) || []) + "\n      } (data length: " + (data ? data.byteLength : data) + ")");
        return keySession.update(data);
      };
      _proto.selectKeySystemFormat = function selectKeySystemFormat(frag) {
        var keyFormats = Object.keys(frag.levelkeys || {});
        if (!this.keyFormatPromise) {
          this.log("Selecting key-system from fragment (sn: " + frag.sn + " " + frag.type + ": " + frag.level + ") key formats " + keyFormats.join(", "));
          this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
        }
        return this.keyFormatPromise;
      };
      _proto.getKeyFormatPromise = function getKeyFormatPromise(keyFormats) {
        var _this3 = this;
        return new Promise(function(resolve, reject) {
          var keySystemsInConfig = getKeySystemsForConfig(_this3.config);
          var keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter(function(value) {
            return !!value && keySystemsInConfig.indexOf(value) !== -1;
          });
          return _this3.getKeySystemSelectionPromise(keySystemsToAttempt).then(function(_ref2) {
            var keySystem = _ref2.keySystem;
            var keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);
            if (keySystemFormat) {
              resolve(keySystemFormat);
            } else {
              reject(new Error('Unable to find format for key-system "' + keySystem + '"'));
            }
          }).catch(reject);
        });
      };
      _proto.loadKey = function loadKey(data) {
        var _this4 = this;
        var decryptdata = data.keyInfo.decryptdata;
        var keyId = this.getKeyIdString(decryptdata);
        var keyDetails = "(keyId: " + keyId + ' format: "' + decryptdata.keyFormat + '" method: ' + decryptdata.method + " uri: " + decryptdata.uri + ")";
        this.log("Starting session for key " + keyDetails);
        var keySessionContextPromise = this.keyIdToKeySessionPromise[keyId];
        if (!keySessionContextPromise) {
          keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = this.getKeySystemForKeyPromise(decryptdata).then(function(_ref3) {
            var keySystem = _ref3.keySystem, mediaKeys = _ref3.mediaKeys;
            _this4.throwIfDestroyed();
            _this4.log("Handle encrypted media sn: " + data.frag.sn + " " + data.frag.type + ": " + data.frag.level + " using key " + keyDetails);
            return _this4.attemptSetMediaKeys(keySystem, mediaKeys).then(function() {
              _this4.throwIfDestroyed();
              var keySessionContext = _this4.createMediaKeySessionContext({
                keySystem,
                mediaKeys,
                decryptdata
              });
              var scheme = "cenc";
              return _this4.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, "playlist-key");
            });
          });
          keySessionContextPromise.catch(function(error) {
            return _this4.handleError(error);
          });
        }
        return keySessionContextPromise;
      };
      _proto.throwIfDestroyed = function throwIfDestroyed(message) {
        if (!this.hls) {
          throw new Error("invalid state");
        }
      };
      _proto.handleError = function handleError(error) {
        if (!this.hls) {
          return;
        }
        this.error(error.message);
        if (error instanceof EMEKeyError) {
          this.hls.trigger(Events.ERROR, error.data);
        } else {
          this.hls.trigger(Events.ERROR, {
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_NO_KEYS,
            error,
            fatal: true
          });
        }
      };
      _proto.getKeySystemForKeyPromise = function getKeySystemForKeyPromise(decryptdata) {
        var keyId = this.getKeyIdString(decryptdata);
        var mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];
        if (!mediaKeySessionContext) {
          var keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);
          var keySystemsToAttempt = keySystem ? [keySystem] : getKeySystemsForConfig(this.config);
          return this.attemptKeySystemAccess(keySystemsToAttempt);
        }
        return mediaKeySessionContext;
      };
      _proto.getKeySystemSelectionPromise = function getKeySystemSelectionPromise(keySystemsToAttempt) {
        if (!keySystemsToAttempt.length) {
          keySystemsToAttempt = getKeySystemsForConfig(this.config);
        }
        if (keySystemsToAttempt.length === 0) {
          throw new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
            fatal: true
          }, "Missing key-system license configuration options " + JSON.stringify({
            drmSystems: this.config.drmSystems
          }));
        }
        return this.attemptKeySystemAccess(keySystemsToAttempt);
      };
      _proto._onMediaEncrypted = function _onMediaEncrypted(event) {
        var _this5 = this;
        var initDataType = event.initDataType, initData = event.initData;
        this.debug('"' + event.type + '" event: init data type: "' + initDataType + '"');
        if (initData === null) {
          return;
        }
        var keyId;
        var keySystemDomain;
        if (initDataType === "sinf" && this.config.drmSystems[KeySystems.FAIRPLAY]) {
          var json = bin2str(new Uint8Array(initData));
          try {
            var sinf = base64Decode(JSON.parse(json).sinf);
            var tenc = parseSinf(new Uint8Array(sinf));
            if (!tenc) {
              return;
            }
            keyId = tenc.subarray(8, 24);
            keySystemDomain = KeySystems.FAIRPLAY;
          } catch (error) {
            this.warn('Failed to parse sinf "encrypted" event message initData');
            return;
          }
        } else {
          var psshInfo = parsePssh(initData);
          if (psshInfo === null) {
            return;
          }
          if (psshInfo.version === 0 && psshInfo.systemId === KeySystemIds.WIDEVINE && psshInfo.data) {
            keyId = psshInfo.data.subarray(8, 24);
          }
          keySystemDomain = keySystemIdToKeySystemDomain(psshInfo.systemId);
        }
        if (!keySystemDomain || !keyId) {
          return;
        }
        var keyIdHex = Hex.hexDump(keyId);
        var keyIdToKeySessionPromise = this.keyIdToKeySessionPromise, mediaKeySessions = this.mediaKeySessions;
        var keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];
        var _loop = function _loop2() {
          var keyContext = mediaKeySessions[i];
          var decryptdata = keyContext.decryptdata;
          if (decryptdata.pssh || !decryptdata.keyId) {
            return 0;
          }
          var oldKeyIdHex = Hex.hexDump(decryptdata.keyId);
          if (keyIdHex === oldKeyIdHex || decryptdata.uri.replace(/-/g, "").indexOf(keyIdHex) !== -1) {
            keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];
            delete keyIdToKeySessionPromise[oldKeyIdHex];
            decryptdata.pssh = new Uint8Array(initData);
            decryptdata.keyId = keyId;
            keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(function() {
              return _this5.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, "encrypted-event-key-match");
            });
            return 1;
          }
        }, _ret;
        for (var i = 0; i < mediaKeySessions.length; i++) {
          _ret = _loop();
          if (_ret === 0)
            continue;
          if (_ret === 1)
            break;
        }
        if (!keySessionContextPromise) {
          keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = this.getKeySystemSelectionPromise([keySystemDomain]).then(function(_ref4) {
            var _keySystemToKeySystem;
            var keySystem = _ref4.keySystem, mediaKeys = _ref4.mediaKeys;
            _this5.throwIfDestroyed();
            var decryptdata = new LevelKey("ISO-23001-7", keyIdHex, (_keySystemToKeySystem = keySystemDomainToKeySystemFormat(keySystem)) != null ? _keySystemToKeySystem : "");
            decryptdata.pssh = new Uint8Array(initData);
            decryptdata.keyId = keyId;
            return _this5.attemptSetMediaKeys(keySystem, mediaKeys).then(function() {
              _this5.throwIfDestroyed();
              var keySessionContext = _this5.createMediaKeySessionContext({
                decryptdata,
                keySystem,
                mediaKeys
              });
              return _this5.generateRequestWithPreferredKeySession(keySessionContext, initDataType, initData, "encrypted-event-no-match");
            });
          });
        }
        keySessionContextPromise.catch(function(error) {
          return _this5.handleError(error);
        });
      };
      _proto._onWaitingForKey = function _onWaitingForKey(event) {
        this.log('"' + event.type + '" event');
      };
      _proto.attemptSetMediaKeys = function attemptSetMediaKeys(keySystem, mediaKeys) {
        var _this6 = this;
        var queue = this.setMediaKeysQueue.slice();
        this.log('Setting media-keys for "' + keySystem + '"');
        var setMediaKeysPromise = Promise.all(queue).then(function() {
          if (!_this6.media) {
            throw new Error("Attempted to set mediaKeys without media element attached");
          }
          return _this6.media.setMediaKeys(mediaKeys);
        });
        this.setMediaKeysQueue.push(setMediaKeysPromise);
        return setMediaKeysPromise.then(function() {
          _this6.log('Media-keys set for "' + keySystem + '"');
          queue.push(setMediaKeysPromise);
          _this6.setMediaKeysQueue = _this6.setMediaKeysQueue.filter(function(p) {
            return queue.indexOf(p) === -1;
          });
        });
      };
      _proto.generateRequestWithPreferredKeySession = function generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {
        var _this$config$drmSyste, _this$config$drmSyste2, _this7 = this;
        var generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null ? void 0 : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) == null ? void 0 : _this$config$drmSyste2.generateRequest;
        if (generateRequestFilter) {
          try {
            var mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);
            if (!mappedInitData) {
              throw new Error("Invalid response from configured generateRequest filter");
            }
            initDataType = mappedInitData.initDataType;
            initData = context.decryptdata.pssh = mappedInitData.initData ? new Uint8Array(mappedInitData.initData) : null;
          } catch (error) {
            var _this$hls;
            this.warn(error.message);
            if ((_this$hls = this.hls) != null && _this$hls.config.debug) {
              throw error;
            }
          }
        }
        if (initData === null) {
          this.log('Skipping key-session request for "' + reason + '" (no initData)');
          return Promise.resolve(context);
        }
        var keyId = this.getKeyIdString(context.decryptdata);
        this.log('Generating key-session request for "' + reason + '": ' + keyId + " (init data type: " + initDataType + " length: " + (initData ? initData.byteLength : null) + ")");
        var licenseStatus = new EventEmitter();
        var onmessage = context._onmessage = function(event) {
          var keySession = context.mediaKeysSession;
          if (!keySession) {
            licenseStatus.emit("error", new Error("invalid state"));
            return;
          }
          var messageType = event.messageType, message = event.message;
          _this7.log('"' + messageType + '" message event for session "' + keySession.sessionId + '" message size: ' + message.byteLength);
          if (messageType === "license-request" || messageType === "license-renewal") {
            _this7.renewLicense(context, message).catch(function(error) {
              _this7.handleError(error);
              licenseStatus.emit("error", error);
            });
          } else if (messageType === "license-release") {
            if (context.keySystem === KeySystems.FAIRPLAY) {
              _this7.updateKeySession(context, strToUtf8array("acknowledged"));
              _this7.removeSession(context);
            }
          } else {
            _this7.warn('unhandled media key message type "' + messageType + '"');
          }
        };
        var onkeystatuseschange = context._onkeystatuseschange = function(event) {
          var keySession = context.mediaKeysSession;
          if (!keySession) {
            licenseStatus.emit("error", new Error("invalid state"));
            return;
          }
          _this7.onKeyStatusChange(context);
          var keyStatus = context.keyStatus;
          licenseStatus.emit("keyStatus", keyStatus);
          if (keyStatus === "expired") {
            _this7.warn(context.keySystem + " expired for key " + keyId);
            _this7.renewKeySession(context);
          }
        };
        context.mediaKeysSession.addEventListener("message", onmessage);
        context.mediaKeysSession.addEventListener("keystatuseschange", onkeystatuseschange);
        var keyUsablePromise = new Promise(function(resolve, reject) {
          licenseStatus.on("error", reject);
          licenseStatus.on("keyStatus", function(keyStatus) {
            if (keyStatus.startsWith("usable")) {
              resolve();
            } else if (keyStatus === "output-restricted") {
              reject(new EMEKeyError({
                type: ErrorTypes.KEY_SYSTEM_ERROR,
                details: ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
                fatal: false
              }, "HDCP level output restricted"));
            } else if (keyStatus === "internal-error") {
              reject(new EMEKeyError({
                type: ErrorTypes.KEY_SYSTEM_ERROR,
                details: ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
                fatal: true
              }, 'key status changed to "' + keyStatus + '"'));
            } else if (keyStatus === "expired") {
              reject(new Error("key expired while generating request"));
            } else {
              _this7.warn('unhandled key status change "' + keyStatus + '"');
            }
          });
        });
        return context.mediaKeysSession.generateRequest(initDataType, initData).then(function() {
          var _context$mediaKeysSes;
          _this7.log('Request generated for key-session "' + ((_context$mediaKeysSes = context.mediaKeysSession) == null ? void 0 : _context$mediaKeysSes.sessionId) + '" keyId: ' + keyId);
        }).catch(function(error) {
          throw new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_NO_SESSION,
            error,
            fatal: false
          }, "Error generating key-session request: " + error);
        }).then(function() {
          return keyUsablePromise;
        }).catch(function(error) {
          licenseStatus.removeAllListeners();
          _this7.removeSession(context);
          throw error;
        }).then(function() {
          licenseStatus.removeAllListeners();
          return context;
        });
      };
      _proto.onKeyStatusChange = function onKeyStatusChange(mediaKeySessionContext) {
        var _this8 = this;
        mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach(function(status2, keyId) {
          _this8.log('key status change "' + status2 + '" for keyStatuses keyId: ' + Hex.hexDump("buffer" in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId)) + " session keyId: " + Hex.hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || [])) + " uri: " + mediaKeySessionContext.decryptdata.uri);
          mediaKeySessionContext.keyStatus = status2;
        });
      };
      _proto.fetchServerCertificate = function fetchServerCertificate(keySystem) {
        var config = this.config;
        var Loader = config.loader;
        var certLoader = new Loader(config);
        var url = this.getServerCertificateUrl(keySystem);
        if (!url) {
          return Promise.resolve();
        }
        this.log('Fetching server certificate for "' + keySystem + '"');
        return new Promise(function(resolve, reject) {
          var loaderContext = {
            responseType: "arraybuffer",
            url
          };
          var loadPolicy = config.certLoadPolicy.default;
          var loaderConfig = {
            loadPolicy,
            timeout: loadPolicy.maxLoadTimeMs,
            maxRetry: 0,
            retryDelay: 0,
            maxRetryDelay: 0
          };
          var loaderCallbacks = {
            onSuccess: function onSuccess(response, stats, context, networkDetails) {
              resolve(response.data);
            },
            onError: function onError(response, contex, networkDetails, stats) {
              reject(new EMEKeyError({
                type: ErrorTypes.KEY_SYSTEM_ERROR,
                details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                fatal: true,
                networkDetails,
                response: _objectSpread2({
                  url: loaderContext.url,
                  data: void 0
                }, response)
              }, '"' + keySystem + '" certificate request failed (' + url + "). Status: " + response.code + " (" + response.text + ")"));
            },
            onTimeout: function onTimeout(stats, context, networkDetails) {
              reject(new EMEKeyError({
                type: ErrorTypes.KEY_SYSTEM_ERROR,
                details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                fatal: true,
                networkDetails,
                response: {
                  url: loaderContext.url,
                  data: void 0
                }
              }, '"' + keySystem + '" certificate request timed out (' + url + ")"));
            },
            onAbort: function onAbort(stats, context, networkDetails) {
              reject(new Error("aborted"));
            }
          };
          certLoader.load(loaderContext, loaderConfig, loaderCallbacks);
        });
      };
      _proto.setMediaKeysServerCertificate = function setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {
        var _this9 = this;
        return new Promise(function(resolve, reject) {
          mediaKeys.setServerCertificate(cert).then(function(success) {
            _this9.log("setServerCertificate " + (success ? "success" : "not supported by CDM") + " (" + (cert == null ? void 0 : cert.byteLength) + ') on "' + keySystem + '"');
            resolve(mediaKeys);
          }).catch(function(error) {
            reject(new EMEKeyError({
              type: ErrorTypes.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
              error,
              fatal: true
            }, error.message));
          });
        });
      };
      _proto.renewLicense = function renewLicense(context, keyMessage) {
        var _this10 = this;
        return this.requestLicense(context, new Uint8Array(keyMessage)).then(function(data) {
          return _this10.updateKeySession(context, new Uint8Array(data)).catch(function(error) {
            throw new EMEKeyError({
              type: ErrorTypes.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,
              error,
              fatal: true
            }, error.message);
          });
        });
      };
      _proto.unpackPlayReadyKeyMessage = function unpackPlayReadyKeyMessage(xhr, licenseChallenge) {
        var xmlString = String.fromCharCode.apply(null, new Uint16Array(licenseChallenge.buffer));
        if (!xmlString.includes("PlayReadyKeyMessage")) {
          xhr.setRequestHeader("Content-Type", "text/xml; charset=utf-8");
          return licenseChallenge;
        }
        var keyMessageXml = new DOMParser().parseFromString(xmlString, "application/xml");
        var headers = keyMessageXml.querySelectorAll("HttpHeader");
        if (headers.length > 0) {
          var header;
          for (var i = 0, len = headers.length; i < len; i++) {
            var _header$querySelector, _header$querySelector2;
            header = headers[i];
            var name = (_header$querySelector = header.querySelector("name")) == null ? void 0 : _header$querySelector.textContent;
            var _value = (_header$querySelector2 = header.querySelector("value")) == null ? void 0 : _header$querySelector2.textContent;
            if (name && _value) {
              xhr.setRequestHeader(name, _value);
            }
          }
        }
        var challengeElement = keyMessageXml.querySelector("Challenge");
        var challengeText = challengeElement == null ? void 0 : challengeElement.textContent;
        if (!challengeText) {
          throw new Error("Cannot find <Challenge> in key message");
        }
        return strToUtf8array(atob(challengeText));
      };
      _proto.setupLicenseXHR = function setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {
        var _this11 = this;
        var licenseXhrSetup = this.config.licenseXhrSetup;
        if (!licenseXhrSetup) {
          xhr.open("POST", url, true);
          return Promise.resolve({
            xhr,
            licenseChallenge
          });
        }
        return Promise.resolve().then(function() {
          if (!keysListItem.decryptdata) {
            throw new Error("Key removed");
          }
          return licenseXhrSetup.call(_this11.hls, xhr, url, keysListItem, licenseChallenge);
        }).catch(function(error) {
          if (!keysListItem.decryptdata) {
            throw error;
          }
          xhr.open("POST", url, true);
          return licenseXhrSetup.call(_this11.hls, xhr, url, keysListItem, licenseChallenge);
        }).then(function(licenseXhrSetupResult) {
          if (!xhr.readyState) {
            xhr.open("POST", url, true);
          }
          var finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;
          return {
            xhr,
            licenseChallenge: finalLicenseChallenge
          };
        });
      };
      _proto.requestLicense = function requestLicense(keySessionContext, licenseChallenge) {
        var _this12 = this;
        var keyLoadPolicy = this.config.keyLoadPolicy.default;
        return new Promise(function(resolve, reject) {
          var url = _this12.getLicenseServerUrl(keySessionContext.keySystem);
          _this12.log("Sending license request to URL: " + url);
          var xhr = new XMLHttpRequest();
          xhr.responseType = "arraybuffer";
          xhr.onreadystatechange = function() {
            if (!_this12.hls || !keySessionContext.mediaKeysSession) {
              return reject(new Error("invalid state"));
            }
            if (xhr.readyState === 4) {
              if (xhr.status === 200) {
                _this12._requestLicenseFailureCount = 0;
                var data = xhr.response;
                _this12.log("License received " + (data instanceof ArrayBuffer ? data.byteLength : data));
                var licenseResponseCallback = _this12.config.licenseResponseCallback;
                if (licenseResponseCallback) {
                  try {
                    data = licenseResponseCallback.call(_this12.hls, xhr, url, keySessionContext);
                  } catch (error) {
                    _this12.error(error);
                  }
                }
                resolve(data);
              } else {
                var retryConfig = keyLoadPolicy.errorRetry;
                var maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;
                _this12._requestLicenseFailureCount++;
                if (_this12._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {
                  reject(new EMEKeyError({
                    type: ErrorTypes.KEY_SYSTEM_ERROR,
                    details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                    fatal: true,
                    networkDetails: xhr,
                    response: {
                      url,
                      data: void 0,
                      code: xhr.status,
                      text: xhr.statusText
                    }
                  }, "License Request XHR failed (" + url + "). Status: " + xhr.status + " (" + xhr.statusText + ")"));
                } else {
                  var attemptsLeft = maxNumRetry - _this12._requestLicenseFailureCount + 1;
                  _this12.warn("Retrying license request, " + attemptsLeft + " attempts left");
                  _this12.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);
                }
              }
            }
          };
          if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {
            keySessionContext.licenseXhr.abort();
          }
          keySessionContext.licenseXhr = xhr;
          _this12.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(function(_ref5) {
            var xhr2 = _ref5.xhr, licenseChallenge2 = _ref5.licenseChallenge;
            if (keySessionContext.keySystem == KeySystems.PLAYREADY) {
              licenseChallenge2 = _this12.unpackPlayReadyKeyMessage(xhr2, licenseChallenge2);
            }
            xhr2.send(licenseChallenge2);
          });
        });
      };
      _proto.onMediaAttached = function onMediaAttached(event, data) {
        if (!this.config.emeEnabled) {
          return;
        }
        var media = data.media;
        this.media = media;
        media.addEventListener("encrypted", this.onMediaEncrypted);
        media.addEventListener("waitingforkey", this.onWaitingForKey);
      };
      _proto.onMediaDetached = function onMediaDetached() {
        var _this13 = this;
        var media = this.media;
        var mediaKeysList = this.mediaKeySessions;
        if (media) {
          media.removeEventListener("encrypted", this.onMediaEncrypted);
          media.removeEventListener("waitingforkey", this.onWaitingForKey);
          this.media = null;
        }
        this._requestLicenseFailureCount = 0;
        this.setMediaKeysQueue = [];
        this.mediaKeySessions = [];
        this.keyIdToKeySessionPromise = {};
        LevelKey.clearKeyUriToKeyIdMap();
        var keySessionCount = mediaKeysList.length;
        EMEController2.CDMCleanupPromise = Promise.all(mediaKeysList.map(function(mediaKeySessionContext) {
          return _this13.removeSession(mediaKeySessionContext);
        }).concat(media == null ? void 0 : media.setMediaKeys(null).catch(function(error) {
          _this13.log("Could not clear media keys: " + error);
        }))).then(function() {
          if (keySessionCount) {
            _this13.log("finished closing key sessions and clearing media keys");
            mediaKeysList.length = 0;
          }
        }).catch(function(error) {
          _this13.log("Could not close sessions and clear media keys: " + error);
        });
      };
      _proto.onManifestLoading = function onManifestLoading() {
        this.keyFormatPromise = null;
      };
      _proto.onManifestLoaded = function onManifestLoaded(event, _ref6) {
        var sessionKeys = _ref6.sessionKeys;
        if (!sessionKeys || !this.config.emeEnabled) {
          return;
        }
        if (!this.keyFormatPromise) {
          var keyFormats = sessionKeys.reduce(function(formats, sessionKey) {
            if (formats.indexOf(sessionKey.keyFormat) === -1) {
              formats.push(sessionKey.keyFormat);
            }
            return formats;
          }, []);
          this.log("Selecting key-system from session-keys " + keyFormats.join(", "));
          this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
        }
      };
      _proto.removeSession = function removeSession(mediaKeySessionContext) {
        var _this14 = this;
        var mediaKeysSession = mediaKeySessionContext.mediaKeysSession, licenseXhr = mediaKeySessionContext.licenseXhr;
        if (mediaKeysSession) {
          this.log("Remove licenses and keys and close session " + mediaKeysSession.sessionId);
          if (mediaKeySessionContext._onmessage) {
            mediaKeysSession.removeEventListener("message", mediaKeySessionContext._onmessage);
            mediaKeySessionContext._onmessage = void 0;
          }
          if (mediaKeySessionContext._onkeystatuseschange) {
            mediaKeysSession.removeEventListener("keystatuseschange", mediaKeySessionContext._onkeystatuseschange);
            mediaKeySessionContext._onkeystatuseschange = void 0;
          }
          if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {
            licenseXhr.abort();
          }
          mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = void 0;
          var index = this.mediaKeySessions.indexOf(mediaKeySessionContext);
          if (index > -1) {
            this.mediaKeySessions.splice(index, 1);
          }
          return mediaKeysSession.remove().catch(function(error) {
            _this14.log("Could not remove session: " + error);
          }).then(function() {
            return mediaKeysSession.close();
          }).catch(function(error) {
            _this14.log("Could not close session: " + error);
          });
        }
      };
      return EMEController2;
    }();
    EMEController.CDMCleanupPromise = void 0;
    var EMEKeyError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(EMEKeyError2, _Error);
      function EMEKeyError2(data, message) {
        var _this15;
        _this15 = _Error.call(this, message) || this;
        _this15.data = void 0;
        data.error || (data.error = new Error(message));
        _this15.data = data;
        data.err = data.error;
        return _this15;
      }
      return EMEKeyError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    var CmObjectType;
    (function(CmObjectType2) {
      CmObjectType2["MANIFEST"] = "m";
      CmObjectType2["AUDIO"] = "a";
      CmObjectType2["VIDEO"] = "v";
      CmObjectType2["MUXED"] = "av";
      CmObjectType2["INIT"] = "i";
      CmObjectType2["CAPTION"] = "c";
      CmObjectType2["TIMED_TEXT"] = "tt";
      CmObjectType2["KEY"] = "k";
      CmObjectType2["OTHER"] = "o";
    })(CmObjectType || (CmObjectType = {}));
    var CmStreamingFormat;
    (function(CmStreamingFormat2) {
      CmStreamingFormat2["DASH"] = "d";
      CmStreamingFormat2["HLS"] = "h";
      CmStreamingFormat2["SMOOTH"] = "s";
      CmStreamingFormat2["OTHER"] = "o";
    })(CmStreamingFormat || (CmStreamingFormat = {}));
    var CmcdHeaderField;
    (function(CmcdHeaderField2) {
      CmcdHeaderField2["OBJECT"] = "CMCD-Object";
      CmcdHeaderField2["REQUEST"] = "CMCD-Request";
      CmcdHeaderField2["SESSION"] = "CMCD-Session";
      CmcdHeaderField2["STATUS"] = "CMCD-Status";
    })(CmcdHeaderField || (CmcdHeaderField = {}));
    var _CmcdHeaderMap;
    var CmcdHeaderMap = (_CmcdHeaderMap = {}, _CmcdHeaderMap[CmcdHeaderField.OBJECT] = ["br", "d", "ot", "tb"], _CmcdHeaderMap[CmcdHeaderField.REQUEST] = ["bl", "dl", "mtp", "nor", "nrr", "su"], _CmcdHeaderMap[CmcdHeaderField.SESSION] = ["cid", "pr", "sf", "sid", "st", "v"], _CmcdHeaderMap[CmcdHeaderField.STATUS] = ["bs", "rtp"], _CmcdHeaderMap);
    var SfItem = function SfItem2(value, params) {
      this.value = void 0;
      this.params = void 0;
      if (Array.isArray(value)) {
        value = value.map(function(v) {
          return v instanceof SfItem2 ? v : new SfItem2(v);
        });
      }
      this.value = value;
      this.params = params;
    };
    var SfToken = function SfToken2(description) {
      this.description = void 0;
      this.description = description;
    };
    var DICT = "Dict";
    function format(value) {
      if (Array.isArray(value)) {
        return JSON.stringify(value);
      }
      if (value instanceof Map) {
        return "Map{}";
      }
      if (value instanceof Set) {
        return "Set{}";
      }
      if (typeof value === "object") {
        return JSON.stringify(value);
      }
      return String(value);
    }
    function throwError(action, src, type, cause) {
      return new Error("failed to " + action + ' "' + format(src) + '" as ' + type, {
        cause
      });
    }
    var BARE_ITEM = "Bare Item";
    var BOOLEAN = "Boolean";
    var BYTES = "Byte Sequence";
    var DECIMAL = "Decimal";
    var INTEGER = "Integer";
    function isInvalidInt(value) {
      return value < -999999999999999 || 999999999999999 < value;
    }
    var STRING_REGEX = /[\x00-\x1f\x7f]+/;
    var TOKEN = "Token";
    var KEY = "Key";
    function serializeError(src, type, cause) {
      return throwError("serialize", src, type, cause);
    }
    function serializeBoolean(value) {
      if (typeof value !== "boolean") {
        throw serializeError(value, BOOLEAN);
      }
      return value ? "?1" : "?0";
    }
    function base64encode(binary) {
      return btoa(String.fromCharCode.apply(String, binary));
    }
    function serializeByteSequence(value) {
      if (ArrayBuffer.isView(value) === false) {
        throw serializeError(value, BYTES);
      }
      return ":" + base64encode(value) + ":";
    }
    function serializeInteger(value) {
      if (isInvalidInt(value)) {
        throw serializeError(value, INTEGER);
      }
      return value.toString();
    }
    function serializeDate(value) {
      return "@" + serializeInteger(value.getTime() / 1e3);
    }
    function roundToEven(value, precision) {
      if (value < 0) {
        return -roundToEven(-value, precision);
      }
      var decimalShift = Math.pow(10, precision);
      var isEquidistant = Math.abs(value * decimalShift % 1 - 0.5) < Number.EPSILON;
      if (isEquidistant) {
        var flooredValue = Math.floor(value * decimalShift);
        return (flooredValue % 2 === 0 ? flooredValue : flooredValue + 1) / decimalShift;
      } else {
        return Math.round(value * decimalShift) / decimalShift;
      }
    }
    function serializeDecimal(value) {
      var roundedValue = roundToEven(value, 3);
      if (Math.floor(Math.abs(roundedValue)).toString().length > 12) {
        throw serializeError(value, DECIMAL);
      }
      var stringValue = roundedValue.toString();
      return stringValue.includes(".") ? stringValue : stringValue + ".0";
    }
    var STRING = "String";
    function serializeString(value) {
      if (STRING_REGEX.test(value)) {
        throw serializeError(value, STRING);
      }
      return '"' + value.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
    }
    function symbolToStr(symbol) {
      return symbol.description || symbol.toString().slice(7, -1);
    }
    function serializeToken(token) {
      var value = symbolToStr(token);
      if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(value) === false) {
        throw serializeError(value, TOKEN);
      }
      return value;
    }
    function serializeBareItem(value) {
      switch (typeof value) {
        case "number":
          if (!isFiniteNumber(value)) {
            throw serializeError(value, BARE_ITEM);
          }
          if (Number.isInteger(value)) {
            return serializeInteger(value);
          }
          return serializeDecimal(value);
        case "string":
          return serializeString(value);
        case "symbol":
          return serializeToken(value);
        case "boolean":
          return serializeBoolean(value);
        case "object":
          if (value instanceof Date) {
            return serializeDate(value);
          }
          if (value instanceof Uint8Array) {
            return serializeByteSequence(value);
          }
          if (value instanceof SfToken) {
            return serializeToken(value);
          }
        default:
          throw serializeError(value, BARE_ITEM);
      }
    }
    function serializeKey(value) {
      if (/^[a-z*][a-z0-9\-_.*]*$/.test(value) === false) {
        throw serializeError(value, KEY);
      }
      return value;
    }
    function serializeParams(params) {
      if (params == null) {
        return "";
      }
      return Object.entries(params).map(function(_ref) {
        var key = _ref[0], value = _ref[1];
        if (value === true) {
          return ";" + serializeKey(key);
        }
        return ";" + serializeKey(key) + "=" + serializeBareItem(value);
      }).join("");
    }
    function serializeItem(value) {
      if (value instanceof SfItem) {
        return "" + serializeBareItem(value.value) + serializeParams(value.params);
      } else {
        return serializeBareItem(value);
      }
    }
    function serializeInnerList(value) {
      return "(" + value.value.map(serializeItem).join(" ") + ")" + serializeParams(value.params);
    }
    function serializeDict(dict, options) {
      var _options;
      if (options === void 0) {
        options = {
          whitespace: true
        };
      }
      if (typeof dict !== "object") {
        throw serializeError(dict, DICT);
      }
      var entries = dict instanceof Map ? dict.entries() : Object.entries(dict);
      var optionalWhiteSpace = (_options = options) != null && _options.whitespace ? " " : "";
      return Array.from(entries).map(function(_ref) {
        var key = _ref[0], item = _ref[1];
        if (item instanceof SfItem === false) {
          item = new SfItem(item);
        }
        var output = serializeKey(key);
        if (item.value === true) {
          output += serializeParams(item.params);
        } else {
          output += "=";
          if (Array.isArray(item.value)) {
            output += serializeInnerList(item);
          } else {
            output += serializeItem(item);
          }
        }
        return output;
      }).join("," + optionalWhiteSpace);
    }
    function encodeSfDict(value, options) {
      return serializeDict(value, options);
    }
    var isTokenField = function isTokenField2(key) {
      return key === "ot" || key === "sf" || key === "st";
    };
    var isValid = function isValid2(value) {
      if (typeof value === "number") {
        return isFiniteNumber(value);
      }
      return value != null && value !== "" && value !== false;
    };
    function urlToRelativePath(url, base) {
      var to = new URL(url);
      var from = new URL(base);
      if (to.origin !== from.origin) {
        return url;
      }
      var toPath = to.pathname.split("/").slice(1);
      var fromPath = from.pathname.split("/").slice(1, -1);
      while (toPath[0] === fromPath[0]) {
        toPath.shift();
        fromPath.shift();
      }
      while (fromPath.length) {
        fromPath.shift();
        toPath.unshift("..");
      }
      return toPath.join("/");
    }
    function uuid() {
      try {
        return crypto.randomUUID();
      } catch (error) {
        try {
          var url = URL.createObjectURL(new Blob());
          var _uuid = url.toString();
          URL.revokeObjectURL(url);
          return _uuid.slice(_uuid.lastIndexOf("/") + 1);
        } catch (error2) {
          var dt = (/* @__PURE__ */ new Date()).getTime();
          var _uuid2 = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
            var r = (dt + Math.random() * 16) % 16 | 0;
            dt = Math.floor(dt / 16);
            return (c == "x" ? r : r & 3 | 8).toString(16);
          });
          return _uuid2;
        }
      }
    }
    var toRounded = function toRounded2(value) {
      return Math.round(value);
    };
    var toUrlSafe = function toUrlSafe2(value, options) {
      if (options != null && options.baseUrl) {
        value = urlToRelativePath(value, options.baseUrl);
      }
      return encodeURIComponent(value);
    };
    var toHundred = function toHundred2(value) {
      return toRounded(value / 100) * 100;
    };
    var CmcdFormatters = {
      /**
       * Bitrate (kbps) rounded integer
       */
      br: toRounded,
      /**
       * Duration (milliseconds) rounded integer
       */
      d: toRounded,
      /**
       * Buffer Length (milliseconds) rounded nearest 100ms
       */
      bl: toHundred,
      /**
       * Deadline (milliseconds) rounded nearest 100ms
       */
      dl: toHundred,
      /**
       * Measured Throughput (kbps) rounded nearest 100kbps
       */
      mtp: toHundred,
      /**
       * Next Object Request URL encoded
       */
      nor: toUrlSafe,
      /**
       * Requested maximum throughput (kbps) rounded nearest 100kbps
       */
      rtp: toHundred,
      /**
       * Top Bitrate (kbps) rounded integer
       */
      tb: toRounded
    };
    function processCmcd(obj, options) {
      var results = {};
      if (obj == null || typeof obj !== "object") {
        return results;
      }
      var keys = Object.keys(obj).sort();
      var formatters = _extends({}, CmcdFormatters, options == null ? void 0 : options.formatters);
      var filter = options == null ? void 0 : options.filter;
      keys.forEach(function(key) {
        if (filter != null && filter(key)) {
          return;
        }
        var value = obj[key];
        var formatter = formatters[key];
        if (formatter) {
          value = formatter(value, options);
        }
        if (key === "v" && value === 1) {
          return;
        }
        if (key == "pr" && value === 1) {
          return;
        }
        if (!isValid(value)) {
          return;
        }
        if (isTokenField(key) && typeof value === "string") {
          value = new SfToken(value);
        }
        results[key] = value;
      });
      return results;
    }
    function encodeCmcd(cmcd, options) {
      if (options === void 0) {
        options = {};
      }
      if (!cmcd) {
        return "";
      }
      return encodeSfDict(processCmcd(cmcd, options), _extends({
        whitespace: false
      }, options));
    }
    function toCmcdHeaders(cmcd, options) {
      var _options;
      if (options === void 0) {
        options = {};
      }
      if (!cmcd) {
        return {};
      }
      var entries = Object.entries(cmcd);
      var headerMap = Object.entries(CmcdHeaderMap).concat(Object.entries(((_options = options) == null ? void 0 : _options.customHeaderMap) || {}));
      var shards = entries.reduce(function(acc, entry) {
        var _headerMap$find, _acc$field;
        var key = entry[0], value = entry[1];
        var field = ((_headerMap$find = headerMap.find(function(entry2) {
          return entry2[1].includes(key);
        })) == null ? void 0 : _headerMap$find[0]) || CmcdHeaderField.REQUEST;
        (_acc$field = acc[field]) != null ? _acc$field : acc[field] = {};
        acc[field][key] = value;
        return acc;
      }, {});
      return Object.entries(shards).reduce(function(acc, _ref) {
        var field = _ref[0], value = _ref[1];
        acc[field] = encodeCmcd(value, options);
        return acc;
      }, {});
    }
    function appendCmcdHeaders(headers, cmcd, options) {
      return _extends(headers, toCmcdHeaders(cmcd, options));
    }
    var CMCD_PARAM = "CMCD";
    function toCmcdQuery(cmcd, options) {
      if (options === void 0) {
        options = {};
      }
      if (!cmcd) {
        return "";
      }
      var params = encodeCmcd(cmcd, options);
      return CMCD_PARAM + "=" + encodeURIComponent(params);
    }
    var REGEX = /CMCD=[^&#]+/;
    function appendCmcdQuery(url, cmcd, options) {
      var query = toCmcdQuery(cmcd, options);
      if (!query) {
        return url;
      }
      if (REGEX.test(url)) {
        return url.replace(REGEX, query);
      }
      var separator = url.includes("?") ? "&" : "?";
      return "" + url + separator + query;
    }
    var CMCDController = /* @__PURE__ */ function() {
      function CMCDController2(hls) {
        var _this = this;
        this.hls = void 0;
        this.config = void 0;
        this.media = void 0;
        this.sid = void 0;
        this.cid = void 0;
        this.useHeaders = false;
        this.includeKeys = void 0;
        this.initialized = false;
        this.starved = false;
        this.buffering = true;
        this.audioBuffer = void 0;
        this.videoBuffer = void 0;
        this.onWaiting = function() {
          if (_this.initialized) {
            _this.starved = true;
          }
          _this.buffering = true;
        };
        this.onPlaying = function() {
          if (!_this.initialized) {
            _this.initialized = true;
          }
          _this.buffering = false;
        };
        this.applyPlaylistData = function(context) {
          try {
            _this.apply(context, {
              ot: CmObjectType.MANIFEST,
              su: !_this.initialized
            });
          } catch (error) {
            logger.warn("Could not generate manifest CMCD data.", error);
          }
        };
        this.applyFragmentData = function(context) {
          try {
            var fragment = context.frag;
            var level = _this.hls.levels[fragment.level];
            var ot = _this.getObjectType(fragment);
            var data = {
              d: fragment.duration * 1e3,
              ot
            };
            if (ot === CmObjectType.VIDEO || ot === CmObjectType.AUDIO || ot == CmObjectType.MUXED) {
              data.br = level.bitrate / 1e3;
              data.tb = _this.getTopBandwidth(ot) / 1e3;
              data.bl = _this.getBufferLength(ot);
            }
            _this.apply(context, data);
          } catch (error) {
            logger.warn("Could not generate segment CMCD data.", error);
          }
        };
        this.hls = hls;
        var config = this.config = hls.config;
        var cmcd = config.cmcd;
        if (cmcd != null) {
          config.pLoader = this.createPlaylistLoader();
          config.fLoader = this.createFragmentLoader();
          this.sid = cmcd.sessionId || uuid();
          this.cid = cmcd.contentId;
          this.useHeaders = cmcd.useHeaders === true;
          this.includeKeys = cmcd.includeKeys;
          this.registerListeners();
        }
      }
      var _proto = CMCDController2.prototype;
      _proto.registerListeners = function registerListeners() {
        var hls = this.hls;
        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);
        hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
      };
      _proto.unregisterListeners = function unregisterListeners() {
        var hls = this.hls;
        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);
        hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
      };
      _proto.destroy = function destroy() {
        this.unregisterListeners();
        this.onMediaDetached();
        this.hls = this.config = this.audioBuffer = this.videoBuffer = null;
        this.onWaiting = this.onPlaying = null;
      };
      _proto.onMediaAttached = function onMediaAttached(event, data) {
        this.media = data.media;
        this.media.addEventListener("waiting", this.onWaiting);
        this.media.addEventListener("playing", this.onPlaying);
      };
      _proto.onMediaDetached = function onMediaDetached() {
        if (!this.media) {
          return;
        }
        this.media.removeEventListener("waiting", this.onWaiting);
        this.media.removeEventListener("playing", this.onPlaying);
        this.media = null;
      };
      _proto.onBufferCreated = function onBufferCreated(event, data) {
        var _data$tracks$audio, _data$tracks$video;
        this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? void 0 : _data$tracks$audio.buffer;
        this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? void 0 : _data$tracks$video.buffer;
      };
      _proto.createData = function createData() {
        var _this$media;
        return {
          v: 1,
          sf: CmStreamingFormat.HLS,
          sid: this.sid,
          cid: this.cid,
          pr: (_this$media = this.media) == null ? void 0 : _this$media.playbackRate,
          mtp: this.hls.bandwidthEstimate / 1e3
        };
      };
      _proto.apply = function apply(context, data) {
        if (data === void 0) {
          data = {};
        }
        _extends(data, this.createData());
        var isVideo = data.ot === CmObjectType.INIT || data.ot === CmObjectType.VIDEO || data.ot === CmObjectType.MUXED;
        if (this.starved && isVideo) {
          data.bs = true;
          data.su = true;
          this.starved = false;
        }
        if (data.su == null) {
          data.su = this.buffering;
        }
        var includeKeys = this.includeKeys;
        if (includeKeys) {
          data = Object.keys(data).reduce(function(acc, key) {
            includeKeys.includes(key) && (acc[key] = data[key]);
            return acc;
          }, {});
        }
        if (this.useHeaders) {
          if (!context.headers) {
            context.headers = {};
          }
          appendCmcdHeaders(context.headers, data);
        } else {
          context.url = appendCmcdQuery(context.url, data);
        }
      };
      _proto.getObjectType = function getObjectType(fragment) {
        var type = fragment.type;
        if (type === "subtitle") {
          return CmObjectType.TIMED_TEXT;
        }
        if (fragment.sn === "initSegment") {
          return CmObjectType.INIT;
        }
        if (type === "audio") {
          return CmObjectType.AUDIO;
        }
        if (type === "main") {
          if (!this.hls.audioTracks.length) {
            return CmObjectType.MUXED;
          }
          return CmObjectType.VIDEO;
        }
        return void 0;
      };
      _proto.getTopBandwidth = function getTopBandwidth(type) {
        var bitrate = 0;
        var levels;
        var hls = this.hls;
        if (type === CmObjectType.AUDIO) {
          levels = hls.audioTracks;
        } else {
          var max = hls.maxAutoLevel;
          var len = max > -1 ? max + 1 : hls.levels.length;
          levels = hls.levels.slice(0, len);
        }
        for (var _iterator = _createForOfIteratorHelperLoose(levels), _step; !(_step = _iterator()).done; ) {
          var level = _step.value;
          if (level.bitrate > bitrate) {
            bitrate = level.bitrate;
          }
        }
        return bitrate > 0 ? bitrate : NaN;
      };
      _proto.getBufferLength = function getBufferLength(type) {
        var media = this.hls.media;
        var buffer = type === CmObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;
        if (!buffer || !media) {
          return NaN;
        }
        var info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);
        return info.len * 1e3;
      };
      _proto.createPlaylistLoader = function createPlaylistLoader() {
        var pLoader = this.config.pLoader;
        var apply = this.applyPlaylistData;
        var Ctor = pLoader || this.config.loader;
        return /* @__PURE__ */ function() {
          function CmcdPlaylistLoader(config) {
            this.loader = void 0;
            this.loader = new Ctor(config);
          }
          var _proto2 = CmcdPlaylistLoader.prototype;
          _proto2.destroy = function destroy() {
            this.loader.destroy();
          };
          _proto2.abort = function abort() {
            this.loader.abort();
          };
          _proto2.load = function load(context, config, callbacks) {
            apply(context);
            this.loader.load(context, config, callbacks);
          };
          _createClass(CmcdPlaylistLoader, [{
            key: "stats",
            get: function get() {
              return this.loader.stats;
            }
          }, {
            key: "context",
            get: function get() {
              return this.loader.context;
            }
          }]);
          return CmcdPlaylistLoader;
        }();
      };
      _proto.createFragmentLoader = function createFragmentLoader() {
        var fLoader = this.config.fLoader;
        var apply = this.applyFragmentData;
        var Ctor = fLoader || this.config.loader;
        return /* @__PURE__ */ function() {
          function CmcdFragmentLoader(config) {
            this.loader = void 0;
            this.loader = new Ctor(config);
          }
          var _proto3 = CmcdFragmentLoader.prototype;
          _proto3.destroy = function destroy() {
            this.loader.destroy();
          };
          _proto3.abort = function abort() {
            this.loader.abort();
          };
          _proto3.load = function load(context, config, callbacks) {
            apply(context);
            this.loader.load(context, config, callbacks);
          };
          _createClass(CmcdFragmentLoader, [{
            key: "stats",
            get: function get() {
              return this.loader.stats;
            }
          }, {
            key: "context",
            get: function get() {
              return this.loader.context;
            }
          }]);
          return CmcdFragmentLoader;
        }();
      };
      return CMCDController2;
    }();
    var PATHWAY_PENALTY_DURATION_MS = 3e5;
    var ContentSteeringController = /* @__PURE__ */ function() {
      function ContentSteeringController2(hls) {
        this.hls = void 0;
        this.log = void 0;
        this.loader = null;
        this.uri = null;
        this.pathwayId = ".";
        this.pathwayPriority = null;
        this.timeToLoad = 300;
        this.reloadTimer = -1;
        this.updated = 0;
        this.started = false;
        this.enabled = true;
        this.levels = null;
        this.audioTracks = null;
        this.subtitleTracks = null;
        this.penalizedPathways = {};
        this.hls = hls;
        this.log = logger.log.bind(logger, "[content-steering]:");
        this.registerListeners();
      }
      var _proto = ContentSteeringController2.prototype;
      _proto.registerListeners = function registerListeners() {
        var hls = this.hls;
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
        hls.on(Events.ERROR, this.onError, this);
      };
      _proto.unregisterListeners = function unregisterListeners() {
        var hls = this.hls;
        if (!hls) {
          return;
        }
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
        hls.off(Events.ERROR, this.onError, this);
      };
      _proto.startLoad = function startLoad() {
        this.started = true;
        this.clearTimeout();
        if (this.enabled && this.uri) {
          if (this.updated) {
            var ttl = this.timeToLoad * 1e3 - (performance.now() - this.updated);
            if (ttl > 0) {
              this.scheduleRefresh(this.uri, ttl);
              return;
            }
          }
          this.loadSteeringManifest(this.uri);
        }
      };
      _proto.stopLoad = function stopLoad() {
        this.started = false;
        if (this.loader) {
          this.loader.destroy();
          this.loader = null;
        }
        this.clearTimeout();
      };
      _proto.clearTimeout = function clearTimeout2() {
        if (this.reloadTimer !== -1) {
          self.clearTimeout(this.reloadTimer);
          this.reloadTimer = -1;
        }
      };
      _proto.destroy = function destroy() {
        this.unregisterListeners();
        this.stopLoad();
        this.hls = null;
        this.levels = this.audioTracks = this.subtitleTracks = null;
      };
      _proto.removeLevel = function removeLevel(levelToRemove) {
        var levels = this.levels;
        if (levels) {
          this.levels = levels.filter(function(level) {
            return level !== levelToRemove;
          });
        }
      };
      _proto.onManifestLoading = function onManifestLoading() {
        this.stopLoad();
        this.enabled = true;
        this.timeToLoad = 300;
        this.updated = 0;
        this.uri = null;
        this.pathwayId = ".";
        this.levels = this.audioTracks = this.subtitleTracks = null;
      };
      _proto.onManifestLoaded = function onManifestLoaded(event, data) {
        var contentSteering = data.contentSteering;
        if (contentSteering === null) {
          return;
        }
        this.pathwayId = contentSteering.pathwayId;
        this.uri = contentSteering.uri;
        if (this.started) {
          this.startLoad();
        }
      };
      _proto.onManifestParsed = function onManifestParsed(event, data) {
        this.audioTracks = data.audioTracks;
        this.subtitleTracks = data.subtitleTracks;
      };
      _proto.onError = function onError(event, data) {
        var errorAction = data.errorAction;
        if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {
          var levels = this.levels;
          var pathwayPriority = this.pathwayPriority;
          var errorPathway = this.pathwayId;
          if (data.context) {
            var _data$context = data.context, groupId = _data$context.groupId, _pathwayId = _data$context.pathwayId, type = _data$context.type;
            if (groupId && levels) {
              errorPathway = this.getPathwayForGroupId(groupId, type, errorPathway);
            } else if (_pathwayId) {
              errorPathway = _pathwayId;
            }
          }
          if (!(errorPathway in this.penalizedPathways)) {
            this.penalizedPathways[errorPathway] = performance.now();
          }
          if (!pathwayPriority && levels) {
            pathwayPriority = levels.reduce(function(pathways, level) {
              if (pathways.indexOf(level.pathwayId) === -1) {
                pathways.push(level.pathwayId);
              }
              return pathways;
            }, []);
          }
          if (pathwayPriority && pathwayPriority.length > 1) {
            this.updatePathwayPriority(pathwayPriority);
            errorAction.resolved = this.pathwayId !== errorPathway;
          }
          if (!errorAction.resolved) {
            logger.warn("Could not resolve " + data.details + ' ("' + data.error.message + '") with content-steering for Pathway: ' + errorPathway + " levels: " + (levels ? levels.length : levels) + " priorities: " + JSON.stringify(pathwayPriority) + " penalized: " + JSON.stringify(this.penalizedPathways));
          }
        }
      };
      _proto.filterParsedLevels = function filterParsedLevels(levels) {
        this.levels = levels;
        var pathwayLevels = this.getLevelsForPathway(this.pathwayId);
        if (pathwayLevels.length === 0) {
          var _pathwayId2 = levels[0].pathwayId;
          this.log("No levels found in Pathway " + this.pathwayId + '. Setting initial Pathway to "' + _pathwayId2 + '"');
          pathwayLevels = this.getLevelsForPathway(_pathwayId2);
          this.pathwayId = _pathwayId2;
        }
        if (pathwayLevels.length !== levels.length) {
          this.log("Found " + pathwayLevels.length + "/" + levels.length + ' levels in Pathway "' + this.pathwayId + '"');
          return pathwayLevels;
        }
        return levels;
      };
      _proto.getLevelsForPathway = function getLevelsForPathway(pathwayId) {
        if (this.levels === null) {
          return [];
        }
        return this.levels.filter(function(level) {
          return pathwayId === level.pathwayId;
        });
      };
      _proto.updatePathwayPriority = function updatePathwayPriority(pathwayPriority) {
        this.pathwayPriority = pathwayPriority;
        var levels;
        var penalizedPathways = this.penalizedPathways;
        var now2 = performance.now();
        Object.keys(penalizedPathways).forEach(function(pathwayId) {
          if (now2 - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {
            delete penalizedPathways[pathwayId];
          }
        });
        for (var i = 0; i < pathwayPriority.length; i++) {
          var _pathwayId3 = pathwayPriority[i];
          if (_pathwayId3 in penalizedPathways) {
            continue;
          }
          if (_pathwayId3 === this.pathwayId) {
            return;
          }
          var selectedIndex = this.hls.nextLoadLevel;
          var selectedLevel = this.hls.levels[selectedIndex];
          levels = this.getLevelsForPathway(_pathwayId3);
          if (levels.length > 0) {
            this.log('Setting Pathway to "' + _pathwayId3 + '"');
            this.pathwayId = _pathwayId3;
            reassignFragmentLevelIndexes(levels);
            this.hls.trigger(Events.LEVELS_UPDATED, {
              levels
            });
            var levelAfterChange = this.hls.levels[selectedIndex];
            if (selectedLevel && levelAfterChange && this.levels) {
              if (levelAfterChange.attrs["STABLE-VARIANT-ID"] !== selectedLevel.attrs["STABLE-VARIANT-ID"] && levelAfterChange.bitrate !== selectedLevel.bitrate) {
                this.log("Unstable Pathways change from bitrate " + selectedLevel.bitrate + " to " + levelAfterChange.bitrate);
              }
              this.hls.nextLoadLevel = selectedIndex;
            }
            break;
          }
        }
      };
      _proto.getPathwayForGroupId = function getPathwayForGroupId(groupId, type, defaultPathway) {
        var levels = this.getLevelsForPathway(defaultPathway).concat(this.levels || []);
        for (var i = 0; i < levels.length; i++) {
          if (type === PlaylistContextType.AUDIO_TRACK && levels[i].hasAudioGroup(groupId) || type === PlaylistContextType.SUBTITLE_TRACK && levels[i].hasSubtitleGroup(groupId)) {
            return levels[i].pathwayId;
          }
        }
        return defaultPathway;
      };
      _proto.clonePathways = function clonePathways(pathwayClones) {
        var _this = this;
        var levels = this.levels;
        if (!levels) {
          return;
        }
        var audioGroupCloneMap = {};
        var subtitleGroupCloneMap = {};
        pathwayClones.forEach(function(pathwayClone) {
          var cloneId = pathwayClone.ID, baseId = pathwayClone["BASE-ID"], uriReplacement = pathwayClone["URI-REPLACEMENT"];
          if (levels.some(function(level) {
            return level.pathwayId === cloneId;
          })) {
            return;
          }
          var clonedVariants = _this.getLevelsForPathway(baseId).map(function(baseLevel) {
            var attributes = new AttrList(baseLevel.attrs);
            attributes["PATHWAY-ID"] = cloneId;
            var clonedAudioGroupId = attributes.AUDIO && attributes.AUDIO + "_clone_" + cloneId;
            var clonedSubtitleGroupId = attributes.SUBTITLES && attributes.SUBTITLES + "_clone_" + cloneId;
            if (clonedAudioGroupId) {
              audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;
              attributes.AUDIO = clonedAudioGroupId;
            }
            if (clonedSubtitleGroupId) {
              subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;
              attributes.SUBTITLES = clonedSubtitleGroupId;
            }
            var url = performUriReplacement(baseLevel.uri, attributes["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", uriReplacement);
            var clonedLevel = new Level({
              attrs: attributes,
              audioCodec: baseLevel.audioCodec,
              bitrate: baseLevel.bitrate,
              height: baseLevel.height,
              name: baseLevel.name,
              url,
              videoCodec: baseLevel.videoCodec,
              width: baseLevel.width
            });
            if (baseLevel.audioGroups) {
              for (var i = 1; i < baseLevel.audioGroups.length; i++) {
                clonedLevel.addGroupId("audio", baseLevel.audioGroups[i] + "_clone_" + cloneId);
              }
            }
            if (baseLevel.subtitleGroups) {
              for (var _i = 1; _i < baseLevel.subtitleGroups.length; _i++) {
                clonedLevel.addGroupId("text", baseLevel.subtitleGroups[_i] + "_clone_" + cloneId);
              }
            }
            return clonedLevel;
          });
          levels.push.apply(levels, clonedVariants);
          cloneRenditionGroups(_this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);
          cloneRenditionGroups(_this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);
        });
      };
      _proto.loadSteeringManifest = function loadSteeringManifest(uri) {
        var _this2 = this;
        var config = this.hls.config;
        var Loader = config.loader;
        if (this.loader) {
          this.loader.destroy();
        }
        this.loader = new Loader(config);
        var url;
        try {
          url = new self.URL(uri);
        } catch (error) {
          this.enabled = false;
          this.log("Failed to parse Steering Manifest URI: " + uri);
          return;
        }
        if (url.protocol !== "data:") {
          var throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;
          url.searchParams.set("_HLS_pathway", this.pathwayId);
          url.searchParams.set("_HLS_throughput", "" + throughput);
        }
        var context = {
          responseType: "json",
          url: url.href
        };
        var loadPolicy = config.steeringManifestLoadPolicy.default;
        var legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
        var loaderConfig = {
          loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
          retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
          maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
        };
        var callbacks = {
          onSuccess: function onSuccess(response, stats, context2, networkDetails) {
            _this2.log('Loaded steering manifest: "' + url + '"');
            var steeringData = response.data;
            if (steeringData.VERSION !== 1) {
              _this2.log("Steering VERSION " + steeringData.VERSION + " not supported!");
              return;
            }
            _this2.updated = performance.now();
            _this2.timeToLoad = steeringData.TTL;
            var reloadUri = steeringData["RELOAD-URI"], pathwayClones = steeringData["PATHWAY-CLONES"], pathwayPriority = steeringData["PATHWAY-PRIORITY"];
            if (reloadUri) {
              try {
                _this2.uri = new self.URL(reloadUri, url).href;
              } catch (error) {
                _this2.enabled = false;
                _this2.log("Failed to parse Steering Manifest RELOAD-URI: " + reloadUri);
                return;
              }
            }
            _this2.scheduleRefresh(_this2.uri || context2.url);
            if (pathwayClones) {
              _this2.clonePathways(pathwayClones);
            }
            var loadedSteeringData = {
              steeringManifest: steeringData,
              url: url.toString()
            };
            _this2.hls.trigger(Events.STEERING_MANIFEST_LOADED, loadedSteeringData);
            if (pathwayPriority) {
              _this2.updatePathwayPriority(pathwayPriority);
            }
          },
          onError: function onError(error, context2, networkDetails, stats) {
            _this2.log("Error loading steering manifest: " + error.code + " " + error.text + " (" + context2.url + ")");
            _this2.stopLoad();
            if (error.code === 410) {
              _this2.enabled = false;
              _this2.log("Steering manifest " + context2.url + " no longer available");
              return;
            }
            var ttl = _this2.timeToLoad * 1e3;
            if (error.code === 429) {
              var loader = _this2.loader;
              if (typeof (loader == null ? void 0 : loader.getResponseHeader) === "function") {
                var retryAfter = loader.getResponseHeader("Retry-After");
                if (retryAfter) {
                  ttl = parseFloat(retryAfter) * 1e3;
                }
              }
              _this2.log("Steering manifest " + context2.url + " rate limited");
              return;
            }
            _this2.scheduleRefresh(_this2.uri || context2.url, ttl);
          },
          onTimeout: function onTimeout(stats, context2, networkDetails) {
            _this2.log("Timeout loading steering manifest (" + context2.url + ")");
            _this2.scheduleRefresh(_this2.uri || context2.url);
          }
        };
        this.log("Requesting steering manifest: " + url);
        this.loader.load(context, loaderConfig, callbacks);
      };
      _proto.scheduleRefresh = function scheduleRefresh(uri, ttlMs) {
        var _this3 = this;
        if (ttlMs === void 0) {
          ttlMs = this.timeToLoad * 1e3;
        }
        this.clearTimeout();
        this.reloadTimer = self.setTimeout(function() {
          var _this3$hls;
          var media = (_this3$hls = _this3.hls) == null ? void 0 : _this3$hls.media;
          if (media && !media.ended) {
            _this3.loadSteeringManifest(uri);
            return;
          }
          _this3.scheduleRefresh(uri, _this3.timeToLoad * 1e3);
        }, ttlMs);
      };
      return ContentSteeringController2;
    }();
    function cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {
      if (!tracks) {
        return;
      }
      Object.keys(groupCloneMap).forEach(function(audioGroupId) {
        var clonedTracks = tracks.filter(function(track) {
          return track.groupId === audioGroupId;
        }).map(function(track) {
          var clonedTrack = _extends({}, track);
          clonedTrack.details = void 0;
          clonedTrack.attrs = new AttrList(clonedTrack.attrs);
          clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", uriReplacement);
          clonedTrack.groupId = clonedTrack.attrs["GROUP-ID"] = groupCloneMap[audioGroupId];
          clonedTrack.attrs["PATHWAY-ID"] = cloneId;
          return clonedTrack;
        });
        tracks.push.apply(tracks, clonedTracks);
      });
    }
    function performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {
      var host = uriReplacement.HOST, params = uriReplacement.PARAMS, perOptionUris = uriReplacement[perOptionKey];
      var perVariantUri;
      if (stableId) {
        perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];
        if (perVariantUri) {
          uri = perVariantUri;
        }
      }
      var url = new self.URL(uri);
      if (host && !perVariantUri) {
        url.host = host;
      }
      if (params) {
        Object.keys(params).sort().forEach(function(key) {
          if (key) {
            url.searchParams.set(key, params[key]);
          }
        });
      }
      return url.href;
    }
    var AGE_HEADER_LINE_REGEX = /^age:\s*[\d.]+\s*$/im;
    var XhrLoader = /* @__PURE__ */ function() {
      function XhrLoader2(config) {
        this.xhrSetup = void 0;
        this.requestTimeout = void 0;
        this.retryTimeout = void 0;
        this.retryDelay = void 0;
        this.config = null;
        this.callbacks = null;
        this.context = null;
        this.loader = null;
        this.stats = void 0;
        this.xhrSetup = config ? config.xhrSetup || null : null;
        this.stats = new LoadStats();
        this.retryDelay = 0;
      }
      var _proto = XhrLoader2.prototype;
      _proto.destroy = function destroy() {
        this.callbacks = null;
        this.abortInternal();
        this.loader = null;
        this.config = null;
        this.context = null;
        this.xhrSetup = null;
        this.stats = null;
      };
      _proto.abortInternal = function abortInternal() {
        var loader = this.loader;
        self.clearTimeout(this.requestTimeout);
        self.clearTimeout(this.retryTimeout);
        if (loader) {
          loader.onreadystatechange = null;
          loader.onprogress = null;
          if (loader.readyState !== 4) {
            this.stats.aborted = true;
            loader.abort();
          }
        }
      };
      _proto.abort = function abort() {
        var _this$callbacks;
        this.abortInternal();
        if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
          this.callbacks.onAbort(this.stats, this.context, this.loader);
        }
      };
      _proto.load = function load(context, config, callbacks) {
        if (this.stats.loading.start) {
          throw new Error("Loader can only be used once.");
        }
        this.stats.loading.start = self.performance.now();
        this.context = context;
        this.config = config;
        this.callbacks = callbacks;
        this.loadInternal();
      };
      _proto.loadInternal = function loadInternal() {
        var _this = this;
        var config = this.config, context = this.context;
        if (!config || !context) {
          return;
        }
        var xhr = this.loader = new self.XMLHttpRequest();
        var stats = this.stats;
        stats.loading.first = 0;
        stats.loaded = 0;
        stats.aborted = false;
        var xhrSetup = this.xhrSetup;
        if (xhrSetup) {
          Promise.resolve().then(function() {
            if (_this.stats.aborted)
              return;
            return xhrSetup(xhr, context.url);
          }).catch(function(error) {
            xhr.open("GET", context.url, true);
            return xhrSetup(xhr, context.url);
          }).then(function() {
            if (_this.stats.aborted)
              return;
            _this.openAndSendXhr(xhr, context, config);
          }).catch(function(error) {
            _this.callbacks.onError({
              code: xhr.status,
              text: error.message
            }, context, xhr, stats);
            return;
          });
        } else {
          this.openAndSendXhr(xhr, context, config);
        }
      };
      _proto.openAndSendXhr = function openAndSendXhr(xhr, context, config) {
        if (!xhr.readyState) {
          xhr.open("GET", context.url, true);
        }
        var headers = context.headers;
        var _config$loadPolicy = config.loadPolicy, maxTimeToFirstByteMs = _config$loadPolicy.maxTimeToFirstByteMs, maxLoadTimeMs = _config$loadPolicy.maxLoadTimeMs;
        if (headers) {
          for (var header in headers) {
            xhr.setRequestHeader(header, headers[header]);
          }
        }
        if (context.rangeEnd) {
          xhr.setRequestHeader("Range", "bytes=" + context.rangeStart + "-" + (context.rangeEnd - 1));
        }
        xhr.onreadystatechange = this.readystatechange.bind(this);
        xhr.onprogress = this.loadprogress.bind(this);
        xhr.responseType = context.responseType;
        self.clearTimeout(this.requestTimeout);
        config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);
        xhr.send();
      };
      _proto.readystatechange = function readystatechange() {
        var context = this.context, xhr = this.loader, stats = this.stats;
        if (!context || !xhr) {
          return;
        }
        var readyState = xhr.readyState;
        var config = this.config;
        if (stats.aborted) {
          return;
        }
        if (readyState >= 2) {
          if (stats.loading.first === 0) {
            stats.loading.first = Math.max(self.performance.now(), stats.loading.start);
            if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {
              self.clearTimeout(this.requestTimeout);
              config.timeout = config.loadPolicy.maxLoadTimeMs;
              this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));
            }
          }
          if (readyState === 4) {
            self.clearTimeout(this.requestTimeout);
            xhr.onreadystatechange = null;
            xhr.onprogress = null;
            var _status = xhr.status;
            var useResponse = xhr.responseType !== "text";
            if (_status >= 200 && _status < 300 && (useResponse && xhr.response || xhr.responseText !== null)) {
              stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
              var data = useResponse ? xhr.response : xhr.responseText;
              var len = xhr.responseType === "arraybuffer" ? data.byteLength : data.length;
              stats.loaded = stats.total = len;
              stats.bwEstimate = stats.total * 8e3 / (stats.loading.end - stats.loading.first);
              if (!this.callbacks) {
                return;
              }
              var onProgress = this.callbacks.onProgress;
              if (onProgress) {
                onProgress(stats, context, data, xhr);
              }
              if (!this.callbacks) {
                return;
              }
              var response = {
                url: xhr.responseURL,
                data,
                code: _status
              };
              this.callbacks.onSuccess(response, stats, context, xhr);
            } else {
              var retryConfig = config.loadPolicy.errorRetry;
              var retryCount = stats.retry;
              var _response = {
                url: context.url,
                data: void 0,
                code: _status
              };
              if (shouldRetry(retryConfig, retryCount, false, _response)) {
                this.retry(retryConfig);
              } else {
                logger.error(_status + " while loading " + context.url);
                this.callbacks.onError({
                  code: _status,
                  text: xhr.statusText
                }, context, xhr, stats);
              }
            }
          }
        }
      };
      _proto.loadtimeout = function loadtimeout() {
        var _this$config;
        var retryConfig = (_this$config = this.config) == null ? void 0 : _this$config.loadPolicy.timeoutRetry;
        var retryCount = this.stats.retry;
        if (shouldRetry(retryConfig, retryCount, true)) {
          this.retry(retryConfig);
        } else {
          var _this$context;
          logger.warn("timeout while loading " + ((_this$context = this.context) == null ? void 0 : _this$context.url));
          var callbacks = this.callbacks;
          if (callbacks) {
            this.abortInternal();
            callbacks.onTimeout(this.stats, this.context, this.loader);
          }
        }
      };
      _proto.retry = function retry(retryConfig) {
        var context = this.context, stats = this.stats;
        this.retryDelay = getRetryDelay(retryConfig, stats.retry);
        stats.retry++;
        logger.warn((status ? "HTTP Status " + status : "Timeout") + " while loading " + (context == null ? void 0 : context.url) + ", retrying " + stats.retry + "/" + retryConfig.maxNumRetry + " in " + this.retryDelay + "ms");
        this.abortInternal();
        this.loader = null;
        self.clearTimeout(this.retryTimeout);
        this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
      };
      _proto.loadprogress = function loadprogress(event) {
        var stats = this.stats;
        stats.loaded = event.loaded;
        if (event.lengthComputable) {
          stats.total = event.total;
        }
      };
      _proto.getCacheAge = function getCacheAge() {
        var result = null;
        if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {
          var ageHeader = this.loader.getResponseHeader("age");
          result = ageHeader ? parseFloat(ageHeader) : null;
        }
        return result;
      };
      _proto.getResponseHeader = function getResponseHeader(name) {
        if (this.loader && new RegExp("^" + name + ":\\s*[\\d.]+\\s*$", "im").test(this.loader.getAllResponseHeaders())) {
          return this.loader.getResponseHeader(name);
        }
        return null;
      };
      return XhrLoader2;
    }();
    function fetchSupported() {
      if (
        // @ts-ignore
        self.fetch && self.AbortController && self.ReadableStream && self.Request
      ) {
        try {
          new self.ReadableStream({});
          return true;
        } catch (e) {
        }
      }
      return false;
    }
    var BYTERANGE = /(\d+)-(\d+)\/(\d+)/;
    var FetchLoader = /* @__PURE__ */ function() {
      function FetchLoader2(config) {
        this.fetchSetup = void 0;
        this.requestTimeout = void 0;
        this.request = null;
        this.response = null;
        this.controller = void 0;
        this.context = null;
        this.config = null;
        this.callbacks = null;
        this.stats = void 0;
        this.loader = null;
        this.fetchSetup = config.fetchSetup || getRequest;
        this.controller = new self.AbortController();
        this.stats = new LoadStats();
      }
      var _proto = FetchLoader2.prototype;
      _proto.destroy = function destroy() {
        this.loader = this.callbacks = this.context = this.config = this.request = null;
        this.abortInternal();
        this.response = null;
        this.fetchSetup = this.controller = this.stats = null;
      };
      _proto.abortInternal = function abortInternal() {
        if (this.controller && !this.stats.loading.end) {
          this.stats.aborted = true;
          this.controller.abort();
        }
      };
      _proto.abort = function abort() {
        var _this$callbacks;
        this.abortInternal();
        if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
          this.callbacks.onAbort(this.stats, this.context, this.response);
        }
      };
      _proto.load = function load(context, config, callbacks) {
        var _this = this;
        var stats = this.stats;
        if (stats.loading.start) {
          throw new Error("Loader can only be used once.");
        }
        stats.loading.start = self.performance.now();
        var initParams = getRequestParameters(context, this.controller.signal);
        var onProgress = callbacks.onProgress;
        var isArrayBuffer = context.responseType === "arraybuffer";
        var LENGTH = isArrayBuffer ? "byteLength" : "length";
        var _config$loadPolicy = config.loadPolicy, maxTimeToFirstByteMs = _config$loadPolicy.maxTimeToFirstByteMs, maxLoadTimeMs = _config$loadPolicy.maxLoadTimeMs;
        this.context = context;
        this.config = config;
        this.callbacks = callbacks;
        this.request = this.fetchSetup(context, initParams);
        self.clearTimeout(this.requestTimeout);
        config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
        this.requestTimeout = self.setTimeout(function() {
          _this.abortInternal();
          callbacks.onTimeout(stats, context, _this.response);
        }, config.timeout);
        self.fetch(this.request).then(function(response) {
          _this.response = _this.loader = response;
          var first = Math.max(self.performance.now(), stats.loading.start);
          self.clearTimeout(_this.requestTimeout);
          config.timeout = maxLoadTimeMs;
          _this.requestTimeout = self.setTimeout(function() {
            _this.abortInternal();
            callbacks.onTimeout(stats, context, _this.response);
          }, maxLoadTimeMs - (first - stats.loading.start));
          if (!response.ok) {
            var status2 = response.status, statusText = response.statusText;
            throw new FetchError(statusText || "fetch, bad network response", status2, response);
          }
          stats.loading.first = first;
          stats.total = getContentLength(response.headers) || stats.total;
          if (onProgress && isFiniteNumber(config.highWaterMark)) {
            return _this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);
          }
          if (isArrayBuffer) {
            return response.arrayBuffer();
          }
          if (context.responseType === "json") {
            return response.json();
          }
          return response.text();
        }).then(function(responseData) {
          var response = _this.response;
          if (!response) {
            throw new Error("loader destroyed");
          }
          self.clearTimeout(_this.requestTimeout);
          stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
          var total = responseData[LENGTH];
          if (total) {
            stats.loaded = stats.total = total;
          }
          var loaderResponse = {
            url: response.url,
            data: responseData,
            code: response.status
          };
          if (onProgress && !isFiniteNumber(config.highWaterMark)) {
            onProgress(stats, context, responseData, response);
          }
          callbacks.onSuccess(loaderResponse, stats, context, response);
        }).catch(function(error) {
          self.clearTimeout(_this.requestTimeout);
          if (stats.aborted) {
            return;
          }
          var code = !error ? 0 : error.code || 0;
          var text = !error ? null : error.message;
          callbacks.onError({
            code,
            text
          }, context, error ? error.details : null, stats);
        });
      };
      _proto.getCacheAge = function getCacheAge() {
        var result = null;
        if (this.response) {
          var ageHeader = this.response.headers.get("age");
          result = ageHeader ? parseFloat(ageHeader) : null;
        }
        return result;
      };
      _proto.getResponseHeader = function getResponseHeader(name) {
        return this.response ? this.response.headers.get(name) : null;
      };
      _proto.loadProgressively = function loadProgressively(response, stats, context, highWaterMark, onProgress) {
        if (highWaterMark === void 0) {
          highWaterMark = 0;
        }
        var chunkCache = new ChunkCache();
        var reader = response.body.getReader();
        var pump = function pump2() {
          return reader.read().then(function(data) {
            if (data.done) {
              if (chunkCache.dataLength) {
                onProgress(stats, context, chunkCache.flush(), response);
              }
              return Promise.resolve(new ArrayBuffer(0));
            }
            var chunk = data.value;
            var len = chunk.length;
            stats.loaded += len;
            if (len < highWaterMark || chunkCache.dataLength) {
              chunkCache.push(chunk);
              if (chunkCache.dataLength >= highWaterMark) {
                onProgress(stats, context, chunkCache.flush(), response);
              }
            } else {
              onProgress(stats, context, chunk, response);
            }
            return pump2();
          }).catch(function() {
            return Promise.reject();
          });
        };
        return pump();
      };
      return FetchLoader2;
    }();
    function getRequestParameters(context, signal) {
      var initParams = {
        method: "GET",
        mode: "cors",
        credentials: "same-origin",
        signal,
        headers: new self.Headers(_extends({}, context.headers))
      };
      if (context.rangeEnd) {
        initParams.headers.set("Range", "bytes=" + context.rangeStart + "-" + String(context.rangeEnd - 1));
      }
      return initParams;
    }
    function getByteRangeLength(byteRangeHeader) {
      var result = BYTERANGE.exec(byteRangeHeader);
      if (result) {
        return parseInt(result[2]) - parseInt(result[1]) + 1;
      }
    }
    function getContentLength(headers) {
      var contentRange = headers.get("Content-Range");
      if (contentRange) {
        var byteRangeLength = getByteRangeLength(contentRange);
        if (isFiniteNumber(byteRangeLength)) {
          return byteRangeLength;
        }
      }
      var contentLength = headers.get("Content-Length");
      if (contentLength) {
        return parseInt(contentLength);
      }
    }
    function getRequest(context, initParams) {
      return new self.Request(context.url, initParams);
    }
    var FetchError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(FetchError2, _Error);
      function FetchError2(message, code, details) {
        var _this2;
        _this2 = _Error.call(this, message) || this;
        _this2.code = void 0;
        _this2.details = void 0;
        _this2.code = code;
        _this2.details = details;
        return _this2;
      }
      return FetchError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    var WHITESPACE_CHAR = /\s/;
    var Cues = {
      newCue: function newCue(track, startTime, endTime, captionScreen) {
        var result = [];
        var row;
        var cue;
        var indenting;
        var indent;
        var text;
        var Cue = self.VTTCue || self.TextTrackCue;
        for (var r = 0; r < captionScreen.rows.length; r++) {
          row = captionScreen.rows[r];
          indenting = true;
          indent = 0;
          text = "";
          if (!row.isEmpty()) {
            var _track$cues;
            for (var c = 0; c < row.chars.length; c++) {
              if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {
                indent++;
              } else {
                text += row.chars[c].uchar;
                indenting = false;
              }
            }
            row.cueStartTime = startTime;
            if (startTime === endTime) {
              endTime += 1e-4;
            }
            if (indent >= 16) {
              indent--;
            } else {
              indent++;
            }
            var cueText = fixLineBreaks(text.trim());
            var id = generateCueId(startTime, endTime, cueText);
            if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id))) {
              cue = new Cue(startTime, endTime, cueText);
              cue.id = id;
              cue.line = r + 1;
              cue.align = "left";
              cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);
              result.push(cue);
            }
          }
        }
        if (track && result.length) {
          result.sort(function(cueA, cueB) {
            if (cueA.line === "auto" || cueB.line === "auto") {
              return 0;
            }
            if (cueA.line > 8 && cueB.line > 8) {
              return cueB.line - cueA.line;
            }
            return cueA.line - cueB.line;
          });
          result.forEach(function(cue2) {
            return addCueToTrack(track, cue2);
          });
        }
        return result;
      }
    };
    var defaultLoadPolicy = {
      maxTimeToFirstByteMs: 8e3,
      maxLoadTimeMs: 2e4,
      timeoutRetry: null,
      errorRetry: null
    };
    var hlsDefaultConfig = _objectSpread2(_objectSpread2({
      autoStartLoad: true,
      // used by stream-controller
      startPosition: -1,
      // used by stream-controller
      defaultAudioCodec: void 0,
      // used by stream-controller
      debug: false,
      // used by logger
      capLevelOnFPSDrop: false,
      // used by fps-controller
      capLevelToPlayerSize: false,
      // used by cap-level-controller
      ignoreDevicePixelRatio: false,
      // used by cap-level-controller
      preferManagedMediaSource: true,
      initialLiveManifestSize: 1,
      // used by stream-controller
      maxBufferLength: 30,
      // used by stream-controller
      backBufferLength: Infinity,
      // used by buffer-controller
      frontBufferFlushThreshold: Infinity,
      maxBufferSize: 60 * 1e3 * 1e3,
      // used by stream-controller
      maxBufferHole: 0.1,
      // used by stream-controller
      highBufferWatchdogPeriod: 2,
      // used by stream-controller
      nudgeOffset: 0.1,
      // used by stream-controller
      nudgeMaxRetry: 3,
      // used by stream-controller
      maxFragLookUpTolerance: 0.25,
      // used by stream-controller
      liveSyncDurationCount: 3,
      // used by latency-controller
      liveMaxLatencyDurationCount: Infinity,
      // used by latency-controller
      liveSyncDuration: void 0,
      // used by latency-controller
      liveMaxLatencyDuration: void 0,
      // used by latency-controller
      maxLiveSyncPlaybackRate: 1,
      // used by latency-controller
      liveDurationInfinity: false,
      // used by buffer-controller
      /**
       * @deprecated use backBufferLength
       */
      liveBackBufferLength: null,
      // used by buffer-controller
      maxMaxBufferLength: 600,
      // used by stream-controller
      enableWorker: true,
      // used by transmuxer
      workerPath: null,
      // used by transmuxer
      enableSoftwareAES: true,
      // used by decrypter
      startLevel: void 0,
      // used by level-controller
      startFragPrefetch: false,
      // used by stream-controller
      fpsDroppedMonitoringPeriod: 5e3,
      // used by fps-controller
      fpsDroppedMonitoringThreshold: 0.2,
      // used by fps-controller
      appendErrorMaxRetry: 3,
      // used by buffer-controller
      loader: XhrLoader,
      // loader: FetchLoader,
      fLoader: void 0,
      // used by fragment-loader
      pLoader: void 0,
      // used by playlist-loader
      xhrSetup: void 0,
      // used by xhr-loader
      licenseXhrSetup: void 0,
      // used by eme-controller
      licenseResponseCallback: void 0,
      // used by eme-controller
      abrController: AbrController,
      bufferController: BufferController,
      capLevelController: CapLevelController,
      errorController: ErrorController,
      fpsController: FPSController,
      stretchShortVideoTrack: false,
      // used by mp4-remuxer
      maxAudioFramesDrift: 1,
      // used by mp4-remuxer
      forceKeyFrameOnDiscontinuity: true,
      // used by ts-demuxer
      abrEwmaFastLive: 3,
      // used by abr-controller
      abrEwmaSlowLive: 9,
      // used by abr-controller
      abrEwmaFastVoD: 3,
      // used by abr-controller
      abrEwmaSlowVoD: 9,
      // used by abr-controller
      abrEwmaDefaultEstimate: 5e5,
      // 500 kbps  // used by abr-controller
      abrEwmaDefaultEstimateMax: 5e6,
      // 5 mbps
      abrBandWidthFactor: 0.95,
      // used by abr-controller
      abrBandWidthUpFactor: 0.7,
      // used by abr-controller
      abrMaxWithRealBitrate: false,
      // used by abr-controller
      maxStarvationDelay: 4,
      // used by abr-controller
      maxLoadingDelay: 4,
      // used by abr-controller
      minAutoBitrate: 0,
      // used by hls
      emeEnabled: false,
      // used by eme-controller
      widevineLicenseUrl: void 0,
      // used by eme-controller
      drmSystems: {},
      // used by eme-controller
      drmSystemOptions: {},
      // used by eme-controller
      requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess,
      // used by eme-controller
      testBandwidth: true,
      progressive: false,
      lowLatencyMode: true,
      cmcd: void 0,
      enableDateRangeMetadataCues: true,
      enableEmsgMetadataCues: true,
      enableID3MetadataCues: true,
      useMediaCapabilities: true,
      certLoadPolicy: {
        default: defaultLoadPolicy
      },
      keyLoadPolicy: {
        default: {
          maxTimeToFirstByteMs: 8e3,
          maxLoadTimeMs: 2e4,
          timeoutRetry: {
            maxNumRetry: 1,
            retryDelayMs: 1e3,
            maxRetryDelayMs: 2e4,
            backoff: "linear"
          },
          errorRetry: {
            maxNumRetry: 8,
            retryDelayMs: 1e3,
            maxRetryDelayMs: 2e4,
            backoff: "linear"
          }
        }
      },
      manifestLoadPolicy: {
        default: {
          maxTimeToFirstByteMs: Infinity,
          maxLoadTimeMs: 2e4,
          timeoutRetry: {
            maxNumRetry: 2,
            retryDelayMs: 0,
            maxRetryDelayMs: 0
          },
          errorRetry: {
            maxNumRetry: 1,
            retryDelayMs: 1e3,
            maxRetryDelayMs: 8e3
          }
        }
      },
      playlistLoadPolicy: {
        default: {
          maxTimeToFirstByteMs: 1e4,
          maxLoadTimeMs: 2e4,
          timeoutRetry: {
            maxNumRetry: 2,
            retryDelayMs: 0,
            maxRetryDelayMs: 0
          },
          errorRetry: {
            maxNumRetry: 2,
            retryDelayMs: 1e3,
            maxRetryDelayMs: 8e3
          }
        }
      },
      fragLoadPolicy: {
        default: {
          maxTimeToFirstByteMs: 1e4,
          maxLoadTimeMs: 12e4,
          timeoutRetry: {
            maxNumRetry: 4,
            retryDelayMs: 0,
            maxRetryDelayMs: 0
          },
          errorRetry: {
            maxNumRetry: 6,
            retryDelayMs: 1e3,
            maxRetryDelayMs: 8e3
          }
        }
      },
      steeringManifestLoadPolicy: {
        default: {
          maxTimeToFirstByteMs: 1e4,
          maxLoadTimeMs: 2e4,
          timeoutRetry: {
            maxNumRetry: 2,
            retryDelayMs: 0,
            maxRetryDelayMs: 0
          },
          errorRetry: {
            maxNumRetry: 1,
            retryDelayMs: 1e3,
            maxRetryDelayMs: 8e3
          }
        }
      },
      // These default settings are deprecated in favor of the above policies
      // and are maintained for backwards compatibility
      manifestLoadingTimeOut: 1e4,
      manifestLoadingMaxRetry: 1,
      manifestLoadingRetryDelay: 1e3,
      manifestLoadingMaxRetryTimeout: 64e3,
      levelLoadingTimeOut: 1e4,
      levelLoadingMaxRetry: 4,
      levelLoadingRetryDelay: 1e3,
      levelLoadingMaxRetryTimeout: 64e3,
      fragLoadingTimeOut: 2e4,
      fragLoadingMaxRetry: 6,
      fragLoadingRetryDelay: 1e3,
      fragLoadingMaxRetryTimeout: 64e3
    }, timelineConfig()), {}, {
      subtitleStreamController: SubtitleStreamController,
      subtitleTrackController: SubtitleTrackController,
      timelineController: TimelineController,
      audioStreamController: AudioStreamController,
      audioTrackController: AudioTrackController,
      emeController: EMEController,
      cmcdController: CMCDController,
      contentSteeringController: ContentSteeringController
    });
    function timelineConfig() {
      return {
        cueHandler: Cues,
        // used by timeline-controller
        enableWebVTT: true,
        // used by timeline-controller
        enableIMSC1: true,
        // used by timeline-controller
        enableCEA708Captions: true,
        // used by timeline-controller
        captionsTextTrack1Label: "English",
        // used by timeline-controller
        captionsTextTrack1LanguageCode: "en",
        // used by timeline-controller
        captionsTextTrack2Label: "Spanish",
        // used by timeline-controller
        captionsTextTrack2LanguageCode: "es",
        // used by timeline-controller
        captionsTextTrack3Label: "Unknown CC",
        // used by timeline-controller
        captionsTextTrack3LanguageCode: "",
        // used by timeline-controller
        captionsTextTrack4Label: "Unknown CC",
        // used by timeline-controller
        captionsTextTrack4LanguageCode: "",
        // used by timeline-controller
        renderTextTracksNatively: true
      };
    }
    function mergeConfig(defaultConfig, userConfig) {
      if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {
        throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
      }
      if (userConfig.liveMaxLatencyDurationCount !== void 0 && (userConfig.liveSyncDurationCount === void 0 || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {
        throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
      }
      if (userConfig.liveMaxLatencyDuration !== void 0 && (userConfig.liveSyncDuration === void 0 || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {
        throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
      }
      var defaultsCopy = deepCpy(defaultConfig);
      var deprecatedSettingTypes = ["manifest", "level", "frag"];
      var deprecatedSettings = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
      deprecatedSettingTypes.forEach(function(type) {
        var policyName = (type === "level" ? "playlist" : type) + "LoadPolicy";
        var policyNotSet = userConfig[policyName] === void 0;
        var report = [];
        deprecatedSettings.forEach(function(setting) {
          var deprecatedSetting = type + "Loading" + setting;
          var value = userConfig[deprecatedSetting];
          if (value !== void 0 && policyNotSet) {
            report.push(deprecatedSetting);
            var settings = defaultsCopy[policyName].default;
            userConfig[policyName] = {
              default: settings
            };
            switch (setting) {
              case "TimeOut":
                settings.maxLoadTimeMs = value;
                settings.maxTimeToFirstByteMs = value;
                break;
              case "MaxRetry":
                settings.errorRetry.maxNumRetry = value;
                settings.timeoutRetry.maxNumRetry = value;
                break;
              case "RetryDelay":
                settings.errorRetry.retryDelayMs = value;
                settings.timeoutRetry.retryDelayMs = value;
                break;
              case "MaxRetryTimeout":
                settings.errorRetry.maxRetryDelayMs = value;
                settings.timeoutRetry.maxRetryDelayMs = value;
                break;
            }
          }
        });
        if (report.length) {
          logger.warn('hls.js config: "' + report.join('", "') + '" setting(s) are deprecated, use "' + policyName + '": ' + JSON.stringify(userConfig[policyName]));
        }
      });
      return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);
    }
    function deepCpy(obj) {
      if (obj && typeof obj === "object") {
        if (Array.isArray(obj)) {
          return obj.map(deepCpy);
        }
        return Object.keys(obj).reduce(function(result, key) {
          result[key] = deepCpy(obj[key]);
          return result;
        }, {});
      }
      return obj;
    }
    function enableStreamingMode(config) {
      var currentLoader = config.loader;
      if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {
        logger.log("[config]: Custom loader detected, cannot enable progressive streaming");
        config.progressive = false;
      } else {
        var canStreamProgressively = fetchSupported();
        if (canStreamProgressively) {
          config.loader = FetchLoader;
          config.progressive = true;
          config.enableSoftwareAES = true;
          logger.log("[config]: Progressive streaming enabled, using FetchLoader");
        }
      }
    }
    var chromeOrFirefox;
    var LevelController = /* @__PURE__ */ function(_BasePlaylistControll) {
      _inheritsLoose(LevelController2, _BasePlaylistControll);
      function LevelController2(hls, contentSteeringController) {
        var _this;
        _this = _BasePlaylistControll.call(this, hls, "[level-controller]") || this;
        _this._levels = [];
        _this._firstLevel = -1;
        _this._maxAutoLevel = -1;
        _this._startLevel = void 0;
        _this.currentLevel = null;
        _this.currentLevelIndex = -1;
        _this.manualLevelIndex = -1;
        _this.steering = void 0;
        _this.onParsedComplete = void 0;
        _this.steering = contentSteeringController;
        _this._registerListeners();
        return _this;
      }
      var _proto = LevelController2.prototype;
      _proto._registerListeners = function _registerListeners() {
        var hls = this.hls;
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
        hls.on(Events.ERROR, this.onError, this);
      };
      _proto._unregisterListeners = function _unregisterListeners() {
        var hls = this.hls;
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
        hls.off(Events.ERROR, this.onError, this);
      };
      _proto.destroy = function destroy() {
        this._unregisterListeners();
        this.steering = null;
        this.resetLevels();
        _BasePlaylistControll.prototype.destroy.call(this);
      };
      _proto.stopLoad = function stopLoad() {
        var levels = this._levels;
        levels.forEach(function(level) {
          level.loadError = 0;
          level.fragmentError = 0;
        });
        _BasePlaylistControll.prototype.stopLoad.call(this);
      };
      _proto.resetLevels = function resetLevels() {
        this._startLevel = void 0;
        this.manualLevelIndex = -1;
        this.currentLevelIndex = -1;
        this.currentLevel = null;
        this._levels = [];
        this._maxAutoLevel = -1;
      };
      _proto.onManifestLoading = function onManifestLoading(event, data) {
        this.resetLevels();
      };
      _proto.onManifestLoaded = function onManifestLoaded(event, data) {
        var preferManagedMediaSource = this.hls.config.preferManagedMediaSource;
        var levels = [];
        var redundantSet = {};
        var generatePathwaySet = {};
        var resolutionFound = false;
        var videoCodecFound = false;
        var audioCodecFound = false;
        data.levels.forEach(function(levelParsed) {
          var _audioCodec, _videoCodec;
          var attributes = levelParsed.attrs;
          var audioCodec = levelParsed.audioCodec, videoCodec = levelParsed.videoCodec;
          if (((_audioCodec = audioCodec) == null ? void 0 : _audioCodec.indexOf("mp4a.40.34")) !== -1) {
            chromeOrFirefox || (chromeOrFirefox = /chrome|firefox/i.test(navigator.userAgent));
            if (chromeOrFirefox) {
              levelParsed.audioCodec = audioCodec = void 0;
            }
          }
          if (audioCodec) {
            levelParsed.audioCodec = audioCodec = getCodecCompatibleName(audioCodec, preferManagedMediaSource);
          }
          if (((_videoCodec = videoCodec) == null ? void 0 : _videoCodec.indexOf("avc1")) === 0) {
            videoCodec = levelParsed.videoCodec = convertAVC1ToAVCOTI(videoCodec);
          }
          var width = levelParsed.width, height = levelParsed.height, unknownCodecs = levelParsed.unknownCodecs;
          resolutionFound || (resolutionFound = !!(width && height));
          videoCodecFound || (videoCodecFound = !!videoCodec);
          audioCodecFound || (audioCodecFound = !!audioCodec);
          if (unknownCodecs != null && unknownCodecs.length || audioCodec && !areCodecsMediaSourceSupported(audioCodec, "audio", preferManagedMediaSource) || videoCodec && !areCodecsMediaSourceSupported(videoCodec, "video", preferManagedMediaSource)) {
            return;
          }
          var CODECS = attributes.CODECS, FRAMERATE = attributes["FRAME-RATE"], HDCP = attributes["HDCP-LEVEL"], PATHWAY = attributes["PATHWAY-ID"], RESOLUTION = attributes.RESOLUTION, VIDEO_RANGE = attributes["VIDEO-RANGE"];
          var contentSteeringPrefix = (PATHWAY || ".") + "-";
          var levelKey = "" + contentSteeringPrefix + levelParsed.bitrate + "-" + RESOLUTION + "-" + FRAMERATE + "-" + CODECS + "-" + VIDEO_RANGE + "-" + HDCP;
          if (!redundantSet[levelKey]) {
            var level = new Level(levelParsed);
            redundantSet[levelKey] = level;
            generatePathwaySet[levelKey] = 1;
            levels.push(level);
          } else if (redundantSet[levelKey].uri !== levelParsed.url && !levelParsed.attrs["PATHWAY-ID"]) {
            var pathwayCount = generatePathwaySet[levelKey] += 1;
            levelParsed.attrs["PATHWAY-ID"] = new Array(pathwayCount + 1).join(".");
            var _level = new Level(levelParsed);
            redundantSet[levelKey] = _level;
            levels.push(_level);
          } else {
            redundantSet[levelKey].addGroupId("audio", attributes.AUDIO);
            redundantSet[levelKey].addGroupId("text", attributes.SUBTITLES);
          }
        });
        this.filterAndSortMediaOptions(levels, data, resolutionFound, videoCodecFound, audioCodecFound);
      };
      _proto.filterAndSortMediaOptions = function filterAndSortMediaOptions(filteredLevels, data, resolutionFound, videoCodecFound, audioCodecFound) {
        var _this2 = this;
        var audioTracks = [];
        var subtitleTracks = [];
        var levels = filteredLevels;
        if ((resolutionFound || videoCodecFound) && audioCodecFound) {
          levels = levels.filter(function(_ref) {
            var videoCodec = _ref.videoCodec, videoRange = _ref.videoRange, width = _ref.width, height = _ref.height;
            return (!!videoCodec || !!(width && height)) && isVideoRange(videoRange);
          });
        }
        if (levels.length === 0) {
          Promise.resolve().then(function() {
            if (_this2.hls) {
              if (data.levels.length) {
                _this2.warn("One or more CODECS in variant not supported: " + JSON.stringify(data.levels[0].attrs));
              }
              var error = new Error("no level with compatible codecs found in manifest");
              _this2.hls.trigger(Events.ERROR, {
                type: ErrorTypes.MEDIA_ERROR,
                details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                fatal: true,
                url: data.url,
                error,
                reason: error.message
              });
            }
          });
          return;
        }
        if (data.audioTracks) {
          var preferManagedMediaSource = this.hls.config.preferManagedMediaSource;
          audioTracks = data.audioTracks.filter(function(track) {
            return !track.audioCodec || areCodecsMediaSourceSupported(track.audioCodec, "audio", preferManagedMediaSource);
          });
          assignTrackIdsByGroup(audioTracks);
        }
        if (data.subtitles) {
          subtitleTracks = data.subtitles;
          assignTrackIdsByGroup(subtitleTracks);
        }
        var unsortedLevels = levels.slice(0);
        levels.sort(function(a, b) {
          if (a.attrs["HDCP-LEVEL"] !== b.attrs["HDCP-LEVEL"]) {
            return (a.attrs["HDCP-LEVEL"] || "") > (b.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
          }
          if (resolutionFound && a.height !== b.height) {
            return a.height - b.height;
          }
          if (a.frameRate !== b.frameRate) {
            return a.frameRate - b.frameRate;
          }
          if (a.videoRange !== b.videoRange) {
            return VideoRangeValues.indexOf(a.videoRange) - VideoRangeValues.indexOf(b.videoRange);
          }
          if (a.videoCodec !== b.videoCodec) {
            var valueA = videoCodecPreferenceValue(a.videoCodec);
            var valueB = videoCodecPreferenceValue(b.videoCodec);
            if (valueA !== valueB) {
              return valueB - valueA;
            }
          }
          if (a.uri === b.uri && a.codecSet !== b.codecSet) {
            var _valueA = codecsSetSelectionPreferenceValue(a.codecSet);
            var _valueB = codecsSetSelectionPreferenceValue(b.codecSet);
            if (_valueA !== _valueB) {
              return _valueB - _valueA;
            }
          }
          if (a.bitrate !== b.bitrate) {
            return a.bitrate - b.bitrate;
          }
          return 0;
        });
        var firstLevelInPlaylist = unsortedLevels[0];
        if (this.steering) {
          levels = this.steering.filterParsedLevels(levels);
          if (levels.length !== unsortedLevels.length) {
            for (var i = 0; i < unsortedLevels.length; i++) {
              if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {
                firstLevelInPlaylist = unsortedLevels[i];
                break;
              }
            }
          }
        }
        this._levels = levels;
        for (var _i = 0; _i < levels.length; _i++) {
          if (levels[_i] === firstLevelInPlaylist) {
            var _this$hls$userConfig;
            this._firstLevel = _i;
            var firstLevelBitrate = firstLevelInPlaylist.bitrate;
            var bandwidthEstimate = this.hls.bandwidthEstimate;
            this.log("manifest loaded, " + levels.length + " level(s) found, first bitrate: " + firstLevelBitrate);
            if (((_this$hls$userConfig = this.hls.userConfig) == null ? void 0 : _this$hls$userConfig.abrEwmaDefaultEstimate) === void 0) {
              var startingBwEstimate = Math.min(firstLevelBitrate, this.hls.config.abrEwmaDefaultEstimateMax);
              if (startingBwEstimate > bandwidthEstimate && bandwidthEstimate === hlsDefaultConfig.abrEwmaDefaultEstimate) {
                this.hls.bandwidthEstimate = startingBwEstimate;
              }
            }
            break;
          }
        }
        var audioOnly = audioCodecFound && !videoCodecFound;
        var edata = {
          levels,
          audioTracks,
          subtitleTracks,
          sessionData: data.sessionData,
          sessionKeys: data.sessionKeys,
          firstLevel: this._firstLevel,
          stats: data.stats,
          audio: audioCodecFound,
          video: videoCodecFound,
          altAudio: !audioOnly && audioTracks.some(function(t) {
            return !!t.url;
          })
        };
        this.hls.trigger(Events.MANIFEST_PARSED, edata);
        if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {
          this.hls.startLoad(this.hls.config.startPosition);
        }
      };
      _proto.onError = function onError(event, data) {
        if (data.fatal || !data.context) {
          return;
        }
        if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {
          this.checkRetry(data);
        }
      };
      _proto.onFragBuffered = function onFragBuffered(event, _ref2) {
        var frag = _ref2.frag;
        if (frag !== void 0 && frag.type === PlaylistLevelType.MAIN) {
          var el = frag.elementaryStreams;
          if (!Object.keys(el).some(function(type) {
            return !!el[type];
          })) {
            return;
          }
          var level = this._levels[frag.level];
          if (level != null && level.loadError) {
            this.log("Resetting level error count of " + level.loadError + " on frag buffered");
            level.loadError = 0;
          }
        }
      };
      _proto.onLevelLoaded = function onLevelLoaded(event, data) {
        var _data$deliveryDirecti2;
        var level = data.level, details = data.details;
        var curLevel = this._levels[level];
        if (!curLevel) {
          var _data$deliveryDirecti;
          this.warn("Invalid level index " + level);
          if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {
            details.deltaUpdateFailed = true;
          }
          return;
        }
        if (level === this.currentLevelIndex) {
          if (curLevel.fragmentError === 0) {
            curLevel.loadError = 0;
          }
          this.playlistLoaded(level, data, curLevel.details);
        } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {
          details.deltaUpdateFailed = true;
        }
      };
      _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
        _BasePlaylistControll.prototype.loadPlaylist.call(this);
        var currentLevelIndex = this.currentLevelIndex;
        var currentLevel = this.currentLevel;
        if (currentLevel && this.shouldLoadPlaylist(currentLevel)) {
          var url = currentLevel.uri;
          if (hlsUrlParameters) {
            try {
              url = hlsUrlParameters.addDirectives(url);
            } catch (error) {
              this.warn("Could not construct new URL with HLS Delivery Directives: " + error);
            }
          }
          var pathwayId = currentLevel.attrs["PATHWAY-ID"];
          this.log("Loading level index " + currentLevelIndex + ((hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== void 0 ? " at sn " + hlsUrlParameters.msn + " part " + hlsUrlParameters.part : "") + " with" + (pathwayId ? " Pathway " + pathwayId : "") + " " + url);
          this.clearTimer();
          this.hls.trigger(Events.LEVEL_LOADING, {
            url,
            level: currentLevelIndex,
            pathwayId: currentLevel.attrs["PATHWAY-ID"],
            id: 0,
            // Deprecated Level urlId
            deliveryDirectives: hlsUrlParameters || null
          });
        }
      };
      _proto.removeLevel = function removeLevel(levelIndex) {
        var _this3 = this, _this$currentLevel;
        var levels = this._levels.filter(function(level, index) {
          if (index !== levelIndex) {
            return true;
          }
          if (_this3.steering) {
            _this3.steering.removeLevel(level);
          }
          if (level === _this3.currentLevel) {
            _this3.currentLevel = null;
            _this3.currentLevelIndex = -1;
            if (level.details) {
              level.details.fragments.forEach(function(f) {
                return f.level = -1;
              });
            }
          }
          return false;
        });
        reassignFragmentLevelIndexes(levels);
        this._levels = levels;
        if (this.currentLevelIndex > -1 && (_this$currentLevel = this.currentLevel) != null && _this$currentLevel.details) {
          this.currentLevelIndex = this.currentLevel.details.fragments[0].level;
        }
        this.hls.trigger(Events.LEVELS_UPDATED, {
          levels
        });
      };
      _proto.onLevelsUpdated = function onLevelsUpdated(event, _ref3) {
        var levels = _ref3.levels;
        this._levels = levels;
      };
      _proto.checkMaxAutoUpdated = function checkMaxAutoUpdated() {
        var _this$hls = this.hls, autoLevelCapping = _this$hls.autoLevelCapping, maxAutoLevel = _this$hls.maxAutoLevel, maxHdcpLevel = _this$hls.maxHdcpLevel;
        if (this._maxAutoLevel !== maxAutoLevel) {
          this._maxAutoLevel = maxAutoLevel;
          this.hls.trigger(Events.MAX_AUTO_LEVEL_UPDATED, {
            autoLevelCapping,
            levels: this.levels,
            maxAutoLevel,
            minAutoLevel: this.hls.minAutoLevel,
            maxHdcpLevel
          });
        }
      };
      _createClass(LevelController2, [{
        key: "levels",
        get: function get() {
          if (this._levels.length === 0) {
            return null;
          }
          return this._levels;
        }
      }, {
        key: "level",
        get: function get() {
          return this.currentLevelIndex;
        },
        set: function set(newLevel) {
          var levels = this._levels;
          if (levels.length === 0) {
            return;
          }
          if (newLevel < 0 || newLevel >= levels.length) {
            var error = new Error("invalid level idx");
            var fatal = newLevel < 0;
            this.hls.trigger(Events.ERROR, {
              type: ErrorTypes.OTHER_ERROR,
              details: ErrorDetails.LEVEL_SWITCH_ERROR,
              level: newLevel,
              fatal,
              error,
              reason: error.message
            });
            if (fatal) {
              return;
            }
            newLevel = Math.min(newLevel, levels.length - 1);
          }
          var lastLevelIndex = this.currentLevelIndex;
          var lastLevel = this.currentLevel;
          var lastPathwayId = lastLevel ? lastLevel.attrs["PATHWAY-ID"] : void 0;
          var level = levels[newLevel];
          var pathwayId = level.attrs["PATHWAY-ID"];
          this.currentLevelIndex = newLevel;
          this.currentLevel = level;
          if (lastLevelIndex === newLevel && level.details && lastLevel && lastPathwayId === pathwayId) {
            return;
          }
          this.log("Switching to level " + newLevel + " (" + (level.height ? level.height + "p " : "") + (level.videoRange ? level.videoRange + " " : "") + (level.codecSet ? level.codecSet + " " : "") + "@" + level.bitrate + ")" + (pathwayId ? " with Pathway " + pathwayId : "") + " from level " + lastLevelIndex + (lastPathwayId ? " with Pathway " + lastPathwayId : ""));
          var levelSwitchingData = {
            level: newLevel,
            attrs: level.attrs,
            details: level.details,
            bitrate: level.bitrate,
            averageBitrate: level.averageBitrate,
            maxBitrate: level.maxBitrate,
            realBitrate: level.realBitrate,
            width: level.width,
            height: level.height,
            codecSet: level.codecSet,
            audioCodec: level.audioCodec,
            videoCodec: level.videoCodec,
            audioGroups: level.audioGroups,
            subtitleGroups: level.subtitleGroups,
            loaded: level.loaded,
            loadError: level.loadError,
            fragmentError: level.fragmentError,
            name: level.name,
            id: level.id,
            uri: level.uri,
            url: level.url,
            urlId: 0,
            audioGroupIds: level.audioGroupIds,
            textGroupIds: level.textGroupIds
          };
          this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);
          var levelDetails = level.details;
          if (!levelDetails || levelDetails.live) {
            var hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details);
            this.loadPlaylist(hlsUrlParameters);
          }
        }
      }, {
        key: "manualLevel",
        get: function get() {
          return this.manualLevelIndex;
        },
        set: function set(newLevel) {
          this.manualLevelIndex = newLevel;
          if (this._startLevel === void 0) {
            this._startLevel = newLevel;
          }
          if (newLevel !== -1) {
            this.level = newLevel;
          }
        }
      }, {
        key: "firstLevel",
        get: function get() {
          return this._firstLevel;
        },
        set: function set(newLevel) {
          this._firstLevel = newLevel;
        }
      }, {
        key: "startLevel",
        get: function get() {
          if (this._startLevel === void 0) {
            var configStartLevel = this.hls.config.startLevel;
            if (configStartLevel !== void 0) {
              return configStartLevel;
            }
            return this.hls.firstAutoLevel;
          }
          return this._startLevel;
        },
        set: function set(newLevel) {
          this._startLevel = newLevel;
        }
      }, {
        key: "nextLoadLevel",
        get: function get() {
          if (this.manualLevelIndex !== -1) {
            return this.manualLevelIndex;
          } else {
            return this.hls.nextAutoLevel;
          }
        },
        set: function set(nextLevel) {
          this.level = nextLevel;
          if (this.manualLevelIndex === -1) {
            this.hls.nextAutoLevel = nextLevel;
          }
        }
      }]);
      return LevelController2;
    }(BasePlaylistController);
    function assignTrackIdsByGroup(tracks) {
      var groups = {};
      tracks.forEach(function(track) {
        var groupId = track.groupId || "";
        track.id = groups[groupId] = groups[groupId] || 0;
        groups[groupId]++;
      });
    }
    var KeyLoader = /* @__PURE__ */ function() {
      function KeyLoader2(config) {
        this.config = void 0;
        this.keyUriToKeyInfo = {};
        this.emeController = null;
        this.config = config;
      }
      var _proto = KeyLoader2.prototype;
      _proto.abort = function abort(type) {
        for (var uri in this.keyUriToKeyInfo) {
          var loader = this.keyUriToKeyInfo[uri].loader;
          if (loader) {
            var _loader$context;
            if (type && type !== ((_loader$context = loader.context) == null ? void 0 : _loader$context.frag.type)) {
              return;
            }
            loader.abort();
          }
        }
      };
      _proto.detach = function detach() {
        for (var uri in this.keyUriToKeyInfo) {
          var keyInfo = this.keyUriToKeyInfo[uri];
          if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {
            delete this.keyUriToKeyInfo[uri];
          }
        }
      };
      _proto.destroy = function destroy() {
        this.detach();
        for (var uri in this.keyUriToKeyInfo) {
          var loader = this.keyUriToKeyInfo[uri].loader;
          if (loader) {
            loader.destroy();
          }
        }
        this.keyUriToKeyInfo = {};
      };
      _proto.createKeyLoadError = function createKeyLoadError(frag, details, error, networkDetails, response) {
        if (details === void 0) {
          details = ErrorDetails.KEY_LOAD_ERROR;
        }
        return new LoadError({
          type: ErrorTypes.NETWORK_ERROR,
          details,
          fatal: false,
          frag,
          response,
          error,
          networkDetails
        });
      };
      _proto.loadClear = function loadClear(loadingFrag, encryptedFragments) {
        var _this = this;
        if (this.emeController && this.config.emeEnabled) {
          var sn = loadingFrag.sn, cc = loadingFrag.cc;
          var _loop = function _loop2() {
            var frag = encryptedFragments[i];
            if (cc <= frag.cc && (sn === "initSegment" || frag.sn === "initSegment" || sn < frag.sn)) {
              _this.emeController.selectKeySystemFormat(frag).then(function(keySystemFormat) {
                frag.setKeyFormat(keySystemFormat);
              });
              return 1;
            }
          };
          for (var i = 0; i < encryptedFragments.length; i++) {
            if (_loop())
              break;
          }
        }
      };
      _proto.load = function load(frag) {
        var _this2 = this;
        if (!frag.decryptdata && frag.encrypted && this.emeController) {
          return this.emeController.selectKeySystemFormat(frag).then(function(keySystemFormat) {
            return _this2.loadInternal(frag, keySystemFormat);
          });
        }
        return this.loadInternal(frag);
      };
      _proto.loadInternal = function loadInternal(frag, keySystemFormat) {
        var _keyInfo, _keyInfo2;
        if (keySystemFormat) {
          frag.setKeyFormat(keySystemFormat);
        }
        var decryptdata = frag.decryptdata;
        if (!decryptdata) {
          var error = new Error(keySystemFormat ? "Expected frag.decryptdata to be defined after setting format " + keySystemFormat : "Missing decryption data on fragment in onKeyLoading");
          return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));
        }
        var uri = decryptdata.uri;
        if (!uri) {
          return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('Invalid key URI: "' + uri + '"')));
        }
        var keyInfo = this.keyUriToKeyInfo[uri];
        if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {
          decryptdata.key = keyInfo.decryptdata.key;
          return Promise.resolve({
            frag,
            keyInfo
          });
        }
        if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {
          var _keyInfo$mediaKeySess;
          switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus) {
            case void 0:
            case "status-pending":
            case "usable":
            case "usable-in-future":
              return keyInfo.keyLoadPromise.then(function(keyLoadedData) {
                decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;
                return {
                  frag,
                  keyInfo
                };
              });
          }
        }
        keyInfo = this.keyUriToKeyInfo[uri] = {
          decryptdata,
          keyLoadPromise: null,
          loader: null,
          mediaKeySessionContext: null
        };
        switch (decryptdata.method) {
          case "ISO-23001-7":
          case "SAMPLE-AES":
          case "SAMPLE-AES-CENC":
          case "SAMPLE-AES-CTR":
            if (decryptdata.keyFormat === "identity") {
              return this.loadKeyHTTP(keyInfo, frag);
            }
            return this.loadKeyEME(keyInfo, frag);
          case "AES-128":
            return this.loadKeyHTTP(keyInfo, frag);
          default:
            return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('Key supplied with unsupported METHOD: "' + decryptdata.method + '"')));
        }
      };
      _proto.loadKeyEME = function loadKeyEME(keyInfo, frag) {
        var keyLoadedData = {
          frag,
          keyInfo
        };
        if (this.emeController && this.config.emeEnabled) {
          var keySessionContextPromise = this.emeController.loadKey(keyLoadedData);
          if (keySessionContextPromise) {
            return (keyInfo.keyLoadPromise = keySessionContextPromise.then(function(keySessionContext) {
              keyInfo.mediaKeySessionContext = keySessionContext;
              return keyLoadedData;
            })).catch(function(error) {
              keyInfo.keyLoadPromise = null;
              throw error;
            });
          }
        }
        return Promise.resolve(keyLoadedData);
      };
      _proto.loadKeyHTTP = function loadKeyHTTP(keyInfo, frag) {
        var _this3 = this;
        var config = this.config;
        var Loader = config.loader;
        var keyLoader = new Loader(config);
        frag.keyLoader = keyInfo.loader = keyLoader;
        return keyInfo.keyLoadPromise = new Promise(function(resolve, reject) {
          var loaderContext = {
            keyInfo,
            frag,
            responseType: "arraybuffer",
            url: keyInfo.decryptdata.uri
          };
          var loadPolicy = config.keyLoadPolicy.default;
          var loaderConfig = {
            loadPolicy,
            timeout: loadPolicy.maxLoadTimeMs,
            maxRetry: 0,
            retryDelay: 0,
            maxRetryDelay: 0
          };
          var loaderCallbacks = {
            onSuccess: function onSuccess(response, stats, context, networkDetails) {
              var frag2 = context.frag, keyInfo2 = context.keyInfo, uri = context.url;
              if (!frag2.decryptdata || keyInfo2 !== _this3.keyUriToKeyInfo[uri]) {
                return reject(_this3.createKeyLoadError(frag2, ErrorDetails.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), networkDetails));
              }
              keyInfo2.decryptdata.key = frag2.decryptdata.key = new Uint8Array(response.data);
              frag2.keyLoader = null;
              keyInfo2.loader = null;
              resolve({
                frag: frag2,
                keyInfo: keyInfo2
              });
            },
            onError: function onError(response, context, networkDetails, stats) {
              _this3.resetLoader(context);
              reject(_this3.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error("HTTP Error " + response.code + " loading key " + response.text), networkDetails, _objectSpread2({
                url: loaderContext.url,
                data: void 0
              }, response)));
            },
            onTimeout: function onTimeout(stats, context, networkDetails) {
              _this3.resetLoader(context);
              reject(_this3.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), networkDetails));
            },
            onAbort: function onAbort(stats, context, networkDetails) {
              _this3.resetLoader(context);
              reject(_this3.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error("key loading aborted"), networkDetails));
            }
          };
          keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);
        });
      };
      _proto.resetLoader = function resetLoader(context) {
        var frag = context.frag, keyInfo = context.keyInfo, uri = context.url;
        var loader = keyInfo.loader;
        if (frag.keyLoader === loader) {
          frag.keyLoader = null;
          keyInfo.loader = null;
        }
        delete this.keyUriToKeyInfo[uri];
        if (loader) {
          loader.destroy();
        }
      };
      return KeyLoader2;
    }();
    function getSourceBuffer() {
      return self.SourceBuffer || self.WebKitSourceBuffer;
    }
    function isMSESupported() {
      var mediaSource = getMediaSource();
      if (!mediaSource) {
        return false;
      }
      var sourceBuffer = getSourceBuffer();
      return !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === "function" && typeof sourceBuffer.prototype.remove === "function";
    }
    function isSupported() {
      if (!isMSESupported()) {
        return false;
      }
      var mediaSource = getMediaSource();
      return typeof (mediaSource == null ? void 0 : mediaSource.isTypeSupported) === "function" && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some(function(codecsForVideoContainer) {
        return mediaSource.isTypeSupported(mimeTypeForCodec(codecsForVideoContainer, "video"));
      }) || ["mp4a.40.2", "fLaC"].some(function(codecForAudioContainer) {
        return mediaSource.isTypeSupported(mimeTypeForCodec(codecForAudioContainer, "audio"));
      }));
    }
    function changeTypeSupported() {
      var _sourceBuffer$prototy;
      var sourceBuffer = getSourceBuffer();
      return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === "function";
    }
    var STALL_MINIMUM_DURATION_MS = 250;
    var MAX_START_GAP_JUMP = 2;
    var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;
    var SKIP_BUFFER_RANGE_START = 0.05;
    var GapController = /* @__PURE__ */ function() {
      function GapController2(config, media, fragmentTracker, hls) {
        this.config = void 0;
        this.media = null;
        this.fragmentTracker = void 0;
        this.hls = void 0;
        this.nudgeRetry = 0;
        this.stallReported = false;
        this.stalled = null;
        this.moved = false;
        this.seeking = false;
        this.config = config;
        this.media = media;
        this.fragmentTracker = fragmentTracker;
        this.hls = hls;
      }
      var _proto = GapController2.prototype;
      _proto.destroy = function destroy() {
        this.media = null;
        this.hls = this.fragmentTracker = null;
      };
      _proto.poll = function poll(lastCurrentTime, activeFrag) {
        var config = this.config, media = this.media, stalled = this.stalled;
        if (media === null) {
          return;
        }
        var currentTime = media.currentTime, seeking = media.seeking;
        var seeked = this.seeking && !seeking;
        var beginSeek = !this.seeking && seeking;
        this.seeking = seeking;
        if (currentTime !== lastCurrentTime) {
          this.moved = true;
          if (!seeking) {
            this.nudgeRetry = 0;
          }
          if (stalled !== null) {
            if (this.stallReported) {
              var _stalledDuration = self.performance.now() - stalled;
              logger.warn("playback not stuck anymore @" + currentTime + ", after " + Math.round(_stalledDuration) + "ms");
              this.stallReported = false;
            }
            this.stalled = null;
          }
          return;
        }
        if (beginSeek || seeked) {
          this.stalled = null;
          return;
        }
        if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !BufferHelper.getBuffered(media).length) {
          this.nudgeRetry = 0;
          return;
        }
        var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
        var nextStart = bufferInfo.nextStart || 0;
        if (seeking) {
          var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;
          var noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);
          if (hasEnoughBuffer || noBufferGap) {
            return;
          }
          this.moved = false;
        }
        if (!this.moved && this.stalled !== null) {
          var _level$details;
          var isBuffered = bufferInfo.len > 0;
          if (!isBuffered && !nextStart) {
            return;
          }
          var startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;
          var level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;
          var isLive = level == null ? void 0 : (_level$details = level.details) == null ? void 0 : _level$details.live;
          var maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;
          var partialOrGap = this.fragmentTracker.getPartialFragment(currentTime);
          if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {
            if (!media.paused) {
              this._trySkipBufferHole(partialOrGap);
            }
            return;
          }
        }
        var tnow = self.performance.now();
        if (stalled === null) {
          this.stalled = tnow;
          return;
        }
        var stalledDuration = tnow - stalled;
        if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {
          this._reportStall(bufferInfo);
          if (!this.media) {
            return;
          }
        }
        var bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);
        this._tryFixBufferStall(bufferedWithHoles, stalledDuration);
      };
      _proto._tryFixBufferStall = function _tryFixBufferStall(bufferInfo, stalledDurationMs) {
        var config = this.config, fragmentTracker = this.fragmentTracker, media = this.media;
        if (media === null) {
          return;
        }
        var currentTime = media.currentTime;
        var partial = fragmentTracker.getPartialFragment(currentTime);
        if (partial) {
          var targetTime = this._trySkipBufferHole(partial);
          if (targetTime || !this.media) {
            return;
          }
        }
        if ((bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && stalledDurationMs > config.highBufferWatchdogPeriod * 1e3) {
          logger.warn("Trying to nudge playhead over buffer-hole");
          this.stalled = null;
          this._tryNudgeBuffer();
        }
      };
      _proto._reportStall = function _reportStall(bufferInfo) {
        var hls = this.hls, media = this.media, stallReported = this.stallReported;
        if (!stallReported && media) {
          this.stallReported = true;
          var error = new Error("Playback stalling at @" + media.currentTime + " due to low buffer (" + JSON.stringify(bufferInfo) + ")");
          logger.warn(error.message);
          hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.BUFFER_STALLED_ERROR,
            fatal: false,
            error,
            buffer: bufferInfo.len
          });
        }
      };
      _proto._trySkipBufferHole = function _trySkipBufferHole(partial) {
        var config = this.config, hls = this.hls, media = this.media;
        if (media === null) {
          return 0;
        }
        var currentTime = media.currentTime;
        var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
        var startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;
        if (startTime) {
          var bufferStarved = bufferInfo.len <= config.maxBufferHole;
          var waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;
          var gapLength = startTime - currentTime;
          if (gapLength > 0 && (bufferStarved || waiting)) {
            if (gapLength > config.maxBufferHole) {
              var fragmentTracker = this.fragmentTracker;
              var startGap = false;
              if (currentTime === 0) {
                var startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);
                if (startFrag && startTime < startFrag.end) {
                  startGap = true;
                }
              }
              if (!startGap) {
                var startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);
                if (startProvisioned) {
                  var moreToLoad = false;
                  var pos = startProvisioned.end;
                  while (pos < startTime) {
                    var provisioned = fragmentTracker.getPartialFragment(pos);
                    if (provisioned) {
                      pos += provisioned.duration;
                    } else {
                      moreToLoad = true;
                      break;
                    }
                  }
                  if (moreToLoad) {
                    return 0;
                  }
                }
              }
            }
            var targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);
            logger.warn("skipping hole, adjusting currentTime from " + currentTime + " to " + targetTime);
            this.moved = true;
            this.stalled = null;
            media.currentTime = targetTime;
            if (partial && !partial.gap) {
              var error = new Error("fragment loaded with buffer holes, seeking from " + currentTime + " to " + targetTime);
              hls.trigger(Events.ERROR, {
                type: ErrorTypes.MEDIA_ERROR,
                details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,
                fatal: false,
                error,
                reason: error.message,
                frag: partial
              });
            }
            return targetTime;
          }
        }
        return 0;
      };
      _proto._tryNudgeBuffer = function _tryNudgeBuffer() {
        var config = this.config, hls = this.hls, media = this.media, nudgeRetry = this.nudgeRetry;
        if (media === null) {
          return;
        }
        var currentTime = media.currentTime;
        this.nudgeRetry++;
        if (nudgeRetry < config.nudgeMaxRetry) {
          var targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;
          var error = new Error("Nudging 'currentTime' from " + currentTime + " to " + targetTime);
          logger.warn(error.message);
          media.currentTime = targetTime;
          hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.BUFFER_NUDGE_ON_STALL,
            error,
            fatal: false
          });
        } else {
          var _error = new Error("Playhead still not moving while enough data buffered @" + currentTime + " after " + config.nudgeMaxRetry + " nudges");
          logger.error(_error.message);
          hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.BUFFER_STALLED_ERROR,
            error: _error,
            fatal: true
          });
        }
      };
      return GapController2;
    }();
    var TICK_INTERVAL = 100;
    var StreamController = /* @__PURE__ */ function(_BaseStreamController) {
      _inheritsLoose(StreamController2, _BaseStreamController);
      function StreamController2(hls, fragmentTracker, keyLoader) {
        var _this;
        _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, "[stream-controller]", PlaylistLevelType.MAIN) || this;
        _this.audioCodecSwap = false;
        _this.gapController = null;
        _this.level = -1;
        _this._forceStartLoad = false;
        _this.altAudio = false;
        _this.audioOnly = false;
        _this.fragPlaying = null;
        _this.onvplaying = null;
        _this.onvseeked = null;
        _this.fragLastKbps = 0;
        _this.couldBacktrack = false;
        _this.backtrackFragment = null;
        _this.audioCodecSwitch = false;
        _this.videoBuffer = null;
        _this._registerListeners();
        return _this;
      }
      var _proto = StreamController2.prototype;
      _proto._registerListeners = function _registerListeners() {
        var hls = this.hls;
        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
        hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
        hls.on(Events.ERROR, this.onError, this);
        hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
        hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
        hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
        hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      };
      _proto._unregisterListeners = function _unregisterListeners() {
        var hls = this.hls;
        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
        hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
        hls.off(Events.ERROR, this.onError, this);
        hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
        hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
        hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
        hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      };
      _proto.onHandlerDestroying = function onHandlerDestroying() {
        this._unregisterListeners();
        _BaseStreamController.prototype.onHandlerDestroying.call(this);
      };
      _proto.startLoad = function startLoad(startPosition) {
        if (this.levels) {
          var lastCurrentTime = this.lastCurrentTime, hls = this.hls;
          this.stopLoad();
          this.setInterval(TICK_INTERVAL);
          this.level = -1;
          if (!this.startFragRequested) {
            var startLevel = hls.startLevel;
            if (startLevel === -1) {
              if (hls.config.testBandwidth && this.levels.length > 1) {
                startLevel = 0;
                this.bitrateTest = true;
              } else {
                startLevel = hls.firstAutoLevel;
              }
            }
            this.level = hls.nextLoadLevel = startLevel;
            this.loadedmetadata = false;
          }
          if (lastCurrentTime > 0 && startPosition === -1) {
            this.log("Override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
            startPosition = lastCurrentTime;
          }
          this.state = State.IDLE;
          this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
          this.tick();
        } else {
          this._forceStartLoad = true;
          this.state = State.STOPPED;
        }
      };
      _proto.stopLoad = function stopLoad() {
        this._forceStartLoad = false;
        _BaseStreamController.prototype.stopLoad.call(this);
      };
      _proto.doTick = function doTick() {
        switch (this.state) {
          case State.WAITING_LEVEL: {
            var levels = this.levels, level = this.level;
            var currentLevel = levels == null ? void 0 : levels[level];
            var details = currentLevel == null ? void 0 : currentLevel.details;
            if (details && (!details.live || this.levelLastLoaded === currentLevel)) {
              if (this.waitForCdnTuneIn(details)) {
                break;
              }
              this.state = State.IDLE;
              break;
            } else if (this.hls.nextLoadLevel !== this.level) {
              this.state = State.IDLE;
              break;
            }
            break;
          }
          case State.FRAG_LOADING_WAITING_RETRY:
            {
              var _this$media;
              var now2 = self.performance.now();
              var retryDate = this.retryDate;
              if (!retryDate || now2 >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {
                var _levels = this.levels, _level = this.level;
                var _currentLevel = _levels == null ? void 0 : _levels[_level];
                this.resetStartWhenNotLoaded(_currentLevel || null);
                this.state = State.IDLE;
              }
            }
            break;
        }
        if (this.state === State.IDLE) {
          this.doTickIdle();
        }
        this.onTickEnd();
      };
      _proto.onTickEnd = function onTickEnd() {
        _BaseStreamController.prototype.onTickEnd.call(this);
        this.checkBuffer();
        this.checkFragmentChanged();
      };
      _proto.doTickIdle = function doTickIdle() {
        var hls = this.hls, levelLastLoaded = this.levelLastLoaded, levels = this.levels, media = this.media;
        var config = hls.config, level = hls.nextLoadLevel;
        if (levelLastLoaded === null || !media && (this.startFragRequested || !config.startFragPrefetch)) {
          return;
        }
        if (this.altAudio && this.audioOnly) {
          return;
        }
        if (!(levels != null && levels[level])) {
          return;
        }
        var levelInfo = levels[level];
        var bufferInfo = this.getMainFwdBufferInfo();
        if (bufferInfo === null) {
          return;
        }
        var lastDetails = this.getLevelDetails();
        if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {
          var data = {};
          if (this.altAudio) {
            data.type = "video";
          }
          this.hls.trigger(Events.BUFFER_EOS, data);
          this.state = State.ENDED;
          return;
        }
        if (hls.loadLevel !== level && hls.manualLevel === -1) {
          this.log("Adapting to level " + level + " from level " + this.level);
        }
        this.level = hls.nextLoadLevel = level;
        var levelDetails = levelInfo.details;
        if (!levelDetails || this.state === State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== levelInfo) {
          this.level = level;
          this.state = State.WAITING_LEVEL;
          return;
        }
        var bufferLen = bufferInfo.len;
        var maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);
        if (bufferLen >= maxBufLen) {
          return;
        }
        if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {
          this.backtrackFragment = null;
        }
        var targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;
        var frag = this.getNextFragment(targetBufferTime, levelDetails);
        if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== "initSegment" && this.fragmentTracker.getState(frag) !== FragmentState.OK) {
          var _this$backtrackFragme;
          var backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;
          var fragIdx = backtrackSn - levelDetails.startSN;
          var backtrackFrag = levelDetails.fragments[fragIdx - 1];
          if (backtrackFrag && frag.cc === backtrackFrag.cc) {
            frag = backtrackFrag;
            this.fragmentTracker.removeFragment(backtrackFrag);
          }
        } else if (this.backtrackFragment && bufferInfo.len) {
          this.backtrackFragment = null;
        }
        if (frag && this.isLoopLoading(frag, targetBufferTime)) {
          var gapStart = frag.gap;
          if (!gapStart) {
            var type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;
            var mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
            if (mediaBuffer) {
              this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);
            }
          }
          frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);
        }
        if (!frag) {
          return;
        }
        if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {
          frag = frag.initSegment;
        }
        this.loadFragment(frag, levelInfo, targetBufferTime);
      };
      _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {
        var fragState = this.fragmentTracker.getState(frag);
        this.fragCurrent = frag;
        if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
          if (frag.sn === "initSegment") {
            this._loadInitSegment(frag, level);
          } else if (this.bitrateTest) {
            this.log("Fragment " + frag.sn + " of level " + frag.level + " is being downloaded to test bitrate and will not be buffered");
            this._loadBitrateTestFrag(frag, level);
          } else {
            this.startFragRequested = true;
            _BaseStreamController.prototype.loadFragment.call(this, frag, level, targetBufferTime);
          }
        } else {
          this.clearTrackerIfNeeded(frag);
        }
      };
      _proto.getBufferedFrag = function getBufferedFrag(position) {
        return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);
      };
      _proto.followingBufferedFrag = function followingBufferedFrag(frag) {
        if (frag) {
          return this.getBufferedFrag(frag.end + 0.5);
        }
        return null;
      };
      _proto.immediateLevelSwitch = function immediateLevelSwitch() {
        this.abortCurrentFrag();
        this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
      };
      _proto.nextLevelSwitch = function nextLevelSwitch() {
        var levels = this.levels, media = this.media;
        if (media != null && media.readyState) {
          var fetchdelay;
          var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);
          if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {
            this.flushMainBuffer(0, fragPlayingCurrent.start - 1);
          }
          var levelDetails = this.getLevelDetails();
          if (levelDetails != null && levelDetails.live) {
            var bufferInfo = this.getMainFwdBufferInfo();
            if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {
              return;
            }
          }
          if (!media.paused && levels) {
            var nextLevelId = this.hls.nextLoadLevel;
            var nextLevel = levels[nextLevelId];
            var fragLastKbps = this.fragLastKbps;
            if (fragLastKbps && this.fragCurrent) {
              fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1e3 * fragLastKbps) + 1;
            } else {
              fetchdelay = 0;
            }
          } else {
            fetchdelay = 0;
          }
          var bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
          if (bufferedFrag) {
            var nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);
            if (nextBufferedFrag) {
              this.abortCurrentFrag();
              var maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;
              var fragDuration = nextBufferedFrag.duration;
              var startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * (this.couldBacktrack ? 0.5 : 0.125)), fragDuration * (this.couldBacktrack ? 0.75 : 0.25)));
              this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);
            }
          }
        }
      };
      _proto.abortCurrentFrag = function abortCurrentFrag() {
        var fragCurrent = this.fragCurrent;
        this.fragCurrent = null;
        this.backtrackFragment = null;
        if (fragCurrent) {
          fragCurrent.abortRequests();
          this.fragmentTracker.removeFragment(fragCurrent);
        }
        switch (this.state) {
          case State.KEY_LOADING:
          case State.FRAG_LOADING:
          case State.FRAG_LOADING_WAITING_RETRY:
          case State.PARSING:
          case State.PARSED:
            this.state = State.IDLE;
            break;
        }
        this.nextLoadPosition = this.getLoadPosition();
      };
      _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset) {
        _BaseStreamController.prototype.flushMainBuffer.call(this, startOffset, endOffset, this.altAudio ? "video" : null);
      };
      _proto.onMediaAttached = function onMediaAttached(event, data) {
        _BaseStreamController.prototype.onMediaAttached.call(this, event, data);
        var media = data.media;
        this.onvplaying = this.onMediaPlaying.bind(this);
        this.onvseeked = this.onMediaSeeked.bind(this);
        media.addEventListener("playing", this.onvplaying);
        media.addEventListener("seeked", this.onvseeked);
        this.gapController = new GapController(this.config, media, this.fragmentTracker, this.hls);
      };
      _proto.onMediaDetaching = function onMediaDetaching() {
        var media = this.media;
        if (media && this.onvplaying && this.onvseeked) {
          media.removeEventListener("playing", this.onvplaying);
          media.removeEventListener("seeked", this.onvseeked);
          this.onvplaying = this.onvseeked = null;
          this.videoBuffer = null;
        }
        this.fragPlaying = null;
        if (this.gapController) {
          this.gapController.destroy();
          this.gapController = null;
        }
        _BaseStreamController.prototype.onMediaDetaching.call(this);
      };
      _proto.onMediaPlaying = function onMediaPlaying() {
        this.tick();
      };
      _proto.onMediaSeeked = function onMediaSeeked() {
        var media = this.media;
        var currentTime = media ? media.currentTime : null;
        if (isFiniteNumber(currentTime)) {
          this.log("Media seeked to " + currentTime.toFixed(3));
        }
        var bufferInfo = this.getMainFwdBufferInfo();
        if (bufferInfo === null || bufferInfo.len === 0) {
          this.warn('Main forward buffer length on "seeked" event ' + (bufferInfo ? bufferInfo.len : "empty") + ")");
          return;
        }
        this.tick();
      };
      _proto.onManifestLoading = function onManifestLoading() {
        this.log("Trigger BUFFER_RESET");
        this.hls.trigger(Events.BUFFER_RESET, void 0);
        this.fragmentTracker.removeAllFragments();
        this.couldBacktrack = false;
        this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0;
        this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null;
        this.altAudio = this.audioOnly = this.startFragRequested = false;
      };
      _proto.onManifestParsed = function onManifestParsed(event, data) {
        var aac = false;
        var heaac = false;
        data.levels.forEach(function(level) {
          var codec = level.audioCodec;
          if (codec) {
            aac = aac || codec.indexOf("mp4a.40.2") !== -1;
            heaac = heaac || codec.indexOf("mp4a.40.5") !== -1;
          }
        });
        this.audioCodecSwitch = aac && heaac && !changeTypeSupported();
        if (this.audioCodecSwitch) {
          this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC");
        }
        this.levels = data.levels;
        this.startFragRequested = false;
      };
      _proto.onLevelLoading = function onLevelLoading(event, data) {
        var levels = this.levels;
        if (!levels || this.state !== State.IDLE) {
          return;
        }
        var level = levels[data.level];
        if (!level.details || level.details.live && this.levelLastLoaded !== level || this.waitForCdnTuneIn(level.details)) {
          this.state = State.WAITING_LEVEL;
        }
      };
      _proto.onLevelLoaded = function onLevelLoaded(event, data) {
        var _curLevel$details;
        var levels = this.levels;
        var newLevelId = data.level;
        var newDetails = data.details;
        var duration = newDetails.totalduration;
        if (!levels) {
          this.warn("Levels were reset while loading level " + newLevelId);
          return;
        }
        this.log("Level " + newLevelId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "]" + (newDetails.lastPartSn ? "[part-" + newDetails.lastPartSn + "-" + newDetails.lastPartIndex + "]" : "") + ", cc [" + newDetails.startCC + ", " + newDetails.endCC + "] duration:" + duration);
        var curLevel = levels[newLevelId];
        var fragCurrent = this.fragCurrent;
        if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {
          if (fragCurrent.level !== data.level && fragCurrent.loader) {
            this.abortCurrentFrag();
          }
        }
        var sliding = 0;
        if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {
          var _this$levelLastLoaded;
          this.checkLiveUpdate(newDetails);
          if (newDetails.deltaUpdateFailed) {
            return;
          }
          sliding = this.alignPlaylists(newDetails, curLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);
        }
        curLevel.details = newDetails;
        this.levelLastLoaded = curLevel;
        this.hls.trigger(Events.LEVEL_UPDATED, {
          details: newDetails,
          level: newLevelId
        });
        if (this.state === State.WAITING_LEVEL) {
          if (this.waitForCdnTuneIn(newDetails)) {
            return;
          }
          this.state = State.IDLE;
        }
        if (!this.startFragRequested) {
          this.setStartPosition(newDetails, sliding);
        } else if (newDetails.live) {
          this.synchronizeToLiveEdge(newDetails);
        }
        this.tick();
      };
      _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {
        var _frag$initSegment;
        var frag = data.frag, part = data.part, payload = data.payload;
        var levels = this.levels;
        if (!levels) {
          this.warn("Levels were reset while fragment load was in progress. Fragment " + frag.sn + " of level " + frag.level + " will not be buffered");
          return;
        }
        var currentLevel = levels[frag.level];
        var details = currentLevel.details;
        if (!details) {
          this.warn("Dropping fragment " + frag.sn + " of level " + frag.level + " after level details were reset");
          this.fragmentTracker.removeFragment(frag);
          return;
        }
        var videoCodec = currentLevel.videoCodec;
        var accurateTimeOffset = details.PTSKnown || !details.live;
        var initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;
        var audioCodec = this._getAudioCodec(currentLevel);
        var transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
        var partIndex = part ? part.index : -1;
        var partial = partIndex !== -1;
        var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
        var initPTS = this.initPTS[frag.cc];
        transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
      };
      _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {
        var fromAltAudio = this.altAudio;
        var altAudio = !!data.url;
        if (!altAudio) {
          if (this.mediaBuffer !== this.media) {
            this.log("Switching on main audio, use media.buffered to schedule main fragment loading");
            this.mediaBuffer = this.media;
            var fragCurrent = this.fragCurrent;
            if (fragCurrent) {
              this.log("Switching to main audio track, cancel main fragment load");
              fragCurrent.abortRequests();
              this.fragmentTracker.removeFragment(fragCurrent);
            }
            this.resetTransmuxer();
            this.resetLoadingState();
          } else if (this.audioOnly) {
            this.resetTransmuxer();
          }
          var hls = this.hls;
          if (fromAltAudio) {
            hls.trigger(Events.BUFFER_FLUSHING, {
              startOffset: 0,
              endOffset: Number.POSITIVE_INFINITY,
              type: null
            });
            this.fragmentTracker.removeAllFragments();
          }
          hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);
        }
      };
      _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {
        var trackId = data.id;
        var altAudio = !!this.hls.audioTracks[trackId].url;
        if (altAudio) {
          var videoBuffer = this.videoBuffer;
          if (videoBuffer && this.mediaBuffer !== videoBuffer) {
            this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading");
            this.mediaBuffer = videoBuffer;
          }
        }
        this.altAudio = altAudio;
        this.tick();
      };
      _proto.onBufferCreated = function onBufferCreated(event, data) {
        var tracks = data.tracks;
        var mediaTrack;
        var name;
        var alternate = false;
        for (var type in tracks) {
          var track = tracks[type];
          if (track.id === "main") {
            name = type;
            mediaTrack = track;
            if (type === "video") {
              var videoTrack = tracks[type];
              if (videoTrack) {
                this.videoBuffer = videoTrack.buffer;
              }
            }
          } else {
            alternate = true;
          }
        }
        if (alternate && mediaTrack) {
          this.log("Alternate track found, use " + name + ".buffered to schedule main fragment loading");
          this.mediaBuffer = mediaTrack.buffer;
        } else {
          this.mediaBuffer = this.media;
        }
      };
      _proto.onFragBuffered = function onFragBuffered(event, data) {
        var frag = data.frag, part = data.part;
        if (frag && frag.type !== PlaylistLevelType.MAIN) {
          return;
        }
        if (this.fragContextChanged(frag)) {
          this.warn("Fragment " + frag.sn + (part ? " p: " + part.index : "") + " of level " + frag.level + " finished buffering, but was aborted. state: " + this.state);
          if (this.state === State.PARSED) {
            this.state = State.IDLE;
          }
          return;
        }
        var stats = part ? part.stats : frag.stats;
        this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));
        if (frag.sn !== "initSegment") {
          this.fragPrevious = frag;
        }
        this.fragBufferedComplete(frag, part);
      };
      _proto.onError = function onError(event, data) {
        var _data$context;
        if (data.fatal) {
          this.state = State.ERROR;
          return;
        }
        switch (data.details) {
          case ErrorDetails.FRAG_GAP:
          case ErrorDetails.FRAG_PARSING_ERROR:
          case ErrorDetails.FRAG_DECRYPT_ERROR:
          case ErrorDetails.FRAG_LOAD_ERROR:
          case ErrorDetails.FRAG_LOAD_TIMEOUT:
          case ErrorDetails.KEY_LOAD_ERROR:
          case ErrorDetails.KEY_LOAD_TIMEOUT:
            this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);
            break;
          case ErrorDetails.LEVEL_LOAD_ERROR:
          case ErrorDetails.LEVEL_LOAD_TIMEOUT:
          case ErrorDetails.LEVEL_PARSING_ERROR:
            if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {
              this.state = State.IDLE;
            }
            break;
          case ErrorDetails.BUFFER_APPEND_ERROR:
          case ErrorDetails.BUFFER_FULL_ERROR:
            if (!data.parent || data.parent !== "main") {
              return;
            }
            if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {
              this.resetLoadingState();
              return;
            }
            if (this.reduceLengthAndFlushBuffer(data)) {
              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            }
            break;
          case ErrorDetails.INTERNAL_EXCEPTION:
            this.recoverWorkerError(data);
            break;
        }
      };
      _proto.checkBuffer = function checkBuffer() {
        var media = this.media, gapController = this.gapController;
        if (!media || !gapController || !media.readyState) {
          return;
        }
        if (this.loadedmetadata || !BufferHelper.getBuffered(media).length) {
          var activeFrag = this.state !== State.IDLE ? this.fragCurrent : null;
          gapController.poll(this.lastCurrentTime, activeFrag);
        }
        this.lastCurrentTime = media.currentTime;
      };
      _proto.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {
        this.state = State.IDLE;
        if (!this.loadedmetadata) {
          this.startFragRequested = false;
          this.nextLoadPosition = this.startPosition;
        }
        this.tickImmediate();
      };
      _proto.onBufferFlushed = function onBufferFlushed(event, _ref) {
        var type = _ref.type;
        if (type !== ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {
          var mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);
          this.tick();
        }
      };
      _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {
        if (this.level > -1 && this.fragCurrent) {
          this.level = this.fragCurrent.level;
        }
        this.levels = data.levels;
      };
      _proto.swapAudioCodec = function swapAudioCodec() {
        this.audioCodecSwap = !this.audioCodecSwap;
      };
      _proto.seekToStartPos = function seekToStartPos() {
        var media = this.media;
        if (!media) {
          return;
        }
        var currentTime = media.currentTime;
        var startPosition = this.startPosition;
        if (startPosition >= 0 && currentTime < startPosition) {
          if (media.seeking) {
            this.log("could not seek to " + startPosition + ", already seeking at " + currentTime);
            return;
          }
          var buffered = BufferHelper.getBuffered(media);
          var bufferStart = buffered.length ? buffered.start(0) : 0;
          var delta = bufferStart - startPosition;
          if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {
            this.log("adjusting start position by " + delta + " to match buffer start");
            startPosition += delta;
            this.startPosition = startPosition;
          }
          this.log("seek to target start position " + startPosition + " from current time " + currentTime);
          media.currentTime = startPosition;
        }
      };
      _proto._getAudioCodec = function _getAudioCodec(currentLevel) {
        var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
        if (this.audioCodecSwap && audioCodec) {
          this.log("Swapping audio codec");
          if (audioCodec.indexOf("mp4a.40.5") !== -1) {
            audioCodec = "mp4a.40.2";
          } else {
            audioCodec = "mp4a.40.5";
          }
        }
        return audioCodec;
      };
      _proto._loadBitrateTestFrag = function _loadBitrateTestFrag(frag, level) {
        var _this2 = this;
        frag.bitrateTest = true;
        this._doFragLoad(frag, level).then(function(data) {
          var hls = _this2.hls;
          if (!data || _this2.fragContextChanged(frag)) {
            return;
          }
          level.fragmentError = 0;
          _this2.state = State.IDLE;
          _this2.startFragRequested = false;
          _this2.bitrateTest = false;
          var stats = frag.stats;
          stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();
          hls.trigger(Events.FRAG_LOADED, data);
          frag.bitrateTest = false;
        });
      };
      _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {
        var _id3$samples;
        var id = "main";
        var hls = this.hls;
        var remuxResult = transmuxResult.remuxResult, chunkMeta = transmuxResult.chunkMeta;
        var context = this.getCurrentContext(chunkMeta);
        if (!context) {
          this.resetWhenMissingContext(chunkMeta);
          return;
        }
        var frag = context.frag, part = context.part, level = context.level;
        var video = remuxResult.video, text = remuxResult.text, id3 = remuxResult.id3, initSegment = remuxResult.initSegment;
        var details = level.details;
        var audio = this.altAudio ? void 0 : remuxResult.audio;
        if (this.fragContextChanged(frag)) {
          this.fragmentTracker.removeFragment(frag);
          return;
        }
        this.state = State.PARSING;
        if (initSegment) {
          if (initSegment != null && initSegment.tracks) {
            var mapFragment = frag.initSegment || frag;
            this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);
            hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {
              frag: mapFragment,
              id,
              tracks: initSegment.tracks
            });
          }
          var initPTS = initSegment.initPTS;
          var timescale = initSegment.timescale;
          if (isFiniteNumber(initPTS)) {
            this.initPTS[frag.cc] = {
              baseTime: initPTS,
              timescale
            };
            hls.trigger(Events.INIT_PTS_FOUND, {
              frag,
              id,
              initPTS,
              timescale
            });
          }
        }
        if (video && details && frag.sn !== "initSegment") {
          var prevFrag = details.fragments[frag.sn - 1 - details.startSN];
          var isFirstFragment = frag.sn === details.startSN;
          var isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;
          if (remuxResult.independent !== false) {
            var startPTS = video.startPTS, endPTS = video.endPTS, startDTS = video.startDTS, endDTS = video.endDTS;
            if (part) {
              part.elementaryStreams[video.type] = {
                startPTS,
                endPTS,
                startDTS,
                endDTS
              };
            } else {
              if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {
                this.couldBacktrack = true;
              }
              if (video.dropped && video.independent) {
                var bufferInfo = this.getMainFwdBufferInfo();
                var targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;
                var startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;
                if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {
                  this.backtrack(frag);
                  return;
                } else if (isFirstInDiscontinuity) {
                  frag.gap = true;
                }
                frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);
              } else if (isFirstFragment && startPTS > MAX_START_GAP_JUMP) {
                frag.gap = true;
              }
            }
            frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);
            if (this.backtrackFragment) {
              this.backtrackFragment = frag;
            }
            this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);
          } else if (isFirstFragment || isFirstInDiscontinuity) {
            frag.gap = true;
          } else {
            this.backtrack(frag);
            return;
          }
        }
        if (audio) {
          var _startPTS = audio.startPTS, _endPTS = audio.endPTS, _startDTS = audio.startDTS, _endDTS = audio.endDTS;
          if (part) {
            part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {
              startPTS: _startPTS,
              endPTS: _endPTS,
              startDTS: _startDTS,
              endDTS: _endDTS
            };
          }
          frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, _startPTS, _endPTS, _startDTS, _endDTS);
          this.bufferFragmentData(audio, frag, part, chunkMeta);
        }
        if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {
          var emittedID3 = {
            id,
            frag,
            details,
            samples: id3.samples
          };
          hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);
        }
        if (details && text) {
          var emittedText = {
            id,
            frag,
            details,
            samples: text.samples
          };
          hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);
        }
      };
      _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
        var _this3 = this;
        if (this.state !== State.PARSING) {
          return;
        }
        this.audioOnly = !!tracks.audio && !tracks.video;
        if (this.altAudio && !this.audioOnly) {
          delete tracks.audio;
        }
        var audio = tracks.audio, video = tracks.video, audiovideo = tracks.audiovideo;
        if (audio) {
          var audioCodec = currentLevel.audioCodec;
          var ua = navigator.userAgent.toLowerCase();
          if (this.audioCodecSwitch) {
            if (audioCodec) {
              if (audioCodec.indexOf("mp4a.40.5") !== -1) {
                audioCodec = "mp4a.40.2";
              } else {
                audioCodec = "mp4a.40.5";
              }
            }
            if (audio.metadata.channelCount !== 1 && ua.indexOf("firefox") === -1) {
              audioCodec = "mp4a.40.5";
            }
          }
          if (audioCodec && audioCodec.indexOf("mp4a.40.5") !== -1 && ua.indexOf("android") !== -1 && audio.container !== "audio/mpeg") {
            audioCodec = "mp4a.40.2";
            this.log("Android: force audio codec to " + audioCodec);
          }
          if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {
            this.log('Swapping manifest audio codec "' + currentLevel.audioCodec + '" for "' + audioCodec + '"');
          }
          audio.levelCodec = audioCodec;
          audio.id = "main";
          this.log("Init audio buffer, container:" + audio.container + ", codecs[selected/level/parsed]=[" + (audioCodec || "") + "/" + (currentLevel.audioCodec || "") + "/" + audio.codec + "]");
        }
        if (video) {
          video.levelCodec = currentLevel.videoCodec;
          video.id = "main";
          this.log("Init video buffer, container:" + video.container + ", codecs[level/parsed]=[" + (currentLevel.videoCodec || "") + "/" + video.codec + "]");
        }
        if (audiovideo) {
          this.log("Init audiovideo buffer, container:" + audiovideo.container + ", codecs[level/parsed]=[" + currentLevel.codecs + "/" + audiovideo.codec + "]");
        }
        this.hls.trigger(Events.BUFFER_CODECS, tracks);
        Object.keys(tracks).forEach(function(trackName) {
          var track = tracks[trackName];
          var initSegment = track.initSegment;
          if (initSegment != null && initSegment.byteLength) {
            _this3.hls.trigger(Events.BUFFER_APPENDING, {
              type: trackName,
              data: initSegment,
              frag,
              part: null,
              chunkMeta,
              parent: frag.type
            });
          }
        });
        this.tickImmediate();
      };
      _proto.getMainFwdBufferInfo = function getMainFwdBufferInfo() {
        return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, PlaylistLevelType.MAIN);
      };
      _proto.backtrack = function backtrack(frag) {
        this.couldBacktrack = true;
        this.backtrackFragment = frag;
        this.resetTransmuxer();
        this.flushBufferGap(frag);
        this.fragmentTracker.removeFragment(frag);
        this.fragPrevious = null;
        this.nextLoadPosition = frag.start;
        this.state = State.IDLE;
      };
      _proto.checkFragmentChanged = function checkFragmentChanged() {
        var video = this.media;
        var fragPlayingCurrent = null;
        if (video && video.readyState > 1 && video.seeking === false) {
          var currentTime = video.currentTime;
          if (BufferHelper.isBuffered(video, currentTime)) {
            fragPlayingCurrent = this.getAppendedFrag(currentTime);
          } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {
            fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);
          }
          if (fragPlayingCurrent) {
            this.backtrackFragment = null;
            var fragPlaying = this.fragPlaying;
            var fragCurrentLevel = fragPlayingCurrent.level;
            if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel) {
              this.fragPlaying = fragPlayingCurrent;
              this.hls.trigger(Events.FRAG_CHANGED, {
                frag: fragPlayingCurrent
              });
              if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {
                this.hls.trigger(Events.LEVEL_SWITCHED, {
                  level: fragCurrentLevel
                });
              }
            }
          }
        }
      };
      _createClass(StreamController2, [{
        key: "nextLevel",
        get: function get() {
          var frag = this.nextBufferedFrag;
          if (frag) {
            return frag.level;
          }
          return -1;
        }
      }, {
        key: "currentFrag",
        get: function get() {
          var media = this.media;
          if (media) {
            return this.fragPlaying || this.getAppendedFrag(media.currentTime);
          }
          return null;
        }
      }, {
        key: "currentProgramDateTime",
        get: function get() {
          var media = this.media;
          if (media) {
            var currentTime = media.currentTime;
            var frag = this.currentFrag;
            if (frag && isFiniteNumber(currentTime) && isFiniteNumber(frag.programDateTime)) {
              var epocMs = frag.programDateTime + (currentTime - frag.start) * 1e3;
              return new Date(epocMs);
            }
          }
          return null;
        }
      }, {
        key: "currentLevel",
        get: function get() {
          var frag = this.currentFrag;
          if (frag) {
            return frag.level;
          }
          return -1;
        }
      }, {
        key: "nextBufferedFrag",
        get: function get() {
          var frag = this.currentFrag;
          if (frag) {
            return this.followingBufferedFrag(frag);
          }
          return null;
        }
      }, {
        key: "forceStartLoad",
        get: function get() {
          return this._forceStartLoad;
        }
      }]);
      return StreamController2;
    }(BaseStreamController);
    var Hls = /* @__PURE__ */ function() {
      Hls2.isMSESupported = function isMSESupported$1() {
        return isMSESupported();
      };
      Hls2.isSupported = function isSupported$1() {
        return isSupported();
      };
      Hls2.getMediaSource = function getMediaSource$1() {
        return getMediaSource();
      };
      function Hls2(userConfig) {
        if (userConfig === void 0) {
          userConfig = {};
        }
        this.config = void 0;
        this.userConfig = void 0;
        this.coreComponents = void 0;
        this.networkControllers = void 0;
        this.started = false;
        this._emitter = new EventEmitter();
        this._autoLevelCapping = -1;
        this._maxHdcpLevel = null;
        this.abrController = void 0;
        this.bufferController = void 0;
        this.capLevelController = void 0;
        this.latencyController = void 0;
        this.levelController = void 0;
        this.streamController = void 0;
        this.audioTrackController = void 0;
        this.subtitleTrackController = void 0;
        this.emeController = void 0;
        this.cmcdController = void 0;
        this._media = null;
        this.url = null;
        this.triggeringException = void 0;
        enableLogs(userConfig.debug || false, "Hls instance");
        var config = this.config = mergeConfig(Hls2.DefaultConfig, userConfig);
        this.userConfig = userConfig;
        if (config.progressive) {
          enableStreamingMode(config);
        }
        var ConfigAbrController = config.abrController, ConfigBufferController = config.bufferController, ConfigCapLevelController = config.capLevelController, ConfigErrorController = config.errorController, ConfigFpsController = config.fpsController;
        var errorController = new ConfigErrorController(this);
        var abrController = this.abrController = new ConfigAbrController(this);
        var bufferController = this.bufferController = new ConfigBufferController(this);
        var capLevelController = this.capLevelController = new ConfigCapLevelController(this);
        var fpsController = new ConfigFpsController(this);
        var playListLoader = new PlaylistLoader(this);
        var id3TrackController = new ID3TrackController(this);
        var ConfigContentSteeringController = config.contentSteeringController;
        var contentSteering = ConfigContentSteeringController ? new ConfigContentSteeringController(this) : null;
        var levelController = this.levelController = new LevelController(this, contentSteering);
        var fragmentTracker = new FragmentTracker(this);
        var keyLoader = new KeyLoader(this.config);
        var streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);
        capLevelController.setStreamController(streamController);
        fpsController.setStreamController(streamController);
        var networkControllers = [playListLoader, levelController, streamController];
        if (contentSteering) {
          networkControllers.splice(1, 0, contentSteering);
        }
        this.networkControllers = networkControllers;
        var coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];
        this.audioTrackController = this.createController(config.audioTrackController, networkControllers);
        var AudioStreamControllerClass = config.audioStreamController;
        if (AudioStreamControllerClass) {
          networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));
        }
        this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);
        var SubtitleStreamControllerClass = config.subtitleStreamController;
        if (SubtitleStreamControllerClass) {
          networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));
        }
        this.createController(config.timelineController, coreComponents);
        keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);
        this.cmcdController = this.createController(config.cmcdController, coreComponents);
        this.latencyController = this.createController(LatencyController, coreComponents);
        this.coreComponents = coreComponents;
        networkControllers.push(errorController);
        var onErrorOut = errorController.onErrorOut;
        if (typeof onErrorOut === "function") {
          this.on(Events.ERROR, onErrorOut, errorController);
        }
      }
      var _proto = Hls2.prototype;
      _proto.createController = function createController(ControllerClass, components) {
        if (ControllerClass) {
          var controllerInstance = new ControllerClass(this);
          if (components) {
            components.push(controllerInstance);
          }
          return controllerInstance;
        }
        return null;
      };
      _proto.on = function on(event, listener, context) {
        if (context === void 0) {
          context = this;
        }
        this._emitter.on(event, listener, context);
      };
      _proto.once = function once(event, listener, context) {
        if (context === void 0) {
          context = this;
        }
        this._emitter.once(event, listener, context);
      };
      _proto.removeAllListeners = function removeAllListeners(event) {
        this._emitter.removeAllListeners(event);
      };
      _proto.off = function off(event, listener, context, once) {
        if (context === void 0) {
          context = this;
        }
        this._emitter.off(event, listener, context, once);
      };
      _proto.listeners = function listeners(event) {
        return this._emitter.listeners(event);
      };
      _proto.emit = function emit(event, name, eventObject) {
        return this._emitter.emit(event, name, eventObject);
      };
      _proto.trigger = function trigger(event, eventObject) {
        if (this.config.debug) {
          return this.emit(event, event, eventObject);
        } else {
          try {
            return this.emit(event, event, eventObject);
          } catch (error) {
            logger.error("An internal error happened while handling event " + event + '. Error message: "' + error.message + '". Here is a stacktrace:', error);
            if (!this.triggeringException) {
              this.triggeringException = true;
              var fatal = event === Events.ERROR;
              this.trigger(Events.ERROR, {
                type: ErrorTypes.OTHER_ERROR,
                details: ErrorDetails.INTERNAL_EXCEPTION,
                fatal,
                event,
                error
              });
              this.triggeringException = false;
            }
          }
        }
        return false;
      };
      _proto.listenerCount = function listenerCount(event) {
        return this._emitter.listenerCount(event);
      };
      _proto.destroy = function destroy() {
        logger.log("destroy");
        this.trigger(Events.DESTROYING, void 0);
        this.detachMedia();
        this.removeAllListeners();
        this._autoLevelCapping = -1;
        this.url = null;
        this.networkControllers.forEach(function(component) {
          return component.destroy();
        });
        this.networkControllers.length = 0;
        this.coreComponents.forEach(function(component) {
          return component.destroy();
        });
        this.coreComponents.length = 0;
        var config = this.config;
        config.xhrSetup = config.fetchSetup = void 0;
        this.userConfig = null;
      };
      _proto.attachMedia = function attachMedia(media) {
        logger.log("attachMedia");
        this._media = media;
        this.trigger(Events.MEDIA_ATTACHING, {
          media
        });
      };
      _proto.detachMedia = function detachMedia() {
        logger.log("detachMedia");
        this.trigger(Events.MEDIA_DETACHING, void 0);
        this._media = null;
      };
      _proto.loadSource = function loadSource(url) {
        this.stopLoad();
        var media = this.media;
        var loadedSource = this.url;
        var loadingSource = this.url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {
          alwaysNormalize: true
        });
        this._autoLevelCapping = -1;
        this._maxHdcpLevel = null;
        logger.log("loadSource:" + loadingSource);
        if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {
          this.detachMedia();
          this.attachMedia(media);
        }
        this.trigger(Events.MANIFEST_LOADING, {
          url
        });
      };
      _proto.startLoad = function startLoad(startPosition) {
        if (startPosition === void 0) {
          startPosition = -1;
        }
        logger.log("startLoad(" + startPosition + ")");
        this.started = true;
        this.networkControllers.forEach(function(controller) {
          controller.startLoad(startPosition);
        });
      };
      _proto.stopLoad = function stopLoad() {
        logger.log("stopLoad");
        this.started = false;
        this.networkControllers.forEach(function(controller) {
          controller.stopLoad();
        });
      };
      _proto.resumeBuffering = function resumeBuffering() {
        if (this.started) {
          this.networkControllers.forEach(function(controller) {
            if ("fragmentLoader" in controller) {
              controller.startLoad(-1);
            }
          });
        }
      };
      _proto.pauseBuffering = function pauseBuffering() {
        this.networkControllers.forEach(function(controller) {
          if ("fragmentLoader" in controller) {
            controller.stopLoad();
          }
        });
      };
      _proto.swapAudioCodec = function swapAudioCodec() {
        logger.log("swapAudioCodec");
        this.streamController.swapAudioCodec();
      };
      _proto.recoverMediaError = function recoverMediaError() {
        logger.log("recoverMediaError");
        var media = this._media;
        this.detachMedia();
        if (media) {
          this.attachMedia(media);
        }
      };
      _proto.removeLevel = function removeLevel(levelIndex) {
        this.levelController.removeLevel(levelIndex);
      };
      _proto.setAudioOption = function setAudioOption(audioOption) {
        var _this$audioTrackContr;
        return (_this$audioTrackContr = this.audioTrackController) == null ? void 0 : _this$audioTrackContr.setAudioOption(audioOption);
      };
      _proto.setSubtitleOption = function setSubtitleOption(subtitleOption) {
        var _this$subtitleTrackCo;
        (_this$subtitleTrackCo = this.subtitleTrackController) == null ? void 0 : _this$subtitleTrackCo.setSubtitleOption(subtitleOption);
        return null;
      };
      _createClass(Hls2, [{
        key: "levels",
        get: function get() {
          var levels = this.levelController.levels;
          return levels ? levels : [];
        }
        /**
         * Index of quality level (variant) currently played
         */
      }, {
        key: "currentLevel",
        get: function get() {
          return this.streamController.currentLevel;
        },
        set: function set(newLevel) {
          logger.log("set currentLevel:" + newLevel);
          this.levelController.manualLevel = newLevel;
          this.streamController.immediateLevelSwitch();
        }
        /**
         * Index of next quality level loaded as scheduled by stream controller.
         */
      }, {
        key: "nextLevel",
        get: function get() {
          return this.streamController.nextLevel;
        },
        set: function set(newLevel) {
          logger.log("set nextLevel:" + newLevel);
          this.levelController.manualLevel = newLevel;
          this.streamController.nextLevelSwitch();
        }
        /**
         * Return the quality level of the currently or last (of none is loaded currently) segment
         */
      }, {
        key: "loadLevel",
        get: function get() {
          return this.levelController.level;
        },
        set: function set(newLevel) {
          logger.log("set loadLevel:" + newLevel);
          this.levelController.manualLevel = newLevel;
        }
        /**
         * get next quality level loaded
         */
      }, {
        key: "nextLoadLevel",
        get: function get() {
          return this.levelController.nextLoadLevel;
        },
        set: function set(level) {
          this.levelController.nextLoadLevel = level;
        }
        /**
         * Return "first level": like a default level, if not set,
         * falls back to index of first level referenced in manifest
         */
      }, {
        key: "firstLevel",
        get: function get() {
          return Math.max(this.levelController.firstLevel, this.minAutoLevel);
        },
        set: function set(newLevel) {
          logger.log("set firstLevel:" + newLevel);
          this.levelController.firstLevel = newLevel;
        }
        /**
         * Return the desired start level for the first fragment that will be loaded.
         * The default value of -1 indicates automatic start level selection.
         * Setting hls.nextAutoLevel without setting a startLevel will result in
         * the nextAutoLevel value being used for one fragment load.
         */
      }, {
        key: "startLevel",
        get: function get() {
          var startLevel = this.levelController.startLevel;
          if (startLevel === -1 && this.abrController.forcedAutoLevel > -1) {
            return this.abrController.forcedAutoLevel;
          }
          return startLevel;
        },
        set: function set(newLevel) {
          logger.log("set startLevel:" + newLevel);
          if (newLevel !== -1) {
            newLevel = Math.max(newLevel, this.minAutoLevel);
          }
          this.levelController.startLevel = newLevel;
        }
        /**
         * Whether level capping is enabled.
         * Default value is set via `config.capLevelToPlayerSize`.
         */
      }, {
        key: "capLevelToPlayerSize",
        get: function get() {
          return this.config.capLevelToPlayerSize;
        },
        set: function set(shouldStartCapping) {
          var newCapLevelToPlayerSize = !!shouldStartCapping;
          if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {
            if (newCapLevelToPlayerSize) {
              this.capLevelController.startCapping();
            } else {
              this.capLevelController.stopCapping();
              this.autoLevelCapping = -1;
              this.streamController.nextLevelSwitch();
            }
            this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;
          }
        }
        /**
         * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
         */
      }, {
        key: "autoLevelCapping",
        get: function get() {
          return this._autoLevelCapping;
        },
        set: (
          /**
           * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
           */
          function set(newLevel) {
            if (this._autoLevelCapping !== newLevel) {
              logger.log("set autoLevelCapping:" + newLevel);
              this._autoLevelCapping = newLevel;
              this.levelController.checkMaxAutoUpdated();
            }
          }
        )
      }, {
        key: "bandwidthEstimate",
        get: function get() {
          var bwEstimator = this.abrController.bwEstimator;
          if (!bwEstimator) {
            return NaN;
          }
          return bwEstimator.getEstimate();
        },
        set: function set(abrEwmaDefaultEstimate) {
          this.abrController.resetEstimator(abrEwmaDefaultEstimate);
        }
        /**
         * get time to first byte estimate
         * @type {number}
         */
      }, {
        key: "ttfbEstimate",
        get: function get() {
          var bwEstimator = this.abrController.bwEstimator;
          if (!bwEstimator) {
            return NaN;
          }
          return bwEstimator.getEstimateTTFB();
        }
      }, {
        key: "maxHdcpLevel",
        get: function get() {
          return this._maxHdcpLevel;
        },
        set: function set(value) {
          if (isHdcpLevel(value) && this._maxHdcpLevel !== value) {
            this._maxHdcpLevel = value;
            this.levelController.checkMaxAutoUpdated();
          }
        }
        /**
         * True when automatic level selection enabled
         */
      }, {
        key: "autoLevelEnabled",
        get: function get() {
          return this.levelController.manualLevel === -1;
        }
        /**
         * Level set manually (if any)
         */
      }, {
        key: "manualLevel",
        get: function get() {
          return this.levelController.manualLevel;
        }
        /**
         * min level selectable in auto mode according to config.minAutoBitrate
         */
      }, {
        key: "minAutoLevel",
        get: function get() {
          var levels = this.levels, minAutoBitrate = this.config.minAutoBitrate;
          if (!levels)
            return 0;
          var len = levels.length;
          for (var i = 0; i < len; i++) {
            if (levels[i].maxBitrate >= minAutoBitrate) {
              return i;
            }
          }
          return 0;
        }
        /**
         * max level selectable in auto mode according to autoLevelCapping
         */
      }, {
        key: "maxAutoLevel",
        get: function get() {
          var levels = this.levels, autoLevelCapping = this.autoLevelCapping, maxHdcpLevel = this.maxHdcpLevel;
          var maxAutoLevel;
          if (autoLevelCapping === -1 && levels != null && levels.length) {
            maxAutoLevel = levels.length - 1;
          } else {
            maxAutoLevel = autoLevelCapping;
          }
          if (maxHdcpLevel) {
            for (var i = maxAutoLevel; i--; ) {
              var hdcpLevel = levels[i].attrs["HDCP-LEVEL"];
              if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {
                return i;
              }
            }
          }
          return maxAutoLevel;
        }
      }, {
        key: "firstAutoLevel",
        get: function get() {
          return this.abrController.firstAutoLevel;
        }
        /**
         * next automatically selected quality level
         */
      }, {
        key: "nextAutoLevel",
        get: function get() {
          return this.abrController.nextAutoLevel;
        },
        set: function set(nextLevel) {
          this.abrController.nextAutoLevel = nextLevel;
        }
        /**
         * get the datetime value relative to media.currentTime for the active level Program Date Time if present
         */
      }, {
        key: "playingDate",
        get: function get() {
          return this.streamController.currentProgramDateTime;
        }
      }, {
        key: "mainForwardBufferInfo",
        get: function get() {
          return this.streamController.getMainFwdBufferInfo();
        }
      }, {
        key: "allAudioTracks",
        get: function get() {
          var audioTrackController = this.audioTrackController;
          return audioTrackController ? audioTrackController.allAudioTracks : [];
        }
        /**
         * Get the list of selectable audio tracks
         */
      }, {
        key: "audioTracks",
        get: function get() {
          var audioTrackController = this.audioTrackController;
          return audioTrackController ? audioTrackController.audioTracks : [];
        }
        /**
         * index of the selected audio track (index in audio track lists)
         */
      }, {
        key: "audioTrack",
        get: function get() {
          var audioTrackController = this.audioTrackController;
          return audioTrackController ? audioTrackController.audioTrack : -1;
        },
        set: function set(audioTrackId) {
          var audioTrackController = this.audioTrackController;
          if (audioTrackController) {
            audioTrackController.audioTrack = audioTrackId;
          }
        }
        /**
         * get the complete list of subtitle tracks across all media groups
         */
      }, {
        key: "allSubtitleTracks",
        get: function get() {
          var subtitleTrackController = this.subtitleTrackController;
          return subtitleTrackController ? subtitleTrackController.allSubtitleTracks : [];
        }
        /**
         * get alternate subtitle tracks list from playlist
         */
      }, {
        key: "subtitleTracks",
        get: function get() {
          var subtitleTrackController = this.subtitleTrackController;
          return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
        }
        /**
         * index of the selected subtitle track (index in subtitle track lists)
         */
      }, {
        key: "subtitleTrack",
        get: function get() {
          var subtitleTrackController = this.subtitleTrackController;
          return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
        },
        set: (
          /**
           * select an subtitle track, based on its index in subtitle track lists
           */
          function set(subtitleTrackId) {
            var subtitleTrackController = this.subtitleTrackController;
            if (subtitleTrackController) {
              subtitleTrackController.subtitleTrack = subtitleTrackId;
            }
          }
        )
        /**
         * Whether subtitle display is enabled or not
         */
      }, {
        key: "media",
        get: function get() {
          return this._media;
        }
      }, {
        key: "subtitleDisplay",
        get: function get() {
          var subtitleTrackController = this.subtitleTrackController;
          return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
        },
        set: function set(value) {
          var subtitleTrackController = this.subtitleTrackController;
          if (subtitleTrackController) {
            subtitleTrackController.subtitleDisplay = value;
          }
        }
        /**
         * get mode for Low-Latency HLS loading
         */
      }, {
        key: "lowLatencyMode",
        get: function get() {
          return this.config.lowLatencyMode;
        },
        set: function set(mode) {
          this.config.lowLatencyMode = mode;
        }
        /**
         * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)
         * @returns null prior to loading live Playlist
         */
      }, {
        key: "liveSyncPosition",
        get: function get() {
          return this.latencyController.liveSyncPosition;
        }
        /**
         * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)
         * @returns 0 before first playlist is loaded
         */
      }, {
        key: "latency",
        get: function get() {
          return this.latencyController.latency;
        }
        /**
         * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```
         * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```
         * @returns 0 before first playlist is loaded
         */
      }, {
        key: "maxLatency",
        get: function get() {
          return this.latencyController.maxLatency;
        }
        /**
         * target distance from the edge as calculated by the latency controller
         */
      }, {
        key: "targetLatency",
        get: function get() {
          return this.latencyController.targetLatency;
        }
        /**
         * the rate at which the edge of the current live playlist is advancing or 1 if there is none
         */
      }, {
        key: "drift",
        get: function get() {
          return this.latencyController.drift;
        }
        /**
         * set to true when startLoad is called before MANIFEST_PARSED event
         */
      }, {
        key: "forceStartLoad",
        get: function get() {
          return this.streamController.forceStartLoad;
        }
      }], [{
        key: "version",
        get: (
          /**
           * Get the video-dev/hls.js package version.
           */
          function get() {
            return "1.5.1";
          }
        )
      }, {
        key: "Events",
        get: function get() {
          return Events;
        }
      }, {
        key: "ErrorTypes",
        get: function get() {
          return ErrorTypes;
        }
      }, {
        key: "ErrorDetails",
        get: function get() {
          return ErrorDetails;
        }
        /**
         * Get the default configuration applied to new instances.
         */
      }, {
        key: "DefaultConfig",
        get: function get() {
          if (!Hls2.defaultConfig) {
            return hlsDefaultConfig;
          }
          return Hls2.defaultConfig;
        },
        set: function set(defaultConfig) {
          Hls2.defaultConfig = defaultConfig;
        }
      }]);
      return Hls2;
    }();
    Hls.defaultConfig = void 0;
    return Hls;
  });
})(false);
var Clappr = function() {
  "use strict";
  function e(e2, t2) {
    var r2 = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var i2 = Object.getOwnPropertySymbols(e2);
      t2 && (i2 = i2.filter(function(t3) {
        return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
      })), r2.push.apply(r2, i2);
    }
    return r2;
  }
  function t(t2) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var n2 = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? e(Object(n2), true).forEach(function(e2) {
        r(t2, e2, n2[e2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(n2)) : e(Object(n2)).forEach(function(e2) {
        Object.defineProperty(t2, e2, Object.getOwnPropertyDescriptor(n2, e2));
      });
    }
    return t2;
  }
  function r(e2, t2, r2) {
    return (t2 = function(e3) {
      var t3 = function(e4, t4) {
        if ("object" != typeof e4 || null === e4)
          return e4;
        var r3 = e4[Symbol.toPrimitive];
        if (void 0 !== r3) {
          var i2 = r3.call(e4, t4 || "default");
          if ("object" != typeof i2)
            return i2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t4 ? String : Number)(e4);
      }(e3, "string");
      return "symbol" == typeof t3 ? t3 : String(t3);
    }(t2)) in e2 ? Object.defineProperty(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2, e2;
  }
  function i(e2, t2) {
    var r2 = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var i2 = Object.getOwnPropertySymbols(e2);
      t2 && (i2 = i2.filter(function(t3) {
        return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
      })), r2.push.apply(r2, i2);
    }
    return r2;
  }
  function n(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2 = null != arguments[t2] ? arguments[t2] : {};
      t2 % 2 ? i(Object(r2), true).forEach(function(t3) {
        u(e2, t3, r2[t3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : i(Object(r2)).forEach(function(t3) {
        Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
      });
    }
    return e2;
  }
  function a(e2) {
    return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
      return typeof e3;
    } : function(e3) {
      return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
    }, a(e2);
  }
  function s(e2, t2) {
    if (!(e2 instanceof t2))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(e2, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var i2 = t2[r2];
      i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e2, i2.key, i2);
    }
  }
  function l(e2, t2, r2) {
    return t2 && o(e2.prototype, t2), r2 && o(e2, r2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
  }
  function u(e2, t2, r2) {
    return t2 in e2 ? Object.defineProperty(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2, e2;
  }
  function c(e2, t2) {
    if ("function" != typeof t2 && null !== t2)
      throw new TypeError("Super expression must either be null or a function");
    e2.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e2, writable: true, configurable: true } }), Object.defineProperty(e2, "prototype", { writable: false }), t2 && h(e2, t2);
  }
  function d(e2) {
    return d = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e3) {
      return e3.__proto__ || Object.getPrototypeOf(e3);
    }, d(e2);
  }
  function h(e2, t2) {
    return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e3, t3) {
      return e3.__proto__ = t3, e3;
    }, h(e2, t2);
  }
  function f(e2) {
    if (void 0 === e2)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e2;
  }
  function p(e2, t2) {
    if (t2 && ("object" == typeof t2 || "function" == typeof t2))
      return t2;
    if (void 0 !== t2)
      throw new TypeError("Derived constructors may only return object or undefined");
    return f(e2);
  }
  function g(e2) {
    var t2 = function() {
      if ("undefined" == typeof Reflect || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if ("function" == typeof Proxy)
        return true;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), true;
      } catch (e3) {
        return false;
      }
    }();
    return function() {
      var r2, i2 = d(e2);
      if (t2) {
        var n2 = d(this).constructor;
        r2 = Reflect.construct(i2, arguments, n2);
      } else
        r2 = i2.apply(this, arguments);
      return p(this, r2);
    };
  }
  function v(e2, t2) {
    for (; !Object.prototype.hasOwnProperty.call(e2, t2) && null !== (e2 = d(e2)); )
      ;
    return e2;
  }
  function m() {
    return m = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e2, t2, r2) {
      var i2 = v(e2, t2);
      if (i2) {
        var n2 = Object.getOwnPropertyDescriptor(i2, t2);
        return n2.get ? n2.get.call(arguments.length < 3 ? e2 : r2) : n2.value;
      }
    }, m.apply(this, arguments);
  }
  function y(e2, t2) {
    return function(e3) {
      if (Array.isArray(e3))
        return e3;
    }(e2) || function(e3, t3) {
      var r2 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
      if (null == r2)
        return;
      var i2, n2, a2 = [], s2 = true, o2 = false;
      try {
        for (r2 = r2.call(e3); !(s2 = (i2 = r2.next()).done) && (a2.push(i2.value), !t3 || a2.length !== t3); s2 = true)
          ;
      } catch (e4) {
        o2 = true, n2 = e4;
      } finally {
        try {
          s2 || null == r2.return || r2.return();
        } finally {
          if (o2)
            throw n2;
        }
      }
      return a2;
    }(e2, t2) || E(e2, t2) || function() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function A(e2) {
    return function(e3) {
      if (Array.isArray(e3))
        return T(e3);
    }(e2) || function(e3) {
      if ("undefined" != typeof Symbol && null != e3[Symbol.iterator] || null != e3["@@iterator"])
        return Array.from(e3);
    }(e2) || E(e2) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function E(e2, t2) {
    if (e2) {
      if ("string" == typeof e2)
        return T(e2, t2);
      var r2 = Object.prototype.toString.call(e2).slice(8, -1);
      return "Object" === r2 && e2.constructor && (r2 = e2.constructor.name), "Map" === r2 || "Set" === r2 ? Array.from(e2) : "Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? T(e2, t2) : void 0;
    }
  }
  function T(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, i2 = new Array(t2); r2 < t2; r2++)
      i2[r2] = e2[r2];
    return i2;
  }
  function b(e2, t2) {
    var r2 = "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
    if (!r2) {
      if (Array.isArray(e2) || (r2 = E(e2)) || t2 && e2 && "number" == typeof e2.length) {
        r2 && (e2 = r2);
        var i2 = 0, n2 = function() {
        };
        return { s: n2, n: function() {
          return i2 >= e2.length ? { done: true } : { done: false, value: e2[i2++] };
        }, e: function(e3) {
          throw e3;
        }, f: n2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var a2, s2 = true, o2 = false;
    return { s: function() {
      r2 = r2.call(e2);
    }, n: function() {
      var e3 = r2.next();
      return s2 = e3.done, e3;
    }, e: function(e3) {
      o2 = true, a2 = e3;
    }, f: function() {
      try {
        s2 || null == r2.return || r2.return();
      } finally {
        if (o2)
          throw a2;
      }
    } };
  }
  Array.prototype.find || Object.defineProperty(Array.prototype, "find", { value: function(e2) {
    if (null == this)
      throw new TypeError('"this" is null or not defined');
    var t2 = Object(this), r2 = t2.length >>> 0;
    if ("function" != typeof e2)
      throw new TypeError("predicate must be a function");
    for (var i2 = arguments[1], n2 = 0; n2 < r2; ) {
      var a2 = t2[n2];
      if (e2.call(i2, a2, n2, t2))
        return a2;
      n2++;
    }
  } }), Object.entries || (Object.entries = function(e2) {
    for (var t2 = Object.keys(e2), r2 = t2.length, i2 = new Array(r2); r2--; )
      i2[r2] = [t2[r2], e2[t2[r2]]];
    return i2;
  }), Object.values || (Object.values = function(e2) {
    for (var t2 = Object.keys(e2), r2 = t2.length, i2 = new Array(r2); r2--; )
      i2[r2] = e2[t2[r2]];
    return i2;
  }), "function" != typeof Object.assign && Object.defineProperty(Object, "assign", { value: function(e2, t2) {
    if (null == e2)
      throw new TypeError("Cannot convert undefined or null to object");
    for (var r2 = Object(e2), i2 = 1; i2 < arguments.length; i2++) {
      var n2 = arguments[i2];
      if (null != n2)
        for (var a2 in n2)
          Object.prototype.hasOwnProperty.call(n2, a2) && (r2[a2] = n2[a2]);
    }
    return r2;
  }, writable: true, configurable: true }), Array.prototype.findIndex || Object.defineProperty(Array.prototype, "findIndex", { value: function(e2) {
    if (null == this)
      throw new TypeError('"this" is null or not defined');
    var t2 = Object(this), r2 = t2.length >>> 0;
    if ("function" != typeof e2)
      throw new TypeError("predicate must be a function");
    for (var i2 = arguments[1], n2 = 0; n2 < r2; ) {
      var a2 = t2[n2];
      if (e2.call(i2, a2, n2, t2))
        return n2;
      n2++;
    }
    return -1;
  }, configurable: true, writable: true });
  var k, S = { mp4: "data:video/mp4;base64,AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAAC721kYXQhEAUgpBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcCEQBSCkG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAsJtb292AAAAbG12aGQAAAAAAAAAAAAAAAAAAAPoAAAALwABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAB7HRyYWsAAABcdGtoZAAAAAMAAAAAAAAAAAAAAAIAAAAAAAAALwAAAAAAAAAAAAAAAQEAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAAC8AAAAAAAEAAAAAAWRtZGlhAAAAIG1kaGQAAAAAAAAAAAAAAAAAAKxEAAAIAFXEAAAAAAAtaGRscgAAAAAAAAAAc291bgAAAAAAAAAAAAAAAFNvdW5kSGFuZGxlcgAAAAEPbWluZgAAABBzbWhkAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAADTc3RibAAAAGdzdHNkAAAAAAAAAAEAAABXbXA0YQAAAAAAAAABAAAAAAAAAAAAAgAQAAAAAKxEAAAAAAAzZXNkcwAAAAADgICAIgACAASAgIAUQBUAAAAAAfQAAAHz+QWAgIACEhAGgICAAQIAAAAYc3R0cwAAAAAAAAABAAAAAgAABAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAIAAAABAAAAHHN0c3oAAAAAAAAAAAAAAAIAAAFzAAABdAAAABRzdGNvAAAAAAAAAAEAAAAsAAAAYnVkdGEAAABabWV0YQAAAAAAAAAhaGRscgAAAAAAAAAAbWRpcmFwcGwAAAAAAAAAAAAAAAAtaWxzdAAAACWpdG9vAAAAHWRhdGEAAAABAAAAAExhdmY1Ni40MC4xMDE=" }, _ = function() {
    var e2, t2, r2, i2, n2, a2, s2 = [], o2 = s2.concat, l2 = s2.filter, u2 = s2.slice, c2 = window.document, d2 = {}, h2 = {}, f2 = { "column-count": 1, columns: 1, "font-weight": 1, "line-height": 1, opacity: 1, "z-index": 1, zoom: 1 }, p2 = /^\s*<(\w+|!)[^>]*>/, g2 = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, v2 = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, m2 = /^(?:body|html)$/i, y2 = /([A-Z])/g, A2 = ["val", "css", "html", "text", "data", "width", "height", "offset"], E2 = c2.createElement("table"), T2 = c2.createElement("tr"), b2 = { tr: c2.createElement("tbody"), tbody: E2, thead: E2, tfoot: E2, td: T2, th: T2, "*": c2.createElement("div") }, k2 = /complete|loaded|interactive/, S2 = /^[\w-]*$/, _2 = {}, C2 = _2.toString, L2 = {}, D2 = c2.createElement("div"), R2 = { tabindex: "tabIndex", readonly: "readOnly", for: "htmlFor", class: "className", maxlength: "maxLength", cellspacing: "cellSpacing", cellpadding: "cellPadding", rowspan: "rowSpan", colspan: "colSpan", usemap: "useMap", frameborder: "frameBorder", contenteditable: "contentEditable" }, I2 = Array.isArray || function(e3) {
      return e3 instanceof Array;
    };
    function O2(e3) {
      return null == e3 ? String(e3) : _2[C2.call(e3)] || "object";
    }
    function w2(e3) {
      return "function" == O2(e3);
    }
    function P2(e3) {
      return null != e3 && e3 == e3.window;
    }
    function x2(e3) {
      return null != e3 && e3.nodeType == e3.DOCUMENT_NODE;
    }
    function N2(e3) {
      return "object" == O2(e3);
    }
    function F2(e3) {
      return N2(e3) && !P2(e3) && Object.getPrototypeOf(e3) == Object.prototype;
    }
    function M2(e3) {
      var t3 = !!e3 && "length" in e3 && e3.length, i3 = r2.type(e3);
      return "function" != i3 && !P2(e3) && ("array" == i3 || 0 === t3 || "number" == typeof t3 && t3 > 0 && t3 - 1 in e3);
    }
    function B2(e3) {
      return e3.replace(/::/g, "/").replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2").replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/_/g, "-").toLowerCase();
    }
    function U2(e3) {
      return e3 in h2 ? h2[e3] : h2[e3] = new RegExp("(^|\\s)" + e3 + "(\\s|$)");
    }
    function G2(e3, t3) {
      return "number" != typeof t3 || f2[B2(e3)] ? t3 : t3 + "px";
    }
    function V2(e3) {
      return "children" in e3 ? u2.call(e3.children) : r2.map(e3.childNodes, function(e4) {
        if (1 == e4.nodeType)
          return e4;
      });
    }
    function K2(e3, t3) {
      var r3, i3 = e3 ? e3.length : 0;
      for (r3 = 0; r3 < i3; r3++)
        this[r3] = e3[r3];
      this.length = i3, this.selector = t3 || "";
    }
    function j2(r3, i3, n3) {
      for (t2 in i3)
        n3 && (F2(i3[t2]) || I2(i3[t2])) ? (F2(i3[t2]) && !F2(r3[t2]) && (r3[t2] = {}), I2(i3[t2]) && !I2(r3[t2]) && (r3[t2] = []), j2(r3[t2], i3[t2], n3)) : i3[t2] !== e2 && (r3[t2] = i3[t2]);
    }
    function H2(e3, t3) {
      return null == t3 ? r2(e3) : r2(e3).filter(t3);
    }
    function Y2(e3, t3, r3, i3) {
      return w2(t3) ? t3.call(e3, r3, i3) : t3;
    }
    function W2(e3, t3, r3) {
      null == r3 ? e3.removeAttribute(t3) : e3.setAttribute(t3, r3);
    }
    function $2(t3, r3) {
      var i3 = t3.className || "", n3 = i3 && i3.baseVal !== e2;
      if (r3 === e2)
        return n3 ? i3.baseVal : i3;
      n3 ? i3.baseVal = r3 : t3.className = r3;
    }
    function z2(e3) {
      try {
        return e3 ? "true" == e3 || "false" != e3 && ("null" == e3 ? null : +e3 + "" == e3 ? +e3 : /^[\[\{]/.test(e3) ? r2.parseJSON(e3) : e3) : e3;
      } catch (t3) {
        return e3;
      }
    }
    function q2(e3, t3) {
      t3(e3);
      for (var r3 = 0, i3 = e3.childNodes.length; r3 < i3; r3++)
        q2(e3.childNodes[r3], t3);
    }
    return L2.matches = function(e3, t3) {
      if (!t3 || !e3 || 1 !== e3.nodeType)
        return false;
      var r3 = e3.matches || e3.webkitMatchesSelector || e3.mozMatchesSelector || e3.oMatchesSelector || e3.matchesSelector;
      if (r3)
        return r3.call(e3, t3);
      var i3, n3 = e3.parentNode, a3 = !n3;
      return a3 && (n3 = D2).appendChild(e3), i3 = ~L2.qsa(n3, t3).indexOf(e3), a3 && D2.removeChild(e3), i3;
    }, n2 = function(e3) {
      return e3.replace(/-+(.)?/g, function(e4, t3) {
        return t3 ? t3.toUpperCase() : "";
      });
    }, a2 = function(e3) {
      return l2.call(e3, function(t3, r3) {
        return e3.indexOf(t3) == r3;
      });
    }, L2.fragment = function(t3, i3, n3) {
      var a3, s3, o3;
      return g2.test(t3) && (a3 = r2(c2.createElement(RegExp.$1))), a3 || (t3.replace && (t3 = t3.replace(v2, "<$1></$2>")), i3 === e2 && (i3 = p2.test(t3) && RegExp.$1), i3 in b2 || (i3 = "*"), (o3 = b2[i3]).innerHTML = "" + t3, a3 = r2.each(u2.call(o3.childNodes), function() {
        o3.removeChild(this);
      })), F2(n3) && (s3 = r2(a3), r2.each(n3, function(e3, t4) {
        A2.indexOf(e3) > -1 ? s3[e3](t4) : s3.attr(e3, t4);
      })), a3;
    }, L2.Z = function(e3, t3) {
      return new K2(e3, t3);
    }, L2.isZ = function(e3) {
      return e3 instanceof L2.Z;
    }, L2.init = function(t3, i3) {
      var n3, a3;
      if (!t3)
        return L2.Z();
      if ("string" == typeof t3)
        if ("<" == (t3 = t3.trim())[0] && p2.test(t3))
          n3 = L2.fragment(t3, RegExp.$1, i3), t3 = null;
        else {
          if (i3 !== e2)
            return r2(i3).find(t3);
          n3 = L2.qsa(c2, t3);
        }
      else {
        if (w2(t3))
          return r2(c2).ready(t3);
        if (L2.isZ(t3))
          return t3;
        if (I2(t3))
          a3 = t3, n3 = l2.call(a3, function(e3) {
            return null != e3;
          });
        else if (N2(t3))
          n3 = [t3], t3 = null;
        else if (p2.test(t3))
          n3 = L2.fragment(t3.trim(), RegExp.$1, i3), t3 = null;
        else {
          if (i3 !== e2)
            return r2(i3).find(t3);
          n3 = L2.qsa(c2, t3);
        }
      }
      return L2.Z(n3, t3);
    }, (r2 = function(e3, t3) {
      return L2.init(e3, t3);
    }).extend = function(e3) {
      var t3, r3 = u2.call(arguments, 1);
      return "boolean" == typeof e3 && (t3 = e3, e3 = r3.shift()), r3.forEach(function(r4) {
        j2(e3, r4, t3);
      }), e3;
    }, L2.qsa = function(e3, t3) {
      var r3, i3 = "#" == t3[0], n3 = !i3 && "." == t3[0], a3 = i3 || n3 ? t3.slice(1) : t3, s3 = S2.test(a3);
      return e3.getElementById && s3 && i3 ? (r3 = e3.getElementById(a3)) ? [r3] : [] : 1 !== e3.nodeType && 9 !== e3.nodeType && 11 !== e3.nodeType ? [] : u2.call(s3 && !i3 && e3.getElementsByClassName ? n3 ? e3.getElementsByClassName(a3) : e3.getElementsByTagName(t3) : e3.querySelectorAll(t3));
    }, r2.contains = c2.documentElement.contains ? function(e3, t3) {
      return e3 !== t3 && e3.contains(t3);
    } : function(e3, t3) {
      for (; t3 && (t3 = t3.parentNode); )
        if (t3 === e3)
          return true;
      return false;
    }, r2.type = O2, r2.isFunction = w2, r2.isWindow = P2, r2.isArray = I2, r2.isPlainObject = F2, r2.isEmptyObject = function(e3) {
      var t3;
      for (t3 in e3)
        return false;
      return true;
    }, r2.isNumeric = function(e3) {
      var t3 = Number(e3), r3 = typeof e3;
      return null != e3 && "boolean" != r3 && ("string" != r3 || e3.length) && !isNaN(t3) && isFinite(t3) || false;
    }, r2.inArray = function(e3, t3, r3) {
      return s2.indexOf.call(t3, e3, r3);
    }, r2.camelCase = n2, r2.trim = function(e3) {
      return null == e3 ? "" : String.prototype.trim.call(e3);
    }, r2.uuid = 0, r2.support = {}, r2.expr = {}, r2.noop = function() {
    }, r2.map = function(e3, t3) {
      var i3, n3, a3, s3, o3 = [];
      if (M2(e3))
        for (n3 = 0; n3 < e3.length; n3++)
          null != (i3 = t3(e3[n3], n3)) && o3.push(i3);
      else
        for (a3 in e3)
          null != (i3 = t3(e3[a3], a3)) && o3.push(i3);
      return (s3 = o3).length > 0 ? r2.fn.concat.apply([], s3) : s3;
    }, r2.each = function(e3, t3) {
      var r3, i3;
      if (M2(e3)) {
        for (r3 = 0; r3 < e3.length; r3++)
          if (false === t3.call(e3[r3], r3, e3[r3]))
            return e3;
      } else
        for (i3 in e3)
          if (false === t3.call(e3[i3], i3, e3[i3]))
            return e3;
      return e3;
    }, r2.grep = function(e3, t3) {
      return l2.call(e3, t3);
    }, window.JSON && (r2.parseJSON = JSON.parse), r2.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(e3, t3) {
      _2["[object " + t3 + "]"] = t3.toLowerCase();
    }), r2.fn = { constructor: L2.Z, length: 0, forEach: s2.forEach, reduce: s2.reduce, push: s2.push, sort: s2.sort, splice: s2.splice, indexOf: s2.indexOf, concat: function() {
      var e3, t3, r3 = [];
      for (e3 = 0; e3 < arguments.length; e3++)
        t3 = arguments[e3], r3[e3] = L2.isZ(t3) ? t3.toArray() : t3;
      return o2.apply(L2.isZ(this) ? this.toArray() : this, r3);
    }, map: function(e3) {
      return r2(r2.map(this, function(t3, r3) {
        return e3.call(t3, r3, t3);
      }));
    }, slice: function() {
      return r2(u2.apply(this, arguments));
    }, ready: function(e3) {
      return k2.test(c2.readyState) && c2.body ? e3(r2) : c2.addEventListener("DOMContentLoaded", function() {
        e3(r2);
      }, false), this;
    }, get: function(t3) {
      return t3 === e2 ? u2.call(this) : this[t3 >= 0 ? t3 : t3 + this.length];
    }, toArray: function() {
      return this.get();
    }, size: function() {
      return this.length;
    }, remove: function() {
      return this.each(function() {
        null != this.parentNode && this.parentNode.removeChild(this);
      });
    }, each: function(e3) {
      return s2.every.call(this, function(t3, r3) {
        return false !== e3.call(t3, r3, t3);
      }), this;
    }, filter: function(e3) {
      return w2(e3) ? this.not(this.not(e3)) : r2(l2.call(this, function(t3) {
        return L2.matches(t3, e3);
      }));
    }, add: function(e3, t3) {
      return r2(a2(this.concat(r2(e3, t3))));
    }, is: function(e3) {
      return this.length > 0 && L2.matches(this[0], e3);
    }, not: function(t3) {
      var i3 = [];
      if (w2(t3) && t3.call !== e2)
        this.each(function(e3) {
          t3.call(this, e3) || i3.push(this);
        });
      else {
        var n3 = "string" == typeof t3 ? this.filter(t3) : M2(t3) && w2(t3.item) ? u2.call(t3) : r2(t3);
        this.forEach(function(e3) {
          n3.indexOf(e3) < 0 && i3.push(e3);
        });
      }
      return r2(i3);
    }, has: function(e3) {
      return this.filter(function() {
        return N2(e3) ? r2.contains(this, e3) : r2(this).find(e3).size();
      });
    }, eq: function(e3) {
      return -1 === e3 ? this.slice(e3) : this.slice(e3, +e3 + 1);
    }, first: function() {
      var e3 = this[0];
      return e3 && !N2(e3) ? e3 : r2(e3);
    }, last: function() {
      var e3 = this[this.length - 1];
      return e3 && !N2(e3) ? e3 : r2(e3);
    }, find: function(e3) {
      var t3 = this;
      return e3 ? "object" == typeof e3 ? r2(e3).filter(function() {
        var e4 = this;
        return s2.some.call(t3, function(t4) {
          return r2.contains(t4, e4);
        });
      }) : 1 == this.length ? r2(L2.qsa(this[0], e3)) : this.map(function() {
        return L2.qsa(this, e3);
      }) : r2();
    }, closest: function(e3, t3) {
      var i3 = [], n3 = "object" == typeof e3 && r2(e3);
      return this.each(function(r3, a3) {
        for (; a3 && !(n3 ? n3.indexOf(a3) >= 0 : L2.matches(a3, e3)); )
          a3 = a3 !== t3 && !x2(a3) && a3.parentNode;
        a3 && i3.indexOf(a3) < 0 && i3.push(a3);
      }), r2(i3);
    }, parents: function(e3) {
      for (var t3 = [], i3 = this; i3.length > 0; )
        i3 = r2.map(i3, function(e4) {
          if ((e4 = e4.parentNode) && !x2(e4) && t3.indexOf(e4) < 0)
            return t3.push(e4), e4;
        });
      return H2(t3, e3);
    }, parent: function(e3) {
      return H2(a2(this.pluck("parentNode")), e3);
    }, children: function(e3) {
      return H2(this.map(function() {
        return V2(this);
      }), e3);
    }, contents: function() {
      return this.map(function() {
        return this.contentDocument || u2.call(this.childNodes);
      });
    }, siblings: function(e3) {
      return H2(this.map(function(e4, t3) {
        return l2.call(V2(t3.parentNode), function(e5) {
          return e5 !== t3;
        });
      }), e3);
    }, empty: function() {
      return this.each(function() {
        this.innerHTML = "";
      });
    }, pluck: function(e3) {
      return r2.map(this, function(t3) {
        return t3[e3];
      });
    }, show: function() {
      return this.each(function() {
        var e3, t3, r3;
        "none" == this.style.display && (this.style.display = ""), "none" == getComputedStyle(this, "").getPropertyValue("display") && (this.style.display = (e3 = this.nodeName, d2[e3] || (t3 = c2.createElement(e3), c2.body.appendChild(t3), r3 = getComputedStyle(t3, "").getPropertyValue("display"), t3.parentNode.removeChild(t3), "none" == r3 && (r3 = "block"), d2[e3] = r3), d2[e3]));
      });
    }, replaceWith: function(e3) {
      return this.before(e3).remove();
    }, wrap: function(e3) {
      var t3 = w2(e3);
      if (this[0] && !t3)
        var i3 = r2(e3).get(0), n3 = i3.parentNode || this.length > 1;
      return this.each(function(a3) {
        r2(this).wrapAll(t3 ? e3.call(this, a3) : n3 ? i3.cloneNode(true) : i3);
      });
    }, wrapAll: function(e3) {
      if (this[0]) {
        var t3;
        for (r2(this[0]).before(e3 = r2(e3)); (t3 = e3.children()).length; )
          e3 = t3.first();
        r2(e3).append(this);
      }
      return this;
    }, wrapInner: function(e3) {
      var t3 = w2(e3);
      return this.each(function(i3) {
        var n3 = r2(this), a3 = n3.contents(), s3 = t3 ? e3.call(this, i3) : e3;
        a3.length ? a3.wrapAll(s3) : n3.append(s3);
      });
    }, unwrap: function() {
      return this.parent().each(function() {
        r2(this).replaceWith(r2(this).children());
      }), this;
    }, clone: function() {
      return this.map(function() {
        return this.cloneNode(true);
      });
    }, hide: function() {
      return this.css("display", "none");
    }, toggle: function(t3) {
      return this.each(function() {
        var i3 = r2(this);
        (t3 === e2 ? "none" == i3.css("display") : t3) ? i3.show() : i3.hide();
      });
    }, prev: function(e3) {
      return r2(this.pluck("previousElementSibling")).filter(e3 || "*");
    }, next: function(e3) {
      return r2(this.pluck("nextElementSibling")).filter(e3 || "*");
    }, html: function(e3) {
      return 0 in arguments ? this.each(function(t3) {
        var i3 = this.innerHTML;
        r2(this).empty().append(Y2(this, e3, t3, i3));
      }) : 0 in this ? this[0].innerHTML : null;
    }, text: function(e3) {
      return 0 in arguments ? this.each(function(t3) {
        var r3 = Y2(this, e3, t3, this.textContent);
        this.textContent = null == r3 ? "" : "" + r3;
      }) : 0 in this ? this.pluck("textContent").join("") : null;
    }, attr: function(r3, i3) {
      var n3;
      return "string" != typeof r3 || 1 in arguments ? this.each(function(e3) {
        if (1 === this.nodeType)
          if (N2(r3))
            for (t2 in r3)
              W2(this, t2, r3[t2]);
          else
            W2(this, r3, Y2(this, i3, e3, this.getAttribute(r3)));
      }) : 0 in this && 1 == this[0].nodeType && null != (n3 = this[0].getAttribute(r3)) ? n3 : e2;
    }, removeAttr: function(e3) {
      return this.each(function() {
        1 === this.nodeType && e3.split(" ").forEach(function(e4) {
          W2(this, e4);
        }, this);
      });
    }, prop: function(e3, t3) {
      return e3 = R2[e3] || e3, 1 in arguments ? this.each(function(r3) {
        this[e3] = Y2(this, t3, r3, this[e3]);
      }) : this[0] && this[0][e3];
    }, removeProp: function(e3) {
      return e3 = R2[e3] || e3, this.each(function() {
        delete this[e3];
      });
    }, data: function(t3, r3) {
      var i3 = "data-" + t3.replace(y2, "-$1").toLowerCase(), n3 = 1 in arguments ? this.attr(i3, r3) : this.attr(i3);
      return null !== n3 ? z2(n3) : e2;
    }, val: function(e3) {
      return 0 in arguments ? (null == e3 && (e3 = ""), this.each(function(t3) {
        this.value = Y2(this, e3, t3, this.value);
      })) : this[0] && (this[0].multiple ? r2(this[0]).find("option").filter(function() {
        return this.selected;
      }).pluck("value") : this[0].value);
    }, offset: function(e3) {
      if (e3)
        return this.each(function(t4) {
          var i3 = r2(this), n3 = Y2(this, e3, t4, i3.offset()), a3 = i3.offsetParent().offset(), s3 = { top: n3.top - a3.top, left: n3.left - a3.left };
          "static" == i3.css("position") && (s3.position = "relative"), i3.css(s3);
        });
      if (!this.length)
        return null;
      if (c2.documentElement !== this[0] && !r2.contains(c2.documentElement, this[0]))
        return { top: 0, left: 0 };
      var t3 = this[0].getBoundingClientRect();
      return { left: t3.left + window.pageXOffset, top: t3.top + window.pageYOffset, width: Math.round(t3.width), height: Math.round(t3.height) };
    }, css: function(e3, i3) {
      if (arguments.length < 2) {
        var a3 = this[0];
        if ("string" == typeof e3) {
          if (!a3)
            return;
          return a3.style[n2(e3)] || getComputedStyle(a3, "").getPropertyValue(e3);
        }
        if (I2(e3)) {
          if (!a3)
            return;
          var s3 = {}, o3 = getComputedStyle(a3, "");
          return r2.each(e3, function(e4, t3) {
            s3[t3] = a3.style[n2(t3)] || o3.getPropertyValue(t3);
          }), s3;
        }
      }
      var l3 = "";
      if ("string" == O2(e3))
        i3 || 0 === i3 ? l3 = B2(e3) + ":" + G2(e3, i3) : this.each(function() {
          this.style.removeProperty(B2(e3));
        });
      else
        for (t2 in e3)
          e3[t2] || 0 === e3[t2] ? l3 += B2(t2) + ":" + G2(t2, e3[t2]) + ";" : this.each(function() {
            this.style.removeProperty(B2(t2));
          });
      return this.each(function() {
        this.style.cssText += ";" + l3;
      });
    }, index: function(e3) {
      return e3 ? this.indexOf(r2(e3)[0]) : this.parent().children().indexOf(this[0]);
    }, hasClass: function(e3) {
      return !!e3 && s2.some.call(this, function(e4) {
        return this.test($2(e4));
      }, U2(e3));
    }, addClass: function(e3) {
      return e3 ? this.each(function(t3) {
        if ("className" in this) {
          i2 = [];
          var n3 = $2(this);
          Y2(this, e3, t3, n3).split(/\s+/g).forEach(function(e4) {
            r2(this).hasClass(e4) || i2.push(e4);
          }, this), i2.length && $2(this, n3 + (n3 ? " " : "") + i2.join(" "));
        }
      }) : this;
    }, removeClass: function(t3) {
      return this.each(function(r3) {
        if ("className" in this) {
          if (t3 === e2)
            return $2(this, "");
          i2 = $2(this), Y2(this, t3, r3, i2).split(/\s+/g).forEach(function(e3) {
            i2 = i2.replace(U2(e3), " ");
          }), $2(this, i2.trim());
        }
      });
    }, toggleClass: function(t3, i3) {
      return t3 ? this.each(function(n3) {
        var a3 = r2(this);
        Y2(this, t3, n3, $2(this)).split(/\s+/g).forEach(function(t4) {
          (i3 === e2 ? !a3.hasClass(t4) : i3) ? a3.addClass(t4) : a3.removeClass(t4);
        });
      }) : this;
    }, scrollTop: function(t3) {
      if (this.length) {
        var r3 = "scrollTop" in this[0];
        return t3 === e2 ? r3 ? this[0].scrollTop : this[0].pageYOffset : this.each(r3 ? function() {
          this.scrollTop = t3;
        } : function() {
          this.scrollTo(this.scrollX, t3);
        });
      }
    }, scrollLeft: function(t3) {
      if (this.length) {
        var r3 = "scrollLeft" in this[0];
        return t3 === e2 ? r3 ? this[0].scrollLeft : this[0].pageXOffset : this.each(r3 ? function() {
          this.scrollLeft = t3;
        } : function() {
          this.scrollTo(t3, this.scrollY);
        });
      }
    }, position: function() {
      if (this.length) {
        var e3 = this[0], t3 = this.offsetParent(), i3 = this.offset(), n3 = m2.test(t3[0].nodeName) ? { top: 0, left: 0 } : t3.offset();
        return i3.top -= parseFloat(r2(e3).css("margin-top")) || 0, i3.left -= parseFloat(r2(e3).css("margin-left")) || 0, n3.top += parseFloat(r2(t3[0]).css("border-top-width")) || 0, n3.left += parseFloat(r2(t3[0]).css("border-left-width")) || 0, { top: i3.top - n3.top, left: i3.left - n3.left };
      }
    }, offsetParent: function() {
      return this.map(function() {
        for (var e3 = this.offsetParent || c2.body; e3 && !m2.test(e3.nodeName) && "static" == r2(e3).css("position"); )
          e3 = e3.offsetParent;
        return e3;
      });
    } }, r2.fn.detach = r2.fn.remove, ["width", "height"].forEach(function(t3) {
      var i3 = t3.replace(/./, function(e3) {
        return e3[0].toUpperCase();
      });
      r2.fn[t3] = function(n3) {
        var a3, s3 = this[0];
        return n3 === e2 ? P2(s3) ? s3["inner" + i3] : x2(s3) ? s3.documentElement["scroll" + i3] : (a3 = this.offset()) && a3[t3] : this.each(function(e3) {
          (s3 = r2(this)).css(t3, Y2(this, n3, e3, s3[t3]()));
        });
      };
    }), ["after", "prepend", "before", "append"].forEach(function(t3, i3) {
      var n3 = i3 % 2;
      r2.fn[t3] = function() {
        var t4, a3, s3 = r2.map(arguments, function(i4) {
          var n4 = [];
          return "array" == (t4 = O2(i4)) ? (i4.forEach(function(t5) {
            return t5.nodeType !== e2 ? n4.push(t5) : r2.zepto.isZ(t5) ? n4 = n4.concat(t5.get()) : void (n4 = n4.concat(L2.fragment(t5)));
          }), n4) : "object" == t4 || null == i4 ? i4 : L2.fragment(i4);
        }), o3 = this.length > 1;
        return s3.length < 1 ? this : this.each(function(e3, t5) {
          a3 = n3 ? t5 : t5.parentNode, t5 = 0 == i3 ? t5.nextSibling : 1 == i3 ? t5.firstChild : 2 == i3 ? t5 : null;
          var l3 = r2.contains(c2.documentElement, a3);
          s3.forEach(function(e4) {
            if (o3)
              e4 = e4.cloneNode(true);
            else if (!a3)
              return r2(e4).remove();
            a3.insertBefore(e4, t5), l3 && q2(e4, function(e5) {
              if (!(null == e5.nodeName || "SCRIPT" !== e5.nodeName.toUpperCase() || e5.type && "text/javascript" !== e5.type || e5.src)) {
                var t6 = e5.ownerDocument ? e5.ownerDocument.defaultView : window;
                t6.eval.call(t6, e5.innerHTML);
              }
            });
          });
        });
      }, r2.fn[n3 ? t3 + "To" : "insert" + (i3 ? "Before" : "After")] = function(e3) {
        return r2(e3)[t3](this), this;
      };
    }), L2.Z.prototype = K2.prototype = r2.fn, L2.uniq = a2, L2.deserializeValue = z2, r2.zepto = L2, r2;
  }();
  window.Zepto = _, void 0 === window.$ && (window.$ = _), function(e2) {
    var t2, r2, i2 = +/* @__PURE__ */ new Date(), n2 = window.document, a2 = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, s2 = /^(?:text|application)\/javascript/i, o2 = /^(?:text|application)\/xml/i, l2 = "application/json", u2 = "text/html", c2 = /^\s*$/, d2 = n2.createElement("a");
    function h2(t3, r3, i3, a3) {
      if (t3.global)
        return function(t4, r4, i4) {
          var n3 = e2.Event(r4);
          return e2(t4).trigger(n3, i4), !n3.isDefaultPrevented();
        }(r3 || n2, i3, a3);
    }
    function f2(e3, t3) {
      var r3 = t3.context;
      if (false === t3.beforeSend.call(r3, e3, t3) || false === h2(t3, r3, "ajaxBeforeSend", [e3, t3]))
        return false;
      h2(t3, r3, "ajaxSend", [e3, t3]);
    }
    function p2(e3, t3, r3, i3) {
      var n3 = r3.context, a3 = "success";
      r3.success.call(n3, e3, a3, t3), i3 && i3.resolveWith(n3, [e3, a3, t3]), h2(r3, n3, "ajaxSuccess", [t3, r3, e3]), v2(a3, t3, r3);
    }
    function g2(e3, t3, r3, i3, n3) {
      var a3 = i3.context;
      i3.error.call(a3, r3, t3, e3), n3 && n3.rejectWith(a3, [r3, t3, e3]), h2(i3, a3, "ajaxError", [r3, i3, e3 || t3]), v2(t3, r3, i3);
    }
    function v2(t3, r3, i3) {
      var n3 = i3.context;
      i3.complete.call(n3, r3, t3), h2(i3, n3, "ajaxComplete", [r3, i3]), function(t4) {
        t4.global && !--e2.active && h2(t4, null, "ajaxStop");
      }(i3);
    }
    function m2() {
    }
    function y2(e3, t3) {
      return "" == t3 ? e3 : (e3 + "&" + t3).replace(/[&?]{1,2}/, "?");
    }
    function A2(t3, r3, i3, n3) {
      return e2.isFunction(r3) && (n3 = i3, i3 = r3, r3 = void 0), e2.isFunction(i3) || (n3 = i3, i3 = void 0), { url: t3, data: r3, success: i3, dataType: n3 };
    }
    d2.href = window.location.href, e2.active = 0, e2.ajaxJSONP = function(t3, r3) {
      if (!("type" in t3))
        return e2.ajax(t3);
      var a3, s3, o3 = t3.jsonpCallback, l3 = (e2.isFunction(o3) ? o3() : o3) || "Zepto" + i2++, u3 = n2.createElement("script"), c3 = window[l3], d3 = function(t4) {
        e2(u3).triggerHandler("error", t4 || "abort");
      }, h3 = { abort: d3 };
      return r3 && r3.promise(h3), e2(u3).on("load error", function(i3, n3) {
        clearTimeout(s3), e2(u3).off().remove(), "error" != i3.type && a3 ? p2(a3[0], h3, t3, r3) : g2(null, n3 || "error", h3, t3, r3), window[l3] = c3, a3 && e2.isFunction(c3) && c3(a3[0]), c3 = a3 = void 0;
      }), false === f2(h3, t3) ? (d3("abort"), h3) : (window[l3] = function() {
        a3 = arguments;
      }, u3.src = t3.url.replace(/\?(.+)=\?/, "?$1=" + l3), n2.head.appendChild(u3), t3.timeout > 0 && (s3 = setTimeout(function() {
        d3("timeout");
      }, t3.timeout)), h3);
    }, e2.ajaxSettings = { type: "GET", beforeSend: m2, success: m2, error: m2, complete: m2, context: null, global: true, xhr: function() {
      return new window.XMLHttpRequest();
    }, accepts: { script: "text/javascript, application/javascript, application/x-javascript", json: l2, xml: "application/xml, text/xml", html: u2, text: "text/plain" }, crossDomain: false, timeout: 0, processData: true, cache: true, dataFilter: m2 }, e2.ajax = function(i3) {
      var a3, v3, A3 = e2.extend({}, i3 || {}), E3 = e2.Deferred && e2.Deferred();
      for (t2 in e2.ajaxSettings)
        void 0 === A3[t2] && (A3[t2] = e2.ajaxSettings[t2]);
      !function(t3) {
        t3.global && 0 == e2.active++ && h2(t3, null, "ajaxStart");
      }(A3), A3.crossDomain || ((a3 = n2.createElement("a")).href = A3.url, a3.href = a3.href, A3.crossDomain = d2.protocol + "//" + d2.host != a3.protocol + "//" + a3.host), A3.url || (A3.url = window.location.toString()), (v3 = A3.url.indexOf("#")) > -1 && (A3.url = A3.url.slice(0, v3)), function(t3) {
        t3.processData && t3.data && "string" != e2.type(t3.data) && (t3.data = e2.param(t3.data, t3.traditional)), !t3.data || t3.type && "GET" != t3.type.toUpperCase() && "jsonp" != t3.dataType || (t3.url = y2(t3.url, t3.data), t3.data = void 0);
      }(A3);
      var T3 = A3.dataType, b2 = /\?.+=\?/.test(A3.url);
      if (b2 && (T3 = "jsonp"), false !== A3.cache && (i3 && true === i3.cache || "script" != T3 && "jsonp" != T3) || (A3.url = y2(A3.url, "_=" + Date.now())), "jsonp" == T3)
        return b2 || (A3.url = y2(A3.url, A3.jsonp ? A3.jsonp + "=?" : false === A3.jsonp ? "" : "callback=?")), e2.ajaxJSONP(A3, E3);
      var k2, S2 = A3.accepts[T3], _2 = {}, C2 = function(e3, t3) {
        _2[e3.toLowerCase()] = [e3, t3];
      }, L2 = /^([\w-]+:)\/\//.test(A3.url) ? RegExp.$1 : window.location.protocol, D2 = A3.xhr(), R2 = D2.setRequestHeader;
      if (E3 && E3.promise(D2), A3.crossDomain || C2("X-Requested-With", "XMLHttpRequest"), C2("Accept", S2 || "*/*"), (S2 = A3.mimeType || S2) && (S2.indexOf(",") > -1 && (S2 = S2.split(",", 2)[0]), D2.overrideMimeType && D2.overrideMimeType(S2)), (A3.contentType || false !== A3.contentType && A3.data && "GET" != A3.type.toUpperCase()) && C2("Content-Type", A3.contentType || "application/x-www-form-urlencoded"), A3.headers)
        for (r2 in A3.headers)
          C2(r2, A3.headers[r2]);
      if (D2.setRequestHeader = C2, D2.onreadystatechange = function() {
        if (4 == D2.readyState) {
          D2.onreadystatechange = m2, clearTimeout(k2);
          var t3, r3 = false;
          if (D2.status >= 200 && D2.status < 300 || 304 == D2.status || 0 == D2.status && "file:" == L2) {
            if (T3 = T3 || function(e3) {
              return e3 && (e3 = e3.split(";", 2)[0]), e3 && (e3 == u2 ? "html" : e3 == l2 ? "json" : s2.test(e3) ? "script" : o2.test(e3) && "xml") || "text";
            }(A3.mimeType || D2.getResponseHeader("content-type")), "arraybuffer" == D2.responseType || "blob" == D2.responseType)
              t3 = D2.response;
            else {
              t3 = D2.responseText;
              try {
                t3 = function(e3, t4, r4) {
                  if (r4.dataFilter == m2)
                    return e3;
                  var i4 = r4.context;
                  return r4.dataFilter.call(i4, e3, t4);
                }(t3, T3, A3), "script" == T3 ? (0, eval)(t3) : "xml" == T3 ? t3 = D2.responseXML : "json" == T3 && (t3 = c2.test(t3) ? null : e2.parseJSON(t3));
              } catch (e3) {
                r3 = e3;
              }
              if (r3)
                return g2(r3, "parsererror", D2, A3, E3);
            }
            p2(t3, D2, A3, E3);
          } else
            g2(D2.statusText || null, D2.status ? "error" : "abort", D2, A3, E3);
        }
      }, false === f2(D2, A3))
        return D2.abort(), g2(null, "abort", D2, A3, E3), D2;
      var I2 = !("async" in A3) || A3.async;
      if (D2.open(A3.type, A3.url, I2, A3.username, A3.password), A3.xhrFields)
        for (r2 in A3.xhrFields)
          D2[r2] = A3.xhrFields[r2];
      for (r2 in _2)
        R2.apply(D2, _2[r2]);
      return A3.timeout > 0 && (k2 = setTimeout(function() {
        D2.onreadystatechange = m2, D2.abort(), g2(null, "timeout", D2, A3, E3);
      }, A3.timeout)), D2.send(A3.data ? A3.data : null), D2;
    }, e2.get = function() {
      return e2.ajax(A2.apply(null, arguments));
    }, e2.post = function() {
      var t3 = A2.apply(null, arguments);
      return t3.type = "POST", e2.ajax(t3);
    }, e2.getJSON = function() {
      var t3 = A2.apply(null, arguments);
      return t3.dataType = "json", e2.ajax(t3);
    }, e2.fn.load = function(t3, r3, i3) {
      if (!this.length)
        return this;
      var n3, s3 = this, o3 = t3.split(/\s/), l3 = A2(t3, r3, i3), u3 = l3.success;
      return o3.length > 1 && (l3.url = o3[0], n3 = o3[1]), l3.success = function(t4) {
        s3.html(n3 ? e2("<div>").html(t4.replace(a2, "")).find(n3) : t4), u3 && u3.apply(s3, arguments);
      }, e2.ajax(l3), this;
    };
    var E2 = encodeURIComponent;
    function T2(t3, r3, i3, n3) {
      var a3, s3 = e2.isArray(r3), o3 = e2.isPlainObject(r3);
      e2.each(r3, function(r4, l3) {
        a3 = e2.type(l3), n3 && (r4 = i3 ? n3 : n3 + "[" + (o3 || "object" == a3 || "array" == a3 ? r4 : "") + "]"), !n3 && s3 ? t3.add(l3.name, l3.value) : "array" == a3 || !i3 && "object" == a3 ? T2(t3, l3, i3, r4) : t3.add(r4, l3);
      });
    }
    e2.param = function(t3, r3) {
      var i3 = [];
      return i3.add = function(t4, r4) {
        e2.isFunction(r4) && (r4 = r4()), null == r4 && (r4 = ""), this.push(E2(t4) + "=" + E2(r4));
      }, T2(i3, t3, r3), i3.join("&").replace(/%20/g, "+");
    };
  }(_), (k = _).Callbacks = function(e2) {
    e2 = k.extend({}, e2);
    var t2, r2, i2, n2, a2, s2, o2 = [], l2 = !e2.once && [], u2 = function(d2) {
      for (t2 = e2.memory && d2, r2 = true, s2 = n2 || 0, n2 = 0, a2 = o2.length, i2 = true; o2 && s2 < a2; ++s2)
        if (false === o2[s2].apply(d2[0], d2[1]) && e2.stopOnFalse) {
          t2 = false;
          break;
        }
      i2 = false, o2 && (l2 ? l2.length && u2(l2.shift()) : t2 ? o2.length = 0 : c2.disable());
    }, c2 = { add: function() {
      if (o2) {
        var r3 = o2.length, s3 = function(t3) {
          k.each(t3, function(t4, r4) {
            "function" == typeof r4 ? e2.unique && c2.has(r4) || o2.push(r4) : r4 && r4.length && "string" != typeof r4 && s3(r4);
          });
        };
        s3(arguments), i2 ? a2 = o2.length : t2 && (n2 = r3, u2(t2));
      }
      return this;
    }, remove: function() {
      return o2 && k.each(arguments, function(e3, t3) {
        for (var r3; (r3 = k.inArray(t3, o2, r3)) > -1; )
          o2.splice(r3, 1), i2 && (r3 <= a2 && --a2, r3 <= s2 && --s2);
      }), this;
    }, has: function(e3) {
      return !(!o2 || !(e3 ? k.inArray(e3, o2) > -1 : o2.length));
    }, empty: function() {
      return a2 = o2.length = 0, this;
    }, disable: function() {
      return o2 = l2 = t2 = void 0, this;
    }, disabled: function() {
      return !o2;
    }, lock: function() {
      return l2 = void 0, t2 || c2.disable(), this;
    }, locked: function() {
      return !l2;
    }, fireWith: function(e3, t3) {
      return !o2 || r2 && !l2 || (t3 = [e3, (t3 = t3 || []).slice ? t3.slice() : t3], i2 ? l2.push(t3) : u2(t3)), this;
    }, fire: function() {
      return c2.fireWith(this, arguments);
    }, fired: function() {
      return !!r2;
    } };
    return c2;
  }, function(e2) {
    var t2 = Array.prototype.slice;
    function r2(t3) {
      var i2 = [["resolve", "done", e2.Callbacks({ once: 1, memory: 1 }), "resolved"], ["reject", "fail", e2.Callbacks({ once: 1, memory: 1 }), "rejected"], ["notify", "progress", e2.Callbacks({ memory: 1 })]], n2 = "pending", a2 = { state: function() {
        return n2;
      }, always: function() {
        return s2.done(arguments).fail(arguments), this;
      }, then: function() {
        var t4 = arguments;
        return r2(function(r3) {
          e2.each(i2, function(i3, n3) {
            var o2 = e2.isFunction(t4[i3]) && t4[i3];
            s2[n3[1]](function() {
              var t5 = o2 && o2.apply(this, arguments);
              if (t5 && e2.isFunction(t5.promise))
                t5.promise().done(r3.resolve).fail(r3.reject).progress(r3.notify);
              else {
                var i4 = this === a2 ? r3.promise() : this, s3 = o2 ? [t5] : arguments;
                r3[n3[0] + "With"](i4, s3);
              }
            });
          }), t4 = null;
        }).promise();
      }, promise: function(t4) {
        return null != t4 ? e2.extend(t4, a2) : a2;
      } }, s2 = {};
      return e2.each(i2, function(e3, t4) {
        var r3 = t4[2], o2 = t4[3];
        a2[t4[1]] = r3.add, o2 && r3.add(function() {
          n2 = o2;
        }, i2[1 ^ e3][2].disable, i2[2][2].lock), s2[t4[0]] = function() {
          return s2[t4[0] + "With"](this === s2 ? a2 : this, arguments), this;
        }, s2[t4[0] + "With"] = r3.fireWith;
      }), a2.promise(s2), t3 && t3.call(s2, s2), s2;
    }
    e2.when = function(i2) {
      var n2, a2, s2, o2 = t2.call(arguments), l2 = o2.length, u2 = 0, c2 = 1 !== l2 || i2 && e2.isFunction(i2.promise) ? l2 : 0, d2 = 1 === c2 ? i2 : r2(), h2 = function(e3, r3, i3) {
        return function(a3) {
          r3[e3] = this, i3[e3] = arguments.length > 1 ? t2.call(arguments) : a3, i3 === n2 ? d2.notifyWith(r3, i3) : --c2 || d2.resolveWith(r3, i3);
        };
      };
      if (l2 > 1)
        for (n2 = new Array(l2), a2 = new Array(l2), s2 = new Array(l2); u2 < l2; ++u2)
          o2[u2] && e2.isFunction(o2[u2].promise) ? o2[u2].promise().done(h2(u2, s2, o2)).fail(d2.reject).progress(h2(u2, a2, n2)) : --c2;
      return c2 || d2.resolveWith(s2, o2), d2.promise();
    }, e2.Deferred = r2;
  }(_), function(e2) {
    var t2, r2 = 1, i2 = Array.prototype.slice, n2 = e2.isFunction, a2 = function(e3) {
      return "string" == typeof e3;
    }, s2 = {}, o2 = {}, l2 = "onfocusin" in window, u2 = { focus: "focusin", blur: "focusout" }, c2 = { mouseenter: "mouseover", mouseleave: "mouseout" };
    function d2(e3) {
      return e3._zid || (e3._zid = r2++);
    }
    function h2(e3, t3, r3, i3) {
      if ((t3 = f2(t3)).ns)
        var n3 = (a3 = t3.ns, new RegExp("(?:^| )" + a3.replace(" ", " .* ?") + "(?: |$)"));
      var a3;
      return (s2[d2(e3)] || []).filter(function(e4) {
        return e4 && (!t3.e || e4.e == t3.e) && (!t3.ns || n3.test(e4.ns)) && (!r3 || d2(e4.fn) === d2(r3)) && (!i3 || e4.sel == i3);
      });
    }
    function f2(e3) {
      var t3 = ("" + e3).split(".");
      return { e: t3[0], ns: t3.slice(1).sort().join(" ") };
    }
    function p2(e3, t3) {
      return e3.del && !l2 && e3.e in u2 || !!t3;
    }
    function g2(e3) {
      return c2[e3] || l2 && u2[e3] || e3;
    }
    function v2(r3, i3, n3, a3, o3, l3, u3) {
      var h3 = d2(r3), v3 = s2[h3] || (s2[h3] = []);
      i3.split(/\s/).forEach(function(i4) {
        if ("ready" == i4)
          return e2(document).ready(n3);
        var s3 = f2(i4);
        s3.fn = n3, s3.sel = o3, s3.e in c2 && (n3 = function(t3) {
          var r4 = t3.relatedTarget;
          if (!r4 || r4 !== this && !e2.contains(this, r4))
            return s3.fn.apply(this, arguments);
        }), s3.del = l3;
        var d3 = l3 || n3;
        s3.proxy = function(e3) {
          if (!(e3 = b2(e3)).isImmediatePropagationStopped()) {
            e3.data = a3;
            var i5 = d3.apply(r3, e3._args == t2 ? [e3] : [e3].concat(e3._args));
            return false === i5 && (e3.preventDefault(), e3.stopPropagation()), i5;
          }
        }, s3.i = v3.length, v3.push(s3), "addEventListener" in r3 && r3.addEventListener(g2(s3.e), s3.proxy, p2(s3, u3));
      });
    }
    function m2(e3, t3, r3, i3, n3) {
      var a3 = d2(e3);
      (t3 || "").split(/\s/).forEach(function(t4) {
        h2(e3, t4, r3, i3).forEach(function(t5) {
          delete s2[a3][t5.i], "removeEventListener" in e3 && e3.removeEventListener(g2(t5.e), t5.proxy, p2(t5, n3));
        });
      });
    }
    o2.click = o2.mousedown = o2.mouseup = o2.mousemove = "MouseEvents", e2.event = { add: v2, remove: m2 }, e2.proxy = function(t3, r3) {
      var s3 = 2 in arguments && i2.call(arguments, 2);
      if (n2(t3)) {
        var o3 = function() {
          return t3.apply(r3, s3 ? s3.concat(i2.call(arguments)) : arguments);
        };
        return o3._zid = d2(t3), o3;
      }
      if (a2(r3))
        return s3 ? (s3.unshift(t3[r3], t3), e2.proxy.apply(null, s3)) : e2.proxy(t3[r3], t3);
      throw new TypeError("expected function");
    }, e2.fn.bind = function(e3, t3, r3) {
      return this.on(e3, t3, r3);
    }, e2.fn.unbind = function(e3, t3) {
      return this.off(e3, t3);
    }, e2.fn.one = function(e3, t3, r3, i3) {
      return this.on(e3, t3, r3, i3, 1);
    };
    var y2 = function() {
      return true;
    }, A2 = function() {
      return false;
    }, E2 = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/, T2 = { preventDefault: "isDefaultPrevented", stopImmediatePropagation: "isImmediatePropagationStopped", stopPropagation: "isPropagationStopped" };
    function b2(r3, i3) {
      return !i3 && r3.isDefaultPrevented || (i3 || (i3 = r3), e2.each(T2, function(e3, t3) {
        var n3 = i3[e3];
        r3[e3] = function() {
          return this[t3] = y2, n3 && n3.apply(i3, arguments);
        }, r3[t3] = A2;
      }), r3.timeStamp || (r3.timeStamp = Date.now()), (i3.defaultPrevented !== t2 ? i3.defaultPrevented : "returnValue" in i3 ? false === i3.returnValue : i3.getPreventDefault && i3.getPreventDefault()) && (r3.isDefaultPrevented = y2)), r3;
    }
    function k2(e3) {
      var r3, i3 = { originalEvent: e3 };
      for (r3 in e3)
        E2.test(r3) || e3[r3] === t2 || (i3[r3] = e3[r3]);
      return b2(i3, e3);
    }
    e2.fn.delegate = function(e3, t3, r3) {
      return this.on(t3, e3, r3);
    }, e2.fn.undelegate = function(e3, t3, r3) {
      return this.off(t3, e3, r3);
    }, e2.fn.live = function(t3, r3) {
      return e2(document.body).delegate(this.selector, t3, r3), this;
    }, e2.fn.die = function(t3, r3) {
      return e2(document.body).undelegate(this.selector, t3, r3), this;
    }, e2.fn.on = function(r3, s3, o3, l3, u3) {
      var c3, d3, h3 = this;
      return r3 && !a2(r3) ? (e2.each(r3, function(e3, t3) {
        h3.on(e3, s3, o3, t3, u3);
      }), h3) : (a2(s3) || n2(l3) || false === l3 || (l3 = o3, o3 = s3, s3 = t2), l3 !== t2 && false !== o3 || (l3 = o3, o3 = t2), false === l3 && (l3 = A2), h3.each(function(t3, n3) {
        u3 && (c3 = function(e3) {
          return m2(n3, e3.type, l3), l3.apply(this, arguments);
        }), s3 && (d3 = function(t4) {
          var r4, a3 = e2(t4.target).closest(s3, n3).get(0);
          if (a3 && a3 !== n3)
            return r4 = e2.extend(k2(t4), { currentTarget: a3, liveFired: n3 }), (c3 || l3).apply(a3, [r4].concat(i2.call(arguments, 1)));
        }), v2(n3, r3, l3, o3, s3, d3 || c3);
      }));
    }, e2.fn.off = function(r3, i3, s3) {
      var o3 = this;
      return r3 && !a2(r3) ? (e2.each(r3, function(e3, t3) {
        o3.off(e3, i3, t3);
      }), o3) : (a2(i3) || n2(s3) || false === s3 || (s3 = i3, i3 = t2), false === s3 && (s3 = A2), o3.each(function() {
        m2(this, r3, s3, i3);
      }));
    }, e2.fn.trigger = function(t3, r3) {
      return (t3 = a2(t3) || e2.isPlainObject(t3) ? e2.Event(t3) : b2(t3))._args = r3, this.each(function() {
        t3.type in u2 && "function" == typeof this[t3.type] ? this[t3.type]() : "dispatchEvent" in this ? this.dispatchEvent(t3) : e2(this).triggerHandler(t3, r3);
      });
    }, e2.fn.triggerHandler = function(t3, r3) {
      var i3, n3;
      return this.each(function(s3, o3) {
        (i3 = k2(a2(t3) ? e2.Event(t3) : t3))._args = r3, i3.target = o3, e2.each(h2(o3, t3.type || t3), function(e3, t4) {
          if (n3 = t4.proxy(i3), i3.isImmediatePropagationStopped())
            return false;
        });
      }), n3;
    }, "focusin focusout focus blur load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select keydown keypress keyup error".split(" ").forEach(function(t3) {
      e2.fn[t3] = function(e3) {
        return 0 in arguments ? this.bind(t3, e3) : this.trigger(t3);
      };
    }), e2.Event = function(e3, t3) {
      a2(e3) || (e3 = (t3 = e3).type);
      var r3 = document.createEvent(o2[e3] || "Events"), i3 = true;
      if (t3)
        for (var n3 in t3)
          "bubbles" == n3 ? i3 = !!t3[n3] : r3[n3] = t3[n3];
      return r3.initEvent(e3, i3, true), b2(r3);
    };
  }(_), function() {
    try {
      getComputedStyle(void 0);
    } catch (t2) {
      var e2 = getComputedStyle;
      window.getComputedStyle = function(t3, r2) {
        try {
          return e2(t3, r2);
        } catch (e3) {
          return null;
        }
      };
    }
  }(), function(e2) {
    var t2 = e2.zepto, r2 = t2.qsa, i2 = t2.matches;
    function n2(t3) {
      return !(!(t3 = e2(t3)).width() && !t3.height()) && "none" !== t3.css("display");
    }
    var a2 = e2.expr[":"] = { visible: function() {
      if (n2(this))
        return this;
    }, hidden: function() {
      if (!n2(this))
        return this;
    }, selected: function() {
      if (this.selected)
        return this;
    }, checked: function() {
      if (this.checked)
        return this;
    }, parent: function() {
      return this.parentNode;
    }, first: function(e3) {
      if (0 === e3)
        return this;
    }, last: function(e3, t3) {
      if (e3 === t3.length - 1)
        return this;
    }, eq: function(e3, t3, r3) {
      if (e3 === r3)
        return this;
    }, contains: function(t3, r3, i3) {
      if (e2(this).text().indexOf(i3) > -1)
        return this;
    }, has: function(e3, r3, i3) {
      if (t2.qsa(this, i3).length)
        return this;
    } }, s2 = new RegExp("(.*):(\\w+)(?:\\(([^)]+)\\))?$\\s*"), o2 = /^\s*>/, l2 = "Zepto" + +/* @__PURE__ */ new Date();
    function u2(e3, t3) {
      e3 = e3.replace(/=#\]/g, '="#"]');
      var r3, i3, n3 = s2.exec(e3);
      if (n3 && n3[2] in a2 && (r3 = a2[n3[2]], i3 = n3[3], e3 = n3[1], i3)) {
        var o3 = Number(i3);
        i3 = isNaN(o3) ? i3.replace(/^["']|["']$/g, "") : o3;
      }
      return t3(e3, r3, i3);
    }
    t2.qsa = function(i3, n3) {
      return u2(n3, function(a3, s3, u3) {
        try {
          var c2;
          !a3 && s3 ? a3 = "*" : o2.test(a3) && (c2 = e2(i3).addClass(l2), a3 = "." + l2 + " " + a3);
          var d2 = r2(i3, a3);
        } catch (e3) {
          throw console.error("error performing selector: %o", n3), e3;
        } finally {
          c2 && c2.removeClass(l2);
        }
        return s3 ? t2.uniq(e2.map(d2, function(e3, t3) {
          return s3.call(e3, t3, d2, u3);
        })) : d2;
      });
    }, t2.matches = function(e3, t3) {
      return u2(t3, function(t4, r3, n3) {
        return (!t4 || i2(e3, t4)) && (!r3 || r3.call(e3, null, n3) === e3);
      });
    };
  }(_);
  var C, L, D, R = _, I = [{ name: "Chromium", group: "Chrome", identifier: "Chromium/([0-9.]*)" }, { name: "Chrome Mobile", group: "Chrome", identifier: "Chrome/([0-9.]*) Mobile", versionIdentifier: "Chrome/([0-9.]*)" }, { name: "Chrome", group: "Chrome", identifier: "Chrome/([0-9.]*)" }, { name: "Chrome for iOS", group: "Chrome", identifier: "CriOS/([0-9.]*)" }, { name: "Android Browser", group: "Chrome", identifier: "CrMo/([0-9.]*)" }, { name: "Firefox", group: "Firefox", identifier: "Firefox/([0-9.]*)" }, { name: "Opera Mini", group: "Opera", identifier: "Opera Mini/([0-9.]*)" }, { name: "Opera", group: "Opera", identifier: "Opera ([0-9.]*)" }, { name: "Opera", group: "Opera", identifier: "Opera/([0-9.]*)", versionIdentifier: "Version/([0-9.]*)" }, { name: "IEMobile", group: "Explorer", identifier: "IEMobile/([0-9.]*)" }, { name: "Internet Explorer", group: "Explorer", identifier: "MSIE ([a-zA-Z0-9.]*)" }, { name: "Internet Explorer", group: "Explorer", identifier: "Trident/([0-9.]*)", versionIdentifier: "rv:([0-9.]*)" }, { name: "Spartan", group: "Spartan", identifier: "Edge/([0-9.]*)", versionIdentifier: "Edge/([0-9.]*)" }, { name: "Safari", group: "Safari", identifier: "Safari/([0-9.]*)", versionIdentifier: "Version/([0-9.]*)" }], O = [{ name: "Windows 2000", group: "Windows", identifier: "Windows NT 5.0", version: "5.0" }, { name: "Windows XP", group: "Windows", identifier: "Windows NT 5.1", version: "5.1" }, { name: "Windows Vista", group: "Windows", identifier: "Windows NT 6.0", version: "6.0" }, { name: "Windows 7", group: "Windows", identifier: "Windows NT 6.1", version: "7.0" }, { name: "Windows 8", group: "Windows", identifier: "Windows NT 6.2", version: "8.0" }, { name: "Windows 8.1", group: "Windows", identifier: "Windows NT 6.3", version: "8.1" }, { name: "Windows 10", group: "Windows", identifier: "Windows NT 10.0", version: "10.0" }, { name: "Windows Phone", group: "Windows Phone", identifier: "Windows Phone ([0-9.]*)" }, { name: "Windows Phone", group: "Windows Phone", identifier: "Windows Phone OS ([0-9.]*)" }, { name: "Windows", group: "Windows", identifier: "Windows" }, { name: "Chrome OS", group: "Chrome OS", identifier: "CrOS" }, { name: "Android", group: "Android", identifier: "Android", versionIdentifier: "Android ([a-zA-Z0-9.-]*)" }, { name: "iPad", group: "iOS", identifier: "iPad", versionIdentifier: "OS ([0-9_]*)", versionSeparator: "[_|.]" }, { name: "iPod", group: "iOS", identifier: "iPod", versionIdentifier: "OS ([0-9_]*)", versionSeparator: "[_|.]" }, { name: "iPhone", group: "iOS", identifier: "iPhone OS", versionIdentifier: "OS ([0-9_]*)", versionSeparator: "[_|.]" }, { name: "Mac OS X High Sierra", group: "Mac OS", identifier: "Mac OS X (10([_|.])13([0-9_.]*))", versionSeparator: "[_|.]" }, { name: "Mac OS X Sierra", group: "Mac OS", identifier: "Mac OS X (10([_|.])12([0-9_.]*))", versionSeparator: "[_|.]" }, { name: "Mac OS X El Capitan", group: "Mac OS", identifier: "Mac OS X (10([_|.])11([0-9_.]*))", versionSeparator: "[_|.]" }, { name: "Mac OS X Yosemite", group: "Mac OS", identifier: "Mac OS X (10([_|.])10([0-9_.]*))", versionSeparator: "[_|.]" }, { name: "Mac OS X Mavericks", group: "Mac OS", identifier: "Mac OS X (10([_|.])9([0-9_.]*))", versionSeparator: "[_|.]" }, { name: "Mac OS X Mountain Lion", group: "Mac OS", identifier: "Mac OS X (10([_|.])8([0-9_.]*))", versionSeparator: "[_|.]" }, { name: "Mac OS X Lion", group: "Mac OS", identifier: "Mac OS X (10([_|.])7([0-9_.]*))", versionSeparator: "[_|.]" }, { name: "Mac OS X Snow Leopard", group: "Mac OS", identifier: "Mac OS X (10([_|.])6([0-9_.]*))", versionSeparator: "[_|.]" }, { name: "Mac OS X Leopard", group: "Mac OS", identifier: "Mac OS X (10([_|.])5([0-9_.]*))", versionSeparator: "[_|.]" }, { name: "Mac OS X Tiger", group: "Mac OS", identifier: "Mac OS X (10([_|.])4([0-9_.]*))", versionSeparator: "[_|.]" }, { name: "Mac OS X Panther", group: "Mac OS", identifier: "Mac OS X (10([_|.])3([0-9_.]*))", versionSeparator: "[_|.]" }, { name: "Mac OS X Jaguar", group: "Mac OS", identifier: "Mac OS X (10([_|.])2([0-9_.]*))", versionSeparator: "[_|.]" }, { name: "Mac OS X Puma", group: "Mac OS", identifier: "Mac OS X (10([_|.])1([0-9_.]*))", versionSeparator: "[_|.]" }, { name: "Mac OS X Cheetah", group: "Mac OS", identifier: "Mac OS X (10([_|.])0([0-9_.]*))", versionSeparator: "[_|.]" }, { name: "Mac OS", group: "Mac OS", identifier: "Mac OS" }, { name: "Ubuntu", group: "Linux", identifier: "Ubuntu", versionIdentifier: "Ubuntu/([0-9.]*)" }, { name: "Debian", group: "Linux", identifier: "Debian" }, { name: "Gentoo", group: "Linux", identifier: "Gentoo" }, { name: "Linux", group: "Linux", identifier: "Linux" }, { name: "BlackBerry", group: "BlackBerry", identifier: "BlackBerry" }], w = {}, P = function(e2, t2) {
    var r2 = e2.split(".", 2);
    t2.fullVersion = e2, r2[0] && (t2.majorVersion = parseInt(r2[0])), r2[1] && (t2.minorVersion = parseInt(r2[1]));
  }, x = function(e2, t2, r2) {
    var i2 = "[" == t2.substr(0, 1) ? new RegExp(t2, "g") : t2, n2 = e2.split(i2, 2);
    "." != t2 && (e2 = e2.replace(new RegExp(t2, "g"), ".")), r2.fullVersion = e2, n2 && n2[0] && (r2.majorVersion = parseInt(n2[0])), n2 && n2[1] && (r2.minorVersion = parseInt(n2[1]));
  }, N = function(e2) {
    var t2, r2 = e2.match(/\b(playstation 4|nx|opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if (/trident/i.test(r2[1]))
      return t2 = /\brv[ :]+(\d+)/g.exec(e2) || [], { name: "IE", version: parseInt(t2[1] || "") };
    if ("Chrome" === r2[1]) {
      if (null != (t2 = e2.match(/\bOPR\/(\d+)/)))
        return { name: "Opera", version: parseInt(t2[1]) };
      if (null != (t2 = e2.match(/\bEdge\/(\d+)/)))
        return { name: "Edge", version: parseInt(t2[1]) };
    } else
      /android/i.test(e2) && (t2 = e2.match(/version\/(\d+)/i)) && (r2.splice(1, 1, "Android WebView"), r2.splice(2, 1, t2[1]));
    return { name: (r2 = r2[2] ? [r2[1], r2[2]] : [navigator.appName, navigator.appVersion, "-?"])[0], version: parseInt(r2[1]) };
  }(navigator.userAgent);
  w.isEdge = /Edg|EdgiOS|EdgA/i.test(navigator.userAgent), w.isChrome = /Chrome|CriOS/i.test(navigator.userAgent) && !w.isEdge, w.isSafari = /Safari/i.test(navigator.userAgent) && !w.isChrome && !w.isEdge, w.isFirefox = /Firefox/i.test(navigator.userAgent), w.isLegacyIE = !!window.ActiveXObject, w.isIE = w.isLegacyIE || /trident.*rv:1\d/i.test(navigator.userAgent), w.isIE11 = /trident.*rv:11/i.test(navigator.userAgent), w.isChromecast = w.isChrome && /CrKey/i.test(navigator.userAgent), w.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone|IEMobile|Mobile Safari|Opera Mini/i.test(navigator.userAgent), w.isiOS = /iPad|iPhone|iPod/i.test(navigator.userAgent), w.isAndroid = /Android/i.test(navigator.userAgent), w.isWindowsPhone = /Windows Phone/i.test(navigator.userAgent), w.isWin8App = /MSAppHost/i.test(navigator.userAgent), w.isWiiU = /WiiU/i.test(navigator.userAgent), w.isPS4 = /PlayStation 4/i.test(navigator.userAgent), w.hasLocalstorage = function() {
    try {
      return localStorage.setItem("clappr", "clappr"), localStorage.removeItem("clappr"), true;
    } catch (e2) {
      return false;
    }
  }(), w.hasFlash = function() {
    try {
      return !!new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
    } catch (e2) {
      return !(!navigator.mimeTypes || void 0 === navigator.mimeTypes["application/x-shockwave-flash"] || !navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin);
    }
  }(), w.name = N.name, w.version = N.version, w.userAgent = navigator.userAgent, w.data = function() {
    var e2, t2 = {}, r2 = w.userAgent.toLowerCase(), i2 = b(I);
    try {
      for (i2.s(); !(e2 = i2.n()).done; ) {
        var n2 = e2.value, a2 = new RegExp(n2.identifier.toLowerCase()).exec(r2);
        if (null != a2 && a2[1]) {
          if (t2.name = n2.name, t2.group = n2.group, n2.versionIdentifier) {
            var s2 = new RegExp(n2.versionIdentifier.toLowerCase()).exec(r2);
            null != s2 && s2[1] && P(s2[1], t2);
          } else
            P(a2[1], t2);
          break;
        }
      }
    } catch (e3) {
      i2.e(e3);
    } finally {
      i2.f();
    }
    return t2;
  }(), w.os = function() {
    var e2, t2 = {}, r2 = w.userAgent.toLowerCase(), i2 = b(O);
    try {
      for (i2.s(); !(e2 = i2.n()).done; ) {
        var n2 = e2.value, a2 = new RegExp(n2.identifier.toLowerCase()).exec(r2);
        if (null != a2) {
          if (t2.name = n2.name, t2.group = n2.group, n2.version)
            x(n2.version, n2.versionSeparator ? n2.versionSeparator : ".", t2);
          else if (a2[1])
            x(a2[1], n2.versionSeparator ? n2.versionSeparator : ".", t2);
          else if (n2.versionIdentifier) {
            var s2 = new RegExp(n2.versionIdentifier.toLowerCase()).exec(r2);
            null != s2 && s2[1] && x(s2[1], n2.versionSeparator ? n2.versionSeparator : ".", t2);
          }
          break;
        }
      }
    } catch (e3) {
      i2.e(e3);
    } finally {
      i2.f();
    }
    return t2;
  }(), w.isWindows = /^Windows$/i.test(w.os.group), w.isMacOS = /^Mac OS$/i.test(w.os.group), w.isLinux = /^Linux$/i.test(w.os.group), w.viewport = ((C = {}).width = R(window).width(), C.height = R(window).height(), C), w.device = (L = w.userAgent, (D = /\((iP(?:hone|ad|od))?(?:[^;]*; ){0,2}([^)]+(?=\)))/.exec(L)) && (D[1] || D[2]) || ""), void 0 !== window.orientation && function() {
    switch (window.orientation) {
      case -90:
      case 90:
        w.viewport.orientation = "landscape";
        break;
      default:
        w.viewport.orientation = "portrait";
    }
  }();
  var F = {}, M = [], B = (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function(e2) {
    window.setTimeout(e2, 1e3 / 60);
  }).bind(window), U = (window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout).bind(window);
  function G(e2, t2) {
    if (t2)
      for (var r2 in t2) {
        var i2 = Object.getOwnPropertyDescriptor(t2, r2);
        i2 ? Object.defineProperty(e2, r2, i2) : e2[r2] = t2[r2];
      }
    return e2;
  }
  function V(e2, t2) {
    var r2 = function(e3) {
      c(i2, e3);
      var r3 = g(i2);
      function i2() {
        var e4;
        s(this, i2);
        for (var n2 = arguments.length, a2 = new Array(n2), o2 = 0; o2 < n2; o2++)
          a2[o2] = arguments[o2];
        return e4 = r3.call.apply(r3, [this].concat(a2)), t2.initialize && t2.initialize.apply(f(e4), a2), e4;
      }
      return l(i2);
    }(e2);
    return G(r2.prototype, t2), r2;
  }
  var K = { fullscreenElement: function() {
    return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
  }, requestFullscreen: function(e2) {
    if (e2.requestFullscreen)
      return e2.requestFullscreen();
    if (e2.webkitRequestFullscreen) {
      if ("function" == typeof e2.then)
        return e2.webkitRequestFullscreen();
      e2.webkitRequestFullscreen();
    } else {
      if (e2.mozRequestFullScreen)
        return e2.mozRequestFullScreen();
      if (e2.msRequestFullscreen)
        return e2.msRequestFullscreen();
      e2.querySelector && e2.querySelector("video") && e2.querySelector("video").webkitEnterFullScreen ? e2.querySelector("video").webkitEnterFullScreen() : e2.webkitEnterFullScreen && e2.webkitEnterFullScreen();
    }
  }, cancelFullscreen: function() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document;
    e2.exitFullscreen ? e2.exitFullscreen() : e2.webkitCancelFullScreen ? e2.webkitCancelFullScreen() : e2.webkitExitFullscreen ? e2.webkitExitFullscreen() : e2.mozCancelFullScreen ? e2.mozCancelFullScreen() : e2.msExitFullscreen && e2.msExitFullscreen();
  }, fullscreenEnabled: function() {
    return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled);
  } }, j = function() {
    function e2() {
      s(this, e2);
    }
    return l(e2, null, [{ key: "_defaultConfig", value: function() {
      return { volume: { value: 100, parse: parseInt } };
    } }, { key: "_defaultValueFor", value: function(e3) {
      try {
        return this._defaultConfig()[e3].parse(this._defaultConfig()[e3].value);
      } catch (e4) {
        return;
      }
    } }, { key: "_createKeyspace", value: function(e3) {
      return "clappr.".concat(document.domain, ".").concat(e3);
    } }, { key: "restore", value: function(e3) {
      return w.hasLocalstorage && localStorage[this._createKeyspace(e3)] ? this._defaultConfig()[e3].parse(localStorage[this._createKeyspace(e3)]) : this._defaultValueFor(e3);
    } }, { key: "persist", value: function(e3, t2) {
      if (w.hasLocalstorage)
        try {
          return localStorage[this._createKeyspace(e3)] = t2, true;
        } catch (e4) {
          return false;
        }
    } }]), e2;
  }(), H = function() {
    function e2() {
      s(this, e2);
    }
    return l(e2, null, [{ key: "params", get: function() {
      var e3 = window.location.search.substring(1);
      return e3 !== this.query && (this._urlParams = this.parse(e3), this.query = e3), this._urlParams;
    } }, { key: "hashParams", get: function() {
      var e3 = window.location.hash.substring(1);
      return e3 !== this.hash && (this._hashParams = this.parse(e3), this.hash = e3), this._hashParams;
    } }, { key: "parse", value: function(e3) {
      for (var t2, r2 = /\+/g, i2 = /([^&=]+)=?([^&]*)/g, n2 = function(e4) {
        return decodeURIComponent(e4.replace(r2, " "));
      }, a2 = {}; t2 = i2.exec(e3); )
        a2[n2(t2[1]).toLowerCase()] = n2(t2[2]);
      return a2;
    } }]), e2;
  }();
  function Y() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "t", t2 = 0, r2 = H.params[e2] || H.hashParams[e2] || "", i2 = r2.match(/[0-9]+[hms]+/g) || [];
    if (i2.length > 0) {
      var n2 = { h: 3600, m: 60, s: 1 };
      i2.forEach(function(e3) {
        if (e3) {
          var r3 = e3[e3.length - 1], i3 = parseInt(e3.slice(0, e3.length - 1), 10);
          t2 += i3 * n2[r3];
        }
      });
    } else
      r2 && (t2 = parseInt(r2, 10));
    return t2;
  }
  function W(e2) {
    return F[e2] || (F[e2] = 0), e2 + ++F[e2];
  }
  function $(e2) {
    return e2 - parseFloat(e2) + 1 >= 0;
  }
  function z() {
    var e2 = document.getElementsByTagName("script");
    return e2.length ? e2[e2.length - 1].src : "";
  }
  function q() {
    return window.navigator && window.navigator.language;
  }
  function X(e2, t2) {
    var r2 = (t2 = Object.assign({ inline: false, muted: false, timeout: 250, type: "video", source: S.mp4, element: null }, t2)).element ? t2.element : document.createElement(t2.type);
    r2.muted = t2.muted, true === t2.muted && r2.setAttribute("muted", "muted"), true === t2.inline && r2.setAttribute("playsinline", "playsinline"), r2.src = t2.source;
    var i2 = r2.play(), n2 = setTimeout(function() {
      a2(false, new Error("Timeout ".concat(t2.timeout, " ms has been reached")));
    }, t2.timeout), a2 = function(t3) {
      var r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
      clearTimeout(n2), e2(t3, r3);
    };
    void 0 !== i2 ? i2.then(function() {
      return a2(true);
    }).catch(function(e3) {
      return a2(false, e3);
    }) : a2(true);
  }
  var Z = function() {
    function e2() {
      s(this, e2);
    }
    return l(e2, null, [{ key: "configure", value: function(e3) {
      this.options = R.extend(true, this.options, e3);
    } }, { key: "create", value: function(e3) {
      return this.options.recycleVideo && "video" === e3 && M.length > 0 ? M.shift() : document.createElement(e3);
    } }, { key: "garbage", value: function(e3) {
      this.options.recycleVideo && "VIDEO" === e3.tagName.toUpperCase() && (R(e3).children().remove(), Object.values(e3.attributes).forEach(function(t2) {
        return e3.removeAttribute(t2.name);
      }), M.push(e3));
    } }]), e2;
  }();
  Z.options = { recycleVideo: false };
  var Q = function() {
    function e2() {
      var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 500;
      s(this, e2), this.delay = t2, this.lastTime = 0;
    }
    return l(e2, [{ key: "handle", value: function(e3, t2) {
      var r2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], i2 = (/* @__PURE__ */ new Date()).getTime(), n2 = i2 - this.lastTime;
      n2 < this.delay && n2 > 0 && (t2(), r2 && e3.preventDefault()), this.lastTime = i2;
    } }]), e2;
  }(), J = { Config: j, Fullscreen: K, QueryString: H, DomRecycler: Z, assign: G, extend: V, formatTime: function(e2, t2) {
    if (!isFinite(e2))
      return "--:--";
    e2 *= 1e3;
    var r2 = (e2 = parseInt(e2 / 1e3)) % 60, i2 = (e2 = parseInt(e2 / 60)) % 60, n2 = (e2 = parseInt(e2 / 60)) % 24, a2 = parseInt(e2 / 24), s2 = "";
    return a2 && a2 > 0 && (s2 += a2 + ":", n2 < 1 && (s2 += "00:")), (n2 && n2 > 0 || t2) && (s2 += ("0" + n2).slice(-2) + ":"), s2 += ("0" + i2).slice(-2) + ":", (s2 += ("0" + r2).slice(-2)).trim();
  }, seekStringToSeconds: Y, uniqueId: W, currentScriptUrl: z, isNumber: $, requestAnimationFrame: B, cancelAnimationFrame: U, getBrowserLanguage: q, now: function() {
    return window.performance && window.performance.now ? performance.now() : Date.now();
  }, removeArrayItem: function(e2, t2) {
    var r2 = e2.indexOf(t2);
    r2 >= 0 && e2.splice(r2, 1);
  }, listContainsIgnoreCase: function(e2, t2) {
    return void 0 !== e2 && void 0 !== t2 && void 0 !== t2.find(function(t3) {
      return e2.toLowerCase() === t3.toLowerCase();
    });
  }, canAutoPlayMedia: X, Media: S, DoubleEventHandler: Q }, ee = "font-weight: bold; font-size: 13px;", te = "color: #ff8000;" + ee, re = "color: #ff0000;" + ee, ie = ["color: #0000ff;" + ee, "color: #006600;" + ee, te, re, re], ne = ["debug", "info", "warn", "error", "disabled"], ae = function() {
    function e2() {
      var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3;
      s(this, e2), this.EXCLUDE_LIST = ["timeupdate", "playback:timeupdate", "playback:progress", "container:hover", "container:timeupdate", "container:progress"], this.level = t2, this.previousLevel = this.level, this.offLevel = r2;
    }
    return l(e2, [{ key: "level", get: function() {
      return this._level;
    }, set: function(e3) {
      this._level = e3;
    } }, { key: "debug", value: function(e3) {
      this.log(e3, 0, Array.prototype.slice.call(arguments, 1));
    } }, { key: "info", value: function(e3) {
      this.log(e3, 1, Array.prototype.slice.call(arguments, 1));
    } }, { key: "warn", value: function(e3) {
      this.log(e3, 2, Array.prototype.slice.call(arguments, 1));
    } }, { key: "error", value: function(e3) {
      this.log(e3, 3, Array.prototype.slice.call(arguments, 1));
    } }, { key: "onOff", value: function() {
      this.level === this.offLevel ? this.level = this.previousLevel : (this.previousLevel = this.level, this.level = this.offLevel), window.console && window.console.log && window.console.log("%c[Clappr.Log] set log level to " + ne[this.level], te);
    } }, { key: "log", value: function(e3, t2, r2) {
      if (!(this.EXCLUDE_LIST.indexOf(r2[0]) >= 0 || t2 < this.level)) {
        r2 || (r2 = e3, e3 = null);
        var i2 = ie[t2], n2 = "";
        e3 && (n2 = "[" + e3 + "]"), window.console && window.console.log && window.console.log.apply(console, ["%c[" + ne[t2] + "]" + n2, i2].concat(r2));
      }
    } }]), e2;
  }();
  ae.LEVEL_DEBUG = 0, ae.LEVEL_INFO = 1, ae.LEVEL_WARN = 2, ae.LEVEL_ERROR = 3, ae.getInstance = function() {
    return void 0 === this._instance && (this._instance = new this()), this._instance;
  }, ae.setLevel = function(e2) {
    this.getInstance().level = e2;
  }, ae.debug = function() {
    this.getInstance().debug.apply(this.getInstance(), arguments);
  }, ae.info = function() {
    this.getInstance().info.apply(this.getInstance(), arguments);
  }, ae.warn = function() {
    this.getInstance().warn.apply(this.getInstance(), arguments);
  }, ae.error = function() {
    this.getInstance().error.apply(this.getInstance(), arguments);
  };
  var se = Array.prototype.slice, oe = /\s+/, le = function(e2, t2, r2, i2) {
    if (!r2)
      return true;
    if ("object" === a(r2)) {
      for (var n2 in r2)
        e2[t2].apply(e2, [n2, r2[n2]].concat(i2));
      return false;
    }
    if (oe.test(r2)) {
      for (var s2 = r2.split(oe), o2 = 0, l2 = s2.length; o2 < l2; o2++)
        e2[t2].apply(e2, [s2[o2]].concat(i2));
      return false;
    }
    return true;
  }, ue = function(e2, t2, r2, i2) {
    var n2, a2 = -1, s2 = e2.length, o2 = t2[0], l2 = t2[1], u2 = t2[2];
    !function c2() {
      try {
        switch (t2.length) {
          case 0:
            for (; ++a2 < s2; )
              (n2 = e2[a2]).callback.call(n2.ctx);
            return;
          case 1:
            for (; ++a2 < s2; )
              (n2 = e2[a2]).callback.call(n2.ctx, o2);
            return;
          case 2:
            for (; ++a2 < s2; )
              (n2 = e2[a2]).callback.call(n2.ctx, o2, l2);
            return;
          case 3:
            for (; ++a2 < s2; )
              (n2 = e2[a2]).callback.call(n2.ctx, o2, l2, u2);
            return;
          default:
            for (; ++a2 < s2; )
              (n2 = e2[a2]).callback.apply(n2.ctx, t2);
            return;
        }
      } catch (e3) {
        ae.error.apply(ae, [r2, "error on event", i2, "trigger", "-", e3]), c2();
      }
    }();
  }, ce = function() {
    function e2() {
      s(this, e2);
    }
    return l(e2, [{ key: "on", value: function(e3, t2, r2) {
      return le(this, "on", e3, [t2, r2]) && t2 ? (this._events || (this._events = {}), (this._events[e3] || (this._events[e3] = [])).push({ callback: t2, context: r2, ctx: r2 || this }), this) : this;
    } }, { key: "once", value: function(e3, t2, r2) {
      var i2, n2 = this;
      if (!le(this, "once", e3, [t2, r2]) || !t2)
        return this;
      var a2 = function() {
        return n2.off(e3, i2);
      };
      return i2 = function() {
        a2(), t2.apply(this, arguments);
      }, this.on(e3, i2, r2);
    } }, { key: "off", value: function(e3, t2, r2) {
      var i2, n2, a2, s2, o2, l2, u2, c2;
      if (!this._events || !le(this, "off", e3, [t2, r2]))
        return this;
      if (!e3 && !t2 && !r2)
        return this._events = void 0, this;
      for (o2 = 0, l2 = (s2 = e3 ? [e3] : Object.keys(this._events)).length; o2 < l2; o2++)
        if (e3 = s2[o2], a2 = this._events[e3]) {
          if (this._events[e3] = i2 = [], t2 || r2)
            for (u2 = 0, c2 = a2.length; u2 < c2; u2++)
              n2 = a2[u2], (t2 && t2 !== n2.callback && t2 !== n2.callback._callback || r2 && r2 !== n2.context) && i2.push(n2);
          i2.length || delete this._events[e3];
        }
      return this;
    } }, { key: "trigger", value: function(e3) {
      var t2 = this.name || this.constructor.name;
      if (ae.debug.apply(ae, [t2].concat(Array.prototype.slice.call(arguments))), !this._events)
        return this;
      var r2 = se.call(arguments, 1);
      if (!le(this, "trigger", e3, r2))
        return this;
      var i2 = this._events[e3], n2 = this._events.all;
      return i2 && ue(i2, r2, t2, e3), n2 && ue(n2, arguments, t2, e3), this;
    } }, { key: "stopListening", value: function(e3, t2, r2) {
      var i2 = this._listeningTo;
      if (!i2)
        return this;
      var n2 = !t2 && !r2;
      for (var s2 in r2 || "object" !== a(t2) || (r2 = this), e3 && ((i2 = {})[e3._listenId] = e3), i2)
        (e3 = i2[s2]).off(t2, r2, this), (n2 || 0 === Object.keys(e3._events).length) && delete this._listeningTo[s2];
      return this;
    } }], [{ key: "register", value: function(t2) {
      e2.Custom || (e2.Custom = {});
      var r2 = "string" == typeof t2 && t2.toUpperCase().trim();
      r2 && !e2.Custom[r2] ? e2.Custom[r2] = r2.toLowerCase().split("_").map(function(e3, t3) {
        return 0 === t3 ? e3 : e3 = e3[0].toUpperCase() + e3.slice(1);
      }).join("") : ae.error("Events", "Error when register event: " + t2);
    } }, { key: "listAvailableCustomEvents", value: function() {
      return e2.Custom || (e2.Custom = {}), Object.keys(e2.Custom).filter(function(t2) {
        return "string" == typeof e2.Custom[t2];
      });
    } }]), e2;
  }(), de = { listenTo: "on", listenToOnce: "once" };
  Object.keys(de).forEach(function(e2) {
    ce.prototype[e2] = function(t2, r2, i2) {
      return (this._listeningTo || (this._listeningTo = {}))[t2._listenId || (t2._listenId = W("l"))] = t2, i2 || "object" !== a(r2) || (i2 = this), t2[de[e2]](r2, i2, this), this;
    };
  }), ce.PLAYER_READY = "ready", ce.PLAYER_RESIZE = "resize", ce.PLAYER_FULLSCREEN = "fullscreen", ce.PLAYER_PLAY = "play", ce.PLAYER_PAUSE = "pause", ce.PLAYER_STOP = "stop", ce.PLAYER_ENDED = "ended", ce.PLAYER_SEEK = "seek", ce.PLAYER_ERROR = "playererror", ce.ERROR = "error", ce.PLAYER_TIMEUPDATE = "timeupdate", ce.PLAYER_VOLUMEUPDATE = "volumeupdate", ce.PLAYER_SUBTITLE_AVAILABLE = "subtitleavailable", ce.PLAYBACK_PROGRESS = "playback:progress", ce.PLAYBACK_TIMEUPDATE = "playback:timeupdate", ce.PLAYBACK_READY = "playback:ready", ce.PLAYBACK_BUFFERING = "playback:buffering", ce.PLAYBACK_BUFFERFULL = "playback:bufferfull", ce.PLAYBACK_SETTINGSUPDATE = "playback:settingsupdate", ce.PLAYBACK_LOADEDMETADATA = "playback:loadedmetadata", ce.PLAYBACK_HIGHDEFINITIONUPDATE = "playback:highdefinitionupdate", ce.PLAYBACK_BITRATE = "playback:bitrate", ce.PLAYBACK_LEVELS_AVAILABLE = "playback:levels:available", ce.PLAYBACK_LEVEL_SWITCH_START = "playback:levels:switch:start", ce.PLAYBACK_LEVEL_SWITCH_END = "playback:levels:switch:end", ce.PLAYBACK_PLAYBACKSTATE = "playback:playbackstate", ce.PLAYBACK_DVR = "playback:dvr", ce.PLAYBACK_MEDIACONTROL_DISABLE = "playback:mediacontrol:disable", ce.PLAYBACK_MEDIACONTROL_ENABLE = "playback:mediacontrol:enable", ce.PLAYBACK_ENDED = "playback:ended", ce.PLAYBACK_PLAY_INTENT = "playback:play:intent", ce.PLAYBACK_PLAY = "playback:play", ce.PLAYBACK_PAUSE = "playback:pause", ce.PLAYBACK_SEEK = "playback:seek", ce.PLAYBACK_SEEKED = "playback:seeked", ce.PLAYBACK_STOP = "playback:stop", ce.PLAYBACK_ERROR = "playback:error", ce.PLAYBACK_STATS_ADD = "playback:stats:add", ce.PLAYBACK_FRAGMENT_LOADED = "playback:fragment:loaded", ce.PLAYBACK_LEVEL_SWITCH = "playback:level:switch", ce.PLAYBACK_SUBTITLE_AVAILABLE = "playback:subtitle:available", ce.PLAYBACK_SUBTITLE_CHANGED = "playback:subtitle:changed", ce.PLAYBACK_AUDIO_AVAILABLE = "playback:audio:available", ce.PLAYBACK_AUDIO_CHANGED = "playback:audio:changed", ce.CORE_CONTAINERS_CREATED = "core:containers:created", ce.CORE_ACTIVE_CONTAINER_CHANGED = "core:active:container:changed", ce.CORE_OPTIONS_CHANGE = "core:options:change", ce.CORE_READY = "core:ready", ce.CORE_FULLSCREEN = "core:fullscreen", ce.CORE_RESIZE = "core:resize", ce.CORE_SCREEN_ORIENTATION_CHANGED = "core:screen:orientation:changed", ce.CORE_MOUSE_MOVE = "core:mousemove", ce.CORE_MOUSE_LEAVE = "core:mouseleave", ce.CONTAINER_PLAYBACKSTATE = "container:playbackstate", ce.CONTAINER_PLAYBACKDVRSTATECHANGED = "container:dvr", ce.CONTAINER_BITRATE = "container:bitrate", ce.CONTAINER_STATS_REPORT = "container:stats:report", ce.CONTAINER_DESTROYED = "container:destroyed", ce.CONTAINER_READY = "container:ready", ce.CONTAINER_RESIZE = "container:resize", ce.CONTAINER_ERROR = "container:error", ce.CONTAINER_LOADEDMETADATA = "container:loadedmetadata", ce.CONTAINER_SUBTITLE_AVAILABLE = "container:subtitle:available", ce.CONTAINER_SUBTITLE_CHANGED = "container:subtitle:changed", ce.CONTAINER_AUDIO_AVAILABLE = "container:audio:available", ce.CONTAINER_AUDIO_CHANGED = "container:audio:changed", ce.CONTAINER_TIMEUPDATE = "container:timeupdate", ce.CONTAINER_PROGRESS = "container:progress", ce.CONTAINER_PLAY = "container:play", ce.CONTAINER_STOP = "container:stop", ce.CONTAINER_PAUSE = "container:pause", ce.CONTAINER_ENDED = "container:ended", ce.CONTAINER_CLICK = "container:click", ce.CONTAINER_DBLCLICK = "container:dblclick", ce.CONTAINER_CONTEXTMENU = "container:contextmenu", ce.CONTAINER_MOUSE_ENTER = "container:mouseenter", ce.CONTAINER_MOUSE_LEAVE = "container:mouseleave", ce.CONTAINER_MOUSE_UP = "container:mouseup", ce.CONTAINER_MOUSE_DOWN = "container:mousedown", ce.CONTAINER_SEEK = "container:seek", ce.CONTAINER_SEEKED = "container:seeked", ce.CONTAINER_VOLUME = "container:volume", ce.CONTAINER_FULLSCREEN = "container:fullscreen", ce.CONTAINER_STATE_BUFFERING = "container:state:buffering", ce.CONTAINER_STATE_BUFFERFULL = "container:state:bufferfull", ce.CONTAINER_SETTINGSUPDATE = "container:settingsupdate", ce.CONTAINER_HIGHDEFINITIONUPDATE = "container:highdefinitionupdate", ce.CONTAINER_MEDIACONTROL_SHOW = "container:mediacontrol:show", ce.CONTAINER_MEDIACONTROL_HIDE = "container:mediacontrol:hide", ce.CONTAINER_MEDIACONTROL_DISABLE = "container:mediacontrol:disable", ce.CONTAINER_MEDIACONTROL_ENABLE = "container:mediacontrol:enable", ce.CONTAINER_STATS_ADD = "container:stats:add", ce.CONTAINER_OPTIONS_CHANGE = "container:options:change", ce.MEDIACONTROL_RENDERED = "mediacontrol:rendered", ce.MEDIACONTROL_FULLSCREEN = "mediacontrol:fullscreen", ce.MEDIACONTROL_SHOW = "mediacontrol:show", ce.MEDIACONTROL_HIDE = "mediacontrol:hide", ce.MEDIACONTROL_MOUSEMOVE_SEEKBAR = "mediacontrol:mousemove:seekbar", ce.MEDIACONTROL_MOUSELEAVE_SEEKBAR = "mediacontrol:mouseleave:seekbar", ce.MEDIACONTROL_PLAYING = "mediacontrol:playing", ce.MEDIACONTROL_NOTPLAYING = "mediacontrol:notplaying", ce.MEDIACONTROL_CONTAINERCHANGED = "mediacontrol:containerchanged", ce.MEDIACONTROL_OPTIONS_CHANGE = "mediacontrol:options:change";
  var he = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2() {
      var e3, i2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return s(this, r2), (e3 = t2.call(this, i2))._options = i2, e3.uniqueId = W("o"), e3;
    }
    return l(r2, [{ key: "options", get: function() {
      return this._options;
    } }]), r2;
  }(ce), fe = { evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g }, pe = /(.)^/, ge = { "'": "'", "\\": "\\", "\r": "r", "\n": "n", "	": "t", "\u2028": "u2028", "\u2029": "u2029" }, ve = /\\|'|\r|\n|\t|\u2028|\u2029/g, me = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;" }, ye = new RegExp(`[&<>"']`, "g"), Ae = function(e2) {
    return null === e2 ? "" : ("" + e2).replace(ye, function(e3) {
      return me[e3];
    });
  }, Ee = 0, Te = function(e2, t2) {
    var r2, i2 = new RegExp([(fe.escape || pe).source, (fe.interpolate || pe).source, (fe.evaluate || pe).source].join("|") + "|$", "g"), n2 = 0, a2 = "__p+='";
    e2.replace(i2, function(t3, r3, i3, s3, o2) {
      return a2 += e2.slice(n2, o2).replace(ve, function(e3) {
        return "\\" + ge[e3];
      }), r3 && (a2 += "'+\n((__t=(" + r3 + "))==null?'':escapeExpr(__t))+\n'"), i3 && (a2 += "'+\n((__t=(" + i3 + "))==null?'':__t)+\n'"), s3 && (a2 += "';\n" + s3 + "\n__p+='"), n2 = o2 + t3.length, t3;
    }), a2 += "';\n", fe.variable || (a2 = "with(obj||{}){\n" + a2 + "}\n"), a2 = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + a2 + "return __p;\n//# sourceURL=/microtemplates/source[" + Ee++ + "]";
    try {
      r2 = new Function(fe.variable || "obj", "escapeExpr", a2);
    } catch (e3) {
      throw e3.source = a2, e3;
    }
    if (t2)
      return r2(t2, Ae);
    var s2 = function(e3) {
      return r2.call(this, e3, Ae);
    };
    return s2.source = "function(" + (fe.variable || "obj") + "){\n" + a2 + "}", s2;
  };
  Te.settings = fe;
  var be = { getStyleFor: function(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { baseUrl: "" };
    return R('<style class="clappr-style"></style>').html(Te(e2.toString())(t2));
  } }, ke = /^(\S+)\s*(.*)$/, Se = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2(e3) {
      var i2;
      return s(this, r2), (i2 = t2.call(this, e3)).cid = W("c"), i2._ensureElement(), i2.delegateEvents(), i2;
    }
    return l(r2, [{ key: "tagName", get: function() {
      return "div";
    } }, { key: "events", get: function() {
      return {};
    } }, { key: "attributes", get: function() {
      return {};
    } }, { key: "$", value: function(e3) {
      return this.$el.find(e3);
    } }, { key: "render", value: function() {
      return this;
    } }, { key: "destroy", value: function() {
      return this.$el.remove(), this.stopListening(), this.undelegateEvents(), this;
    } }, { key: "setElement", value: function(e3, t3) {
      return this.$el && this.undelegateEvents(), this.$el = R.zepto.isZ(e3) ? e3 : R(e3), this.el = this.$el[0], false !== t3 && this.delegateEvents(), this;
    } }, { key: "delegateEvents", value: function(e3) {
      for (var t3 in e3 || (e3 = this.events), this.undelegateEvents(), e3) {
        var r3 = e3[t3];
        if (r3 && r3.constructor !== Function && (r3 = this[e3[t3]]), r3) {
          var i2 = t3.match(ke), n2 = i2[1], a2 = i2[2];
          n2 += ".delegateEvents" + this.cid, "" === a2 ? this.$el.on(n2, r3.bind(this)) : this.$el.on(n2, a2, r3.bind(this));
        }
      }
      return this;
    } }, { key: "undelegateEvents", value: function() {
      return this.$el.off(".delegateEvents" + this.cid), this;
    } }, { key: "_ensureElement", value: function() {
      if (this.el)
        this.setElement(this.el, false);
      else {
        var e3 = R.extend(true, {}, this.attributes);
        this.id && (e3.id = this.id), this.className && (e3.class = this.className);
        var t3 = R(Z.create(this.tagName)).attr(e3);
        this.setElement(t3, false);
      }
    } }]), r2;
  }(he), _e = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2() {
      var e3, i2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = arguments.length > 1 ? arguments[1] : void 0;
      return s(this, r2), (e3 = t2.call(this, i2)).core = n2, e3;
    }
    return l(r2, [{ key: "name", get: function() {
      return "error";
    } }, { key: "createError", value: function(e3) {
      this.core ? this.core.trigger(ce.ERROR, e3) : ae.warn(this.name, "Core is not set. Error: ", e3);
    } }], [{ key: "Levels", get: function() {
      return { FATAL: "FATAL", WARN: "WARN", INFO: "INFO" };
    } }]), r2;
  }(he), Ce = { createError: function(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { useCodePrefix: true }, r2 = this.constructor && this.constructor.type || "", i2 = this.name || r2, n2 = this.i18n || this.core && this.core.i18n || this.container && this.container.i18n, a2 = "".concat(i2, ":").concat(e2 && e2.code || "unknown"), s2 = { description: "", level: _e.Levels.FATAL, origin: i2, scope: r2, raw: {} }, o2 = Object.assign({}, s2, e2, { code: t2.useCodePrefix ? a2 : e2.code });
    if (n2 && o2.level == _e.Levels.FATAL && !o2.UI) {
      var l2 = { title: n2.t("default_error_title"), message: n2.t("default_error_message") };
      o2.UI = l2;
    }
    return this.playerError ? this.playerError.createError(o2) : ae.warn(i2, "PlayerError is not defined. Error: ", o2), o2;
  } }, Le = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2(e3) {
      var i2;
      return s(this, r2), (i2 = t2.call(this, e3.options)).core = e3, i2.enabled = true, i2.bindEvents(), i2.render(), i2;
    }
    return l(r2, [{ key: "playerError", get: function() {
      return this.core.playerError;
    } }, { key: "bindEvents", value: function() {
    } }, { key: "getExternalInterface", value: function() {
      return {};
    } }, { key: "enable", value: function() {
      this.enabled || (this.bindEvents(), this.$el.show(), this.enabled = true);
    } }, { key: "disable", value: function() {
      this.stopListening(), this.$el.hide(), this.enabled = false;
    } }, { key: "render", value: function() {
      return this;
    } }]), r2;
  }(Se);
  Object.assign(Le.prototype, Ce), Le.extend = function(e2) {
    return V(Le, e2);
  }, Le.type = "core";
  var De = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2(e3, i2, n2) {
      var a2;
      return s(this, r2), (a2 = t2.call(this, e3))._i18n = i2, a2.currentTime = 0, a2.volume = 100, a2.playback = e3.playback, a2.playerError = n2, a2.settings = R.extend(true, {}, a2.playback.settings), a2.isReady = false, a2.mediaControlDisabled = false, a2.plugins = [a2.playback], a2.dblTapHandler = new Q(500), a2.clickTimer = null, a2.clickDelay = 200, a2.actionsMetadata = {}, a2.bindEvents(), a2;
    }
    return l(r2, [{ key: "name", get: function() {
      return "Container";
    } }, { key: "attributes", get: function() {
      return { class: "container", "data-container": "" };
    } }, { key: "events", get: function() {
      return { click: "clicked", dblclick: "dblClicked", touchend: "dblTap", contextmenu: "onContextMenu", mouseenter: "mouseEnter", mouseleave: "mouseLeave", mouseup: "onMouseUp", mousedown: "onMouseDown" };
    } }, { key: "ended", get: function() {
      return this.playback.ended;
    } }, { key: "buffering", get: function() {
      return this.playback.buffering;
    } }, { key: "i18n", get: function() {
      return this._i18n;
    } }, { key: "hasClosedCaptionsTracks", get: function() {
      return this.playback.hasClosedCaptionsTracks;
    } }, { key: "closedCaptionsTracks", get: function() {
      return this.playback.closedCaptionsTracks;
    } }, { key: "closedCaptionsTrackId", get: function() {
      return this.playback.closedCaptionsTrackId;
    }, set: function(e3) {
      this.playback.closedCaptionsTrackId = e3;
    } }, { key: "audioTracks", get: function() {
      return this.playback.audioTracks;
    } }, { key: "currentAudioTrack", get: function() {
      return this.playback.currentAudioTrack;
    } }, { key: "bindEvents", value: function() {
      this.listenTo(this.playback, ce.PLAYBACK_PROGRESS, this.onProgress), this.listenTo(this.playback, ce.PLAYBACK_TIMEUPDATE, this.timeUpdated), this.listenTo(this.playback, ce.PLAYBACK_READY, this.ready), this.listenTo(this.playback, ce.PLAYBACK_BUFFERING, this.onBuffering), this.listenTo(this.playback, ce.PLAYBACK_BUFFERFULL, this.bufferfull), this.listenTo(this.playback, ce.PLAYBACK_SETTINGSUPDATE, this.settingsUpdate), this.listenTo(this.playback, ce.PLAYBACK_LOADEDMETADATA, this.loadedMetadata), this.listenTo(this.playback, ce.PLAYBACK_HIGHDEFINITIONUPDATE, this.highDefinitionUpdate), this.listenTo(this.playback, ce.PLAYBACK_BITRATE, this.updateBitrate), this.listenTo(this.playback, ce.PLAYBACK_PLAYBACKSTATE, this.playbackStateChanged), this.listenTo(this.playback, ce.PLAYBACK_DVR, this.playbackDvrStateChanged), this.listenTo(this.playback, ce.PLAYBACK_MEDIACONTROL_DISABLE, this.disableMediaControl), this.listenTo(this.playback, ce.PLAYBACK_MEDIACONTROL_ENABLE, this.enableMediaControl), this.listenTo(this.playback, ce.PLAYBACK_SEEK, this.onSeek), this.listenTo(this.playback, ce.PLAYBACK_SEEKED, this.onSeeked), this.listenTo(this.playback, ce.PLAYBACK_ENDED, this.onEnded), this.listenTo(this.playback, ce.PLAYBACK_PLAY, this.playing), this.listenTo(this.playback, ce.PLAYBACK_PAUSE, this.paused), this.listenTo(this.playback, ce.PLAYBACK_STOP, this.stopped), this.listenTo(this.playback, ce.PLAYBACK_ERROR, this.error), this.listenTo(this.playback, ce.PLAYBACK_SUBTITLE_AVAILABLE, this.subtitleAvailable), this.listenTo(this.playback, ce.PLAYBACK_SUBTITLE_CHANGED, this.subtitleChanged), this.listenTo(this.playback, ce.PLAYBACK_AUDIO_AVAILABLE, this.audioAvailable), this.listenTo(this.playback, ce.PLAYBACK_AUDIO_CHANGED, this.audioChanged);
    } }, { key: "subtitleAvailable", value: function() {
      this.trigger(ce.CONTAINER_SUBTITLE_AVAILABLE);
    } }, { key: "subtitleChanged", value: function(e3) {
      this.trigger(ce.CONTAINER_SUBTITLE_CHANGED, e3);
    } }, { key: "audioAvailable", value: function(e3) {
      this.trigger(ce.CONTAINER_AUDIO_AVAILABLE, e3);
    } }, { key: "audioChanged", value: function(e3) {
      this.trigger(ce.CONTAINER_AUDIO_CHANGED, e3);
    } }, { key: "playbackStateChanged", value: function(e3) {
      this.trigger(ce.CONTAINER_PLAYBACKSTATE, e3);
    } }, { key: "playbackDvrStateChanged", value: function(e3) {
      this.settings = this.playback.settings, this.dvrInUse = e3, this.trigger(ce.CONTAINER_PLAYBACKDVRSTATECHANGED, e3);
    } }, { key: "updateBitrate", value: function(e3) {
      this.trigger(ce.CONTAINER_BITRATE, e3);
    } }, { key: "statsReport", value: function(e3) {
      this.trigger(ce.CONTAINER_STATS_REPORT, e3);
    } }, { key: "getPlaybackType", value: function() {
      return this.playback.getPlaybackType();
    } }, { key: "isDvrEnabled", value: function() {
      return !!this.playback.dvrEnabled;
    } }, { key: "isDvrInUse", value: function() {
      return !!this.dvrInUse;
    } }, { key: "destroy", value: function() {
      this.disableResizeObserver(), this.trigger(ce.CONTAINER_DESTROYED, this, this.name), this.stopListening(), this.plugins.forEach(function(e3) {
        return e3.destroy();
      }), this.$el.remove();
    } }, { key: "setStyle", value: function(e3) {
      this.$el.css(e3);
    } }, { key: "animate", value: function(e3, t3) {
      return this.$el.animate(e3, t3).promise();
    } }, { key: "ready", value: function() {
      this.isReady = true, this.trigger(ce.CONTAINER_READY, this.name);
    } }, { key: "isPlaying", value: function() {
      return this.playback.isPlaying();
    } }, { key: "getStartTimeOffset", value: function() {
      return this.playback.getStartTimeOffset();
    } }, { key: "getCurrentTime", value: function() {
      return this.currentTime;
    } }, { key: "getDuration", value: function() {
      return this.playback.getDuration();
    } }, { key: "error", value: function(e3) {
      this.isReady || this.ready(), this.trigger(ce.CONTAINER_ERROR, e3, this.name);
    } }, { key: "loadedMetadata", value: function(e3) {
      this.trigger(ce.CONTAINER_LOADEDMETADATA, e3);
    } }, { key: "timeUpdated", value: function(e3) {
      this.currentTime = e3.current, this.trigger(ce.CONTAINER_TIMEUPDATE, e3, this.name);
    } }, { key: "onProgress", value: function() {
      for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++)
        t3[r3] = arguments[r3];
      this.trigger.apply(this, [ce.CONTAINER_PROGRESS].concat(t3, [this.name]));
    } }, { key: "playing", value: function() {
      this.trigger(ce.CONTAINER_PLAY, this.name, this.actionsMetadata.playEvent || {}), this.actionsMetadata.playEvent = {};
    } }, { key: "paused", value: function() {
      this.trigger(ce.CONTAINER_PAUSE, this.name, this.actionsMetadata.pauseEvent || {}), this.actionsMetadata.pauseEvent = {};
    } }, { key: "stopped", value: function() {
      this.trigger(ce.CONTAINER_STOP, this.actionsMetadata.stopEvent || {}), this.actionsMetadata.stopEvent = {};
    } }, { key: "play", value: function() {
      var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.actionsMetadata.playEvent = e3, this.playback.play(e3);
    } }, { key: "stop", value: function() {
      var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.actionsMetadata.stopEvent = e3, this.playback.stop(e3), this.currentTime = 0;
    } }, { key: "switchAudioTrack", value: function(e3) {
      this.playback.switchAudioTrack(e3);
    } }, { key: "pause", value: function() {
      var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.actionsMetadata.pauseEvent = e3, this.playback.pause(e3);
    } }, { key: "onEnded", value: function() {
      this.trigger(ce.CONTAINER_ENDED, this, this.name), this.currentTime = 0;
    } }, { key: "clicked", value: function() {
      var e3 = this;
      this.options.chromeless && !this.options.allowUserInteraction || (this.clickTimer = setTimeout(function() {
        e3.clickTimer && e3.trigger(ce.CONTAINER_CLICK, e3, e3.name);
      }, this.clickDelay));
    } }, { key: "cancelClicked", value: function() {
      clearTimeout(this.clickTimer), this.clickTimer = null;
    } }, { key: "dblClicked", value: function() {
      this.options.chromeless && !this.options.allowUserInteraction || (this.cancelClicked(), this.trigger(ce.CONTAINER_DBLCLICK, this, this.name));
    } }, { key: "dblTap", value: function(e3) {
      var t3 = this;
      this.options.chromeless && !this.options.allowUserInteraction || this.dblTapHandler.handle(e3, function() {
        t3.cancelClicked(), t3.trigger(ce.CONTAINER_DBLCLICK, t3, t3.name);
      });
    } }, { key: "onContextMenu", value: function(e3) {
      this.options.chromeless && !this.options.allowUserInteraction || this.trigger(ce.CONTAINER_CONTEXTMENU, e3, this.name);
    } }, { key: "seek", value: function(e3) {
      this.playback.seek(e3);
    } }, { key: "onSeek", value: function(e3) {
      this.trigger(ce.CONTAINER_SEEK, e3, this.name);
    } }, { key: "onSeeked", value: function() {
      this.trigger(ce.CONTAINER_SEEKED, this.name);
    } }, { key: "seekPercentage", value: function(e3) {
      var t3 = this.getDuration();
      if (e3 >= 0 && e3 <= 100) {
        var r3 = t3 * (e3 / 100);
        this.seek(r3);
      }
    } }, { key: "setVolume", value: function(e3) {
      this.volume = parseFloat(e3), this.trigger(ce.CONTAINER_VOLUME, this.volume, this.name), this.playback.volume(this.volume);
    } }, { key: "fullscreen", value: function() {
      this.trigger(ce.CONTAINER_FULLSCREEN, this.name);
    } }, { key: "onBuffering", value: function() {
      this.trigger(ce.CONTAINER_STATE_BUFFERING, this.name);
    } }, { key: "bufferfull", value: function() {
      this.trigger(ce.CONTAINER_STATE_BUFFERFULL, this.name);
    } }, { key: "addPlugin", value: function(e3) {
      this.plugins.push(e3);
    } }, { key: "hasPlugin", value: function(e3) {
      return !!this.getPlugin(e3);
    } }, { key: "getPlugin", value: function(e3) {
      return this.plugins.filter(function(t3) {
        return t3.name === e3;
      })[0];
    } }, { key: "mouseEnter", value: function() {
      this.options.chromeless && !this.options.allowUserInteraction || this.trigger(ce.CONTAINER_MOUSE_ENTER);
    } }, { key: "mouseLeave", value: function() {
      this.options.chromeless && !this.options.allowUserInteraction || this.trigger(ce.CONTAINER_MOUSE_LEAVE);
    } }, { key: "mouseUp", value: function() {
      this.options.chromeless && !this.options.allowUserInteraction || this.trigger(ce.CONTAINER_MOUSE_UP);
    } }, { key: "mouseDown", value: function() {
      this.options.chromeless && !this.options.allowUserInteraction || this.trigger(ce.CONTAINER_MOUSE_DOWN);
    } }, { key: "settingsUpdate", value: function() {
      this.settings = this.playback.settings, this.trigger(ce.CONTAINER_SETTINGSUPDATE);
    } }, { key: "highDefinitionUpdate", value: function(e3) {
      this.trigger(ce.CONTAINER_HIGHDEFINITIONUPDATE, e3);
    } }, { key: "isHighDefinitionInUse", value: function() {
      return this.playback.isHighDefinitionInUse();
    } }, { key: "disableMediaControl", value: function() {
      this.mediaControlDisabled || (this.mediaControlDisabled = true, this.trigger(ce.CONTAINER_MEDIACONTROL_DISABLE));
    } }, { key: "enableMediaControl", value: function() {
      this.mediaControlDisabled && (this.mediaControlDisabled = false, this.trigger(ce.CONTAINER_MEDIACONTROL_ENABLE));
    } }, { key: "updateStyle", value: function() {
      !this.options.chromeless || this.options.allowUserInteraction ? this.$el.removeClass("chromeless") : this.$el.addClass("chromeless");
    } }, { key: "enableResizeObserver", value: function() {
      var e3 = this;
      this.disableResizeObserver(), this.resizeObserverInterval = setInterval(function() {
        return e3.checkResize();
      }, 500);
    } }, { key: "disableResizeObserver", value: function() {
      this.resizeObserverInterval && clearInterval(this.resizeObserverInterval);
    } }, { key: "checkResize", value: function() {
      var e3 = { width: this.el.clientWidth, height: this.el.clientHeight }, t3 = this.currentSize || {}, r3 = t3.width;
      (t3.height !== e3.height || r3 !== e3.width) && (this.currentSize = e3, this.trigger(ce.CONTAINER_RESIZE, e3));
    } }, { key: "configure", value: function(e3) {
      this._options = R.extend(true, this._options, e3), this.updateStyle(), this.playback.configure(this.options), this.trigger(ce.CONTAINER_OPTIONS_CHANGE);
    } }, { key: "render", value: function() {
      var e3 = be.getStyleFor(".container[data-container] {\n  position: absolute;\n  background-color: black;\n  height: 100%;\n  width: 100%;\n  max-width: 100%; }\n  .container[data-container] .chromeless {\n    cursor: default; }\n\n[data-player]:not(.nocursor) .container[data-container]:not(.chromeless).pointer-enabled {\n  cursor: pointer; }\n".toString(), { baseUrl: this.options.baseUrl });
      return this.$el.append(e3[0]), this.$el.append(this.playback.render().el), this.updateStyle(), this.checkResize(), this.enableResizeObserver(), this;
    } }]), r2;
  }(Se);
  Object.assign(De.prototype, Ce);
  var Re = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2(e3, i2, n2) {
      var a2;
      return s(this, r2), (a2 = t2.call(this, e3)).settings = {}, a2._i18n = i2, a2.playerError = n2, a2._consented = false, a2;
    }
    return l(r2, [{ key: "isAudioOnly", get: function() {
      return false;
    } }, { key: "isAdaptive", get: function() {
      return false;
    } }, { key: "ended", get: function() {
      return false;
    } }, { key: "i18n", get: function() {
      return this._i18n;
    } }, { key: "buffering", get: function() {
      return false;
    } }, { key: "consent", value: function(e3) {
      "function" == typeof e3 && e3();
    } }, { key: "play", value: function() {
    } }, { key: "pause", value: function() {
    } }, { key: "stop", value: function() {
    } }, { key: "seek", value: function(e3) {
    } }, { key: "seekPercentage", value: function(e3) {
    } }, { key: "getStartTimeOffset", value: function() {
      return 0;
    } }, { key: "getDuration", value: function() {
      return 0;
    } }, { key: "isPlaying", value: function() {
      return false;
    } }, { key: "isReady", get: function() {
      return false;
    } }, { key: "hasClosedCaptionsTracks", get: function() {
      return this.closedCaptionsTracks.length > 0;
    } }, { key: "closedCaptionsTracks", get: function() {
      return [];
    } }, { key: "closedCaptionsTrackId", get: function() {
      return -1;
    }, set: function(e3) {
    } }, { key: "audioTracks", get: function() {
      return [];
    } }, { key: "currentAudioTrack", get: function() {
      return null;
    } }, { key: "switchAudioTrack", value: function(e3) {
    } }, { key: "getPlaybackType", value: function() {
      return r2.NO_OP;
    } }, { key: "isHighDefinitionInUse", value: function() {
      return false;
    } }, { key: "mute", value: function() {
    } }, { key: "unmute", value: function() {
    } }, { key: "volume", value: function(e3) {
    } }, { key: "configure", value: function(e3) {
      this._options = R.extend(true, this._options, e3);
    } }, { key: "attemptAutoPlay", value: function() {
      var e3 = this;
      this.canAutoPlay(function(t3, r3) {
        t3 && e3.play();
      });
    } }, { key: "canAutoPlay", value: function(e3) {
      e3(true, null);
    } }]), r2;
  }(Se);
  Object.assign(Re.prototype, Ce), Re.extend = function(e2) {
    return V(Re, e2);
  }, Re.canPlay = function(e2, t2) {
    return false;
  }, Re.VOD = "vod", Re.AOD = "aod", Re.LIVE = "live", Re.NO_OP = "no_op", Re.type = "playback";
  var Ie = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2(e3, i2, n2, a2) {
      var o2;
      return s(this, r2), (o2 = t2.call(this, e3))._i18n = n2, o2.loader = i2, o2.playerError = a2, o2;
    }
    return l(r2, [{ key: "options", get: function() {
      return this._options;
    }, set: function(e3) {
      this._options = e3;
    } }, { key: "createContainers", value: function() {
      var e3 = this;
      return R.Deferred(function(t3) {
        t3.resolve(e3.options.sources.map(function(t4) {
          return e3.createContainer(t4);
        }));
      });
    } }, { key: "findPlaybackPlugin", value: function(e3, t3) {
      return this.loader.playbackPlugins.filter(function(r3) {
        return r3.canPlay(e3, t3);
      })[0];
    } }, { key: "createContainer", value: function(e3) {
      var t3 = null, r3 = this.options.mimeType;
      "object" === a(e3) ? (t3 = e3.source.toString(), e3.mimeType && (r3 = e3.mimeType)) : t3 = e3.toString(), t3.match(/^\/\//) && (t3 = window.location.protocol + t3);
      var i2 = n(n({}, this.options), {}, { src: t3, mimeType: r3 }), s2 = this.findPlaybackPlugin(t3, r3), o2 = s2 ? new s2(i2, this._i18n, this.playerError) : new Re();
      i2 = n(n({}, i2), {}, { playback: o2 });
      var l2 = new De(i2, this._i18n, this.playerError), u2 = R.Deferred();
      return u2.promise(l2), this.addContainerPlugins(l2), this.listenToOnce(l2, ce.CONTAINER_READY, function() {
        return u2.resolve(l2);
      }), l2;
    } }, { key: "addContainerPlugins", value: function(e3) {
      this.loader.containerPlugins.forEach(function(t3) {
        e3.addPlugin(new t3(e3));
      });
    } }]), r2;
  }(he), Oe = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2(e3) {
      var i2;
      return s(this, r2), (i2 = t2.call(this, e3)).playerError = new _e(e3, f(i2)), i2.configureDomRecycler(), i2.firstResize = true, i2.plugins = [], i2.containers = [], i2._boundFullscreenHandler = function() {
        return i2.handleFullscreenChange();
      }, R(document).bind("fullscreenchange", i2._boundFullscreenHandler), R(document).bind("MSFullscreenChange", i2._boundFullscreenHandler), R(document).bind("mozfullscreenchange", i2._boundFullscreenHandler), w.isMobile && R(window).bind("resize", function(e4) {
        i2.handleWindowResize(e4);
      }), i2;
    }
    return l(r2, [{ key: "events", get: function() {
      return { webkitfullscreenchange: "handleFullscreenChange", mousemove: "onMouseMove", mouseleave: "onMouseLeave" };
    } }, { key: "attributes", get: function() {
      return { "data-player": "", tabindex: 9999 };
    } }, { key: "isReady", get: function() {
      return !!this.ready;
    } }, { key: "i18n", get: function() {
      return this.getPlugin("strings") || { t: function(e3) {
        return e3;
      } };
    } }, { key: "mediaControl", get: function() {
      return this._mediaControl || (this._mediaControl = this.getPlugin("media_control")) || this.dummyMediaControl;
    } }, { key: "dummyMediaControl", get: function() {
      return this._dummyMediaControl || (this._dummyMediaControl = new Le(this)), this._dummyMediaControl;
    } }, { key: "activeContainer", get: function() {
      return this._activeContainer;
    }, set: function(e3) {
      this._activeContainer = e3, this.trigger(ce.CORE_ACTIVE_CONTAINER_CHANGED, this._activeContainer);
    } }, { key: "activePlayback", get: function() {
      return this.activeContainer && this.activeContainer.playback;
    } }, { key: "activePlaybackEl", get: function() {
      if (this.activePlayback)
        return this.activePlayback.$el ? this.activePlayback.$el.find("video")[0] : this.activePlayback.el;
    } }, { key: "configureDomRecycler", value: function() {
      var e3 = this.options && this.options.playback && this.options.playback.recycleVideo;
      Z.configure({ recycleVideo: e3 });
    } }, { key: "createContainers", value: function(e3) {
      this.defer = R.Deferred(), this.defer.promise(this), this.containerFactory = new Ie(e3, e3.loader, this.i18n, this.playerError), this.prepareContainers();
    } }, { key: "prepareContainers", value: function() {
      var e3 = this;
      this.containerFactory.createContainers().then(function(t3) {
        return e3.setupContainers(t3);
      }).then(function(t3) {
        return e3.resolveOnContainersReady(t3);
      });
    } }, { key: "updateSize", value: function() {
      this.isFullscreen() ? this.setFullscreen() : this.setPlayerSize();
    } }, { key: "setFullscreen", value: function() {
      w.isiOS || (this.$el.addClass("fullscreen"), this.$el.removeAttr("style"), this.previousSize = { width: this.options.width, height: this.options.height }, this.currentSize = { width: R(window).width(), height: R(window).height() });
    } }, { key: "setPlayerSize", value: function() {
      this.$el.removeClass("fullscreen"), this.currentSize = this.previousSize, this.previousSize = { width: R(window).width(), height: R(window).height() }, this.resize(this.currentSize);
    } }, { key: "resize", value: function(e3) {
      $(e3.height) || $(e3.width) ? (this.el.style.height = "".concat(e3.height, "px"), this.el.style.width = "".concat(e3.width, "px")) : (this.el.style.height = "".concat(e3.height), this.el.style.width = "".concat(e3.width)), this.previousSize = { width: this.options.width, height: this.options.height }, this.options.width = e3.width, this.options.height = e3.height, this.currentSize = e3, this.triggerResize(this.currentSize);
    } }, { key: "enableResizeObserver", value: function() {
      var e3 = this;
      this.disableResizeObserver();
      this.resizeObserverInterval = setInterval(function() {
        e3.triggerResize({ width: e3.el.clientWidth, height: e3.el.clientHeight });
      }, 500);
    } }, { key: "triggerResize", value: function(e3) {
      (this.firstResize || this.oldHeight !== e3.height || this.oldWidth !== e3.width) && (this.oldHeight = e3.height, this.oldWidth = e3.width, this.computedSize = e3, this.firstResize = false, this.trigger(ce.CORE_RESIZE, e3));
    } }, { key: "disableResizeObserver", value: function() {
      this.resizeObserverInterval && clearInterval(this.resizeObserverInterval), this.resizeObserverInterval = null;
    } }, { key: "resolveOnContainersReady", value: function(e3) {
      var t3 = this;
      R.when.apply(R, e3).done(function() {
        t3.defer.resolve(t3), t3.ready = true, t3.trigger(ce.CORE_READY);
      });
    } }, { key: "addPlugin", value: function(e3) {
      this.plugins.push(e3);
    } }, { key: "hasPlugin", value: function(e3) {
      return !!this.getPlugin(e3);
    } }, { key: "getPlugin", value: function(e3) {
      return this.plugins.filter(function(t3) {
        return t3.name === e3;
      })[0];
    } }, { key: "load", value: function(e3, t3) {
      this.options.mimeType = t3, e3 = e3 && e3.constructor === Array ? e3 : [e3], this.options.sources = e3, this.containers.forEach(function(e4) {
        return e4.destroy();
      }), this.containerFactory.options = R.extend(true, this.options, { sources: e3 }), this.prepareContainers();
    } }, { key: "destroy", value: function() {
      this.disableResizeObserver(), this.containers.forEach(function(e3) {
        return e3.destroy();
      }), this.plugins.forEach(function(e3) {
        return e3.destroy();
      }), this.$el.remove(), R(document).unbind("fullscreenchange", this._boundFullscreenHandler), R(document).unbind("MSFullscreenChange", this._boundFullscreenHandler), R(document).unbind("mozfullscreenchange", this._boundFullscreenHandler), this.stopListening();
    } }, { key: "handleFullscreenChange", value: function() {
      this.trigger(ce.CORE_FULLSCREEN, this.isFullscreen()), this.updateSize();
    } }, { key: "handleWindowResize", value: function(e3) {
      var t3 = window.innerWidth > window.innerHeight ? "landscape" : "portrait";
      this._screenOrientation !== t3 && (this._screenOrientation = t3, this.triggerResize({ width: this.el.clientWidth, height: this.el.clientHeight }), this.trigger(ce.CORE_SCREEN_ORIENTATION_CHANGED, { event: e3, orientation: this._screenOrientation }));
    } }, { key: "removeContainer", value: function(e3) {
      this.stopListening(e3), this.containers = this.containers.filter(function(t3) {
        return t3 !== e3;
      });
    } }, { key: "setupContainer", value: function(e3) {
      this.listenTo(e3, ce.CONTAINER_DESTROYED, this.removeContainer), this.containers.push(e3);
    } }, { key: "setupContainers", value: function(e3) {
      return e3.forEach(this.setupContainer.bind(this)), this.trigger(ce.CORE_CONTAINERS_CREATED), this.renderContainers(), this.activeContainer = e3[0], this.render(), this.appendToParent(), this.containers;
    } }, { key: "renderContainers", value: function() {
      var e3 = this;
      this.containers.forEach(function(t3) {
        return e3.el.appendChild(t3.render().el);
      });
    } }, { key: "createContainer", value: function(e3, t3) {
      var r3 = this.containerFactory.createContainer(e3, t3);
      return this.setupContainer(r3), this.el.appendChild(r3.render().el), r3;
    } }, { key: "getCurrentContainer", value: function() {
      return this.activeContainer;
    } }, { key: "getCurrentPlayback", value: function() {
      return this.activePlayback;
    } }, { key: "getPlaybackType", value: function() {
      return this.activeContainer && this.activeContainer.getPlaybackType();
    } }, { key: "isFullscreen", value: function() {
      var e3 = K.fullscreenElement();
      return e3 && e3 === this.el || e3 && e3 === this.activePlaybackEl || this.activePlaybackEl && this.activePlaybackEl.webkitDisplayingFullscreen || false;
    } }, { key: "toggleFullscreen", value: function() {
      var e3 = this;
      if (this.isFullscreen()) {
        var t3 = w.isiOS ? this.activePlaybackEl : document;
        K.cancelFullscreen(t3), !w.isiOS && this.$el.removeClass("fullscreen nocursor");
      } else {
        var r3 = w.isiOS ? this.activePlaybackEl : this.el;
        if (!r3)
          return;
        w.isSafari || w.isiOS ? K.requestFullscreen(r3) : K.requestFullscreen(r3).then(function(e4) {
          return e4;
        }, function(t4) {
          return setTimeout(function() {
            if (!e3.isFullscreen())
              throw new ReferenceError(t4);
          }, 600);
        }), !w.isiOS && this.$el.addClass("fullscreen");
      }
    } }, { key: "onMouseMove", value: function(e3) {
      this.trigger(ce.CORE_MOUSE_MOVE, e3);
    } }, { key: "onMouseLeave", value: function(e3) {
      this.trigger(ce.CORE_MOUSE_LEAVE, e3);
    } }, { key: "configure", value: function(e3) {
      var t3 = this;
      this._options = R.extend(true, this._options, e3), this.configureDomRecycler();
      var r3 = e3.source || e3.sources;
      r3 && this.load(r3, e3.mimeType || this.options.mimeType), this.trigger(ce.CORE_OPTIONS_CHANGE, e3), this.containers.forEach(function(e4) {
        return e4.configure(t3.options);
      });
    } }, { key: "appendToParent", value: function() {
      var e3 = be.getStyleFor('[data-player] {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -o-user-select: none;\n  user-select: none;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  transform: translate3d(0, 0, 0);\n  position: relative;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-style: normal;\n  font-weight: normal;\n  text-align: center;\n  overflow: hidden;\n  font-size: 100%;\n  font-family: "Roboto", "Open Sans", Arial, sans-serif;\n  text-shadow: 0 0 0;\n  box-sizing: border-box; }\n  [data-player]:focus {\n    outline: 0; }\n  [data-player] * {\n    box-sizing: inherit; }\n  [data-player] > * {\n    float: none;\n    max-width: none; }\n  [data-player] > div {\n    display: block; }\n  [data-player].fullscreen {\n    width: 100% !important;\n    height: 100% !important;\n    top: 0;\n    left: 0; }\n  [data-player].nocursor {\n    cursor: none; }\n\n.clappr-style {\n  display: none !important; }\n'.toString(), { baseUrl: this.options.baseUrl }), t3 = be.getStyleFor('[data-player] div, [data-player] span, [data-player] applet, [data-player] object, [data-player] iframe,\n[data-player] h1, [data-player] h2, [data-player] h3, [data-player] h4, [data-player] h5, [data-player] h6, [data-player] p, [data-player] blockquote, [data-player] pre,\n[data-player] a, [data-player] abbr, [data-player] acronym, [data-player] address, [data-player] big, [data-player] cite, [data-player] code,\n[data-player] del, [data-player] dfn, [data-player] em, [data-player] img, [data-player] ins, [data-player] kbd, [data-player] q, [data-player] s, [data-player] samp,\n[data-player] small, [data-player] strike, [data-player] strong, [data-player] sub, [data-player] sup, [data-player] tt, [data-player] var,\n[data-player] b, [data-player] u, [data-player] i, [data-player] center,\n[data-player] dl, [data-player] dt, [data-player] dd, [data-player] ol, [data-player] ul, [data-player] li,\n[data-player] fieldset, [data-player] form, [data-player] label, [data-player] legend,\n[data-player] table, [data-player] caption, [data-player] tbody, [data-player] tfoot, [data-player] thead, [data-player] tr, [data-player] th, [data-player] td,\n[data-player] article, [data-player] aside, [data-player] canvas, [data-player] details, [data-player] embed,\n[data-player] figure, [data-player] figcaption, [data-player] footer, [data-player] header, [data-player] hgroup,\n[data-player] menu, [data-player] nav, [data-player] output, [data-player] ruby, [data-player] section, [data-player] summary,\n[data-player] time, [data-player] mark, [data-player] audio, [data-player] video {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font: inherit;\n  font-size: 100%;\n  vertical-align: baseline; }\n\n[data-player] table {\n  border-collapse: collapse;\n  border-spacing: 0; }\n\n[data-player] caption, [data-player] th, [data-player] td {\n  text-align: left;\n  font-weight: normal;\n  vertical-align: middle; }\n\n[data-player] q, [data-player] blockquote {\n  quotes: none; }\n  [data-player] q:before, [data-player] q:after, [data-player] blockquote:before, [data-player] blockquote:after {\n    content: "";\n    content: none; }\n\n[data-player] a img {\n  border: none; }\n'.toString(), { baseUrl: this.options.baseUrl });
      this.$el.append(e3[0]), this.options.includeResetStyle && this.$el.append(t3[0]), !(this.$el.parent() && this.$el.parent().length) && this.$el.appendTo(this.options.parentElement);
    } }, { key: "render", value: function() {
      this.options.width = this.options.width || this.$el.width(), this.options.height = this.options.height || this.$el.height();
      var e3 = { width: this.options.width, height: this.options.height };
      return this.previousSize = this.currentSize = this.computedSize = e3, this.updateSize(), this.enableResizeObserver(), this;
    } }]), r2;
  }(Se);
  Object.assign(Oe.prototype, Ce);
  var we, Pe, xe = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2(e3) {
      var i2;
      return s(this, r2), (i2 = t2.call(this, e3.options)).player = e3, i2;
    }
    return l(r2, [{ key: "loader", get: function() {
      return this.player.loader;
    } }, { key: "create", value: function() {
      return this.options.loader = this.loader, this.core = new Oe(this.options), this.addCorePlugins(), this.core.createContainers(this.options), this.core;
    } }, { key: "addCorePlugins", value: function() {
      var e3 = this;
      return this.loader.corePlugins.forEach(function(t3) {
        var r3 = new t3(e3.core);
        e3.core.addPlugin(r3), e3.setupExternalInterface(r3);
      }), this.core;
    } }, { key: "setupExternalInterface", value: function(e3) {
      var t3 = e3.getExternalInterface();
      for (var r3 in t3)
        this.player[r3] = t3[r3].bind(e3);
    } }]), r2;
  }(he), Ne = /(\d+)(?:\.(\d+))?(?:\.(\d+))?/, Fe = function() {
    function e2(t2, r2, i2) {
      s(this, e2), this.major = parseInt(t2 || 0, 10), this.minor = parseInt(r2 || 0, 10), this.patch = parseInt(i2 || 0, 10);
    }
    return l(e2, [{ key: "compare", value: function(e3) {
      var t2 = this.major - e3.major;
      return t2 = (t2 = t2 || this.minor - e3.minor) || this.patch - e3.patch;
    } }, { key: "inc", value: function() {
      var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "patch";
      return void 0 !== this[e3] && (this[e3] += 1), this;
    } }, { key: "satisfies", value: function(e3, t2) {
      return this.compare(e3) >= 0 && (!t2 || this.compare(t2) < 0);
    } }, { key: "toString", value: function() {
      return "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);
    } }], [{ key: "parse", value: function() {
      var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", r2 = t2.match(Ne) || [], i2 = y(r2, 4), n2 = i2[1], a2 = i2[2], s2 = i2[3];
      return void 0 === n2 ? null : new e2(n2, a2, s2);
    } }]), e2;
  }(), Me = function(e2, t2) {
    return e2 && t2 ? Object.entries(e2).filter(function(e3) {
      return y(e3, 2)[1].type === t2;
    }).reduce(function(e3, t3) {
      var r2 = y(t3, 2), i2 = r2[0], n2 = r2[1];
      return e3[i2] = n2, e3;
    }, {}) : {};
  }, Be = (we = { plugins: {}, playbacks: [] }, Pe = "0.4.27", function() {
    function e2() {
      var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
      s(this, e2), this.playerId = r2, this.playbackPlugins = A(we.playbacks);
      var i2 = e2.registeredPlugins, n2 = i2.core, a2 = i2.container;
      this.containerPlugins = Object.values(a2), this.corePlugins = Object.values(n2), Array.isArray(t2) || this.validateExternalPluginsType(t2), this.addExternalPlugins(t2);
    }
    return l(e2, [{ key: "groupPluginsByType", value: function(e3) {
      return Array.isArray(e3) && (e3 = e3.reduce(function(e4, t2) {
        return e4[t2.type] || (e4[t2.type] = []), e4[t2.type].push(t2), e4;
      }, {})), e3;
    } }, { key: "removeDups", value: function(e3) {
      var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r2 = function(e4, r3) {
        return e4[r3.prototype.name] && t2 || (e4[r3.prototype.name] && delete e4[r3.prototype.name], e4[r3.prototype.name] = r3), e4;
      }, i2 = e3.reduceRight(r2, /* @__PURE__ */ Object.create(null)), n2 = [];
      for (var a2 in i2)
        n2.unshift(i2[a2]);
      return n2;
    } }, { key: "addExternalPlugins", value: function(t2) {
      var r2 = "boolean" != typeof t2.loadExternalPluginsFirst || t2.loadExternalPluginsFirst, i2 = "boolean" != typeof t2.loadExternalPlaybacksFirst || t2.loadExternalPlaybacksFirst;
      if ((t2 = this.groupPluginsByType(t2)).playback) {
        var n2 = t2.playback.filter(function(t3) {
          return e2.checkVersionSupport(t3), true;
        });
        this.playbackPlugins = i2 ? this.removeDups(n2.concat(this.playbackPlugins)) : this.removeDups(this.playbackPlugins.concat(n2), true);
      }
      if (t2.container) {
        var a2 = t2.container.filter(function(t3) {
          return e2.checkVersionSupport(t3), true;
        });
        this.containerPlugins = r2 ? this.removeDups(a2.concat(this.containerPlugins)) : this.removeDups(this.containerPlugins.concat(a2), true);
      }
      if (t2.core) {
        var s2 = t2.core.filter(function(t3) {
          return e2.checkVersionSupport(t3), true;
        });
        this.corePlugins = r2 ? this.removeDups(s2.concat(this.corePlugins)) : this.removeDups(this.corePlugins.concat(s2), true);
      }
    } }, { key: "validateExternalPluginsType", value: function(e3) {
      ["playback", "container", "core"].forEach(function(t2) {
        (e3[t2] || []).forEach(function(e4) {
          var r2 = "external " + e4.type + " plugin on " + t2 + " array";
          if (e4.type !== t2)
            throw new ReferenceError(r2);
        });
      });
    } }], [{ key: "registeredPlaybacks", get: function() {
      return A(we.playbacks);
    } }, { key: "registeredPlugins", get: function() {
      var e3 = we.plugins;
      return { core: Me(e3, "core"), container: Me(e3, "container") };
    } }, { key: "checkVersionSupport", value: function(e3) {
      var t2 = e3.prototype, r2 = t2.supportedVersion, i2 = t2.name;
      if (!r2 || !r2.min)
        return ae.warn("Loader", "missing version information for ".concat(i2)), false;
      var n2 = r2.max ? Fe.parse(r2.max) : Fe.parse(r2.min).inc("minor"), a2 = Fe.parse(r2.min);
      return !!Fe.parse(Pe).satisfies(a2, n2) || (ae.warn("Loader", "unsupported plugin ".concat(i2, ": Clappr version ").concat(Pe, " does not match required range [").concat(a2, ",").concat(n2, ")")), false);
    } }, { key: "registerPlugin", value: function(t2) {
      if (!t2 || !t2.prototype.name)
        return ae.warn("Loader", "missing information to register plugin: ".concat(t2)), false;
      e2.checkVersionSupport(t2);
      var r2 = we.plugins;
      if (!r2)
        return false;
      var i2 = r2[t2.prototype.name];
      return i2 && ae.warn("Loader", "overriding plugin entry: ".concat(t2.prototype.name, " - ").concat(i2)), r2[t2.prototype.name] = t2, true;
    } }, { key: "registerPlayback", value: function(t2) {
      if (!t2 || !t2.prototype.name)
        return false;
      e2.checkVersionSupport(t2);
      var r2 = we.playbacks, i2 = r2.findIndex(function(e3) {
        return e3.prototype.name === t2.prototype.name;
      });
      if (i2 >= 0) {
        var n2 = r2[i2];
        r2.splice(i2, 1), ae.warn("Loader", "overriding playback entry: ".concat(n2.name, " - ").concat(n2));
      }
      return we.playbacks = [t2].concat(A(r2)), true;
    } }, { key: "unregisterPlugin", value: function(e3) {
      if (!e3)
        return false;
      var t2 = we.plugins;
      return !!t2[e3] && (delete t2[e3], true);
    } }, { key: "unregisterPlayback", value: function(e3) {
      if (!e3)
        return false;
      var t2 = we.playbacks, r2 = t2.findIndex(function(t3) {
        return t3.prototype.name === e3;
      });
      return !(r2 < 0 || (t2.splice(r2, 1), we.playbacks = t2, 0));
    } }, { key: "clearPlugins", value: function() {
      we.plugins = {};
    } }, { key: "clearPlaybacks", value: function() {
      we.playbacks = [];
    } }]), e2;
  }()), Ue = z().replace(/\/[^/]+$/, ""), Ge = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2(e3) {
      var i2;
      s(this, r2), i2 = t2.call(this, e3);
      var n2 = { playerId: W(""), persistConfig: true, width: 640, height: 360, baseUrl: Ue, allowUserInteraction: w.isMobile, includeResetStyle: true, playback: { recycleVideo: true } };
      i2._options = R.extend(true, n2, e3), i2.options.sources = i2._normalizeSources(e3), i2.options.chromeless || (i2.options.allowUserInteraction = true), i2.options.allowUserInteraction || (i2.options.disableKeyboardShortcuts = true), i2._registerOptionEventListeners(i2.options.events), i2._coreFactory = new xe(f(i2));
      var a2 = i2._getParentElement(i2.options);
      return a2 && i2.attachTo(a2), i2;
    }
    return l(r2, [{ key: "loader", get: function() {
      return this._loader || (this._loader = new Be(this.options.plugins || {}, this.options.playerId)), this._loader;
    }, set: function(e3) {
      this._loader = e3;
    } }, { key: "ended", get: function() {
      return this.core.activeContainer.ended;
    } }, { key: "buffering", get: function() {
      return this.core.activeContainer.buffering;
    } }, { key: "isReady", get: function() {
      return !!this._ready;
    } }, { key: "eventsMapping", get: function() {
      return { onReady: ce.PLAYER_READY, onResize: ce.PLAYER_RESIZE, onPlay: ce.PLAYER_PLAY, onPause: ce.PLAYER_PAUSE, onStop: ce.PLAYER_STOP, onEnded: ce.PLAYER_ENDED, onSeek: ce.PLAYER_SEEK, onError: ce.PLAYER_ERROR, onTimeUpdate: ce.PLAYER_TIMEUPDATE, onVolumeUpdate: ce.PLAYER_VOLUMEUPDATE, onSubtitleAvailable: ce.PLAYER_SUBTITLE_AVAILABLE };
    } }, { key: "_getParentElement", value: function(e3) {
      var t3 = e3.parentId, r3 = e3.parent;
      return t3 ? document.querySelector(t3) : r3;
    } }, { key: "attachTo", value: function(e3) {
      return this.options.parentElement = e3, this.core = this._coreFactory.create(), this._addEventListeners(), this;
    } }, { key: "_addEventListeners", value: function() {
      return this.core.isReady ? this._onReady() : this.listenToOnce(this.core, ce.CORE_READY, this._onReady), this.listenTo(this.core, ce.CORE_ACTIVE_CONTAINER_CHANGED, this._containerChanged), this.listenTo(this.core, ce.CORE_FULLSCREEN, this._onFullscreenChange), this.listenTo(this.core, ce.CORE_RESIZE, this._onResize), this;
    } }, { key: "_addContainerEventListeners", value: function() {
      var e3 = this.core.activeContainer;
      return e3 && (this.listenTo(e3, ce.CONTAINER_PLAY, this._onPlay), this.listenTo(e3, ce.CONTAINER_PAUSE, this._onPause), this.listenTo(e3, ce.CONTAINER_STOP, this._onStop), this.listenTo(e3, ce.CONTAINER_ENDED, this._onEnded), this.listenTo(e3, ce.CONTAINER_SEEK, this._onSeek), this.listenTo(e3, ce.CONTAINER_ERROR, this._onError), this.listenTo(e3, ce.CONTAINER_TIMEUPDATE, this._onTimeUpdate), this.listenTo(e3, ce.CONTAINER_VOLUME, this._onVolumeUpdate), this.listenTo(e3, ce.CONTAINER_SUBTITLE_AVAILABLE, this._onSubtitleAvailable)), this;
    } }, { key: "_registerOptionEventListeners", value: function() {
      var e3 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i2 = Object.keys(t3).length > 0;
      return i2 && Object.keys(r3).forEach(function(t4) {
        var i3 = e3.eventsMapping[t4];
        i3 && e3.off(i3, r3[t4]);
      }), Object.keys(t3).forEach(function(r4) {
        var i3 = e3.eventsMapping[r4];
        if (i3) {
          var n2 = t3[r4];
          (n2 = "function" == typeof n2 && n2) && e3.on(i3, n2);
        }
      }), this;
    } }, { key: "_containerChanged", value: function() {
      this.stopListening(), this._addEventListeners();
    } }, { key: "_onReady", value: function() {
      this._ready = true, this._addContainerEventListeners(), this.trigger(ce.PLAYER_READY);
    } }, { key: "_onFullscreenChange", value: function(e3) {
      this.trigger(ce.PLAYER_FULLSCREEN, e3);
    } }, { key: "_onVolumeUpdate", value: function(e3) {
      this.trigger(ce.PLAYER_VOLUMEUPDATE, e3);
    } }, { key: "_onSubtitleAvailable", value: function() {
      this.trigger(ce.PLAYER_SUBTITLE_AVAILABLE);
    } }, { key: "_onResize", value: function(e3) {
      this.trigger(ce.PLAYER_RESIZE, e3);
    } }, { key: "_onPlay", value: function(e3) {
      var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      this.trigger(ce.PLAYER_PLAY, t3);
    } }, { key: "_onPause", value: function(e3) {
      var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      this.trigger(ce.PLAYER_PAUSE, t3);
    } }, { key: "_onStop", value: function() {
      var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.trigger(ce.PLAYER_STOP, this.getCurrentTime(), e3);
    } }, { key: "_onEnded", value: function() {
      this.trigger(ce.PLAYER_ENDED);
    } }, { key: "_onSeek", value: function(e3) {
      this.trigger(ce.PLAYER_SEEK, e3);
    } }, { key: "_onTimeUpdate", value: function(e3) {
      this.trigger(ce.PLAYER_TIMEUPDATE, e3);
    } }, { key: "_onError", value: function(e3) {
      this.trigger(ce.PLAYER_ERROR, e3);
    } }, { key: "_normalizeSources", value: function(e3) {
      var t3 = e3.sources || (void 0 !== e3.source ? [e3.source] : []);
      return 0 === t3.length ? [{ source: "", mimeType: "" }] : t3;
    } }, { key: "resize", value: function(e3) {
      return this.core.resize(e3), this;
    } }, { key: "load", value: function(e3, t3, r3) {
      return void 0 !== r3 && this.configure({ autoPlay: !!r3 }), this.core.load(e3, t3), this;
    } }, { key: "destroy", value: function() {
      return this.stopListening(), this.core.destroy(), this;
    } }, { key: "consent", value: function(e3) {
      this.core.getCurrentPlayback().consent(e3);
    } }, { key: "play", value: function() {
      var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return this.core.activeContainer.play(e3), this;
    } }, { key: "pause", value: function() {
      var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return this.core.activeContainer.pause(e3), this;
    } }, { key: "stop", value: function() {
      var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return this.core.activeContainer.stop(e3), this;
    } }, { key: "seek", value: function(e3) {
      return this.core.activeContainer.seek(e3), this;
    } }, { key: "seekPercentage", value: function(e3) {
      return this.core.activeContainer.seekPercentage(e3), this;
    } }, { key: "mute", value: function() {
      return this.core.activePlayback.mute(), this;
    } }, { key: "unmute", value: function() {
      return this.core.activePlayback.unmute(), this;
    } }, { key: "isPlaying", value: function() {
      return this.core.activeContainer.isPlaying();
    } }, { key: "isDvrEnabled", value: function() {
      return this.core.activeContainer.isDvrEnabled();
    } }, { key: "isDvrInUse", value: function() {
      return this.core.activeContainer.isDvrInUse();
    } }, { key: "configure", value: function() {
      var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return this._registerOptionEventListeners(e3.events, this.options.events), this.core.configure(e3), this;
    } }, { key: "getPlugin", value: function(e3) {
      return this.core.plugins.concat(this.core.activeContainer.plugins).filter(function(t3) {
        return t3.name === e3;
      })[0];
    } }, { key: "getCurrentTime", value: function() {
      return this.core.activeContainer.getCurrentTime();
    } }, { key: "getStartTimeOffset", value: function() {
      return this.core.activeContainer.getStartTimeOffset();
    } }, { key: "getDuration", value: function() {
      return this.core.activeContainer.getDuration();
    } }]), r2;
  }(he);
  Object.assign(Ge.prototype, Ce);
  var Ve = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2(e3) {
      var i2;
      return s(this, r2), (i2 = t2.call(this, e3.options)).container = e3, i2.enabled = true, i2.bindEvents(), i2;
    }
    return l(r2, [{ key: "playerError", get: function() {
      return this.container.playerError;
    } }, { key: "enable", value: function() {
      this.enabled || (this.bindEvents(), this.enabled = true);
    } }, { key: "disable", value: function() {
      this.enabled && (this.stopListening(), this.enabled = false);
    } }, { key: "bindEvents", value: function() {
    } }, { key: "destroy", value: function() {
      this.stopListening();
    } }]), r2;
  }(he);
  Object.assign(Ve.prototype, Ce), Ve.extend = function(e2) {
    return V(Ve, e2);
  }, Ve.type = "container";
  var Ke = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2(e3) {
      var i2;
      return s(this, r2), (i2 = t2.call(this, e3.options)).core = e3, i2.enabled = true, i2.bindEvents(), i2;
    }
    return l(r2, [{ key: "playerError", get: function() {
      return this.core.playerError;
    } }, { key: "bindEvents", value: function() {
    } }, { key: "enable", value: function() {
      this.enabled || (this.bindEvents(), this.enabled = true);
    } }, { key: "disable", value: function() {
      this.enabled && (this.stopListening(), this.enabled = false);
    } }, { key: "getExternalInterface", value: function() {
      return {};
    } }, { key: "destroy", value: function() {
      this.stopListening();
    } }]), r2;
  }(he);
  Object.assign(Ke.prototype, Ce), Ke.extend = function(e2) {
    return V(Ke, e2);
  }, Ke.type = "core";
  var je = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2(e3) {
      var i2;
      return s(this, r2), (i2 = t2.call(this, e3.options)).container = e3, i2.enabled = true, i2.bindEvents(), i2;
    }
    return l(r2, [{ key: "playerError", get: function() {
      return this.container.playerError;
    } }, { key: "enable", value: function() {
      this.enabled || (this.bindEvents(), this.$el.show(), this.enabled = true);
    } }, { key: "disable", value: function() {
      this.stopListening(), this.$el.hide(), this.enabled = false;
    } }, { key: "bindEvents", value: function() {
    } }]), r2;
  }(Se);
  Object.assign(je.prototype, Ce), je.extend = function(e2) {
    return V(je, e2);
  }, je.type = "container";
  var He = { mp4: ["avc1.42E01E", "avc1.58A01E", "avc1.4D401E", "avc1.64001E", "mp4v.20.8", "mp4v.20.240", "mp4a.40.2"].map(function(e2) {
    return 'video/mp4; codecs="' + e2 + ', mp4a.40.2"';
  }), ogg: ['video/ogg; codecs="theora, vorbis"', 'video/ogg; codecs="dirac"', 'video/ogg; codecs="theora, speex"'], "3gpp": ['video/3gpp; codecs="mp4v.20.8, samr"'], webm: ['video/webm; codecs="vp8, vorbis"'], mkv: ['video/x-matroska; codecs="theora, vorbis"'], m3u8: ["application/x-mpegurl"] };
  He.ogv = He.ogg, He["3gp"] = He["3gpp"];
  var Ye = { wav: ["audio/wav"], mp3: ["audio/mp3", 'audio/mpeg;codecs="mp3"'], aac: ['audio/mp4;codecs="mp4a.40.5"'], oga: ["audio/ogg"] }, We = Object.keys(Ye).reduce(function(e2, t2) {
    return [].concat(A(e2), A(Ye[t2]));
  }, []), $e = { code: "unknown", message: "unknown" }, ze = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2() {
      var e3;
      s(this, r2);
      for (var i2 = arguments.length, n2 = new Array(i2), a2 = 0; a2 < i2; a2++)
        n2[a2] = arguments[a2];
      (e3 = t2.call.apply(t2, [this].concat(n2)))._destroyed = false, e3._loadStarted = false, e3._isBuffering = false, e3._playheadMoving = false, e3._playheadMovingTimer = null, e3._stopped = false, e3._ccTrackId = -1, e3._setupSrc(e3.options.src), e3.options.playback || (e3.options.playback = e3.options || {}), e3.options.playback.disableContextMenu = e3.options.playback.disableContextMenu || e3.options.disableVideoTagContextMenu, e3._minDvrSize = e3.isValidMinimumDVRSizeConfig ? e3.minimumDVRSizeConfig : 60;
      var o2, l2 = e3.options.playback, u2 = l2.preload || (w.isSafari ? "auto" : e3.options.preload);
      return e3.options.poster && ("string" == typeof e3.options.poster ? o2 = e3.options.poster : "string" == typeof e3.options.poster.url && (o2 = e3.options.poster.url)), R.extend(true, e3.el, { muted: e3.options.mute, defaultMuted: e3.options.mute, loop: e3.options.loop, poster: o2, preload: u2 || "metadata", crossOrigin: l2.crossOrigin, "x-webkit-playsinline": l2.playInline }), (l2.controls || e3.options.useVideoTagDefaultControls) && e3.$el.attr("controls", ""), l2.playInline && e3.$el.attr({ playsinline: "playsinline" }), l2.crossOrigin && e3.$el.attr({ crossorigin: l2.crossOrigin }), e3.settings = { default: ["seekbar"] }, e3.settings.left = ["playpause", "position", "duration"], e3.settings.right = ["fullscreen", "volume", "hd-indicator"], l2.externalTracks && e3._setupExternalTracks(l2.externalTracks), e3.options.autoPlay && e3.attemptAutoPlay(), e3;
    }
    return l(r2, [{ key: "name", get: function() {
      return "html5_video";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "tagName", get: function() {
      return this.isAudioOnly ? "audio" : "video";
    } }, { key: "isAudioOnly", get: function() {
      var e3 = this.options.src, t3 = r2._mimeTypesForUrl(e3, Ye, this.options.mimeType);
      return this.options.playback && this.options.playback.audioOnly || this.options.audioOnly || We.indexOf(t3[0]) >= 0;
    } }, { key: "attributes", get: function() {
      return { "data-html5-video": "" };
    } }, { key: "events", get: function() {
      return { canplay: "_onCanPlay", canplaythrough: "_handleBufferingEvents", durationchange: "_onDurationChange", ended: "_onEnded", error: "_onError", loadeddata: "_onLoadedData", loadedmetadata: "_onLoadedMetadata", pause: "_onPause", playing: "_onPlaying", progress: "_onProgress", seeking: "_onSeeking", seeked: "_onSeeked", stalled: "_handleBufferingEvents", timeupdate: "_onTimeUpdate", waiting: "_onWaiting" };
    } }, { key: "ended", get: function() {
      return this.el.ended;
    } }, { key: "buffering", get: function() {
      return this._isBuffering;
    } }, { key: "isLive", get: function() {
      return this.getPlaybackType() === Re.LIVE;
    } }, { key: "dvrEnabled", get: function() {
      return this.getDuration() >= this._minDvrSize && this.isLive;
    } }, { key: "minimumDVRSizeConfig", get: function() {
      return this.options.playback && this.options.playback.minimumDvrSize;
    } }, { key: "isValidMinimumDVRSizeConfig", get: function() {
      return void 0 !== this.minimumDVRSizeConfig && "number" == typeof this.minimumDVRSizeConfig;
    } }, { key: "configure", value: function(e3) {
      m(d(r2.prototype), "configure", this).call(this, e3), this.el.loop = !!e3.loop;
    } }, { key: "attemptAutoPlay", value: function() {
      var e3 = this;
      this.canAutoPlay(function(t3, r3) {
        r3 && ae.warn(e3.name, "autoplay error.", { result: t3, error: r3 }), t3 && setTimeout(function() {
          return !e3._destroyed && e3.play();
        }, 0);
      });
    } }, { key: "canAutoPlay", value: function(e3) {
      if (this.options.disableCanAutoPlay)
        e3(true, null);
      else {
        var t3 = { timeout: this.options.autoPlayTimeout || 500, inline: this.options.playback.playInline || false, muted: this.options.mute || false };
        w.isMobile && Z.options.recycleVideo && (t3.element = this.el), X(e3, t3);
      }
    } }, { key: "_setupExternalTracks", value: function(e3) {
      this._externalTracks = e3.map(function(e4) {
        return { kind: e4.kind || "subtitles", label: e4.label, lang: e4.lang, src: e4.src };
      });
    } }, { key: "_setupSrc", value: function(e3) {
      this.el.src !== e3 && (this._ccIsSetup = false, this.el.src = e3, this._src = this.el.src);
    } }, { key: "_onLoadedMetadata", value: function(e3) {
      this._handleBufferingEvents(), this.trigger(ce.PLAYBACK_LOADEDMETADATA, { duration: e3.target.duration, data: e3 }), this._updateSettings();
      var t3 = void 0 === this._options.autoSeekFromUrl || this._options.autoSeekFromUrl;
      this.getPlaybackType() !== Re.LIVE && t3 && this._checkInitialSeek();
    } }, { key: "_onDurationChange", value: function() {
      this._updateSettings(), this._onTimeUpdate(), this._onProgress();
    } }, { key: "_updateSettings", value: function() {
      this.getPlaybackType() === Re.VOD || this.getPlaybackType() === Re.AOD ? this.settings.left = ["playpause", "position", "duration"] : this.settings.left = ["playstop"], this.settings.seekEnabled = this.isSeekEnabled(), this.trigger(ce.PLAYBACK_SETTINGSUPDATE);
    } }, { key: "isSeekEnabled", value: function() {
      return isFinite(this.getDuration());
    } }, { key: "getPlaybackType", value: function() {
      var e3 = "audio" === this.tagName ? Re.AOD : Re.VOD;
      return [0, void 0, 1 / 0].indexOf(this.el.duration) >= 0 ? Re.LIVE : e3;
    } }, { key: "isHighDefinitionInUse", value: function() {
      return false;
    } }, { key: "consent", value: function(e3) {
      var t3 = this;
      if (this.isPlaying() || this.el._consented)
        m(d(r2.prototype), "consent", this).call(this, e3);
      else {
        var i2 = function i3() {
          t3.el.removeEventListener("loadedmetadata", i3, false), t3.el.removeEventListener("error", i3, false), t3.el._consented = true, m(d(r2.prototype), "consent", t3).call(t3, e3);
        };
        this.el.addEventListener("loadedmetadata", i2, false), this.el.addEventListener("error", i2, false), this.el.load();
      }
    } }, { key: "play", value: function() {
      this.trigger(ce.PLAYBACK_PLAY_INTENT), this._stopped = false, this._setupSrc(this._src), this._handleBufferingEvents();
      var e3 = this.el.play();
      e3 && e3.catch && e3.catch(function() {
      });
    } }, { key: "pause", value: function() {
      this.el.pause(), this.dvrEnabled && this._updateDvr(true);
    } }, { key: "stop", value: function() {
      this.pause(), this._stopped = true, this.el.removeAttribute("src"), this.el.load(), this._stopPlayheadMovingChecks(), this._handleBufferingEvents(), this.trigger(ce.PLAYBACK_STOP);
    } }, { key: "volume", value: function(e3) {
      0 === e3 ? (this.$el.attr({ muted: "true" }), this.el.muted = true) : (this.$el.attr({ muted: null }), this.el.muted = false, this.el.volume = e3 / 100);
    } }, { key: "mute", value: function() {
      this.el.muted = true;
    } }, { key: "unmute", value: function() {
      this.el.muted = false;
    } }, { key: "isMuted", value: function() {
      return true === this.el.muted || 0 === this.el.volume;
    } }, { key: "isPlaying", value: function() {
      return !this.el.paused && !this.el.ended;
    } }, { key: "isReady", get: function() {
      return this._isReadyState;
    } }, { key: "_startPlayheadMovingChecks", value: function() {
      null === this._playheadMovingTimer && (this._playheadMovingTimeOnCheck = null, this._determineIfPlayheadMoving(), this._playheadMovingTimer = setInterval(this._determineIfPlayheadMoving.bind(this), 500));
    } }, { key: "_stopPlayheadMovingChecks", value: function() {
      null !== this._playheadMovingTimer && (clearInterval(this._playheadMovingTimer), this._playheadMovingTimer = null, this._playheadMoving = false);
    } }, { key: "_determineIfPlayheadMoving", value: function() {
      var e3 = this._playheadMovingTimeOnCheck, t3 = this.el.currentTime;
      this._playheadMoving = e3 !== t3, this._playheadMovingTimeOnCheck = t3, this._handleBufferingEvents();
    } }, { key: "_onWaiting", value: function() {
      this._loadStarted = true, this._handleBufferingEvents();
    } }, { key: "_onLoadedData", value: function() {
      this._loadStarted = true, this._handleBufferingEvents();
    } }, { key: "_onCanPlay", value: function() {
      this._handleBufferingEvents();
    } }, { key: "_onPlaying", value: function() {
      this._checkForClosedCaptions(), this._startPlayheadMovingChecks(), this._handleBufferingEvents(), this.trigger(ce.PLAYBACK_PLAY);
    } }, { key: "_onPause", value: function() {
      this._stopPlayheadMovingChecks(), this._handleBufferingEvents(), this.trigger(ce.PLAYBACK_PAUSE);
    } }, { key: "_onSeeking", value: function() {
      this.trigger(ce.PLAYBACK_SEEK, this.getCurrentTime()), this._handleBufferingEvents();
    } }, { key: "_onSeeked", value: function() {
      this._handleBufferingEvents(), this.trigger(ce.PLAYBACK_SEEKED);
    } }, { key: "_onEnded", value: function() {
      this._handleBufferingEvents(), this.trigger(ce.PLAYBACK_ENDED, this.name);
    } }, { key: "_handleBufferingEvents", value: function() {
      var e3 = !this.el.ended && !this.el.paused, t3 = this._loadStarted && !this.el.ended && !this._stopped && (e3 && !this._playheadMoving || this.el.readyState < this.el.HAVE_FUTURE_DATA);
      this._isBuffering !== t3 && (this._isBuffering = t3, t3 ? this.trigger(ce.PLAYBACK_BUFFERING, this.name) : this.trigger(ce.PLAYBACK_BUFFERFULL, this.name));
    } }, { key: "_onError", value: function() {
      var e3 = this.el.error || $e, t3 = e3.code, r3 = e3.message, i2 = t3 === $e.code, n2 = this.createError({ code: t3, description: r3, raw: this.el.error, level: i2 ? _e.Levels.WARN : _e.Levels.FATAL });
      i2 ? ae.warn(this.name, "HTML5 unknown error: ", n2) : this.trigger(ce.PLAYBACK_ERROR, n2);
    } }, { key: "destroy", value: function() {
      this._destroyed = true, this.handleTextTrackChange && this.el.textTracks.removeEventListener("change", this.handleTextTrackChange), m(d(r2.prototype), "destroy", this).call(this), this.el.removeAttribute("src"), this.el.load(), this._src = null, Z.garbage(this.el);
    } }, { key: "_updateDvr", value: function(e3) {
      this.trigger(ce.PLAYBACK_DVR, e3), this.trigger(ce.PLAYBACK_STATS_ADD, { dvr: e3 });
    } }, { key: "seek", value: function(e3) {
      e3 < 0 && (ae.warn("Attempt to seek to a negative time. Resetting to live point. Use seekToLivePoint() to seek to the live point."), e3 = this.getDuration()), this.dvrEnabled && this._updateDvr(e3 < this.getDuration() - 3), e3 += this.el.seekable.start(0), this.el.currentTime = e3;
    } }, { key: "seekPercentage", value: function(e3) {
      var t3 = this.el.duration * (e3 / 100);
      this.seek(t3);
    } }, { key: "_checkInitialSeek", value: function() {
      var e3 = Y();
      0 !== e3 && this.seek(e3);
    } }, { key: "getCurrentTime", value: function() {
      return this.el.currentTime;
    } }, { key: "getDuration", value: function() {
      if (this.isLive) {
        if (this.el.seekable.length > 0)
          return this.el.seekable.end(0) - this.el.seekable.start(0);
        this._scheduleUpdateSettingsCheck();
      }
      return this.el.duration;
    } }, { key: "_scheduleUpdateSettingsCheck", value: function() {
      var e3 = this;
      this._updateSettingsCheckInFlight || (this._updateSettingsCheckInFlight = setTimeout(function() {
        e3._updateSettings(), e3._updateSettingsCheckInFlight = null;
      }, 1e3));
    } }, { key: "_onTimeUpdate", value: function() {
      var e3 = this.isLive ? this.getDuration() : this.el.duration;
      this.trigger(ce.PLAYBACK_TIMEUPDATE, { current: this.el.currentTime, total: e3 }, this.name);
    } }, { key: "_onProgress", value: function() {
      if (this.el.buffered.length) {
        for (var e3 = [], t3 = 0, r3 = 0; r3 < this.el.buffered.length; r3++)
          e3 = [].concat(A(e3), [{ start: this.el.buffered.start(r3), end: this.el.buffered.end(r3) }]), this.el.currentTime >= e3[r3].start && this.el.currentTime <= e3[r3].end && (t3 = r3);
        var i2 = { start: e3[t3].start, current: e3[t3].end, total: this.el.duration };
        this.trigger(ce.PLAYBACK_PROGRESS, i2, e3);
      }
    } }, { key: "_typeFor", value: function(e3) {
      var t3 = r2._mimeTypesForUrl(e3, He, this.options.mimeType);
      return 0 === t3.length && (t3 = r2._mimeTypesForUrl(e3, Ye, this.options.mimeType)), (t3[0] || "").split(";")[0];
    } }, { key: "_ready", value: function() {
      this._isReadyState || (this._isReadyState = true, this.trigger(ce.PLAYBACK_READY, this.name));
    } }, { key: "_checkForClosedCaptions", value: function() {
      if (this.isHTML5Video && !this._ccIsSetup) {
        if (this.hasClosedCaptionsTracks) {
          this.trigger(ce.PLAYBACK_SUBTITLE_AVAILABLE);
          var e3 = this.closedCaptionsTrackId;
          this.closedCaptionsTrackId = e3, this.handleTextTrackChange = this._handleTextTrackChange.bind(this), this.el.textTracks.addEventListener("change", this.handleTextTrackChange);
        }
        this._ccIsSetup = true;
      }
    } }, { key: "_handleTextTrackChange", value: function() {
      var e3 = this.closedCaptionsTracks.find(function(e4) {
        return "showing" === e4.track.mode;
      }) || { id: -1 };
      this._ccTrackId !== e3.id && (this._ccTrackId = e3.id, this.trigger(ce.PLAYBACK_SUBTITLE_CHANGED, { id: e3.id }));
    } }, { key: "isHTML5Video", get: function() {
      return this.name === r2.prototype.name;
    } }, { key: "closedCaptionsTracks", get: function() {
      var e3 = 0;
      return (this.el.textTracks ? Array.from(this.el.textTracks) : []).filter(function(e4) {
        return "subtitles" === e4.kind || "captions" === e4.kind;
      }).map(function(t3) {
        return { id: e3++, name: t3.label, track: t3 };
      });
    } }, { key: "closedCaptionsTrackId", get: function() {
      return this._ccTrackId;
    }, set: function(e3) {
      if ($(e3)) {
        var t3, r3 = this.closedCaptionsTracks;
        if (-1 !== e3) {
          if (!(t3 = r3.find(function(t4) {
            return t4.id === e3;
          })))
            return;
          if ("showing" === t3.track.mode)
            return;
        }
        r3.filter(function(e4) {
          return "hidden" !== e4.track.mode;
        }).forEach(function(e4) {
          return e4.track.mode = "hidden";
        }), t3 && (t3.track.mode = "showing"), this._ccTrackId = e3, this.trigger(ce.PLAYBACK_SUBTITLE_CHANGED, { id: e3 });
      }
    } }, { key: "template", get: function() {
      return Te('<% for (var i = 0; i < tracks.length; i++) { %>\n  <track data-html5-video-track="<%= i %>" kind="<%= tracks[i].kind %>" label="<%= tracks[i].label %>" srclang="<%= tracks[i].lang %>" src="<%= tracks[i].src %>">\n<% }; %>\n');
    } }, { key: "render", value: function() {
      this.options.playback.disableContextMenu && this.$el.on("contextmenu", function() {
        return false;
      }), this._externalTracks && this._externalTracks.length > 0 && this.$el.html(this.template({ tracks: this._externalTracks })), this._ready();
      var e3 = be.getStyleFor("[data-html5-video] {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  display: block; }\n".toString(), { baseUrl: this.options.baseUrl });
      return this.$el.append(e3[0]), this;
    } }]), r2;
  }(Re);
  ze._mimeTypesForUrl = function(e2, t2, r2) {
    var i2 = (e2.split("?")[0].match(/.*\.(.*)$/) || [])[1], n2 = r2 || i2 && t2[i2.toLowerCase()] || [];
    return n2.constructor === Array ? n2 : [n2];
  }, ze._canPlay = function(e2, t2, r2, i2) {
    var n2 = ze._mimeTypesForUrl(r2, t2, i2), a2 = document.createElement(e2);
    return !!n2.filter(function(e3) {
      return !!a2.canPlayType(e3).replace(/no/, "");
    })[0];
  }, ze.canPlay = function(e2, t2) {
    return ze._canPlay("audio", Ye, e2, t2) || ze._canPlay("video", He, e2, t2);
  };
  var qe = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2() {
      return s(this, r2), t2.apply(this, arguments);
    }
    return l(r2, [{ key: "name", get: function() {
      return "html5_audio";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "tagName", get: function() {
      return "audio";
    } }, { key: "isAudioOnly", get: function() {
      return true;
    } }, { key: "updateSettings", value: function() {
      this.settings.left = ["playpause", "position", "duration"], this.settings.seekEnabled = this.isSeekEnabled(), this.trigger(ce.PLAYBACK_SETTINGSUPDATE);
    } }, { key: "getPlaybackType", value: function() {
      return Re.AOD;
    } }]), r2;
  }(ze);
  qe.canPlay = function(e2, t2) {
    return ze._canPlay("audio", { wav: ["audio/wav"], mp3: ["audio/mp3", 'audio/mpeg;codecs="mp3"'], aac: ['audio/mp4;codecs="mp4a.40.5"'], oga: ["audio/ogg"] }, e2, t2);
  };
  var Xe = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2(e3) {
      var i2;
      return s(this, r2), (i2 = t2.call(this, e3)).el.src = e3.src, i2;
    }
    return l(r2, [{ key: "name", get: function() {
      return "html_img";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "tagName", get: function() {
      return "img";
    } }, { key: "attributes", get: function() {
      return { "data-html-img": "" };
    } }, { key: "events", get: function() {
      return { load: "_onLoad", abort: "_onError", error: "_onError" };
    } }, { key: "getPlaybackType", value: function() {
      return Re.NO_OP;
    } }, { key: "render", value: function() {
      var e3 = be.getStyleFor("[data-html-img] {\n  max-width: 100%;\n  max-height: 100%; }\n".toString(), { baseUrl: this.options.baseUrl });
      return this.$el.append(e3[0]), this.trigger(ce.PLAYBACK_READY, this.name), this;
    } }, { key: "_onLoad", value: function() {
      this.trigger(ce.PLAYBACK_ENDED, this.name);
    } }, { key: "_onError", value: function(e3) {
      var t3 = "error" === e3.type ? "load error" : "loading aborted";
      this.trigger(ce.PLAYBACK_ERROR, { message: t3 }, this.name);
    } }]), r2;
  }(Re);
  Xe.canPlay = function(e2) {
    return /\.(png|jpg|jpeg|gif|bmp|tiff|pgm|pnm|webp)(|\?.*)$/i.test(e2);
  };
  var Ze = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2() {
      var e3;
      s(this, r2);
      for (var i2 = arguments.length, n2 = new Array(i2), a2 = 0; a2 < i2; a2++)
        n2[a2] = arguments[a2];
      return (e3 = t2.call.apply(t2, [this].concat(n2)))._noiseFrameNum = -1, e3;
    }
    return l(r2, [{ key: "name", get: function() {
      return "no_op";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "template", get: function() {
      return Te("<canvas data-no-op-canvas></canvas>\n<p data-no-op-msg><%=message%></p><p>\n</p>");
    } }, { key: "attributes", get: function() {
      return { "data-no-op": "" };
    } }, { key: "render", value: function() {
      var e3 = this.options.playbackNotSupportedMessage || this.i18n.t("playback_not_supported"), t3 = be.getStyleFor("[data-no-op] {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  text-align: center; }\n\n[data-no-op] p[data-no-op-msg] {\n  position: absolute;\n  text-align: center;\n  font-size: 25px;\n  left: 0;\n  right: 0;\n  color: white;\n  padding: 10px;\n  /* center vertically */\n  top: 50%;\n  transform: translateY(-50%);\n  max-height: 100%;\n  overflow: auto; }\n\n[data-no-op] canvas[data-no-op-canvas] {\n  background-color: #777;\n  height: 100%;\n  width: 100%; }\n".toString(), { baseUrl: this.options.baseUrl });
      this.$el.append(t3[0]), this.$el.html(this.template({ message: e3 })), this.trigger(ce.PLAYBACK_READY, this.name);
      var r3 = !(!this.options.poster || !this.options.poster.showForNoOp);
      return !this.options.autoPlay && r3 || this._animate(), this;
    } }, { key: "_noise", value: function() {
      if (this._noiseFrameNum = (this._noiseFrameNum + 1) % 5, !this._noiseFrameNum) {
        var e3, t3 = this.context.createImageData(this.context.canvas.width, this.context.canvas.height);
        try {
          e3 = new Uint32Array(t3.data.buffer);
        } catch (n3) {
          e3 = new Uint32Array(this.context.canvas.width * this.context.canvas.height * 4);
          for (var r3 = t3.data, i2 = 0; i2 < r3.length; i2++)
            e3[i2] = r3[i2];
        }
        for (var n2 = e3.length, a2 = 6 * Math.random() + 4, s2 = 0, o2 = 0, l2 = 0; l2 < n2; ) {
          if (s2 < 0)
            s2 = a2 * Math.random(), o2 = 255 * Math.pow(Math.random(), 0.4) << 24;
          s2 -= 1, e3[l2++] = o2;
        }
        this.context.putImageData(t3, 0, 0);
      }
    } }, { key: "_loop", value: function() {
      var e3 = this;
      this._stop || (this._noise(), this._animationHandle = B(function() {
        return e3._loop();
      }));
    } }, { key: "destroy", value: function() {
      this._animationHandle && (U(this._animationHandle), this._stop = true);
    } }, { key: "_animate", value: function() {
      this.canvas = this.$el.find("canvas[data-no-op-canvas]")[0], this.context = this.canvas.getContext("2d"), this._loop();
    } }]), r2;
  }(Re);
  Ze.canPlay = function(e2) {
    return true;
  };
  var Qe = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2(e3) {
      var i2;
      return s(this, r2), (i2 = t2.call(this, e3))._initializeMessages(), i2;
    }
    return l(r2, [{ key: "name", get: function() {
      return "strings";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "t", value: function(e3) {
      var t3 = this._language(), r3 = this._messages.en;
      return (t3 && this._messages[t3] || r3)[e3] || r3[e3] || e3;
    } }, { key: "_language", value: function() {
      return this.core.options.language || q();
    } }, { key: "_initializeMessages", value: function() {
      this._messages = R.extend(true, { en: { live: "live", back_to_live: "back to live", disabled: "Disabled", playback_not_supported: "Your browser does not support the playback of this video. Please try using a different browser.", default_error_title: "Could not play video.", default_error_message: "There was a problem trying to load the video." }, de: { live: "Live", back_to_live: "Zur\xFCck zum Live-Video", disabled: "Deaktiviert", playback_not_supported: "Ihr Browser unterst\xFCtzt das Playback Verfahren nicht. Bitte vesuchen Sie es mit einem anderen Browser.", default_error_title: "Video kann nicht abgespielt werden", default_error_message: "Es gab ein Problem beim Laden des Videos" }, pt: { live: "ao vivo", back_to_live: "voltar para o ao vivo", disabled: "Desativado", playback_not_supported: "Seu navegador n\xE3o supporta a reprodu\xE7\xE3o deste video. Por favor, tente usar um navegador diferente.", default_error_title: "N\xE3o foi poss\xEDvel reproduzir o v\xEDdeo.", default_error_message: "Ocorreu um problema ao tentar carregar o v\xEDdeo." }, es_am: { live: "vivo", back_to_live: "volver en vivo", disabled: "No disponible", playback_not_supported: "Su navegador no soporta la reproducci\xF3n de este video. Por favor, utilice un navegador diferente.", default_error_title: "No se puede reproducir el video.", default_error_message: "Se ha producido un error al cargar el video." }, es: { live: "en directo", back_to_live: "volver al directo", disabled: "No disponible", playback_not_supported: "Este navegador no es compatible para reproducir este v\xEDdeo. Utilice un navegador diferente.", default_error_title: "No se puede reproducir el v\xEDdeo.", default_error_message: "Se ha producido un problema al cargar el v\xEDdeo." }, ru: { live: "\u043F\u0440\u044F\u043C\u043E\u0439 \u044D\u0444\u0438\u0440", back_to_live: "\u043A \u043F\u0440\u044F\u043C\u043E\u043C\u0443 \u044D\u0444\u0438\u0440\u0443", disabled: "\u041E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E", playback_not_supported: "\u0412\u0430\u0448 \u0431\u0440\u0430\u0443\u0437\u0435\u0440 \u043D\u0435 \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u0432\u043E\u0441\u043F\u0440\u043E\u0438\u0437\u0432\u0435\u0434\u0435\u043D\u0438\u0435 \u044D\u0442\u043E\u0433\u043E \u0432\u0438\u0434\u0435\u043E. \u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u043F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0434\u0440\u0443\u0433\u043E\u0439 \u0431\u0440\u0430\u0443\u0437\u0435\u0440." }, bg: { live: "\u043D\u0430 \u0436\u0438\u0432\u043E", back_to_live: "\u0412\u044A\u0440\u043D\u0438 \u043D\u0430 \u0436\u0438\u0432\u043E", disabled: "\u0418\u0437\u043A\u043B\u044E\u0447\u0435\u043D\u043E", playback_not_supported: "\u0412\u0430\u0448\u0438\u044F\u0442 \u0431\u0440\u0430\u0443\u0437\u044A\u0440 \u043D\u0435 \u043F\u043E\u0434\u0434\u044A\u0440\u0436\u0430 \u0432\u044A\u0437\u043F\u0440\u043E\u0438\u0437\u0432\u0435\u0436\u0434\u0430\u043D\u0435\u0442\u043E \u043D\u0430 \u0442\u043E\u0432\u0430 \u0432\u0438\u0434\u0435\u043E. \u041C\u043E\u043B\u044F, \u043F\u0440\u043E\u0431\u0432\u0430\u0439\u0442\u0435 \u0441 \u0434\u0440\u0443\u0433 \u0431\u0440\u0430\u0443\u0437\u044A\u0440.", default_error_title: "\u0412\u0438\u0434\u0435\u043E\u0442\u043E \u043D\u0435 \u043C\u043E\u0436\u0435 \u0434\u0430 \u0441\u0435 \u0432\u044A\u0437\u043F\u0440\u043E\u0438\u0437\u0432\u0435\u0434\u0435.", default_error_message: "\u0412\u044A\u0437\u043D\u0438\u043A\u043D\u0430 \u043F\u0440\u043E\u0431\u043B\u0435\u043C \u043F\u0440\u0438 \u0437\u0430\u0440\u0435\u0436\u0434\u0430\u043D\u0435\u0442\u043E \u043D\u0430 \u0432\u0438\u0434\u0435\u043E\u0442\u043E." }, fr: { live: "en direct", back_to_live: "retour au direct", disabled: "D\xE9sactiv\xE9", playback_not_supported: "Votre navigateur ne supporte pas la lecture de cette vid\xE9o. Merci de tenter sur un autre navigateur.", default_error_title: "Impossible de lire la vid\xE9o.", default_error_message: "Un probl\xE8me est survenu lors du chargement de la vid\xE9o." }, tr: { live: "canl\u0131", back_to_live: "canl\u0131 yay\u0131na d\xF6n", disabled: "Engelli", playback_not_supported: "Taray\u0131c\u0131n\u0131z bu videoyu oynatma deste\u011Fine sahip de\u011Fil. L\xFCtfen farkl\u0131 bir taray\u0131c\u0131 ile deneyin." }, et: { live: "Otse\xFClekanne", back_to_live: "Tagasi otse\xFClekande juurde", disabled: "Keelatud", playback_not_supported: "Teie brauser ei toeta selle video taasesitust. Proovige kasutada muud brauserit." }, ar: { live: "\u0645\u0628\u0627\u0634\u0631", back_to_live: "\u0627\u0644\u0631\u062C\u0648\u0639 \u0625\u0644\u0649 \u0627\u0644\u0645\u0628\u0627\u0634\u0631", disabled: "\u0645\u0639\u0637\u0651\u0644", playback_not_supported: "\u0627\u0644\u0645\u062A\u0635\u0641\u062D \u0627\u0644\u0630\u064A \u062A\u0633\u062A\u062E\u062F\u0645\u0647 \u0644\u0627 \u064A\u062F\u0639\u0645 \u062A\u0634\u063A\u064A\u0644 \u0647\u0630\u0627 \u0627\u0644\u0641\u064A\u062F\u064A\u0648. \u0627\u0644\u0631\u062C\u0627\u0621 \u0625\u0633\u062A\u062E\u062F\u0627\u0645 \u0645\u062A\u0635\u0641\u062D \u0622\u062E\u0631.", default_error_title: "\u063A\u064A\u0631 \u0642\u0627\u062F\u0631 \u0627\u0644\u0649 \u0627\u0644\u062A\u0634\u063A\u064A\u0644.", default_error_message: "\u062D\u062F\u062B\u062A \u0645\u0634\u0643\u0644\u0629 \u0623\u062B\u0646\u0627\u0621 \u062A\u062D\u0645\u064A\u0644 \u0627\u0644\u0641\u064A\u062F\u064A\u0648." }, zh: { live: "\u76F4\u64AD", back_to_live: "\u8FD4\u56DE\u76F4\u64AD", disabled: "\u5DF2\u7981\u7528", playback_not_supported: "\u60A8\u7684\u6D4F\u89C8\u5668\u4E0D\u652F\u6301\u8BE5\u89C6\u9891\u7684\u64AD\u653E\u3002\u8BF7\u5C1D\u8BD5\u4F7F\u7528\u53E6\u4E00\u4E2A\u6D4F\u89C8\u5668\u3002", default_error_title: "\u65E0\u6CD5\u64AD\u653E\u89C6\u9891\u3002", default_error_message: "\u5728\u5C1D\u8BD5\u52A0\u8F7D\u89C6\u9891\u65F6\u51FA\u73B0\u4E86\u95EE\u9898\u3002" } }, this.core.options.strings || {}), this._messages["de-DE"] = this._messages.de, this._messages["pt-BR"] = this._messages.pt, this._messages["en-US"] = this._messages.en, this._messages["bg-BG"] = this._messages.bg, this._messages["es-419"] = this._messages.es_am, this._messages["es-ES"] = this._messages.es, this._messages["fr-FR"] = this._messages.fr, this._messages["tr-TR"] = this._messages.tr, this._messages["et-EE"] = this._messages.et, this._messages["ar-IQ"] = this._messages.ar, this._messages["zh-CN"] = this._messages.zh;
    } }]), r2;
  }(Ke), Je = function(e2) {
    c(r2, e2);
    var t2 = g(r2);
    function r2() {
      return s(this, r2), t2.apply(this, arguments);
    }
    return l(r2, [{ key: "name", get: function() {
      return "sources";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "bindEvents", value: function() {
      this.listenTo(this.core, ce.CORE_CONTAINERS_CREATED, this.onContainersCreated);
    } }, { key: "onContainersCreated", value: function() {
      var e3 = this.core.containers.filter(function(e4) {
        return "no_op" !== e4.playback.name;
      })[0] || this.core.containers[0];
      e3 && this.core.containers.forEach(function(t3) {
        t3 !== e3 && t3.destroy();
      });
    } }]), r2;
  }(Ke);
  Be.registerPlugin(Qe), Be.registerPlugin(Je), Be.registerPlayback(Ze), Be.registerPlayback(Xe), Be.registerPlayback(qe), Be.registerPlayback(ze);
  var et = { Player: Ge, Events: ce, Browser: w, ContainerPlugin: Ve, UIContainerPlugin: je, CorePlugin: Ke, UICorePlugin: Le, Playback: Re, Container: De, Core: Oe, PlayerError: _e, Loader: Be, BaseObject: he, UIObject: Se, Utils: J, HTML5Audio: qe, HTML5Video: ze, HTMLImg: Xe, Log: ae, Styler: be, version: "0.4.27", template: Te, $: R };
  function tt(e2, t2) {
    if (!(e2 instanceof t2))
      throw new TypeError("Cannot call a class as a function");
  }
  function rt(e2, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var i2 = t2[r2];
      i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e2, (n2 = i2.key, a2 = void 0, "symbol" == typeof (a2 = function(e3, t3) {
        if ("object" != typeof e3 || null === e3)
          return e3;
        var r3 = e3[Symbol.toPrimitive];
        if (void 0 !== r3) {
          var i3 = r3.call(e3, t3 || "default");
          if ("object" != typeof i3)
            return i3;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t3 ? String : Number)(e3);
      }(n2, "string")) ? a2 : String(a2)), i2);
    }
    var n2, a2;
  }
  function it(e2, t2, r2) {
    return t2 && rt(e2.prototype, t2), r2 && rt(e2, r2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
  }
  function nt(e2, t2) {
    if ("function" != typeof t2 && null !== t2)
      throw new TypeError("Super expression must either be null or a function");
    e2.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e2, writable: true, configurable: true } }), Object.defineProperty(e2, "prototype", { writable: false }), t2 && st(e2, t2);
  }
  function at(e2) {
    return at = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e3) {
      return e3.__proto__ || Object.getPrototypeOf(e3);
    }, at(e2);
  }
  function st(e2, t2) {
    return st = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e3, t3) {
      return e3.__proto__ = t3, e3;
    }, st(e2, t2);
  }
  function ot(e2, t2) {
    if (t2 && ("object" == typeof t2 || "function" == typeof t2))
      return t2;
    if (void 0 !== t2)
      throw new TypeError("Derived constructors may only return object or undefined");
    return function(e3) {
      if (void 0 === e3)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e3;
    }(e2);
  }
  function lt(e2) {
    var t2 = function() {
      if ("undefined" == typeof Reflect || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if ("function" == typeof Proxy)
        return true;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), true;
      } catch (e3) {
        return false;
      }
    }();
    return function() {
      var r2, i2 = at(e2);
      if (t2) {
        var n2 = at(this).constructor;
        r2 = Reflect.construct(i2, arguments, n2);
      } else
        r2 = i2.apply(this, arguments);
      return ot(this, r2);
    };
  }
  function ut(e2, t2) {
    for (; !Object.prototype.hasOwnProperty.call(e2, t2) && null !== (e2 = at(e2)); )
      ;
    return e2;
  }
  function ct() {
    return ct = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e2, t2, r2) {
      var i2 = ut(e2, t2);
      if (i2) {
        var n2 = Object.getOwnPropertyDescriptor(i2, t2);
        return n2.get ? n2.get.call(arguments.length < 3 ? e2 : r2) : n2.value;
      }
    }, ct.apply(this, arguments);
  }
  var dt = function(e2) {
    nt(r2, e2);
    var t2 = lt(r2);
    function r2(e3) {
      return tt(this, r2), t2.call(this, e3);
    }
    return it(r2, [{ key: "name", get: function() {
      return "click_to_pause";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "config", get: function() {
      return this.container.options.clickToPauseConfig || {};
    } }, { key: "bindEvents", value: function() {
      this.listenTo(this.container, ce.CONTAINER_CLICK, this.click), this.listenTo(this.container, ce.CONTAINER_SETTINGSUPDATE, this.settingsUpdate);
    } }, { key: "click", value: function() {
      var e3 = this.config.onClickPayload;
      (this.container.getPlaybackType() !== Re.LIVE || this.container.isDvrEnabled()) && (this.container.isPlaying() ? this.container.pause(e3) : this.container.play(e3));
    } }, { key: "settingsUpdate", value: function() {
      var e3 = this.container.getPlaybackType() !== Re.LIVE || this.container.isDvrEnabled();
      if (e3 !== this.pointerEnabled) {
        var t3 = e3 ? "addClass" : "removeClass";
        this.container.$el[t3]("pointer-enabled"), this.pointerEnabled = e3;
      }
    } }]), r2;
  }(Ve), ht = function(e2) {
    nt(r2, e2);
    var t2 = lt(r2);
    function r2(e3) {
      var i2;
      tt(this, r2), i2 = t2.call(this, e3);
      var n2 = e3.options.closedCaptionsConfig;
      return i2._title = n2 && n2.title ? n2.title : null, i2._ariaLabel = n2 && n2.ariaLabel ? n2.ariaLabel : "cc-button", i2._labelCb = n2 && n2.labelCallback && "function" == typeof n2.labelCallback ? n2.labelCallback : function(e4) {
        return e4.name;
      }, i2;
    }
    return it(r2, [{ key: "name", get: function() {
      return "closed_captions";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "template", get: function() {
      return Te('<button type="button" class="cc-button media-control-button media-control-icon" data-cc-button aria-label="<%= ariaLabel %>"></button>\n<ul>\n  <% if (title) { %>\n  <li data-title><%= title %></li>\n  <% }; %>\n  <li><a href="#" data-cc-select="-1"><%= disabledLabel %></a></li>\n  <% for (var i = 0; i < tracks.length; i++) { %>\n    <li><a href="#" data-cc-select="<%= tracks[i].id %>"><%= tracks[i].label %></a></li>\n  <% }; %>\n</ul>\n');
    } }, { key: "events", get: function() {
      return { "click [data-cc-button]": "toggleContextMenu", "click [data-cc-select]": "onTrackSelect" };
    } }, { key: "attributes", get: function() {
      return { class: "cc-controls", "data-cc-controls": "" };
    } }, { key: "bindEvents", value: function() {
      this.listenTo(this.core, ce.CORE_ACTIVE_CONTAINER_CHANGED, this.containerChanged), this.listenTo(this.core.mediaControl, ce.MEDIACONTROL_RENDERED, this.render), this.listenTo(this.core.mediaControl, ce.MEDIACONTROL_HIDE, this.hideContextMenu), this.bindContainerEvents();
    } }, { key: "bindContainerEvents", value: function() {
      this.container = this.core.activeContainer, this.container && (this.listenTo(this.container, ce.CONTAINER_SUBTITLE_AVAILABLE, this.onSubtitleAvailable), this.listenTo(this.container, ce.CONTAINER_SUBTITLE_CHANGED, this.onSubtitleChanged), this.listenTo(this.container, ce.CONTAINER_STOP, this.onContainerStop));
    } }, { key: "onContainerStop", value: function() {
      this.ccAvailable(false);
    } }, { key: "containerChanged", value: function() {
      this.ccAvailable(false), this.stopListening(), this.bindEvents();
    } }, { key: "onSubtitleAvailable", value: function() {
      this.renderCcButton(), this.ccAvailable(true);
    } }, { key: "onSubtitleChanged", value: function(e3) {
      this.setCurrentContextMenuElement(e3.id);
    } }, { key: "onTrackSelect", value: function(e3) {
      var t3 = parseInt(e3.target.dataset.ccSelect, 10);
      return this.container.closedCaptionsTrackId = t3, this.hideContextMenu(), e3.stopPropagation(), false;
    } }, { key: "ccAvailable", value: function(e3) {
      var t3 = e3 ? "addClass" : "removeClass";
      this.$el[t3]("available");
    } }, { key: "toggleContextMenu", value: function() {
      this.$el.find("ul").toggle();
    } }, { key: "hideContextMenu", value: function() {
      this.$el.find("ul").hide();
    } }, { key: "contextMenuElement", value: function(e3) {
      return this.$el.find("ul a" + (isNaN(e3) ? "" : '[data-cc-select="' + e3 + '"]')).parent();
    } }, { key: "setCurrentContextMenuElement", value: function(e3) {
      if (this._trackId !== e3) {
        this.contextMenuElement().removeClass("current"), this.contextMenuElement(e3).addClass("current");
        var t3 = e3 > -1 ? "addClass" : "removeClass";
        this.$ccButton[t3]("enabled"), this._trackId = e3;
      }
    } }, { key: "renderCcButton", value: function() {
      for (var e3 = this.container ? this.container.closedCaptionsTracks : [], t3 = 0; t3 < e3.length; t3++)
        e3[t3].label = this._labelCb(e3[t3]);
      var r3 = be.getStyleFor(".cc-controls[data-cc-controls] {\n  float: right;\n  position: relative;\n  display: none; }\n  .cc-controls[data-cc-controls].available {\n    display: block; }\n  .cc-controls[data-cc-controls] .cc-button {\n    padding: 6px !important; }\n    .cc-controls[data-cc-controls] .cc-button.enabled {\n      display: block;\n      opacity: 1.0; }\n      .cc-controls[data-cc-controls] .cc-button.enabled:hover {\n        opacity: 1.0;\n        text-shadow: none; }\n  .cc-controls[data-cc-controls] > ul {\n    list-style-type: none;\n    position: absolute;\n    bottom: 25px;\n    border: 1px solid black;\n    display: none;\n    background-color: #e6e6e6; }\n  .cc-controls[data-cc-controls] li {\n    font-size: 10px; }\n    .cc-controls[data-cc-controls] li[data-title] {\n      background-color: #c3c2c2;\n      padding: 5px; }\n    .cc-controls[data-cc-controls] li a {\n      color: #444;\n      padding: 2px 10px;\n      display: block;\n      text-decoration: none; }\n      .cc-controls[data-cc-controls] li a:hover {\n        background-color: #555;\n        color: white; }\n        .cc-controls[data-cc-controls] li a:hover a {\n          color: white;\n          text-decoration: none; }\n    .cc-controls[data-cc-controls] li.current a {\n      color: #f00; }\n", { baseUrl: this.options.baseUrl });
      this.$el.html(this.template({ ariaLabel: this._ariaLabel, disabledLabel: this.core.i18n.t("disabled"), title: this._title, tracks: e3 })), this.$ccButton = this.$el.find("button.cc-button[data-cc-button]"), this.$ccButton.append('<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 49 41.8" style="enable-background:new 0 0 49 41.8;" xml:space="preserve">\n<path d="M47.1,0H3.2C1.6,0,0,1.2,0,2.8v31.5C0,35.9,1.6,37,3.2,37h11.9l3.2,1.9l4.7,2.7c0.9,0.5,2-0.1,2-1.1V37h22.1\n	c1.6,0,1.9-1.1,1.9-2.7V2.8C49,1.2,48.7,0,47.1,0z M7.2,18.6c0-4.8,3.5-9.3,9.9-9.3c4.8,0,7.1,2.7,7.1,2.7l-2.5,4\n	c0,0-1.7-1.7-4.2-1.7c-2.8,0-4.3,2.1-4.3,4.3c0,2.1,1.5,4.4,4.5,4.4c2.5,0,4.9-2.1,4.9-2.1l2.2,4.2c0,0-2.7,2.9-7.6,2.9\n	C10.8,27.9,7.2,23.5,7.2,18.6z M36.9,27.9c-6.4,0-9.9-4.4-9.9-9.3c0-4.8,3.5-9.3,9.9-9.3C41.7,9.3,44,12,44,12l-2.5,4\n	c0,0-1.7-1.7-4.2-1.7c-2.8,0-4.3,2.1-4.3,4.3c0,2.1,1.5,4.4,4.5,4.4c2.5,0,4.9-2.1,4.9-2.1l2.2,4.2C44.5,25,41.9,27.9,36.9,27.9z"/>\n</svg>'), this.$el.append(r3[0]);
    } }, { key: "render", value: function() {
      this.renderCcButton();
      var e3 = this.core.mediaControl.$el.find("button[data-fullscreen]");
      return e3[0] ? this.$el.insertAfter(e3) : this.core.mediaControl.$el.find(".media-control-right-panel[data-media-control]").prepend(this.$el), this;
    } }]), r2;
  }(Le), ft = function(e2) {
    nt(r2, e2);
    var t2 = lt(r2);
    function r2(e3) {
      var i2;
      return tt(this, r2), (i2 = t2.call(this, e3)).settingsUpdate(), i2;
    }
    return it(r2, [{ key: "template", get: function() {
      return Te('<div class="live-info"><%= live %></div>\n<button type="button" class="live-button" aria-label="<%= backToLive %>"><%= backToLive %></button>\n');
    } }, { key: "name", get: function() {
      return "dvr_controls";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "events", get: function() {
      return { "click .live-button": "click" };
    } }, { key: "attributes", get: function() {
      return { class: "dvr-controls", "data-dvr-controls": "" };
    } }, { key: "bindEvents", value: function() {
      this.bindCoreEvents(), this.bindContainerEvents();
    } }, { key: "bindCoreEvents", value: function() {
      var e3 = this;
      this.core.mediaControl.settings ? (this.listenTo(this.core.mediaControl, ce.MEDIACONTROL_CONTAINERCHANGED, this.containerChanged), this.listenTo(this.core.mediaControl, ce.MEDIACONTROL_RENDERED, this.settingsUpdate), this.listenTo(this.core, ce.CORE_OPTIONS_CHANGE, this.render)) : setTimeout(function() {
        return e3.bindCoreEvents();
      }, 100);
    } }, { key: "bindContainerEvents", value: function() {
      this.core.activeContainer && (this.listenToOnce(this.core.activeContainer, ce.CONTAINER_TIMEUPDATE, this.render), this.listenTo(this.core.activeContainer, ce.CONTAINER_PLAYBACKDVRSTATECHANGED, this.dvrChanged));
    } }, { key: "containerChanged", value: function() {
      this.stopListening(), this.bindEvents();
    } }, { key: "dvrChanged", value: function(e3) {
      this.core.getPlaybackType() === Re.LIVE && (this.settingsUpdate(), this.core.mediaControl.$el.addClass("live"), e3 ? (this.core.mediaControl.$el.addClass("dvr"), this.core.mediaControl.$el.find(".media-control-indicator[data-position], .media-control-indicator[data-duration]").hide()) : this.core.mediaControl.$el.removeClass("dvr"));
    } }, { key: "click", value: function() {
      var e3 = this.core.mediaControl, t3 = e3.container;
      t3.isPlaying() || t3.play(), e3.$el.hasClass("dvr") && t3.seek(t3.getDuration());
    } }, { key: "settingsUpdate", value: function() {
      var e3 = this;
      this.stopListening(), this.core.mediaControl.$el.removeClass("live"), this.shouldRender() && (this.render(), this.$el.click(function() {
        return e3.click();
      })), this.bindEvents();
    } }, { key: "shouldRender", value: function() {
      return (void 0 === this.core.options.useDvrControls || !!this.core.options.useDvrControls) && this.core.getPlaybackType() === Re.LIVE;
    } }, { key: "render", value: function() {
      var e3 = be.getStyleFor('.dvr-controls[data-dvr-controls] {\n  display: inline-block;\n  float: left;\n  color: #fff;\n  line-height: 32px;\n  font-size: 10px;\n  font-weight: bold;\n  margin-left: 6px; }\n  .dvr-controls[data-dvr-controls] .live-info {\n    cursor: default;\n    font-family: "Roboto", "Open Sans", Arial, sans-serif;\n    text-transform: uppercase; }\n    .dvr-controls[data-dvr-controls] .live-info:before {\n      content: "";\n      display: inline-block;\n      position: relative;\n      width: 7px;\n      height: 7px;\n      border-radius: 3.5px;\n      margin-right: 3.5px;\n      background-color: #ff0101; }\n    .dvr-controls[data-dvr-controls] .live-info.disabled {\n      opacity: 0.3; }\n      .dvr-controls[data-dvr-controls] .live-info.disabled:before {\n        background-color: #fff; }\n  .dvr-controls[data-dvr-controls] .live-button {\n    cursor: pointer;\n    outline: none;\n    display: none;\n    border: 0;\n    color: #fff;\n    background-color: transparent;\n    height: 32px;\n    padding: 0;\n    opacity: 0.7;\n    font-family: "Roboto", "Open Sans", Arial, sans-serif;\n    text-transform: uppercase;\n    transition: all 0.1s ease; }\n    .dvr-controls[data-dvr-controls] .live-button:before {\n      content: "";\n      display: inline-block;\n      position: relative;\n      width: 7px;\n      height: 7px;\n      border-radius: 3.5px;\n      margin-right: 3.5px;\n      background-color: #fff; }\n    .dvr-controls[data-dvr-controls] .live-button:hover {\n      opacity: 1;\n      text-shadow: rgba(255, 255, 255, 0.75) 0 0 5px; }\n\n.dvr .dvr-controls[data-dvr-controls] .live-info {\n  display: none; }\n\n.dvr .dvr-controls[data-dvr-controls] .live-button {\n  display: block; }\n\n.dvr.media-control.live[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-fill-2[data-seekbar] {\n  background-color: #005aff; }\n\n.media-control.live[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-fill-2[data-seekbar] {\n  background-color: #ff0101; }\n', { baseUrl: this.options.baseUrl });
      return this.$el.html(this.template({ live: this.core.i18n.t("live"), backToLive: this.core.i18n.t("back_to_live") })), this.$el.append(e3[0]), this.shouldRender() && (this.core.mediaControl.$el.addClass("live"), this.core.mediaControl.$(".media-control-left-panel[data-media-control]").append(this.$el)), this;
    } }]), r2;
  }(Le), pt = function(e2) {
    nt(r2, e2);
    var t2 = lt(r2);
    function r2() {
      return tt(this, r2), t2.apply(this, arguments);
    }
    return it(r2, [{ key: "name", get: function() {
      return "end_video";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "bindEvents", value: function() {
      this.listenTo(this.core, ce.CORE_ACTIVE_CONTAINER_CHANGED, this.containerChanged);
      var e3 = this.core.activeContainer;
      e3 && (this.listenTo(e3, ce.CONTAINER_ENDED, this.ended), this.listenTo(e3, ce.CONTAINER_STOP, this.ended));
    } }, { key: "containerChanged", value: function() {
      this.stopListening(), this.bindEvents();
    } }, { key: "ended", value: function() {
      (void 0 === this.core.options.exitFullscreenOnEnd || this.core.options.exitFullscreenOnEnd) && this.core.isFullscreen() && this.core.toggleFullscreen();
    } }]), r2;
  }(Ke), gt = function(e2) {
    nt(r2, e2);
    var t2 = lt(r2);
    function r2(e3) {
      var i2;
      return tt(this, r2), (i2 = t2.call(this, e3)).options.disableErrorScreen ? ot(i2, i2.disable()) : i2;
    }
    return it(r2, [{ key: "name", get: function() {
      return "error_screen";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "template", get: function() {
      return Te('<div class="player-error-screen__content" data-error-screen>\n  <% if (icon) { %>\n  <div class="player-error-screen__icon" data-error-screen><%= icon %></div>\n  <% } %>\n  <div class="player-error-screen__title" data-error-screen><%= title %></div>\n  <div class="player-error-screen__message" data-error-screen><%= message %></div>\n  <div class="player-error-screen__code" data-error-screen>Error code: <%= code %></div>\n  <div class="player-error-screen__reload" data-error-screen><%= reloadIcon %></div>\n</div>\n');
    } }, { key: "container", get: function() {
      return this.core.getCurrentContainer();
    } }, { key: "attributes", get: function() {
      return { class: "player-error-screen", "data-error-screen": "" };
    } }, { key: "bindEvents", value: function() {
      this.listenTo(this.core, ce.ERROR, this.onError), this.listenTo(this.core, ce.CORE_ACTIVE_CONTAINER_CHANGED, this.onContainerChanged);
    } }, { key: "bindReload", value: function() {
      this.reloadButton = this.$el.find(".player-error-screen__reload"), this.reloadButton && this.reloadButton.on("click", this.reload.bind(this));
    } }, { key: "reload", value: function() {
      var e3 = this;
      this.listenToOnce(this.core, ce.CORE_READY, function() {
        return e3.container.play();
      }), this.core.load(this.options.sources, this.options.mimeType), this.unbindReload();
    } }, { key: "unbindReload", value: function() {
      this.reloadButton && this.reloadButton.off("click");
    } }, { key: "onContainerChanged", value: function() {
      this.err = null, this.unbindReload(), this.hide();
    } }, { key: "onError", value: function() {
      var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      e3.level === _e.Levels.FATAL && (this.err = e3, this.container.disableMediaControl(), this.container.stop(), this.show());
    } }, { key: "show", value: function() {
      this.render(), this.$el.show();
    } }, { key: "hide", value: function() {
      this.$el.hide();
    } }, { key: "render", value: function() {
      if (this.err) {
        var e3 = be.getStyleFor("[data-player] .player-error-screen {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  color: #CCCACA;\n  position: absolute;\n  top: 0;\n  height: 100%;\n  width: 100%;\n  background-color: rgba(0, 0, 0, 0.7);\n  z-index: 2000;\n  display: flex;\n  flex-direction: column;\n  justify-content: center; }\n  [data-player] .player-error-screen__content[data-error-screen] {\n    font-size: 14px;\n    color: #CCCACA;\n    margin-top: 45px; }\n  [data-player] .player-error-screen__title[data-error-screen] {\n    font-weight: bold;\n    line-height: 30px;\n    font-size: 18px; }\n  [data-player] .player-error-screen__message[data-error-screen] {\n    width: 90%;\n    margin: 0 auto; }\n  [data-player] .player-error-screen__code[data-error-screen] {\n    font-size: 13px;\n    margin-top: 15px; }\n  [data-player] .player-error-screen__reload {\n    cursor: pointer;\n    width: 30px;\n    margin: 15px auto 0 !important; }\n", { baseUrl: this.options.baseUrl });
        return this.$el.html(this.template({ title: this.err.UI.title, message: this.err.UI.message, code: this.err.code, icon: this.err.UI.icon || "", reloadIcon: '<svg fill="#FFFFFF" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>' })), this.$el.append(e3[0]), this.core.$el.append(this.el), this.bindReload(), this;
      }
    } }]), r2;
  }(Le), vt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">\n  <path fill="#010101" d="M1.425.35L14.575 8l-13.15 7.65V.35z"/>\n</svg>', mt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">\n  <path fill-rule="evenodd" clip-rule="evenodd" fill="#010101" d="M1.712 14.76H6.43V1.24H1.71v13.52zm7.86-13.52v13.52h4.716V1.24H9.573z"/>\n</svg>', yt = R('link[rel="shortcut icon"]'), At = function(e2) {
    nt(r2, e2);
    var t2 = lt(r2);
    function r2(e3) {
      var i2;
      return tt(this, r2), (i2 = t2.call(this, e3))._container = null, i2.configure(), i2;
    }
    return it(r2, [{ key: "name", get: function() {
      return "favicon";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "oldIcon", get: function() {
      return yt;
    } }, { key: "configure", value: function() {
      this.core.options.changeFavicon ? this.enabled || (this.stopListening(this.core, ce.CORE_OPTIONS_CHANGE), this.enable()) : this.enabled && (this.disable(), this.listenTo(this.core, ce.CORE_OPTIONS_CHANGE, this.configure));
    } }, { key: "bindEvents", value: function() {
      this.listenTo(this.core, ce.CORE_OPTIONS_CHANGE, this.configure), this.listenTo(this.core, ce.CORE_ACTIVE_CONTAINER_CHANGED, this.containerChanged), this.core.activeContainer && this.containerChanged();
    } }, { key: "containerChanged", value: function() {
      this._container && this.stopListening(this._container), this._container = this.core.activeContainer, this.listenTo(this._container, ce.CONTAINER_PLAY, this.setPlayIcon), this.listenTo(this._container, ce.CONTAINER_PAUSE, this.setPauseIcon), this.listenTo(this._container, ce.CONTAINER_STOP, this.resetIcon), this.listenTo(this._container, ce.CONTAINER_ENDED, this.resetIcon), this.listenTo(this._container, ce.CONTAINER_ERROR, this.resetIcon), this.resetIcon();
    } }, { key: "disable", value: function() {
      ct(at(r2.prototype), "disable", this).call(this), this.resetIcon();
    } }, { key: "destroy", value: function() {
      ct(at(r2.prototype), "destroy", this).call(this), this.resetIcon();
    } }, { key: "createIcon", value: function(e3) {
      var t3 = R("<canvas/>");
      t3[0].width = 16, t3[0].height = 16;
      var r3 = t3[0].getContext("2d");
      r3.fillStyle = "#000";
      var i2 = R(e3).find("path").attr("d"), n2 = new Path2D(i2);
      r3.fill(n2);
      var a2 = R('<link rel="shortcut icon" type="image/png"/>');
      return a2.attr("href", t3[0].toDataURL("image/png")), a2;
    } }, { key: "setPlayIcon", value: function() {
      this.playIcon || (this.playIcon = this.createIcon(vt)), this.changeIcon(this.playIcon);
    } }, { key: "setPauseIcon", value: function() {
      this.pauseIcon || (this.pauseIcon = this.createIcon(mt)), this.changeIcon(this.pauseIcon);
    } }, { key: "resetIcon", value: function() {
      R('link[rel="shortcut icon"]').remove(), R("head").append(this.oldIcon);
    } }, { key: "changeIcon", value: function(e3) {
      e3 && (R('link[rel="shortcut icon"]').remove(), R("head").append(e3));
    } }]), r2;
  }(Ke), Et = function(e2) {
    nt(r2, e2);
    var t2 = lt(r2);
    function r2(e3) {
      var i2;
      return tt(this, r2), (i2 = t2.call(this, e3)).container.options.gaAccount && (i2.account = i2.container.options.gaAccount, i2.trackerName = i2.container.options.gaTrackerName ? i2.container.options.gaTrackerName + "." : "Clappr.", i2.domainName = i2.container.options.gaDomainName, i2.currentHDState = void 0, i2.embedScript()), i2;
    }
    return it(r2, [{ key: "name", get: function() {
      return "google_analytics";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "embedScript", value: function() {
      var e3 = this;
      if (window._gat)
        this.addEventListeners();
      else {
        var t3 = document.createElement("script");
        t3.setAttribute("type", "text/javascript"), t3.setAttribute("async", "async"), t3.setAttribute("src", "//www.google-analytics.com/ga.js"), t3.onload = function() {
          return e3.addEventListeners();
        }, document.body.appendChild(t3);
      }
    } }, { key: "addEventListeners", value: function() {
      var e3 = this;
      this.container && (this.listenTo(this.container, ce.CONTAINER_READY, this.onReady), this.listenTo(this.container, ce.CONTAINER_PLAY, this.onPlay), this.listenTo(this.container, ce.CONTAINER_STOP, this.onStop), this.listenTo(this.container, ce.CONTAINER_PAUSE, this.onPause), this.listenTo(this.container, ce.CONTAINER_ENDED, this.onEnded), this.listenTo(this.container, ce.CONTAINER_STATE_BUFFERING, this.onBuffering), this.listenTo(this.container, ce.CONTAINER_STATE_BUFFERFULL, this.onBufferFull), this.listenTo(this.container, ce.CONTAINER_ERROR, this.onError), this.listenTo(this.container, ce.CONTAINER_PLAYBACKSTATE, this.onPlaybackChanged), this.listenTo(this.container, ce.CONTAINER_VOLUME, function(t3) {
        return e3.onVolumeChanged(t3);
      }), this.listenTo(this.container, ce.CONTAINER_SEEK, function(t3) {
        return e3.onSeek(t3);
      }), this.listenTo(this.container, ce.CONTAINER_FULL_SCREEN, this.onFullscreen), this.listenTo(this.container, ce.CONTAINER_HIGHDEFINITIONUPDATE, this.onHD), this.listenTo(this.container, ce.CONTAINER_PLAYBACKDVRSTATECHANGED, this.onDVR)), _gaq.push([this.trackerName + "_setAccount", this.account]), this.domainName && _gaq.push([this.trackerName + "_setDomainName", this.domainName]);
    } }, { key: "onReady", value: function() {
      this.push(["Video", "Playback", this.container.playback.name]);
    } }, { key: "onPlay", value: function() {
      this.push(["Video", "Play", this.container.playback.src]);
    } }, { key: "onStop", value: function() {
      this.push(["Video", "Stop", this.container.playback.src]);
    } }, { key: "onEnded", value: function() {
      this.push(["Video", "Ended", this.container.playback.src]);
    } }, { key: "onBuffering", value: function() {
      this.push(["Video", "Buffering", this.container.playback.src]);
    } }, { key: "onBufferFull", value: function() {
      this.push(["Video", "Bufferfull", this.container.playback.src]);
    } }, { key: "onError", value: function() {
      this.push(["Video", "Error", this.container.playback.src]);
    } }, { key: "onHD", value: function(e3) {
      var t3 = e3 ? "ON" : "OFF";
      t3 !== this.currentHDState && (this.currentHDState = t3, this.push(["Video", "HD - " + t3, this.container.playback.src]));
    } }, { key: "onPlaybackChanged", value: function(e3) {
      null !== e3.type && this.push(["Video", "Playback Type - " + e3.type, this.container.playback.src]);
    } }, { key: "onDVR", value: function(e3) {
      var t3 = e3 ? "ON" : "OFF";
      this.push(["Interaction", "DVR - " + t3, this.container.playback.src]);
    } }, { key: "onPause", value: function() {
      this.push(["Video", "Pause", this.container.playback.src]);
    } }, { key: "onSeek", value: function() {
      this.push(["Video", "Seek", this.container.playback.src]);
    } }, { key: "onVolumeChanged", value: function() {
      this.push(["Interaction", "Volume", this.container.playback.src]);
    } }, { key: "onFullscreen", value: function() {
      this.push(["Interaction", "Fullscreen", this.container.playback.src]);
    } }, { key: "push", value: function(e3) {
      var t3 = [this.trackerName + "_trackEvent"].concat(e3);
      _gaq.push(t3);
    } }]), r2;
  }(Ve), Tt = function(e2) {
    this.element = e2 || window.document, this.initialize();
  };
  Tt.KEY_NAMES_BY_CODE = { 8: "backspace", 9: "tab", 13: "enter", 16: "shift", 17: "ctrl", 18: "alt", 20: "caps_lock", 27: "esc", 32: "space", 37: "left", 38: "up", 39: "right", 40: "down", 48: "0", 49: "1", 50: "2", 51: "3", 52: "4", 53: "5", 54: "6", 55: "7", 56: "8", 57: "9", 65: "a", 66: "b", 67: "c", 68: "d", 69: "e", 70: "f", 71: "g", 72: "h", 73: "i", 74: "j", 75: "k", 76: "l", 77: "m", 78: "n", 79: "o", 80: "p", 81: "q", 82: "r", 83: "s", 84: "t", 85: "u", 86: "v", 87: "w", 88: "x", 89: "y", 90: "z", 112: "f1", 113: "f2", 114: "f3", 115: "f4", 116: "f5", 117: "f6", 118: "f7", 119: "f8", 120: "f9", 121: "f10", 122: "f11", 123: "f12" }, Tt.KEY_CODES_BY_NAME = {}, function() {
    for (var e2 in Tt.KEY_NAMES_BY_CODE)
      Object.prototype.hasOwnProperty.call(Tt.KEY_NAMES_BY_CODE, e2) && (Tt.KEY_CODES_BY_NAME[Tt.KEY_NAMES_BY_CODE[e2]] = +e2);
  }(), Tt.MODIFIERS = ["shift", "ctrl", "alt"], Tt.registerEvent = document.addEventListener ? function(e2, t2, r2) {
    e2.addEventListener(t2, r2, false);
  } : document.attachEvent ? function(e2, t2, r2) {
    e2.attachEvent("on" + t2, r2);
  } : void 0, Tt.unregisterEvent = document.removeEventListener ? function(e2, t2, r2) {
    e2.removeEventListener(t2, r2, false);
  } : document.detachEvent ? function(e2, t2, r2) {
    e2.detachEvent("on" + t2, r2);
  } : void 0, Tt.stringContains = function(e2, t2) {
    return -1 !== e2.indexOf(t2);
  }, Tt.neatString = function(e2) {
    return e2.replace(/^\s+|\s+$/g, "").replace(/\s+/g, " ");
  }, Tt.capitalize = function(e2) {
    return e2.toLowerCase().replace(/^./, function(e3) {
      return e3.toUpperCase();
    });
  }, Tt.isString = function(e2) {
    return Tt.stringContains(Object.prototype.toString.call(e2), "String");
  }, Tt.arrayIncludes = Array.prototype.indexOf ? function(e2, t2) {
    return -1 !== e2.indexOf(t2);
  } : function(e2, t2) {
    for (var r2 = 0; r2 < e2.length; r2++)
      if (e2[r2] === t2)
        return true;
    return false;
  }, Tt.extractModifiers = function(e2) {
    var t2, r2;
    for (t2 = [], r2 = 0; r2 < Tt.MODIFIERS.length; r2++)
      Tt.stringContains(e2, Tt.MODIFIERS[r2]) && t2.push(Tt.MODIFIERS[r2]);
    return t2;
  }, Tt.extractKey = function(e2) {
    var t2, r2;
    for (t2 = Tt.neatString(e2).split(" "), r2 = 0; r2 < t2.length; r2++)
      if (!Tt.arrayIncludes(Tt.MODIFIERS, t2[r2]))
        return t2[r2];
  }, Tt.modifiersAndKey = function(e2) {
    var t2, r2;
    return Tt.stringContains(e2, "any") ? Tt.neatString(e2).split(" ").slice(0, 2).join(" ") : (t2 = Tt.extractModifiers(e2), (r2 = Tt.extractKey(e2)) && !Tt.arrayIncludes(Tt.MODIFIERS, r2) && t2.push(r2), t2.join(" "));
  }, Tt.keyName = function(e2) {
    return Tt.KEY_NAMES_BY_CODE[e2 + ""];
  }, Tt.keyCode = function(e2) {
    return +Tt.KEY_CODES_BY_NAME[e2];
  }, Tt.prototype.initialize = function() {
    var e2, t2 = this;
    for (this.lastKeyCode = -1, this.lastModifiers = {}, e2 = 0; e2 < Tt.MODIFIERS.length; e2++)
      this.lastModifiers[Tt.MODIFIERS[e2]] = false;
    this.keysDown = { any: [] }, this.keysUp = { any: [] }, this.downHandler = this.handler("down"), this.upHandler = this.handler("up"), Tt.registerEvent(this.element, "keydown", this.downHandler), Tt.registerEvent(this.element, "keyup", this.upHandler), Tt.registerEvent(window, "unload", function e3() {
      Tt.unregisterEvent(t2.element, "keydown", t2.downHandler), Tt.unregisterEvent(t2.element, "keyup", t2.upHandler), Tt.unregisterEvent(window, "unload", e3);
    });
  }, Tt.prototype.handler = function(e2) {
    var t2 = this;
    return function(r2) {
      var i2, n2, a2;
      for (r2 = r2 || window.event, t2.lastKeyCode = r2.keyCode, i2 = 0; i2 < Tt.MODIFIERS.length; i2++)
        t2.lastModifiers[Tt.MODIFIERS[i2]] = r2[Tt.MODIFIERS[i2] + "Key"];
      for (Tt.arrayIncludes(Tt.MODIFIERS, Tt.keyName(t2.lastKeyCode)) && (t2.lastModifiers[Tt.keyName(t2.lastKeyCode)] = true), n2 = t2["keys" + Tt.capitalize(e2)], i2 = 0; i2 < n2.any.length; i2++)
        false === n2.any[i2](r2) && r2.preventDefault && r2.preventDefault();
      if (n2[a2 = t2.lastModifiersAndKey()])
        for (i2 = 0; i2 < n2[a2].length; i2++)
          false === n2[a2][i2](r2) && r2.preventDefault && r2.preventDefault();
    };
  }, Tt.prototype.registerKeys = function(e2, t2, r2) {
    var i2, n2, a2 = this["keys" + Tt.capitalize(e2)];
    for (Tt.isString(t2) && (t2 = [t2]), i2 = 0; i2 < t2.length; i2++)
      n2 = t2[i2], a2[n2 = Tt.modifiersAndKey(n2 + "")] ? a2[n2].push(r2) : a2[n2] = [r2];
    return this;
  }, Tt.prototype.unregisterKeys = function(e2, t2, r2) {
    var i2, n2, a2, s2 = this["keys" + Tt.capitalize(e2)];
    for (Tt.isString(t2) && (t2 = [t2]), i2 = 0; i2 < t2.length; i2++)
      if (a2 = t2[i2], a2 = Tt.modifiersAndKey(a2 + ""), null === r2)
        delete s2[a2];
      else if (s2[a2]) {
        for (n2 = 0; n2 < s2[a2].length; n2++)
          if (String(s2[a2][n2]) === String(r2)) {
            s2[a2].splice(n2, 1);
            break;
          }
      }
    return this;
  }, Tt.prototype.off = function(e2) {
    return this.unregisterKeys("down", e2, null);
  }, Tt.prototype.delegate = function(e2, t2, r2) {
    return null !== r2 || void 0 !== r2 ? this.registerKeys(e2, t2, r2) : this.unregisterKeys(e2, t2, r2);
  }, Tt.prototype.down = function(e2, t2) {
    return this.delegate("down", e2, t2);
  }, Tt.prototype.up = function(e2, t2) {
    return this.delegate("up", e2, t2);
  }, Tt.prototype.lastKey = function(e2) {
    return e2 ? this.lastModifiers[e2] : Tt.keyName(this.lastKeyCode);
  }, Tt.prototype.lastModifiersAndKey = function() {
    var e2, t2;
    for (e2 = [], t2 = 0; t2 < Tt.MODIFIERS.length; t2++)
      this.lastKey(Tt.MODIFIERS[t2]) && e2.push(Tt.MODIFIERS[t2]);
    return Tt.arrayIncludes(e2, this.lastKey()) || e2.push(this.lastKey()), e2.join(" ");
  };
  var bt = { Kibo: Tt }, kt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">\n  <path fill-rule="evenodd" clip-rule="evenodd" fill="#010101" d="M1.712 1.24h12.6v13.52h-12.6z"/>\n</svg>', St = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">\n  <path fill-rule="evenodd" clip-rule="evenodd" fill="#010101" d="M11.5 11h-.002v1.502L7.798 10H4.5V6h3.297l3.7-2.502V4.5h.003V11zM11 4.49L7.953 6.5H5v3h2.953L11 11.51V4.49z"/>\n</svg>', _t = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">\n  <path fill="#010101" d="M7.156 8L4 11.156V8.5H3V13h4.5v-1H4.844L8 8.844 7.156 8zM8.5 3v1h2.657L8 7.157 8.846 8 12 4.844V7.5h1V3H8.5z"/>\n</svg>', Ct = J.Config, Lt = J.Fullscreen, Dt = J.formatTime, Rt = J.extend, It = J.removeArrayItem, Ot = function(e2) {
    nt(r2, e2);
    var t2 = lt(r2);
    function r2(e3) {
      var i2;
      return tt(this, r2), (i2 = t2.call(this, e3)).persistConfig = i2.options.persistConfig, i2.currentPositionValue = null, i2.currentDurationValue = null, i2.keepVisible = false, i2.fullScreenOnVideoTagSupported = null, i2.setInitialVolume(), i2.settings = { left: ["play", "stop", "pause"], right: ["volume"], default: ["position", "seekbar", "duration"] }, i2.kibo = new Tt(i2.options.focusElement), i2.bindKeyEvents(), i2.container ? R.isEmptyObject(i2.container.settings) || (i2.settings = R.extend({}, i2.container.settings)) : i2.settings = {}, i2.userDisabled = false, (i2.container && i2.container.mediaControlDisabled || i2.options.chromeless) && i2.disable(), i2.stopDragHandler = function(e4) {
        return i2.stopDrag(e4);
      }, i2.updateDragHandler = function(e4) {
        return i2.updateDrag(e4);
      }, R(document).bind("mouseup", i2.stopDragHandler), R(document).bind("mousemove", i2.updateDragHandler), i2;
    }
    return it(r2, [{ key: "name", get: function() {
      return "media_control";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "disabled", get: function() {
      var e3 = this.container && this.container.getPlaybackType() === Re.NO_OP;
      return this.userDisabled || e3;
    } }, { key: "container", get: function() {
      return this.core && this.core.activeContainer;
    } }, { key: "playback", get: function() {
      return this.core && this.core.activePlayback;
    } }, { key: "attributes", get: function() {
      return { class: "media-control", "data-media-control": "" };
    } }, { key: "events", get: function() {
      return { "click [data-play]": "play", "click [data-pause]": "pause", "click [data-playpause]": "togglePlayPause", "click [data-stop]": "stop", "click [data-playstop]": "togglePlayStop", "click [data-fullscreen]": "toggleFullscreen", "click .bar-container[data-seekbar]": "seek", "click .bar-container[data-volume]": "onVolumeClick", "click .drawer-icon[data-volume]": "toggleMute", "mouseenter .drawer-container[data-volume]": "showVolumeBar", "mouseleave .drawer-container[data-volume]": "hideVolumeBar", "mousedown .bar-container[data-volume]": "startVolumeDrag", "mousemove .bar-container[data-volume]": "mousemoveOnVolumeBar", "mousedown .bar-scrubber[data-seekbar]": "startSeekDrag", "mousemove .bar-container[data-seekbar]": "mousemoveOnSeekBar", "mouseleave .bar-container[data-seekbar]": "mouseleaveOnSeekBar", "mouseenter .media-control-layer[data-controls]": "setUserKeepVisible", "mouseleave .media-control-layer[data-controls]": "resetUserKeepVisible" };
    } }, { key: "template", get: function() {
      return Te('<div class="media-control-background" data-background></div>\n<div class="media-control-layer" data-controls>\n  <%  var renderBar = function(name) { %>\n      <div class="bar-container" data-<%= name %>>\n        <div class="bar-background" data-<%= name %>>\n          <div class="bar-fill-1" data-<%= name %>></div>\n          <div class="bar-fill-2" data-<%= name %>></div>\n          <div class="bar-hover" data-<%= name %>></div>\n        </div>\n        <div class="bar-scrubber" data-<%= name %>>\n          <div class="bar-scrubber-icon" data-<%= name %>></div>\n        </div>\n      </div>\n  <%  }; %>\n  <%  var renderSegmentedBar = function(name, segments) {\n      segments = segments || 10; %>\n    <div class="bar-container" data-<%= name %>>\n    <% for (var i = 0; i < segments; i++) { %>\n      <div class="segmented-bar-element" data-<%= name %>></div>\n    <% } %>\n    </div>\n  <% }; %>\n  <% var renderDrawer = function(name, renderContent) { %>\n      <div class="drawer-container" data-<%= name %>>\n        <div class="drawer-icon-container" data-<%= name %>>\n          <div class="drawer-icon media-control-icon" data-<%= name %>></div>\n          <span class="drawer-text" data-<%= name %>></span>\n        </div>\n        <% renderContent(name); %>\n      </div>\n  <% }; %>\n  <% var renderIndicator = function(name) { %>\n      <div class="media-control-indicator" data-<%= name %>></div>\n  <% }; %>\n  <% var renderButton = function(name) { %>\n    <button type="button" class="media-control-button media-control-icon" data-<%= name %> aria-label="<%= name %>"></button>\n  <% }; %>\n  <%  var templates = {\n        bar: renderBar,\n        segmentedBar: renderSegmentedBar,\n      };\n      var render = function(settingsList) {\n        settingsList.forEach(function(setting) {\n          if(setting === "seekbar") {\n            renderBar(setting);\n          } else if (setting === "volume") {\n            renderDrawer(setting, settings.volumeBarTemplate ? templates[settings.volumeBarTemplate] : function(name) { return renderSegmentedBar(name); });\n          } else if (setting === "duration" || setting === "position") {\n            renderIndicator(setting);\n          } else {\n            renderButton(setting);\n          }\n        });\n      }; %>\n  <% if (settings.default && settings.default.length) { %>\n  <div class="media-control-center-panel" data-media-control>\n    <% render(settings.default); %>\n  </div>\n  <% } %>\n  <% if (settings.left && settings.left.length) { %>\n  <div class="media-control-left-panel" data-media-control>\n    <% render(settings.left); %>\n  </div>\n  <% } %>\n  <% if (settings.right && settings.right.length) { %>\n  <div class="media-control-right-panel" data-media-control>\n    <% render(settings.right); %>\n  </div>\n  <% } %>\n</div>\n');
    } }, { key: "volume", get: function() {
      return this.container && this.container.isReady ? this.container.volume : this.intendedVolume;
    } }, { key: "muted", get: function() {
      return 0 === this.volume;
    } }, { key: "getExternalInterface", value: function() {
      var e3 = this;
      return { setVolume: this.setVolume, getVolume: function() {
        return e3.volume;
      } };
    } }, { key: "bindEvents", value: function() {
      var e3 = this;
      this.stopListening(), this.listenTo(this.core, ce.CORE_ACTIVE_CONTAINER_CHANGED, this.onActiveContainerChanged), this.listenTo(this.core, ce.CORE_MOUSE_MOVE, this.show), this.listenTo(this.core, ce.CORE_MOUSE_LEAVE, function() {
        return e3.hide(e3.options.hideMediaControlDelay);
      }), this.listenTo(this.core, ce.CORE_FULLSCREEN, this.show), this.listenTo(this.core, ce.CORE_OPTIONS_CHANGE, this.configure), this.listenTo(this.core, ce.CORE_RESIZE, this.playerResize), this.bindContainerEvents();
    } }, { key: "bindContainerEvents", value: function() {
      this.container && (this.listenTo(this.container, ce.CONTAINER_PLAY, this.changeTogglePlay), this.listenTo(this.container, ce.CONTAINER_PAUSE, this.changeTogglePlay), this.listenTo(this.container, ce.CONTAINER_STOP, this.changeTogglePlay), this.listenTo(this.container, ce.CONTAINER_DBLCLICK, this.toggleFullscreen), this.listenTo(this.container, ce.CONTAINER_TIMEUPDATE, this.onTimeUpdate), this.listenTo(this.container, ce.CONTAINER_PROGRESS, this.updateProgressBar), this.listenTo(this.container, ce.CONTAINER_SETTINGSUPDATE, this.settingsUpdate), this.listenTo(this.container, ce.CONTAINER_PLAYBACKDVRSTATECHANGED, this.settingsUpdate), this.listenTo(this.container, ce.CONTAINER_HIGHDEFINITIONUPDATE, this.highDefinitionUpdate), this.listenTo(this.container, ce.CONTAINER_MEDIACONTROL_DISABLE, this.disable), this.listenTo(this.container, ce.CONTAINER_MEDIACONTROL_ENABLE, this.enable), this.listenTo(this.container, ce.CONTAINER_ENDED, this.ended), this.listenTo(this.container, ce.CONTAINER_VOLUME, this.onVolumeChanged), this.listenTo(this.container, ce.CONTAINER_OPTIONS_CHANGE, this.setInitialVolume), "video" === this.container.playback.el.nodeName.toLowerCase() && this.listenToOnce(this.container, ce.CONTAINER_LOADEDMETADATA, this.onLoadedMetadataOnVideoTag));
    } }, { key: "disable", value: function() {
      this.userDisabled = true, this.hide(), this.unbindKeyEvents(), this.$el.hide();
    } }, { key: "enable", value: function() {
      this.options.chromeless || (this.userDisabled = false, this.bindKeyEvents(), this.show());
    } }, { key: "play", value: function() {
      this.container && this.container.play();
    } }, { key: "pause", value: function() {
      this.container && this.container.pause();
    } }, { key: "stop", value: function() {
      this.container && this.container.stop();
    } }, { key: "setInitialVolume", value: function() {
      var e3 = this.persistConfig ? Ct.restore("volume") : 100, t3 = this.container && this.container.options || this.options;
      this.setVolume(t3.mute ? 0 : e3, true);
    } }, { key: "onVolumeChanged", value: function() {
      this.updateVolumeUI();
    } }, { key: "onLoadedMetadataOnVideoTag", value: function() {
      var e3 = this.playback && this.playback.el;
      !Lt.fullscreenEnabled() && e3.webkitSupportsFullscreen && (this.fullScreenOnVideoTagSupported = true, this.settingsUpdate());
    } }, { key: "updateVolumeUI", value: function() {
      if (this.rendered) {
        this.$volumeBarContainer.find(".bar-fill-2").css({});
        var e3 = this.$volumeBarContainer.width(), t3 = this.$volumeBarBackground.width(), r3 = (e3 - t3) / 2, i2 = t3 * this.volume / 100 + r3;
        this.$volumeBarFill.css({ width: "".concat(this.volume, "%") }), this.$volumeBarScrubber.css({ left: i2 }), this.$volumeBarContainer.find(".segmented-bar-element").removeClass("fill");
        var n2 = Math.ceil(this.volume / 10);
        this.$volumeBarContainer.find(".segmented-bar-element").slice(0, n2).addClass("fill"), this.$volumeIcon.html(""), this.$volumeIcon.removeClass("muted"), this.muted ? (this.$volumeIcon.append('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">\n  <path fill-rule="evenodd" clip-rule="evenodd" fill="#010101" d="M9.75 11.51L6.7 9.5H3.75v-3H6.7L9.75 4.49v.664l.497.498V3.498L6.547 6H3.248v4h3.296l3.7 2.502v-2.154l-.497.5v.662zm3-5.165L12.404 6l-1.655 1.653L9.093 6l-.346.345L10.402 8 8.747 9.654l.346.347 1.655-1.653L12.403 10l.348-.346L11.097 8l1.655-1.655z"/>\n</svg>'), this.$volumeIcon.addClass("muted")) : this.$volumeIcon.append(St), this.applyButtonStyle(this.$volumeIcon);
      }
    } }, { key: "changeTogglePlay", value: function() {
      this.$playPauseToggle.html(""), this.$playStopToggle.html(""), this.container && this.container.isPlaying() ? (this.$playPauseToggle.append(mt), this.$playStopToggle.append(kt), this.trigger(ce.MEDIACONTROL_PLAYING)) : (this.$playPauseToggle.append(vt), this.$playStopToggle.append(vt), this.trigger(ce.MEDIACONTROL_NOTPLAYING), w.isMobile && this.show()), this.applyButtonStyle(this.$playPauseToggle), this.applyButtonStyle(this.$playStopToggle);
    } }, { key: "mousemoveOnSeekBar", value: function(e3) {
      if (this.settings.seekEnabled) {
        var t3 = e3.pageX - this.$seekBarContainer.offset().left - this.$seekBarHover.width() / 2;
        this.$seekBarHover.css({ left: t3 });
      }
      this.trigger(ce.MEDIACONTROL_MOUSEMOVE_SEEKBAR, e3);
    } }, { key: "mouseleaveOnSeekBar", value: function(e3) {
      this.trigger(ce.MEDIACONTROL_MOUSELEAVE_SEEKBAR, e3);
    } }, { key: "onVolumeClick", value: function(e3) {
      this.setVolume(this.getVolumeFromUIEvent(e3));
    } }, { key: "mousemoveOnVolumeBar", value: function(e3) {
      this.draggingVolumeBar && this.setVolume(this.getVolumeFromUIEvent(e3));
    } }, { key: "playerResize", value: function(e3) {
      this.$fullscreenToggle.html("");
      var t3 = this.core.isFullscreen() ? '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">\n  <path fill="#010101" d="M13.5 3.344l-.844-.844L9.5 5.656V3h-1v4.5H13v-1h-2.656L13.5 3.344zM3 9.5h2.656L2.5 12.656l.844.844L6.5 10.344V13h1V8.5H3v1z"/>\n</svg>' : _t;
      this.$fullscreenToggle.append(t3), this.applyButtonStyle(this.$fullscreenToggle), 0 !== this.$el.find(".media-control").length && this.$el.removeClass("w320"), (e3.width <= 320 || this.options.hideVolumeBar) && this.$el.addClass("w320");
    } }, { key: "togglePlayPause", value: function() {
      return this.container.isPlaying() ? this.container.pause() : this.container.play(), false;
    } }, { key: "togglePlayStop", value: function() {
      this.container.isPlaying() ? this.container.stop() : this.container.play();
    } }, { key: "startSeekDrag", value: function(e3) {
      this.settings.seekEnabled && (this.draggingSeekBar = true, this.$el.addClass("dragging"), this.$seekBarLoaded.addClass("media-control-notransition"), this.$seekBarPosition.addClass("media-control-notransition"), this.$seekBarScrubber.addClass("media-control-notransition"), e3 && e3.preventDefault());
    } }, { key: "startVolumeDrag", value: function(e3) {
      this.draggingVolumeBar = true, this.$el.addClass("dragging"), e3 && e3.preventDefault();
    } }, { key: "stopDrag", value: function(e3) {
      this.draggingSeekBar && this.seek(e3), this.$el.removeClass("dragging"), this.$seekBarLoaded.removeClass("media-control-notransition"), this.$seekBarPosition.removeClass("media-control-notransition"), this.$seekBarScrubber.removeClass("media-control-notransition dragging"), this.draggingSeekBar = false, this.draggingVolumeBar = false;
    } }, { key: "updateDrag", value: function(e3) {
      if (this.draggingSeekBar) {
        e3.preventDefault();
        var t3 = (e3.pageX - this.$seekBarContainer.offset().left) / this.$seekBarContainer.width() * 100;
        t3 = Math.min(100, Math.max(t3, 0)), this.setSeekPercentage(t3);
      } else
        this.draggingVolumeBar && (e3.preventDefault(), this.setVolume(this.getVolumeFromUIEvent(e3)));
    } }, { key: "getVolumeFromUIEvent", value: function(e3) {
      return (e3.pageX - this.$volumeBarContainer.offset().left) / this.$volumeBarContainer.width() * 100;
    } }, { key: "toggleMute", value: function() {
      this.setVolume(this.muted ? 100 : 0);
    } }, { key: "setVolume", value: function(e3) {
      var t3 = this, r3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      e3 = Math.min(100, Math.max(e3, 0)), this.intendedVolume = e3, this.persistConfig && !r3 && Ct.persist("volume", e3);
      var i2 = function() {
        t3.container && t3.container.isReady ? t3.container.setVolume(e3) : t3.listenToOnce(t3.container, ce.CONTAINER_READY, function() {
          t3.container.setVolume(e3);
        });
      };
      this.container ? i2() : this.listenToOnce(this, ce.MEDIACONTROL_CONTAINERCHANGED, function() {
        return i2();
      });
    } }, { key: "toggleFullscreen", value: function() {
      this.trigger(ce.MEDIACONTROL_FULLSCREEN, this.name), this.container.fullscreen(), this.core.toggleFullscreen(), this.resetUserKeepVisible();
    } }, { key: "onActiveContainerChanged", value: function() {
      this.fullScreenOnVideoTagSupported = null, this.bindEvents(), this.setInitialVolume(), this.changeTogglePlay(), this.bindContainerEvents(), this.settingsUpdate(), this.container && this.container.trigger(ce.CONTAINER_PLAYBACKDVRSTATECHANGED, this.container.isDvrInUse()), this.container && this.container.mediaControlDisabled && this.disable(), this.trigger(ce.MEDIACONTROL_CONTAINERCHANGED);
    } }, { key: "showVolumeBar", value: function() {
      this.hideVolumeId && clearTimeout(this.hideVolumeId), this.$volumeBarContainer.removeClass("volume-bar-hide");
    } }, { key: "hideVolumeBar", value: function() {
      var e3 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 400;
      this.$volumeBarContainer && (this.draggingVolumeBar ? this.hideVolumeId = setTimeout(function() {
        return e3.hideVolumeBar();
      }, t3) : (this.hideVolumeId && clearTimeout(this.hideVolumeId), this.hideVolumeId = setTimeout(function() {
        return e3.$volumeBarContainer.addClass("volume-bar-hide");
      }, t3)));
    } }, { key: "ended", value: function() {
      this.changeTogglePlay();
    } }, { key: "updateProgressBar", value: function(e3) {
      var t3 = e3.start / e3.total * 100, r3 = e3.current / e3.total * 100;
      this.$seekBarLoaded.css({ left: "".concat(t3, "%"), width: "".concat(r3 - t3, "%") });
    } }, { key: "onTimeUpdate", value: function(e3) {
      if (!this.draggingSeekBar) {
        var t3 = e3.current < 0 ? e3.total : e3.current;
        this.currentPositionValue = t3, this.currentDurationValue = e3.total, this.renderSeekBar();
      }
    } }, { key: "renderSeekBar", value: function() {
      if (null !== this.currentPositionValue && null !== this.currentDurationValue) {
        this.currentSeekBarPercentage = 100, this.container && (this.container.getPlaybackType() !== Re.LIVE || this.container.isDvrInUse()) && (this.currentSeekBarPercentage = this.currentPositionValue / this.currentDurationValue * 100), this.setSeekPercentage(this.currentSeekBarPercentage);
        var e3 = Dt(this.currentPositionValue), t3 = Dt(this.currentDurationValue);
        e3 !== this.displayedPosition && (this.$position.text(e3), this.displayedPosition = e3), t3 !== this.displayedDuration && (this.$duration.text(t3), this.displayedDuration = t3);
      }
    } }, { key: "seek", value: function(e3) {
      if (this.settings.seekEnabled) {
        var t3 = (e3.pageX - this.$seekBarContainer.offset().left) / this.$seekBarContainer.width() * 100;
        return t3 = Math.min(100, Math.max(t3, 0)), this.container && this.container.seekPercentage(t3), this.setSeekPercentage(t3), false;
      }
    } }, { key: "setKeepVisible", value: function() {
      this.keepVisible = true;
    } }, { key: "resetKeepVisible", value: function() {
      this.keepVisible = false;
    } }, { key: "setUserKeepVisible", value: function() {
      this.userKeepVisible = true;
    } }, { key: "resetUserKeepVisible", value: function() {
      this.userKeepVisible = false;
    } }, { key: "isVisible", value: function() {
      return !this.$el.hasClass("media-control-hide");
    } }, { key: "show", value: function(e3) {
      var t3 = this;
      if (!this.disabled) {
        var r3 = e3 && e3.clientX !== this.lastMouseX && e3.clientY !== this.lastMouseY;
        (!e3 || r3 || navigator.userAgent.match(/firefox/i)) && (clearTimeout(this.hideId), this.$el.show(), this.trigger(ce.MEDIACONTROL_SHOW, this.name), this.container && this.container.trigger(ce.CONTAINER_MEDIACONTROL_SHOW, this.name), this.$el.removeClass("media-control-hide"), this.hideId = setTimeout(function() {
          return t3.hide();
        }, 2e3), e3 && (this.lastMouseX = e3.clientX, this.lastMouseY = e3.clientY));
        this.updateCursorStyle(true);
      }
    } }, { key: "hide", value: function() {
      var e3 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
      if (this.isVisible()) {
        var r3 = t3 || 2e3;
        if (clearTimeout(this.hideId), this.disabled || false !== this.options.hideMediaControl) {
          var i2 = this.userKeepVisible || this.keepVisible, n2 = this.draggingSeekBar || this.draggingVolumeBar;
          if (!this.disabled && (t3 || i2 || n2))
            this.hideId = setTimeout(function() {
              return e3.hide();
            }, r3);
          else {
            this.trigger(ce.MEDIACONTROL_HIDE, this.name), this.container && this.container.trigger(ce.CONTAINER_MEDIACONTROL_HIDE, this.name), this.$el.addClass("media-control-hide"), this.hideVolumeBar(0);
            var a2 = false;
            this.updateCursorStyle(a2);
          }
        }
      }
    } }, { key: "updateCursorStyle", value: function(e3) {
      e3 ? this.core.$el.removeClass("nocursor") : this.core.isFullscreen() && this.core.$el.addClass("nocursor");
    } }, { key: "settingsUpdate", value: function() {
      var e3 = this.getSettings();
      !e3 || this.fullScreenOnVideoTagSupported || Lt.fullscreenEnabled() || (e3.default && It(e3.default, "fullscreen"), e3.left && It(e3.left, "fullscreen"), e3.right && It(e3.right, "fullscreen")), JSON.stringify(this.settings) !== JSON.stringify(e3) && (this.settings = e3, this.render());
    } }, { key: "getSettings", value: function() {
      return R.extend(true, {}, this.container && this.container.settings);
    } }, { key: "highDefinitionUpdate", value: function(e3) {
      this.isHD = e3;
      var t3 = e3 ? "addClass" : "removeClass";
      this.$hdIndicator[t3]("enabled");
    } }, { key: "createCachedElements", value: function() {
      var e3 = this.$el.find(".media-control-layer");
      this.$duration = e3.find(".media-control-indicator[data-duration]"), this.$fullscreenToggle = e3.find("button.media-control-button[data-fullscreen]"), this.$playPauseToggle = e3.find("button.media-control-button[data-playpause]"), this.$playStopToggle = e3.find("button.media-control-button[data-playstop]"), this.$position = e3.find(".media-control-indicator[data-position]"), this.$seekBarContainer = e3.find(".bar-container[data-seekbar]"), this.$seekBarHover = e3.find(".bar-hover[data-seekbar]"), this.$seekBarLoaded = e3.find(".bar-fill-1[data-seekbar]"), this.$seekBarPosition = e3.find(".bar-fill-2[data-seekbar]"), this.$seekBarScrubber = e3.find(".bar-scrubber[data-seekbar]"), this.$volumeBarContainer = e3.find(".bar-container[data-volume]"), this.$volumeContainer = e3.find(".drawer-container[data-volume]"), this.$volumeIcon = e3.find(".drawer-icon[data-volume]"), this.$volumeBarBackground = this.$el.find(".bar-background[data-volume]"), this.$volumeBarFill = this.$el.find(".bar-fill-1[data-volume]"), this.$volumeBarScrubber = this.$el.find(".bar-scrubber[data-volume]"), this.$hdIndicator = this.$el.find("button.media-control-button[data-hd-indicator]"), this.resetIndicators(), this.initializeIcons();
    } }, { key: "resetIndicators", value: function() {
      this.displayedPosition = this.$position.text(), this.displayedDuration = this.$duration.text();
    } }, { key: "initializeIcons", value: function() {
      var e3 = this.$el.find(".media-control-layer");
      e3.find("button.media-control-button[data-play]").append(vt), e3.find("button.media-control-button[data-pause]").append(mt), e3.find("button.media-control-button[data-stop]").append(kt), this.$playPauseToggle.append(vt), this.$playStopToggle.append(vt), this.$volumeIcon.append(St), this.$fullscreenToggle.append(_t), this.$hdIndicator.append('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">\n  <path fill="#010101" d="M5.375 7.062H2.637V4.26H.502v7.488h2.135V8.9h2.738v2.848h2.133V4.26H5.375v2.802zm5.97-2.81h-2.84v7.496h2.798c2.65 0 4.195-1.607 4.195-3.77v-.022c0-2.162-1.523-3.704-4.154-3.704zm2.06 3.758c0 1.21-.81 1.896-2.03 1.896h-.83V6.093h.83c1.22 0 2.03.696 2.03 1.896v.02z"/>\n</svg>');
    } }, { key: "setSeekPercentage", value: function(e3) {
      e3 = Math.max(Math.min(e3, 100), 0), this.displayedSeekBarPercentage !== e3 && (this.displayedSeekBarPercentage = e3, this.$seekBarPosition.removeClass("media-control-notransition"), this.$seekBarScrubber.removeClass("media-control-notransition"), this.$seekBarPosition.css({ width: "".concat(e3, "%") }), this.$seekBarScrubber.css({ left: "".concat(e3, "%") }));
    } }, { key: "seekRelative", value: function(e3) {
      if (this.settings.seekEnabled) {
        var t3 = this.container.getCurrentTime(), r3 = this.container.getDuration(), i2 = Math.min(Math.max(t3 + e3, 0), r3);
        i2 = Math.min(100 * i2 / r3, 100), this.container.seekPercentage(i2);
      }
    } }, { key: "bindKeyAndShow", value: function(e3, t3) {
      var r3 = this;
      this.kibo.down(e3, function() {
        return r3.show(), t3();
      });
    } }, { key: "bindKeyEvents", value: function() {
      var e3 = this;
      if (!w.isMobile && !this.options.disableKeyboardShortcuts) {
        this.unbindKeyEvents(), this.kibo = new Tt(this.options.focusElement || this.options.parentElement), this.bindKeyAndShow("space", function() {
          return e3.togglePlayPause();
        }), this.bindKeyAndShow("left", function() {
          return e3.seekRelative(-5);
        }), this.bindKeyAndShow("right", function() {
          return e3.seekRelative(5);
        }), this.bindKeyAndShow("shift left", function() {
          return e3.seekRelative(-10);
        }), this.bindKeyAndShow("shift right", function() {
          return e3.seekRelative(10);
        }), this.bindKeyAndShow("shift ctrl left", function() {
          return e3.seekRelative(-15);
        }), this.bindKeyAndShow("shift ctrl right", function() {
          return e3.seekRelative(15);
        });
        ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"].forEach(function(t3) {
          e3.bindKeyAndShow(t3, function() {
            e3.settings.seekEnabled && e3.container && e3.container.seekPercentage(10 * t3);
          });
        });
      }
    } }, { key: "unbindKeyEvents", value: function() {
      this.kibo && (this.kibo.off("space"), this.kibo.off("left"), this.kibo.off("right"), this.kibo.off("shift left"), this.kibo.off("shift right"), this.kibo.off("shift ctrl left"), this.kibo.off("shift ctrl right"), this.kibo.off(["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"]));
    } }, { key: "parseColors", value: function() {
      if (this.options.mediacontrol) {
        this.buttonsColor = this.options.mediacontrol.buttons;
        var e3 = this.options.mediacontrol.seekbar;
        this.$el.find(".bar-fill-2[data-seekbar]").css("background-color", e3), this.$el.find(".media-control-icon svg path").css("fill", this.buttonsColor), this.$el.find(".segmented-bar-element[data-volume]").css("boxShadow", "inset 2px 0 0 " + this.buttonsColor);
      }
    } }, { key: "applyButtonStyle", value: function(e3) {
      this.buttonsColor && e3 && R(e3).find("svg path").css("fill", this.buttonsColor);
    } }, { key: "destroy", value: function() {
      R(document).unbind("mouseup", this.stopDragHandler), R(document).unbind("mousemove", this.updateDragHandler), this.unbindKeyEvents(), this.stopListening(), ct(at(r2.prototype), "destroy", this).call(this);
    } }, { key: "configure", value: function(e3) {
      this.options.chromeless || e3.source || e3.sources ? this.disable() : this.enable(), this.trigger(ce.MEDIACONTROL_OPTIONS_CHANGE);
    } }, { key: "render", value: function() {
      var e3 = this, t3 = this.options.hideMediaControlDelay || 2e3;
      this.settings && this.$el.html(this.template({ settings: this.settings }));
      var r3 = be.getStyleFor('.media-control-notransition {\n  transition: none !important; }\n\n.media-control[data-media-control] {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  z-index: 9999;\n  pointer-events: none; }\n  .media-control[data-media-control].dragging {\n    pointer-events: auto;\n    cursor: grabbing !important;\n    cursor: url("closed-hand.cur"), move; }\n    .media-control[data-media-control].dragging * {\n      cursor: grabbing !important;\n      cursor: url("closed-hand.cur"), move; }\n  .media-control[data-media-control] .media-control-background[data-background] {\n    position: absolute;\n    height: 40%;\n    width: 100%;\n    bottom: 0;\n    background: linear-gradient(transparent, rgba(0, 0, 0, 0.9));\n    will-change: transform, opacity;\n    transition: opacity 0.6s ease-out; }\n  .media-control[data-media-control] .media-control-icon {\n    line-height: 0;\n    letter-spacing: 0;\n    speak: none;\n    color: #fff;\n    opacity: 0.5;\n    vertical-align: middle;\n    text-align: left;\n    transition: all 0.1s ease; }\n  .media-control[data-media-control] .media-control-icon:hover {\n    color: white;\n    opacity: 0.75;\n    text-shadow: rgba(255, 255, 255, 0.8) 0 0 5px; }\n  .media-control[data-media-control].media-control-hide .media-control-background[data-background] {\n    opacity: 0; }\n  .media-control[data-media-control].media-control-hide .media-control-layer[data-controls] {\n    transform: translateY(50px); }\n    .media-control[data-media-control].media-control-hide .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-scrubber[data-seekbar] {\n      opacity: 0; }\n  .media-control[data-media-control] .media-control-layer[data-controls] {\n    position: absolute;\n    transform: translateY(-7px);\n    bottom: 0;\n    width: 100%;\n    height: 32px;\n    font-size: 0;\n    vertical-align: middle;\n    pointer-events: auto;\n    transition: bottom 0.4s ease-out; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-left-panel[data-media-control] {\n      position: absolute;\n      top: 0;\n      left: 4px;\n      height: 100%; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-center-panel[data-media-control] {\n      height: 100%;\n      text-align: center;\n      line-height: 32px; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-right-panel[data-media-control] {\n      position: absolute;\n      top: 0;\n      right: 4px;\n      height: 100%; }\n    .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button {\n      background-color: transparent;\n      border: 0;\n      margin: 0 6px;\n      padding: 0;\n      cursor: pointer;\n      display: inline-block;\n      width: 32px;\n      height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button svg {\n        width: 100%;\n        height: 22px; }\n        .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button svg path {\n          fill: white; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button:focus {\n        outline: none; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-play] {\n        float: left;\n        height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-pause] {\n        float: left;\n        height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-stop] {\n        float: left;\n        height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-fullscreen] {\n        float: right;\n        background-color: transparent;\n        border: 0;\n        height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-hd-indicator] {\n        background-color: transparent;\n        border: 0;\n        cursor: default;\n        display: none;\n        float: right;\n        height: 100%; }\n        .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-hd-indicator].enabled {\n          display: block;\n          opacity: 1.0; }\n          .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-hd-indicator].enabled:hover {\n            opacity: 1.0;\n            text-shadow: none; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-playpause] {\n        float: left; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-playstop] {\n        float: left; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-indicator[data-position], .media-control[data-media-control] .media-control-layer[data-controls] .media-control-indicator[data-duration] {\n      display: inline-block;\n      font-size: 10px;\n      color: white;\n      cursor: default;\n      line-height: 32px;\n      position: relative; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-indicator[data-position] {\n      margin: 0 6px 0 7px; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-indicator[data-duration] {\n      color: rgba(255, 255, 255, 0.5);\n      margin-right: 6px; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .media-control-indicator[data-duration]:before {\n        content: "|";\n        margin-right: 7px; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] {\n      position: absolute;\n      top: -20px;\n      left: 0;\n      display: inline-block;\n      vertical-align: middle;\n      width: 100%;\n      height: 25px;\n      cursor: pointer; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] {\n        width: 100%;\n        height: 1px;\n        position: relative;\n        top: 12px;\n        background-color: #666666; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-fill-1[data-seekbar] {\n          position: absolute;\n          top: 0;\n          left: 0;\n          width: 0;\n          height: 100%;\n          background-color: #c2c2c2;\n          transition: all 0.1s ease-out; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-fill-2[data-seekbar] {\n          position: absolute;\n          top: 0;\n          left: 0;\n          width: 0;\n          height: 100%;\n          background-color: #005aff;\n          transition: all 0.1s ease-out; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-hover[data-seekbar] {\n          opacity: 0;\n          position: absolute;\n          top: -3px;\n          width: 5px;\n          height: 7px;\n          background-color: rgba(255, 255, 255, 0.5);\n          transition: opacity 0.1s ease; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar]:hover .bar-background[data-seekbar] .bar-hover[data-seekbar] {\n        opacity: 1; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar].seek-disabled {\n        cursor: default; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar].seek-disabled:hover .bar-background[data-seekbar] .bar-hover[data-seekbar] {\n          opacity: 0; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-scrubber[data-seekbar] {\n        position: absolute;\n        transform: translateX(-50%);\n        top: 2px;\n        left: 0;\n        width: 20px;\n        height: 20px;\n        opacity: 1;\n        transition: all 0.1s ease-out; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-scrubber[data-seekbar] .bar-scrubber-icon[data-seekbar] {\n          position: absolute;\n          left: 6px;\n          top: 6px;\n          width: 8px;\n          height: 8px;\n          border-radius: 10px;\n          box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.2);\n          background-color: white; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] {\n      float: right;\n      display: inline-block;\n      height: 32px;\n      cursor: pointer;\n      margin: 0 6px;\n      box-sizing: border-box; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] {\n        float: left;\n        bottom: 0; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume] {\n          background-color: transparent;\n          border: 0;\n          box-sizing: content-box;\n          width: 32px;\n          height: 32px;\n          opacity: 0.5; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume]:hover {\n            opacity: 0.75; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume] svg {\n            height: 24px;\n            position: relative;\n            top: 3px; }\n            .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume] svg path {\n              fill: white; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume].muted svg {\n            margin-left: 2px; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] {\n        float: left;\n        position: relative;\n        overflow: hidden;\n        top: 6px;\n        width: 42px;\n        height: 18px;\n        padding: 3px 0;\n        transition: width .2s ease-out; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] {\n          height: 1px;\n          position: relative;\n          top: 7px;\n          margin: 0 3px;\n          background-color: #666666; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] .bar-fill-1[data-volume] {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 0;\n            height: 100%;\n            background-color: #c2c2c2;\n            transition: all 0.1s ease-out; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] .bar-fill-2[data-volume] {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 0;\n            height: 100%;\n            background-color: #005aff;\n            transition: all 0.1s ease-out; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] .bar-hover[data-volume] {\n            opacity: 0;\n            position: absolute;\n            top: -3px;\n            width: 5px;\n            height: 7px;\n            background-color: rgba(255, 255, 255, 0.5);\n            transition: opacity 0.1s ease; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-scrubber[data-volume] {\n          position: absolute;\n          transform: translateX(-50%);\n          top: 0px;\n          left: 0;\n          width: 20px;\n          height: 20px;\n          opacity: 1;\n          transition: all 0.1s ease-out; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-scrubber[data-volume] .bar-scrubber-icon[data-volume] {\n            position: absolute;\n            left: 6px;\n            top: 6px;\n            width: 8px;\n            height: 8px;\n            border-radius: 10px;\n            box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.2);\n            background-color: white; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume] {\n          float: left;\n          width: 4px;\n          padding-left: 2px;\n          height: 12px;\n          opacity: 0.5;\n          box-shadow: inset 2px 0 0 white;\n          transition: transform .2s ease-out; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume].fill {\n            box-shadow: inset 2px 0 0 #fff;\n            opacity: 1; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume]:nth-of-type(1) {\n            padding-left: 0; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume]:hover {\n            transform: scaleY(1.5); }\n  .media-control[data-media-control].w320 .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume].volume-bar-hide {\n    width: 0;\n    height: 12px;\n    top: 9px;\n    padding: 0; }\n', { baseUrl: this.options.baseUrl });
      this.$el.append(r3[0]), this.createCachedElements(), this.$playPauseToggle.addClass("paused"), this.$playStopToggle.addClass("stopped"), this.changeTogglePlay(), this.container && (this.hideId = setTimeout(function() {
        return e3.hide();
      }, t3), this.disabled && this.hide()), w.isSafari && w.isMobile && (w.version < 10 ? this.$volumeContainer.css("display", "none") : this.$volumeBarContainer.css("display", "none")), this.$seekBarPosition.addClass("media-control-notransition"), this.$seekBarScrubber.addClass("media-control-notransition");
      var i2 = 0;
      return this.displayedSeekBarPercentage && (i2 = this.displayedSeekBarPercentage), this.displayedSeekBarPercentage = null, this.setSeekPercentage(i2), setTimeout(function() {
        !e3.settings.seekEnabled && e3.$seekBarContainer.addClass("seek-disabled"), !w.isMobile && !e3.options.disableKeyboardShortcuts && e3.bindKeyEvents(), e3.playerResize({ width: e3.options.width, height: e3.options.height }), e3.hideVolumeBar(0);
      }, 0), this.parseColors(), this.highDefinitionUpdate(this.isHD), this.core.$el.append(this.el), this.rendered = true, this.updateVolumeUI(), this.trigger(ce.MEDIACONTROL_RENDERED), this;
    } }]), r2;
  }(Le);
  Ot.extend = function(e2) {
    return Rt(Ot, e2);
  };
  for (var wt = function(e2) {
    nt(r2, e2);
    var t2 = lt(r2);
    function r2(e3) {
      var i2;
      return tt(this, r2), (i2 = t2.call(this, e3)).hasStartedPlaying = false, i2.playRequested = false, i2.render(), setTimeout(function() {
        return i2.update();
      }, 0), i2;
    }
    return it(r2, [{ key: "name", get: function() {
      return "poster";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "template", get: function() {
      return Te('<div class="play-wrapper" data-poster></div>\n');
    } }, { key: "shouldRender", get: function() {
      var e3 = !(!this.options.poster || !this.options.poster.showForNoOp);
      return "html_img" !== this.container.playback.name && (this.container.playback.getPlaybackType() !== Re.NO_OP || e3);
    } }, { key: "attributes", get: function() {
      return { class: "player-poster", "data-poster": "" };
    } }, { key: "events", get: function() {
      return { click: "clicked" };
    } }, { key: "showOnVideoEnd", get: function() {
      return !this.options.poster || this.options.poster.showOnVideoEnd || void 0 === this.options.poster.showOnVideoEnd;
    } }, { key: "bindEvents", value: function() {
      this.listenTo(this.container, ce.CONTAINER_STOP, this.onStop), this.listenTo(this.container, ce.CONTAINER_PLAY, this.onPlay), this.listenTo(this.container, ce.CONTAINER_STATE_BUFFERING, this.update), this.listenTo(this.container, ce.CONTAINER_STATE_BUFFERFULL, this.update), this.listenTo(this.container, ce.CONTAINER_OPTIONS_CHANGE, this.render), this.listenTo(this.container, ce.CONTAINER_ERROR, this.onError), this.showOnVideoEnd && this.listenTo(this.container, ce.CONTAINER_ENDED, this.onStop);
    } }, { key: "onError", value: function(e3) {
      this.hasFatalError = e3.level === _e.Levels.FATAL, this.hasFatalError && (this.hasStartedPlaying = false, this.playRequested = false, this.showPlayButton());
    } }, { key: "onPlay", value: function() {
      this.hasStartedPlaying = true, this.update();
    } }, { key: "onStop", value: function() {
      this.hasStartedPlaying = false, this.playRequested = false, this.update();
    } }, { key: "updatePlayButton", value: function(e3) {
      !e3 || this.options.chromeless && !this.options.allowUserInteraction ? this.hidePlayButton() : this.showPlayButton();
    } }, { key: "showPlayButton", value: function() {
      this.hasFatalError && !this.options.disableErrorScreen || (this.$playButton.show(), this.$el.addClass("clickable"));
    } }, { key: "hidePlayButton", value: function() {
      this.$playButton.hide(), this.$el.removeClass("clickable");
    } }, { key: "clicked", value: function() {
      if (!this.hasStartedPlaying)
        return this.options.chromeless && !this.options.allowUserInteraction || (this.playRequested = true, this.update(), this.container.playback && (this.container.playback._consented = true), this.container.play()), false;
    } }, { key: "shouldHideOnPlay", value: function() {
      return !this.container.playback.isAudioOnly;
    } }, { key: "update", value: function() {
      if (this.shouldRender) {
        var e3 = !this.playRequested && !this.hasStartedPlaying && !this.container.buffering;
        this.updatePlayButton(e3), this.updatePoster();
      }
    } }, { key: "updatePoster", value: function() {
      this.hasStartedPlaying ? this.hidePoster() : this.showPoster();
    } }, { key: "showPoster", value: function() {
      this.container.disableMediaControl(), this.$el.show();
    } }, { key: "hidePoster", value: function() {
      this.container.enableMediaControl(), this.shouldHideOnPlay() && this.$el.hide();
    } }, { key: "render", value: function() {
      if (this.shouldRender) {
        var e3 = be.getStyleFor(".player-poster[data-poster] {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  z-index: 998;\n  top: 0;\n  left: 0;\n  background-color: transparent;\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-position: 50% 50%; }\n  .player-poster[data-poster].clickable {\n    cursor: pointer; }\n  .player-poster[data-poster]:hover .play-wrapper[data-poster] {\n    opacity: 1; }\n  .player-poster[data-poster] .play-wrapper[data-poster] {\n    width: 100%;\n    height: 25%;\n    margin: 0 auto;\n    opacity: 0.75;\n    transition: opacity 0.1s ease; }\n    .player-poster[data-poster] .play-wrapper[data-poster] svg {\n      height: 100%; }\n      .player-poster[data-poster] .play-wrapper[data-poster] svg path {\n        fill: #fff; }\n", { baseUrl: this.options.baseUrl });
        if (this.$el.html(this.template()), this.$el.append(e3[0]), this.options.poster && void 0 === this.options.poster.custom) {
          var t3 = this.options.poster.url || this.options.poster;
          this.$el.css({ "background-image": "url(" + t3 + ")" }), this.removeVideoElementPoster();
        } else
          this.options.poster && (this.$el.css({ background: this.options.poster.custom }), this.removeVideoElementPoster());
        this.container.$el.append(this.el), this.$playWrapper = this.$el.find(".play-wrapper"), this.$playWrapper.append(vt), this.$playButton = this.$playWrapper.find("svg"), this.$playButton.addClass("poster-icon"), this.$playButton.attr("data-poster", "");
        var r3 = this.options.mediacontrol && this.options.mediacontrol.buttons;
        return r3 && this.$el.find("svg path").css("fill", r3), this.options.mediacontrol && this.options.mediacontrol.buttons && (r3 = this.options.mediacontrol.buttons, this.$playButton.css("color", r3)), this.update(), this;
      }
    } }, { key: "removeVideoElementPoster", value: function() {
      this.container.playback && this.container.playback.$el && this.container.playback.$el[0] && this.container.playback.$el[0].removeAttribute && this.container.playback.$el[0].removeAttribute("poster");
    } }]), r2;
  }(je), Pt = J.formatTime, xt = function(e2) {
    nt(r2, e2);
    var t2 = lt(r2);
    function r2(e3) {
      var i2;
      return tt(this, r2), (i2 = t2.call(this, e3)).hoveringOverSeekBar = false, i2.hoverPosition = null, i2.duration = null, i2.firstFragDateTime = null, i2.actualLiveTime = !!i2.mediaControl.options.actualLiveTime, i2.actualLiveTime && (i2.mediaControl.options.actualLiveServerTime ? i2.actualLiveServerTimeDiff = (/* @__PURE__ */ new Date()).getTime() - new Date(i2.mediaControl.options.actualLiveServerTime).getTime() : i2.actualLiveServerTimeDiff = 0), i2;
    }
    return it(r2, [{ key: "name", get: function() {
      return "seek_time";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "template", get: function() {
      return Te("<span data-seek-time></span>\n<span data-duration></span>\n");
    } }, { key: "attributes", get: function() {
      return { class: "seek-time", "data-seek-time": "" };
    } }, { key: "mediaControl", get: function() {
      return this.core.mediaControl;
    } }, { key: "mediaControlContainer", get: function() {
      return this.mediaControl.container;
    } }, { key: "isLiveStreamWithDvr", get: function() {
      return this.mediaControlContainer && this.mediaControlContainer.getPlaybackType() === Re.LIVE && this.mediaControlContainer.isDvrEnabled();
    } }, { key: "durationShown", get: function() {
      return this.isLiveStreamWithDvr && !this.actualLiveTime;
    } }, { key: "useActualLiveTime", get: function() {
      return this.actualLiveTime && this.isLiveStreamWithDvr;
    } }, { key: "bindEvents", value: function() {
      this.listenTo(this.mediaControl, ce.MEDIACONTROL_RENDERED, this.render), this.listenTo(this.mediaControl, ce.MEDIACONTROL_MOUSEMOVE_SEEKBAR, this.showTime), this.listenTo(this.mediaControl, ce.MEDIACONTROL_MOUSELEAVE_SEEKBAR, this.hideTime), this.listenTo(this.mediaControl, ce.MEDIACONTROL_CONTAINERCHANGED, this.onContainerChanged), this.mediaControlContainer && (this.listenTo(this.mediaControlContainer, ce.CONTAINER_PLAYBACKDVRSTATECHANGED, this.update), this.listenTo(this.mediaControlContainer, ce.CONTAINER_TIMEUPDATE, this.updateDuration));
    } }, { key: "onContainerChanged", value: function() {
      this.stopListening(), this.bindEvents();
    } }, { key: "updateDuration", value: function(e3) {
      this.duration = e3.total, this.firstFragDateTime = e3.firstFragDateTime, this.update();
    } }, { key: "showTime", value: function(e3) {
      this.hoveringOverSeekBar = true, this.calculateHoverPosition(e3), this.update();
    } }, { key: "hideTime", value: function() {
      this.hoveringOverSeekBar = false, this.update();
    } }, { key: "calculateHoverPosition", value: function(e3) {
      var t3 = e3.pageX - this.mediaControl.$seekBarContainer.offset().left;
      this.hoverPosition = Math.min(1, Math.max(t3 / this.mediaControl.$seekBarContainer.width(), 0));
    } }, { key: "getSeekTime", value: function() {
      var e3, t3, r3, i2;
      return this.useActualLiveTime ? (this.firstFragDateTime ? (i2 = new Date(this.firstFragDateTime), (r3 = new Date(this.firstFragDateTime)).setHours(0, 0, 0, 0), t3 = (i2.getTime() - r3.getTime()) / 1e3 + this.duration) : (r3 = new Date((/* @__PURE__ */ new Date()).getTime() - this.actualLiveServerTimeDiff), t3 = ((i2 = new Date(r3)) - r3.setHours(0, 0, 0, 0)) / 1e3), (e3 = t3 - this.duration + this.hoverPosition * this.duration) < 0 && (e3 += 86400)) : e3 = this.hoverPosition * this.duration, { seekTime: e3, secondsSinceMidnight: t3 };
    } }, { key: "update", value: function() {
      if (this.rendered)
        if (this.shouldBeVisible()) {
          var e3 = this.getSeekTime(), t3 = Pt(e3.seekTime, this.useActualLiveTime);
          if (t3 !== this.displayedSeekTime && (this.$seekTimeEl.text(t3), this.displayedSeekTime = t3), this.durationShown) {
            this.$durationEl.show();
            var r3 = Pt(this.actualLiveTime ? e3.secondsSinceMidnight : this.duration, this.actualLiveTime);
            r3 !== this.displayedDuration && (this.$durationEl.text(r3), this.displayedDuration = r3);
          } else
            this.$durationEl.hide();
          this.$el.show();
          var i2 = this.mediaControl.$seekBarContainer.width(), n2 = this.$el.width(), a2 = this.hoverPosition * i2;
          a2 -= n2 / 2, a2 = Math.max(0, Math.min(a2, i2 - n2)), this.$el.css("left", a2);
        } else
          this.$el.hide(), this.$el.css("left", "-100%");
    } }, { key: "shouldBeVisible", value: function() {
      return this.mediaControlContainer && this.mediaControlContainer.settings.seekEnabled && this.hoveringOverSeekBar && null !== this.hoverPosition && null !== this.duration;
    } }, { key: "render", value: function() {
      var e3 = be.getStyleFor('.seek-time[data-seek-time] {\n  position: absolute;\n  white-space: nowrap;\n  height: 20px;\n  line-height: 20px;\n  font-size: 0;\n  left: -100%;\n  bottom: 55px;\n  background-color: rgba(2, 2, 2, 0.5);\n  z-index: 9999;\n  transition: opacity 0.1s ease; }\n  .seek-time[data-seek-time].hidden[data-seek-time] {\n    opacity: 0; }\n  .seek-time[data-seek-time] [data-seek-time] {\n    display: inline-block;\n    color: white;\n    font-size: 10px;\n    padding-left: 7px;\n    padding-right: 7px;\n    vertical-align: top; }\n  .seek-time[data-seek-time] [data-duration] {\n    display: inline-block;\n    color: rgba(255, 255, 255, 0.5);\n    font-size: 10px;\n    padding-right: 7px;\n    vertical-align: top; }\n    .seek-time[data-seek-time] [data-duration]:before {\n      content: "|";\n      margin-right: 7px; }\n', { baseUrl: this.options.baseUrl });
      this.rendered = true, this.displayedDuration = null, this.displayedSeekTime = null, this.$el.html(this.template()), this.$el.append(e3[0]), this.$el.hide(), this.mediaControl.$el.append(this.el), this.$seekTimeEl = this.$el.find("[data-seek-time]"), this.$durationEl = this.$el.find("[data-duration]"), this.$durationEl.hide(), this.update();
    } }]), r2;
  }(Le), Nt = { ClickToPause: dt, ClosedCaptions: ht, DVRControls: ft, EndVideo: pt, ErrorScreen: gt, Favicon: At, GoogleAnalytics: Et, MediaControl: Ot, Poster: wt, SeekTime: xt, SpinnerThreeBounce: function(e2) {
    nt(r2, e2);
    var t2 = lt(r2);
    function r2(e3) {
      var i2;
      return tt(this, r2), (i2 = t2.call(this, e3)).template = Te("<div data-bounce1></div><div data-bounce2></div><div data-bounce3></div>\n"), i2.showTimeout = null, i2.listenTo(i2.container, ce.CONTAINER_STATE_BUFFERING, i2.onBuffering), i2.listenTo(i2.container, ce.CONTAINER_STATE_BUFFERFULL, i2.onBufferFull), i2.listenTo(i2.container, ce.CONTAINER_STOP, i2.onStop), i2.listenTo(i2.container, ce.CONTAINER_ENDED, i2.onStop), i2.listenTo(i2.container, ce.CONTAINER_ERROR, i2.onStop), i2.render(), i2;
    }
    return it(r2, [{ key: "name", get: function() {
      return "spinner";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "attributes", get: function() {
      return { "data-spinner": "", class: "spinner-three-bounce" };
    } }, { key: "onBuffering", value: function() {
      this.show();
    } }, { key: "onBufferFull", value: function() {
      this.hide();
    } }, { key: "onStop", value: function() {
      this.hide();
    } }, { key: "show", value: function() {
      var e3 = this;
      null === this.showTimeout && (this.showTimeout = setTimeout(function() {
        return e3.$el.show();
      }, 300));
    } }, { key: "hide", value: function() {
      null !== this.showTimeout && (clearTimeout(this.showTimeout), this.showTimeout = null), this.$el.hide();
    } }, { key: "render", value: function() {
      var e3 = be.getStyleFor(".spinner-three-bounce[data-spinner] {\n  position: absolute;\n  margin: 0 auto;\n  width: 70px;\n  text-align: center;\n  z-index: 999;\n  left: 0;\n  right: 0;\n  margin-left: auto;\n  margin-right: auto;\n  /* center vertically */\n  top: 50%;\n  transform: translateY(-50%); }\n  .spinner-three-bounce[data-spinner] > div {\n    width: 18px;\n    height: 18px;\n    background-color: #FFFFFF;\n    border-radius: 100%;\n    display: inline-block;\n    animation: bouncedelay 1.4s infinite ease-in-out;\n    /* Prevent first frame from flickering when animation starts */\n    animation-fill-mode: both; }\n  .spinner-three-bounce[data-spinner] [data-bounce1] {\n    animation-delay: -0.32s; }\n  .spinner-three-bounce[data-spinner] [data-bounce2] {\n    animation-delay: -0.16s; }\n\n@keyframes bouncedelay {\n  0%, 80%, 100% {\n    transform: scale(0); }\n  40% {\n    transform: scale(1); } }\n", { baseUrl: this.options.baseUrl });
      return this.$el.html(this.template()), this.$el.append(e3[0]), this.container.$el.append(this.$el), this.$el.hide(), this.container.buffering && this.onBuffering(), this;
    } }]), r2;
  }(je), Stats: function(e2) {
    nt(r2, e2);
    var t2 = lt(r2);
    function r2(e3) {
      var i2;
      return tt(this, r2), (i2 = t2.call(this, e3)).setInitialAttrs(), i2.reportInterval = i2.options.reportInterval || 5e3, i2.state = "IDLE", i2;
    }
    return it(r2, [{ key: "name", get: function() {
      return "stats";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "bindEvents", value: function() {
      this.listenTo(this.container.playback, ce.PLAYBACK_PLAY, this.onPlay), this.listenTo(this.container, ce.CONTAINER_STOP, this.onStop), this.listenTo(this.container, ce.CONTAINER_ENDED, this.onStop), this.listenTo(this.container, ce.CONTAINER_DESTROYED, this.onStop), this.listenTo(this.container, ce.CONTAINER_STATE_BUFFERING, this.onBuffering), this.listenTo(this.container, ce.CONTAINER_STATE_BUFFERFULL, this.onBufferFull), this.listenTo(this.container, ce.CONTAINER_STATS_ADD, this.onStatsAdd), this.listenTo(this.container, ce.CONTAINER_BITRATE, this.onStatsAdd), this.listenTo(this.container.playback, ce.PLAYBACK_STATS_ADD, this.onStatsAdd);
    } }, { key: "setInitialAttrs", value: function() {
      this.firstPlay = true, this.startupTime = 0, this.rebufferingTime = 0, this.watchingTime = 0, this.rebuffers = 0, this.externalMetrics = {};
    } }, { key: "onPlay", value: function() {
      this.state = "PLAYING", this.watchingTimeInit = Date.now(), this.intervalId || (this.intervalId = setInterval(this.report.bind(this), this.reportInterval));
    } }, { key: "onStop", value: function() {
      clearInterval(this.intervalId), this.report(), this.intervalId = void 0, this.state = "STOPPED";
    } }, { key: "onBuffering", value: function() {
      this.firstPlay ? this.startupTimeInit = Date.now() : this.rebufferingTimeInit = Date.now(), this.state = "BUFFERING", this.rebuffers++;
    } }, { key: "onBufferFull", value: function() {
      this.firstPlay && this.startupTimeInit ? (this.firstPlay = false, this.startupTime = Date.now() - this.startupTimeInit, this.watchingTimeInit = Date.now()) : this.rebufferingTimeInit && (this.rebufferingTime += this.getRebufferingTime()), this.rebufferingTimeInit = void 0, this.state = "PLAYING";
    } }, { key: "getRebufferingTime", value: function() {
      return Date.now() - this.rebufferingTimeInit;
    } }, { key: "getWatchingTime", value: function() {
      return Date.now() - this.watchingTimeInit - this.rebufferingTime;
    } }, { key: "isRebuffering", value: function() {
      return !!this.rebufferingTimeInit;
    } }, { key: "onStatsAdd", value: function(e3) {
      R.extend(this.externalMetrics, e3);
    } }, { key: "getStats", value: function() {
      var e3 = { startupTime: this.startupTime, rebuffers: this.rebuffers, rebufferingTime: this.isRebuffering() ? this.rebufferingTime + this.getRebufferingTime() : this.rebufferingTime, watchingTime: this.isRebuffering() ? this.getWatchingTime() - this.getRebufferingTime() : this.getWatchingTime() };
      return R.extend(e3, this.externalMetrics), e3;
    } }, { key: "report", value: function() {
      this.container.statsReport(this.getStats());
    } }]), r2;
  }(Ve), WaterMark: function(e2) {
    nt(r2, e2);
    var t2 = lt(r2);
    function r2(e3) {
      var i2;
      return tt(this, r2), (i2 = t2.call(this, e3)).configure(), i2;
    }
    return it(r2, [{ key: "name", get: function() {
      return "watermark";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "template", get: function() {
      return Te(`<div class="clappr-watermark" data-watermark data-watermark-<%=position %>>
<% if(typeof imageLink !== 'undefined') { %>
<a target="_blank" href="<%= imageLink %>">
<% } %>
<img src="<%= imageUrl %>">
<% if(typeof imageLink !== 'undefined') { %>
</a>
<% } %>
</div>
`);
    } }, { key: "bindEvents", value: function() {
      this.listenTo(this.container, ce.CONTAINER_PLAY, this.onPlay), this.listenTo(this.container, ce.CONTAINER_STOP, this.onStop), this.listenTo(this.container, ce.CONTAINER_OPTIONS_CHANGE, this.configure);
    } }, { key: "configure", value: function() {
      this.position = this.options.position || "bottom-right", this.options.watermark ? (this.imageUrl = this.options.watermark, this.imageLink = this.options.watermarkLink, this.render()) : this.$el.remove();
    } }, { key: "onPlay", value: function() {
      this.hidden || this.$el.show();
    } }, { key: "onStop", value: function() {
      this.$el.hide();
    } }, { key: "render", value: function() {
      this.$el.hide();
      var e3 = be.getStyleFor(".clappr-watermark[data-watermark] {\n  position: absolute;\n  min-width: 70px;\n  max-width: 200px;\n  width: 12%;\n  text-align: center;\n  z-index: 10; }\n\n.clappr-watermark[data-watermark] a {\n  outline: none;\n  cursor: pointer; }\n\n.clappr-watermark[data-watermark] img {\n  max-width: 100%; }\n\n.clappr-watermark[data-watermark-bottom-left] {\n  bottom: 10px;\n  left: 10px; }\n\n.clappr-watermark[data-watermark-bottom-right] {\n  bottom: 10px;\n  right: 42px; }\n\n.clappr-watermark[data-watermark-top-left] {\n  top: 10px;\n  left: 10px; }\n\n.clappr-watermark[data-watermark-top-right] {\n  top: 10px;\n  right: 37px; }\n", { baseUrl: this.options.baseUrl }), t3 = { position: this.position, imageUrl: this.imageUrl, imageLink: this.imageLink };
      return this.$el.html(this.template(t3)), this.$el.append(e3[0]), this.container.$el.append(this.$el), this;
    } }]), r2;
  }(je) }, Ft = 0, Mt = Object.values(Nt); Ft < Mt.length; Ft++) {
    var Bt = Mt[Ft];
    Be.registerPlugin(Bt);
  }
  var Ut = Nt.ClickToPause, Gt = Nt.ClosedCaptions, Vt = Nt.DVRControls, Kt = Nt.EndVideo, jt = Nt.ErrorScreen, Ht = Nt.Favicon, Yt = Nt.GoogleAnalytics, Wt = Nt.MediaControl, $t = Nt.Poster, zt = Nt.SeekTime, qt = Nt.SpinnerThreeBounce, Xt = Nt.Stats, Zt = Nt.WaterMark, Qt = t(t({}, et), {}, { ClickToPause: Ut, ClosedCaptions: Gt, DVRControls: Vt, EndVideo: Kt, ErrorScreen: jt, Favicon: Ht, GoogleAnalytics: Yt, MediaControl: Wt, Poster: $t, SeekTime: zt, SpinnerThreeBounce: qt, Stats: Xt, WaterMark: Zt, Vendor: bt, Plugins: Nt, version: "0.5.0" });
  function Jt(e2, t2) {
    var r2 = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var i2 = Object.getOwnPropertySymbols(e2);
      t2 && (i2 = i2.filter(function(t3) {
        return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
      })), r2.push.apply(r2, i2);
    }
    return r2;
  }
  function er(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2 = null != arguments[t2] ? arguments[t2] : {};
      t2 % 2 ? Jt(Object(r2), true).forEach(function(t3) {
        ir(e2, t3, r2[t3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : Jt(Object(r2)).forEach(function(t3) {
        Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
      });
    }
    return e2;
  }
  function tr(e2, t2) {
    if (!(e2 instanceof t2))
      throw new TypeError("Cannot call a class as a function");
  }
  function rr(e2, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var i2 = t2[r2];
      i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e2, hr(i2.key), i2);
    }
  }
  function ir(e2, t2, r2) {
    return (t2 = hr(t2)) in e2 ? Object.defineProperty(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2, e2;
  }
  function nr(e2) {
    return nr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e3) {
      return e3.__proto__ || Object.getPrototypeOf(e3);
    }, nr(e2);
  }
  function ar(e2, t2) {
    return ar = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e3, t3) {
      return e3.__proto__ = t3, e3;
    }, ar(e2, t2);
  }
  function sr(e2, t2) {
    if (t2 && ("object" == typeof t2 || "function" == typeof t2))
      return t2;
    if (void 0 !== t2)
      throw new TypeError("Derived constructors may only return object or undefined");
    return function(e3) {
      if (void 0 === e3)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e3;
    }(e2);
  }
  function or(e2) {
    var t2 = function() {
      if ("undefined" == typeof Reflect || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if ("function" == typeof Proxy)
        return true;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), true;
      } catch (e3) {
        return false;
      }
    }();
    return function() {
      var r2, i2 = nr(e2);
      if (t2) {
        var n2 = nr(this).constructor;
        r2 = Reflect.construct(i2, arguments, n2);
      } else
        r2 = i2.apply(this, arguments);
      return sr(this, r2);
    };
  }
  function lr(e2, t2) {
    for (; !Object.prototype.hasOwnProperty.call(e2, t2) && null !== (e2 = nr(e2)); )
      ;
    return e2;
  }
  function ur() {
    return ur = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e2, t2, r2) {
      var i2 = lr(e2, t2);
      if (i2) {
        var n2 = Object.getOwnPropertyDescriptor(i2, t2);
        return n2.get ? n2.get.call(arguments.length < 3 ? e2 : r2) : n2.value;
      }
    }, ur.apply(this, arguments);
  }
  function cr(e2) {
    return function(e3) {
      if (Array.isArray(e3))
        return dr(e3);
    }(e2) || function(e3) {
      if ("undefined" != typeof Symbol && null != e3[Symbol.iterator] || null != e3["@@iterator"])
        return Array.from(e3);
    }(e2) || function(e3, t2) {
      if (!e3)
        return;
      if ("string" == typeof e3)
        return dr(e3, t2);
      var r2 = Object.prototype.toString.call(e3).slice(8, -1);
      "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
      if ("Map" === r2 || "Set" === r2)
        return Array.from(e3);
      if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
        return dr(e3, t2);
    }(e2) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function dr(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, i2 = new Array(t2); r2 < t2; r2++)
      i2[r2] = e2[r2];
    return i2;
  }
  function hr(e2) {
    var t2 = function(e3, t3) {
      if ("object" != typeof e3 || null === e3)
        return e3;
      var r2 = e3[Symbol.toPrimitive];
      if (void 0 !== r2) {
        var i2 = r2.call(e3, t3 || "default");
        if ("object" != typeof i2)
          return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === t3 ? String : Number)(e3);
    }(e2, "string");
    return "symbol" == typeof t2 ? t2 : String(t2);
  }
  "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self;
  function fr(e2) {
    return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
  }
  var pr, gr, vr = { exports: {} };
  pr = vr, "undefined" != typeof window && (gr = () => (() => {
    var e2 = { "./src/config.ts": (
      /*!***********************!*\
          !*** ./src/config.ts ***!
          \***********************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { enableStreamingMode: () => _2, hlsDefaultConfig: () => k2, mergeConfig: () => S2 });
        var i3 = r3(
          /*! ./controller/abr-controller */
          "./src/controller/abr-controller.ts"
        ), n2 = r3(
          /*! ./controller/audio-stream-controller */
          "./src/controller/audio-stream-controller.ts"
        ), a2 = r3(
          /*! ./controller/audio-track-controller */
          "./src/controller/audio-track-controller.ts"
        ), s2 = r3(
          /*! ./controller/subtitle-stream-controller */
          "./src/controller/subtitle-stream-controller.ts"
        ), o2 = r3(
          /*! ./controller/subtitle-track-controller */
          "./src/controller/subtitle-track-controller.ts"
        ), l2 = r3(
          /*! ./controller/buffer-controller */
          "./src/controller/buffer-controller.ts"
        ), u2 = r3(
          /*! ./controller/timeline-controller */
          "./src/controller/timeline-controller.ts"
        ), c2 = r3(
          /*! ./controller/cap-level-controller */
          "./src/controller/cap-level-controller.ts"
        ), d2 = r3(
          /*! ./controller/fps-controller */
          "./src/controller/fps-controller.ts"
        ), h2 = r3(
          /*! ./controller/eme-controller */
          "./src/controller/eme-controller.ts"
        ), f2 = r3(
          /*! ./controller/cmcd-controller */
          "./src/controller/cmcd-controller.ts"
        ), p2 = r3(
          /*! ./utils/xhr-loader */
          "./src/utils/xhr-loader.ts"
        ), g2 = r3(
          /*! ./utils/fetch-loader */
          "./src/utils/fetch-loader.ts"
        ), v2 = r3(
          /*! ./utils/cues */
          "./src/utils/cues.ts"
        ), m2 = r3(
          /*! ./utils/mediakeys-helper */
          "./src/utils/mediakeys-helper.ts"
        ), y2 = r3(
          /*! ./utils/logger */
          "./src/utils/logger.ts"
        );
        function A2() {
          return A2 = Object.assign ? Object.assign.bind() : function(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var r4 = arguments[t4];
              for (var i4 in r4)
                Object.prototype.hasOwnProperty.call(r4, i4) && (e4[i4] = r4[i4]);
            }
            return e4;
          }, A2.apply(this, arguments);
        }
        function E2(e4, t4) {
          var r4 = Object.keys(e4);
          if (Object.getOwnPropertySymbols) {
            var i4 = Object.getOwnPropertySymbols(e4);
            t4 && (i4 = i4.filter(function(t5) {
              return Object.getOwnPropertyDescriptor(e4, t5).enumerable;
            })), r4.push.apply(r4, i4);
          }
          return r4;
        }
        function T2(e4) {
          for (var t4 = 1; t4 < arguments.length; t4++) {
            var r4 = null != arguments[t4] ? arguments[t4] : {};
            t4 % 2 ? E2(Object(r4), true).forEach(function(t5) {
              b2(e4, t5, r4[t5]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(r4)) : E2(Object(r4)).forEach(function(t5) {
              Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(r4, t5));
            });
          }
          return e4;
        }
        function b2(e4, t4, r4) {
          return t4 in e4 ? Object.defineProperty(e4, t4, { value: r4, enumerable: true, configurable: true, writable: true }) : e4[t4] = r4, e4;
        }
        var k2 = T2(T2({ autoStartLoad: true, startPosition: -1, defaultAudioCodec: void 0, debug: false, capLevelOnFPSDrop: false, capLevelToPlayerSize: false, ignoreDevicePixelRatio: false, initialLiveManifestSize: 1, maxBufferLength: 30, backBufferLength: 1 / 0, maxBufferSize: 6e7, maxBufferHole: 0.1, highBufferWatchdogPeriod: 2, nudgeOffset: 0.1, nudgeMaxRetry: 3, maxFragLookUpTolerance: 0.25, liveSyncDurationCount: 3, liveMaxLatencyDurationCount: 1 / 0, liveSyncDuration: void 0, liveMaxLatencyDuration: void 0, maxLiveSyncPlaybackRate: 1, liveDurationInfinity: false, liveBackBufferLength: null, maxMaxBufferLength: 600, enableWorker: true, enableSoftwareAES: true, manifestLoadingTimeOut: 1e4, manifestLoadingMaxRetry: 1, manifestLoadingRetryDelay: 1e3, manifestLoadingMaxRetryTimeout: 64e3, startLevel: void 0, levelLoadingTimeOut: 1e4, levelLoadingMaxRetry: 4, levelLoadingRetryDelay: 1e3, levelLoadingMaxRetryTimeout: 64e3, fragLoadingTimeOut: 2e4, fragLoadingMaxRetry: 6, fragLoadingRetryDelay: 1e3, fragLoadingMaxRetryTimeout: 64e3, startFragPrefetch: false, fpsDroppedMonitoringPeriod: 5e3, fpsDroppedMonitoringThreshold: 0.2, appendErrorMaxRetry: 3, loader: p2.default, fLoader: void 0, pLoader: void 0, xhrSetup: void 0, licenseXhrSetup: void 0, licenseResponseCallback: void 0, abrController: i3.default, bufferController: l2.default, capLevelController: c2.default, fpsController: d2.default, stretchShortVideoTrack: false, maxAudioFramesDrift: 1, forceKeyFrameOnDiscontinuity: true, abrEwmaFastLive: 3, abrEwmaSlowLive: 9, abrEwmaFastVoD: 3, abrEwmaSlowVoD: 9, abrEwmaDefaultEstimate: 5e5, abrBandWidthFactor: 0.95, abrBandWidthUpFactor: 0.7, abrMaxWithRealBitrate: false, maxStarvationDelay: 4, maxLoadingDelay: 4, minAutoBitrate: 0, emeEnabled: false, widevineLicenseUrl: void 0, drmSystemOptions: {}, requestMediaKeySystemAccessFunc: m2.requestMediaKeySystemAccess, testBandwidth: true, progressive: false, lowLatencyMode: true, cmcd: void 0, enableDateRangeMetadataCues: true, enableEmsgMetadataCues: true, enableID3MetadataCues: true }, { cueHandler: v2.default, enableWebVTT: true, enableIMSC1: true, enableCEA708Captions: true, captionsTextTrack1Label: "English", captionsTextTrack1LanguageCode: "en", captionsTextTrack2Label: "Spanish", captionsTextTrack2LanguageCode: "es", captionsTextTrack3Label: "Unknown CC", captionsTextTrack3LanguageCode: "", captionsTextTrack4Label: "Unknown CC", captionsTextTrack4LanguageCode: "", renderTextTracksNatively: true }), {}, { subtitleStreamController: s2.SubtitleStreamController, subtitleTrackController: o2.default, timelineController: u2.TimelineController, audioStreamController: n2.default, audioTrackController: a2.default, emeController: h2.default, cmcdController: f2.default });
        function S2(e4, t4) {
          if ((t4.liveSyncDurationCount || t4.liveMaxLatencyDurationCount) && (t4.liveSyncDuration || t4.liveMaxLatencyDuration))
            throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
          if (void 0 !== t4.liveMaxLatencyDurationCount && (void 0 === t4.liveSyncDurationCount || t4.liveMaxLatencyDurationCount <= t4.liveSyncDurationCount))
            throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
          if (void 0 !== t4.liveMaxLatencyDuration && (void 0 === t4.liveSyncDuration || t4.liveMaxLatencyDuration <= t4.liveSyncDuration))
            throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
          return A2({}, e4, t4);
        }
        function _2(e4) {
          var t4 = e4.loader;
          t4 !== g2.default && t4 !== p2.default ? (y2.logger.log("[config]: Custom loader detected, cannot enable progressive streaming"), e4.progressive = false) : (0, g2.fetchSupported)() && (e4.loader = g2.default, e4.progressive = true, e4.enableSoftwareAES = true, y2.logger.log("[config]: Progressive streaming enabled, using FetchLoader"));
        }
      }
    ), "./src/controller/abr-controller.ts": (
      /*!******************************************!*\
          !*** ./src/controller/abr-controller.ts ***!
          \******************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => d2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ../utils/ewma-bandwidth-estimator */
          "./src/utils/ewma-bandwidth-estimator.ts"
        ), a2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), s2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), o2 = r3(
          /*! ../types/loader */
          "./src/types/loader.ts"
        ), l2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        );
        function u2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        var c2 = function() {
          function e4(e5) {
            this.hls = void 0, this.lastLoadedFragLevel = 0, this._nextAutoLevel = -1, this.timer = void 0, this.onCheck = this._abandonRulesCheck.bind(this), this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this.hls = e5;
            var t5 = e5.config;
            this.bwEstimator = new n2.default(t5.abrEwmaSlowVoD, t5.abrEwmaFastVoD, t5.abrEwmaDefaultEstimate), this.registerListeners();
          }
          var t4, r4, c3, d3 = e4.prototype;
          return d3.registerListeners = function() {
            var e5 = this.hls;
            e5.on(a2.Events.FRAG_LOADING, this.onFragLoading, this), e5.on(a2.Events.FRAG_LOADED, this.onFragLoaded, this), e5.on(a2.Events.FRAG_BUFFERED, this.onFragBuffered, this), e5.on(a2.Events.LEVEL_LOADED, this.onLevelLoaded, this), e5.on(a2.Events.ERROR, this.onError, this);
          }, d3.unregisterListeners = function() {
            var e5 = this.hls;
            e5.off(a2.Events.FRAG_LOADING, this.onFragLoading, this), e5.off(a2.Events.FRAG_LOADED, this.onFragLoaded, this), e5.off(a2.Events.FRAG_BUFFERED, this.onFragBuffered, this), e5.off(a2.Events.LEVEL_LOADED, this.onLevelLoaded, this), e5.off(a2.Events.ERROR, this.onError, this);
          }, d3.destroy = function() {
            this.unregisterListeners(), this.clearTimer(), this.hls = this.onCheck = null, this.fragCurrent = this.partCurrent = null;
          }, d3.onFragLoading = function(e5, t5) {
            var r5, i4 = t5.frag;
            i4.type === o2.PlaylistLevelType.MAIN && (this.timer || (this.fragCurrent = i4, this.partCurrent = null != (r5 = t5.part) ? r5 : null, this.timer = self.setInterval(this.onCheck, 100)));
          }, d3.onLevelLoaded = function(e5, t5) {
            var r5 = this.hls.config;
            t5.details.live ? this.bwEstimator.update(r5.abrEwmaSlowLive, r5.abrEwmaFastLive) : this.bwEstimator.update(r5.abrEwmaSlowVoD, r5.abrEwmaFastVoD);
          }, d3._abandonRulesCheck = function() {
            var e5 = this.fragCurrent, t5 = this.partCurrent, r5 = this.hls, n3 = r5.autoLevelEnabled;
            r5.config;
            var s3 = r5.media;
            if (e5 && s3) {
              var o3 = t5 ? t5.stats : e5.stats, u3 = t5 ? t5.duration : e5.duration;
              if (o3.aborted || o3.loaded && o3.loaded === o3.total || 0 === e5.level)
                return this.clearTimer(), void (this._nextAutoLevel = -1);
              if (n3 && !s3.paused && s3.playbackRate && s3.readyState) {
                var c4 = r5.mainForwardBufferInfo;
                if (null !== c4) {
                  var d4 = performance.now() - o3.loading.start, h2 = Math.abs(s3.playbackRate);
                  if (!(d4 <= 500 * u3 / h2)) {
                    var f2 = o3.loaded && o3.loading.first, p2 = this.bwEstimator.getEstimate(), g2 = r5.levels, v2 = r5.minAutoLevel, m2 = g2[e5.level], y2 = o3.total || Math.max(o3.loaded, Math.round(u3 * m2.maxBitrate / 8)), A2 = f2 ? 1e3 * o3.loaded / d4 : 0, E2 = A2 ? (y2 - o3.loaded) / A2 : 8 * y2 / p2, T2 = c4.len / h2;
                    if (!(E2 <= T2)) {
                      var b2, k2 = Number.POSITIVE_INFINITY;
                      for (b2 = e5.level - 1; b2 > v2; b2--) {
                        var S2 = g2[b2].maxBitrate;
                        if ((k2 = A2 ? u3 * S2 / (6.4 * A2) : u3 * S2 / p2) < T2)
                          break;
                      }
                      k2 >= E2 || (l2.logger.warn("Fragment " + e5.sn + (t5 ? " part " + t5.index : "") + " of level " + e5.level + " is loading too slowly and will cause an underbuffer; aborting and switching to level " + b2 + "\n      Current BW estimate: " + ((0, i3.isFiniteNumber)(p2) ? (p2 / 1024).toFixed(3) : "Unknown") + " Kb/s\n      Estimated load time for current fragment: " + E2.toFixed(3) + " s\n      Estimated load time for the next fragment: " + k2.toFixed(3) + " s\n      Time to underbuffer: " + T2.toFixed(3) + " s"), r5.nextLoadLevel = b2, f2 && this.bwEstimator.sample(d4, o3.loaded), this.clearTimer(), e5.loader && (this.fragCurrent = this.partCurrent = null, e5.loader.abort()), r5.trigger(a2.Events.FRAG_LOAD_EMERGENCY_ABORTED, { frag: e5, part: t5, stats: o3 }));
                    }
                  }
                }
              }
            }
          }, d3.onFragLoaded = function(e5, t5) {
            var r5 = t5.frag, n3 = t5.part;
            if (r5.type === o2.PlaylistLevelType.MAIN && (0, i3.isFiniteNumber)(r5.sn)) {
              var s3 = n3 ? n3.stats : r5.stats, l3 = n3 ? n3.duration : r5.duration;
              if (this.clearTimer(), this.lastLoadedFragLevel = r5.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {
                var u3 = this.hls.levels[r5.level], c4 = (u3.loaded ? u3.loaded.bytes : 0) + s3.loaded, d4 = (u3.loaded ? u3.loaded.duration : 0) + l3;
                u3.loaded = { bytes: c4, duration: d4 }, u3.realBitrate = Math.round(8 * c4 / d4);
              }
              if (r5.bitrateTest) {
                var h2 = { stats: s3, frag: r5, part: n3, id: r5.type };
                this.onFragBuffered(a2.Events.FRAG_BUFFERED, h2);
              }
            }
          }, d3.onFragBuffered = function(e5, t5) {
            var r5 = t5.frag, i4 = t5.part, n3 = i4 ? i4.stats : r5.stats;
            if (!n3.aborted && r5.type === o2.PlaylistLevelType.MAIN && "initSegment" !== r5.sn) {
              var a3 = n3.parsing.end - n3.loading.start;
              this.bwEstimator.sample(a3, n3.loaded), n3.bwEstimate = this.bwEstimator.getEstimate(), r5.bitrateTest ? this.bitrateTestDelay = a3 / 1e3 : this.bitrateTestDelay = 0;
            }
          }, d3.onError = function(e5, t5) {
            switch (t5.details) {
              case s2.ErrorDetails.FRAG_LOAD_ERROR:
              case s2.ErrorDetails.FRAG_LOAD_TIMEOUT:
                this.clearTimer();
            }
          }, d3.clearTimer = function() {
            self.clearInterval(this.timer), this.timer = void 0;
          }, d3.getNextABRAutoLevel = function() {
            var e5 = this.fragCurrent, t5 = this.partCurrent, r5 = this.hls, i4 = r5.maxAutoLevel, n3 = r5.config, a3 = r5.minAutoLevel, s3 = r5.media, o3 = t5 ? t5.duration : e5 ? e5.duration : 0;
            s3 && s3.currentTime;
            var u3 = s3 && 0 !== s3.playbackRate ? Math.abs(s3.playbackRate) : 1, c4 = this.bwEstimator ? this.bwEstimator.getEstimate() : n3.abrEwmaDefaultEstimate, d4 = r5.mainForwardBufferInfo, h2 = (d4 ? d4.len : 0) / u3, f2 = this.findBestLevel(c4, a3, i4, h2, n3.abrBandWidthFactor, n3.abrBandWidthUpFactor);
            if (f2 >= 0)
              return f2;
            l2.logger.trace((h2 ? "rebuffering expected" : "buffer is empty") + ", finding optimal quality level");
            var p2 = o3 ? Math.min(o3, n3.maxStarvationDelay) : n3.maxStarvationDelay, g2 = n3.abrBandWidthFactor, v2 = n3.abrBandWidthUpFactor;
            if (!h2) {
              var m2 = this.bitrateTestDelay;
              m2 && (p2 = (o3 ? Math.min(o3, n3.maxLoadingDelay) : n3.maxLoadingDelay) - m2, l2.logger.trace("bitrate test took " + Math.round(1e3 * m2) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * p2) + " ms"), g2 = v2 = 1);
            }
            return f2 = this.findBestLevel(c4, a3, i4, h2 + p2, g2, v2), Math.max(f2, 0);
          }, d3.findBestLevel = function(e5, t5, r5, n3, a3, s3) {
            for (var o3, u3 = this.fragCurrent, c4 = this.partCurrent, d4 = this.lastLoadedFragLevel, h2 = this.hls.levels, f2 = h2[d4], p2 = !(null == f2 || null === (o3 = f2.details) || void 0 === o3 || !o3.live), g2 = null == f2 ? void 0 : f2.codecSet, v2 = c4 ? c4.duration : u3 ? u3.duration : 0, m2 = r5; m2 >= t5; m2--) {
              var y2 = h2[m2];
              if (y2 && (!g2 || y2.codecSet === g2)) {
                var A2 = y2.details, E2 = (c4 ? null == A2 ? void 0 : A2.partTarget : null == A2 ? void 0 : A2.averagetargetduration) || v2, T2 = void 0;
                T2 = m2 <= d4 ? a3 * e5 : s3 * e5;
                var b2 = h2[m2].maxBitrate, k2 = b2 * E2 / T2;
                if (l2.logger.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + m2 + "/" + Math.round(T2) + "/" + b2 + "/" + E2 + "/" + n3 + "/" + k2), T2 > b2 && (0 === k2 || !(0, i3.isFiniteNumber)(k2) || p2 && !this.bitrateTestDelay || k2 < n3))
                  return m2;
              }
            }
            return -1;
          }, t4 = e4, (r4 = [{ key: "nextAutoLevel", get: function() {
            var e5 = this._nextAutoLevel, t5 = this.bwEstimator;
            if (-1 !== e5 && !t5.canEstimate())
              return e5;
            var r5 = this.getNextABRAutoLevel();
            return -1 !== e5 && this.hls.levels[r5].loadError ? e5 : (-1 !== e5 && (r5 = Math.min(e5, r5)), r5);
          }, set: function(e5) {
            this._nextAutoLevel = e5;
          } }]) && u2(t4.prototype, r4), c3 && u2(t4, c3), Object.defineProperty(t4, "prototype", { writable: false }), e4;
        }();
        const d2 = c2;
      }
    ), "./src/controller/audio-stream-controller.ts": (
      /*!***************************************************!*\
          !*** ./src/controller/audio-stream-controller.ts ***!
          \***************************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => E2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ./base-stream-controller */
          "./src/controller/base-stream-controller.ts"
        ), a2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), s2 = r3(
          /*! ../utils/buffer-helper */
          "./src/utils/buffer-helper.ts"
        ), o2 = r3(
          /*! ./fragment-tracker */
          "./src/controller/fragment-tracker.ts"
        ), l2 = r3(
          /*! ../types/level */
          "./src/types/level.ts"
        ), u2 = r3(
          /*! ../types/loader */
          "./src/types/loader.ts"
        ), c2 = r3(
          /*! ../loader/fragment */
          "./src/loader/fragment.ts"
        ), d2 = r3(
          /*! ../demux/chunk-cache */
          "./src/demux/chunk-cache.ts"
        ), h2 = r3(
          /*! ../demux/transmuxer-interface */
          "./src/demux/transmuxer-interface.ts"
        ), f2 = r3(
          /*! ../types/transmuxer */
          "./src/types/transmuxer.ts"
        ), p2 = r3(
          /*! ./fragment-finders */
          "./src/controller/fragment-finders.ts"
        ), g2 = r3(
          /*! ../utils/discontinuities */
          "./src/utils/discontinuities.ts"
        ), v2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        );
        function m2() {
          return m2 = Object.assign ? Object.assign.bind() : function(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var r4 = arguments[t4];
              for (var i4 in r4)
                Object.prototype.hasOwnProperty.call(r4, i4) && (e4[i4] = r4[i4]);
            }
            return e4;
          }, m2.apply(this, arguments);
        }
        function y2(e4, t4) {
          return y2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
            return e5.__proto__ = t5, e5;
          }, y2(e4, t4);
        }
        var A2 = function(e4) {
          var t4, r4;
          function A3(t5, r5) {
            var i4;
            return (i4 = e4.call(this, t5, r5, "[audio-stream-controller]") || this).videoBuffer = null, i4.videoTrackCC = -1, i4.waitingVideoCC = -1, i4.audioSwitch = false, i4.trackId = -1, i4.waitingData = null, i4.mainDetails = null, i4.bufferFlushed = false, i4.cachedTrackLoadedData = null, i4._registerListeners(), i4;
          }
          r4 = e4, (t4 = A3).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, y2(t4, r4);
          var E3 = A3.prototype;
          return E3.onHandlerDestroying = function() {
            this._unregisterListeners(), this.mainDetails = null;
          }, E3._registerListeners = function() {
            var e5 = this.hls;
            e5.on(a2.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e5.on(a2.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e5.on(a2.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.on(a2.Events.LEVEL_LOADED, this.onLevelLoaded, this), e5.on(a2.Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e5.on(a2.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e5.on(a2.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e5.on(a2.Events.ERROR, this.onError, this), e5.on(a2.Events.BUFFER_RESET, this.onBufferReset, this), e5.on(a2.Events.BUFFER_CREATED, this.onBufferCreated, this), e5.on(a2.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), e5.on(a2.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), e5.on(a2.Events.FRAG_BUFFERED, this.onFragBuffered, this);
          }, E3._unregisterListeners = function() {
            var e5 = this.hls;
            e5.off(a2.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e5.off(a2.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e5.off(a2.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.off(a2.Events.LEVEL_LOADED, this.onLevelLoaded, this), e5.off(a2.Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e5.off(a2.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e5.off(a2.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e5.off(a2.Events.ERROR, this.onError, this), e5.off(a2.Events.BUFFER_RESET, this.onBufferReset, this), e5.off(a2.Events.BUFFER_CREATED, this.onBufferCreated, this), e5.off(a2.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), e5.off(a2.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), e5.off(a2.Events.FRAG_BUFFERED, this.onFragBuffered, this);
          }, E3.onInitPtsFound = function(e5, t5) {
            var r5 = t5.frag, i4 = t5.id, a3 = t5.initPTS;
            if ("main" === i4) {
              var s3 = r5.cc;
              this.initPTS[r5.cc] = a3, this.log("InitPTS for cc: " + s3 + " found from main: " + a3), this.videoTrackCC = s3, this.state === n2.State.WAITING_INIT_PTS && this.tick();
            }
          }, E3.startLoad = function(e5) {
            if (!this.levels)
              return this.startPosition = e5, void (this.state = n2.State.STOPPED);
            var t5 = this.lastCurrentTime;
            this.stopLoad(), this.setInterval(100), this.fragLoadError = 0, t5 > 0 && -1 === e5 ? (this.log("Override startPosition with lastCurrentTime @" + t5.toFixed(3)), e5 = t5, this.state = n2.State.IDLE) : (this.loadedmetadata = false, this.state = n2.State.WAITING_TRACK), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e5, this.tick();
          }, E3.doTick = function() {
            switch (this.state) {
              case n2.State.IDLE:
                this.doTickIdle();
                break;
              case n2.State.WAITING_TRACK:
                var t5, r5 = this.levels, i4 = this.trackId, a3 = null == r5 || null === (t5 = r5[i4]) || void 0 === t5 ? void 0 : t5.details;
                if (a3) {
                  if (this.waitForCdnTuneIn(a3))
                    break;
                  this.state = n2.State.WAITING_INIT_PTS;
                }
                break;
              case n2.State.FRAG_LOADING_WAITING_RETRY:
                var o3, l3 = performance.now(), u3 = this.retryDate;
                (!u3 || l3 >= u3 || null !== (o3 = this.media) && void 0 !== o3 && o3.seeking) && (this.log("RetryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded(this.trackId), this.state = n2.State.IDLE);
                break;
              case n2.State.WAITING_INIT_PTS:
                var c3 = this.waitingData;
                if (c3) {
                  var d3 = c3.frag, h3 = c3.part, f3 = c3.cache, g3 = c3.complete;
                  if (void 0 !== this.initPTS[d3.cc]) {
                    this.waitingData = null, this.waitingVideoCC = -1, this.state = n2.State.FRAG_LOADING;
                    var v3 = { frag: d3, part: h3, payload: f3.flush(), networkDetails: null };
                    this._handleFragmentLoadProgress(v3), g3 && e4.prototype._handleFragmentLoadComplete.call(this, v3);
                  } else if (this.videoTrackCC !== this.waitingVideoCC)
                    this.log("Waiting fragment cc (" + d3.cc + ") cancelled because video is at cc " + this.videoTrackCC), this.clearWaitingFragment();
                  else {
                    var m3 = this.getLoadPosition(), y3 = s2.BufferHelper.bufferInfo(this.mediaBuffer, m3, this.config.maxBufferHole);
                    (0, p2.fragmentWithinToleranceTest)(y3.end, this.config.maxFragLookUpTolerance, d3) < 0 && (this.log("Waiting fragment cc (" + d3.cc + ") @ " + d3.start + " cancelled because another fragment at " + y3.end + " is needed"), this.clearWaitingFragment());
                  }
                } else
                  this.state = n2.State.IDLE;
            }
            this.onTickEnd();
          }, E3.clearWaitingFragment = function() {
            var e5 = this.waitingData;
            e5 && (this.fragmentTracker.removeFragment(e5.frag), this.waitingData = null, this.waitingVideoCC = -1, this.state = n2.State.IDLE);
          }, E3.resetLoadingState = function() {
            this.clearWaitingFragment(), e4.prototype.resetLoadingState.call(this);
          }, E3.onTickEnd = function() {
            var e5 = this.media;
            e5 && e5.readyState && (this.lastCurrentTime = e5.currentTime);
          }, E3.doTickIdle = function() {
            var e5, t5, r5 = this.hls, i4 = this.levels, s3 = this.media, o3 = this.trackId, l3 = r5.config;
            if (i4 && i4[o3] && (s3 || !this.startFragRequested && l3.startFragPrefetch)) {
              var d3 = i4[o3].details;
              if (!d3 || d3.live && this.levelLastLoaded !== o3 || this.waitForCdnTuneIn(d3))
                this.state = n2.State.WAITING_TRACK;
              else {
                var h3 = this.mediaBuffer ? this.mediaBuffer : this.media;
                this.bufferFlushed && h3 && (this.bufferFlushed = false, this.afterBufferFlushed(h3, c2.ElementaryStreamTypes.AUDIO, u2.PlaylistLevelType.AUDIO));
                var f3 = this.getFwdBufferInfo(h3, u2.PlaylistLevelType.AUDIO);
                if (null !== f3) {
                  var p3 = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, u2.PlaylistLevelType.MAIN), g3 = f3.len, v3 = this.getMaxBufferLength(null == p3 ? void 0 : p3.len), m3 = this.audioSwitch;
                  if (!(g3 >= v3) || m3) {
                    if (!m3 && this._streamEnded(f3, d3))
                      return r5.trigger(a2.Events.BUFFER_EOS, { type: "audio" }), void (this.state = n2.State.ENDED);
                    var y3 = d3.fragments[0].start, A4 = f3.end;
                    if (m3 && s3) {
                      var E4 = this.getLoadPosition();
                      A4 = E4, d3.PTSKnown && E4 < y3 && (f3.end > y3 || f3.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), s3.currentTime = y3 + 0.05);
                    }
                    if (!(p3 && A4 > p3.end + d3.targetduration) && (p3 && p3.len || !f3.len)) {
                      var T2 = this.getNextFragment(A4, d3);
                      T2 ? "identity" !== (null === (e5 = T2.decryptdata) || void 0 === e5 ? void 0 : e5.keyFormat) || null !== (t5 = T2.decryptdata) && void 0 !== t5 && t5.key ? this.loadFragment(T2, d3, A4) : this.loadKey(T2, d3) : this.bufferFlushed = true;
                    }
                  }
                }
              }
            }
          }, E3.getMaxBufferLength = function(t5) {
            var r5 = e4.prototype.getMaxBufferLength.call(this);
            return t5 ? Math.max(r5, t5) : r5;
          }, E3.onMediaDetaching = function() {
            this.videoBuffer = null, e4.prototype.onMediaDetaching.call(this);
          }, E3.onAudioTracksUpdated = function(e5, t5) {
            var r5 = t5.audioTracks;
            this.resetTransmuxer(), this.levels = r5.map(function(e6) {
              return new l2.Level(e6);
            });
          }, E3.onAudioTrackSwitching = function(e5, t5) {
            var r5 = !!t5.url;
            this.trackId = t5.id;
            var i4 = this.fragCurrent;
            null != i4 && i4.loader && i4.loader.abort(), this.fragCurrent = null, this.clearWaitingFragment(), r5 ? this.setInterval(100) : this.resetTransmuxer(), r5 ? (this.audioSwitch = true, this.state = n2.State.IDLE) : this.state = n2.State.STOPPED, this.tick();
          }, E3.onManifestLoading = function() {
            this.mainDetails = null, this.fragmentTracker.removeAllFragments(), this.startPosition = this.lastCurrentTime = 0, this.bufferFlushed = false;
          }, E3.onLevelLoaded = function(e5, t5) {
            this.mainDetails = t5.details, null !== this.cachedTrackLoadedData && (this.hls.trigger(a2.Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData), this.cachedTrackLoadedData = null);
          }, E3.onAudioTrackLoaded = function(e5, t5) {
            var r5;
            if (null != this.mainDetails) {
              var i4 = this.levels, a3 = t5.details, s3 = t5.id;
              if (i4) {
                this.log("Track " + s3 + " loaded [" + a3.startSN + "," + a3.endSN + "],duration:" + a3.totalduration);
                var o3 = i4[s3], l3 = 0;
                if (a3.live || null !== (r5 = o3.details) && void 0 !== r5 && r5.live) {
                  var u3 = this.mainDetails;
                  if (a3.fragments[0] || (a3.deltaUpdateFailed = true), a3.deltaUpdateFailed || !u3)
                    return;
                  !o3.details && a3.hasProgramDateTime && u3.hasProgramDateTime ? ((0, g2.alignMediaPlaylistByPDT)(a3, u3), l3 = a3.fragments[0].start) : l3 = this.alignPlaylists(a3, o3.details);
                }
                o3.details = a3, this.levelLastLoaded = s3, this.startFragRequested || !this.mainDetails && a3.live || this.setStartPosition(o3.details, l3), this.state !== n2.State.WAITING_TRACK || this.waitForCdnTuneIn(a3) || (this.state = n2.State.IDLE), this.tick();
              } else
                this.warn("Audio tracks were reset while loading level " + s3);
            } else
              this.cachedTrackLoadedData = t5;
          }, E3._handleFragmentLoadProgress = function(e5) {
            var t5, r5 = e5.frag, i4 = e5.part, a3 = e5.payload, s3 = this.config, o3 = this.trackId, l3 = this.levels;
            if (l3) {
              var c3 = l3[o3];
              console.assert(c3, "Audio track is defined on fragment load progress");
              var p3 = c3.details;
              console.assert(p3, "Audio track details are defined on fragment load progress");
              var g3 = s3.defaultAudioCodec || c3.audioCodec || "mp4a.40.2", v3 = this.transmuxer;
              v3 || (v3 = this.transmuxer = new h2.default(this.hls, u2.PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
              var m3 = this.initPTS[r5.cc], y3 = null === (t5 = r5.initSegment) || void 0 === t5 ? void 0 : t5.data;
              if (void 0 !== m3) {
                var A4 = i4 ? i4.index : -1, E4 = -1 !== A4, T2 = new f2.ChunkMetadata(r5.level, r5.sn, r5.stats.chunkCount, a3.byteLength, A4, E4);
                v3.push(a3, y3, g3, "", r5, i4, p3.totalduration, false, T2, m3);
              } else
                this.log("Unknown video PTS for cc " + r5.cc + ", waiting for video PTS before demuxing audio frag " + r5.sn + " of [" + p3.startSN + " ," + p3.endSN + "],track " + o3), (this.waitingData = this.waitingData || { frag: r5, part: i4, cache: new d2.default(), complete: false }).cache.push(new Uint8Array(a3)), this.waitingVideoCC = this.videoTrackCC, this.state = n2.State.WAITING_INIT_PTS;
            } else
              this.warn("Audio tracks were reset while fragment load was in progress. Fragment " + r5.sn + " of level " + r5.level + " will not be buffered");
          }, E3._handleFragmentLoadComplete = function(t5) {
            this.waitingData ? this.waitingData.complete = true : e4.prototype._handleFragmentLoadComplete.call(this, t5);
          }, E3.onBufferReset = function() {
            this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = false;
          }, E3.onBufferCreated = function(e5, t5) {
            var r5 = t5.tracks.audio;
            r5 && (this.mediaBuffer = r5.buffer || null), t5.tracks.video && (this.videoBuffer = t5.tracks.video.buffer || null);
          }, E3.onFragBuffered = function(e5, t5) {
            var r5, i4 = t5.frag, n3 = t5.part;
            i4.type === u2.PlaylistLevelType.AUDIO ? this.fragContextChanged(i4) ? this.warn("Fragment " + i4.sn + (n3 ? " p: " + n3.index : "") + " of level " + i4.level + " finished buffering, but was aborted. state: " + this.state + ", audioSwitch: " + this.audioSwitch) : ("initSegment" !== i4.sn && (this.fragPrevious = i4, this.audioSwitch && (this.audioSwitch = false, this.hls.trigger(a2.Events.AUDIO_TRACK_SWITCHED, { id: this.trackId }))), this.fragBufferedComplete(i4, n3)) : this.loadedmetadata || i4.type !== u2.PlaylistLevelType.MAIN || null !== (r5 = this.videoBuffer || this.media) && void 0 !== r5 && r5.buffered.length && (this.loadedmetadata = true);
          }, E3.onError = function(t5, r5) {
            switch (r5.details) {
              case v2.ErrorDetails.FRAG_LOAD_ERROR:
              case v2.ErrorDetails.FRAG_LOAD_TIMEOUT:
              case v2.ErrorDetails.KEY_LOAD_ERROR:
              case v2.ErrorDetails.KEY_LOAD_TIMEOUT:
                this.onFragmentOrKeyLoadError(u2.PlaylistLevelType.AUDIO, r5);
                break;
              case v2.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
              case v2.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
                this.state !== n2.State.ERROR && this.state !== n2.State.STOPPED && (this.state = r5.fatal ? n2.State.ERROR : n2.State.IDLE, this.warn(r5.details + " while loading frag, switching to " + this.state + " state"));
                break;
              case v2.ErrorDetails.BUFFER_FULL_ERROR:
                if ("audio" === r5.parent && (this.state === n2.State.PARSING || this.state === n2.State.PARSED)) {
                  var i4 = true, a3 = this.getFwdBufferInfo(this.mediaBuffer, u2.PlaylistLevelType.AUDIO);
                  a3 && a3.len > 0.5 && (i4 = !this.reduceMaxBufferLength(a3.len)), i4 && (this.warn("Buffer full error also media.currentTime is not buffered, flush audio buffer"), this.fragCurrent = null, e4.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio")), this.resetLoadingState();
                }
            }
          }, E3.onBufferFlushed = function(e5, t5) {
            t5.type === c2.ElementaryStreamTypes.AUDIO && (this.bufferFlushed = true);
          }, E3._handleTransmuxComplete = function(e5) {
            var t5, r5 = "audio", i4 = this.hls, s3 = e5.remuxResult, o3 = e5.chunkMeta, l3 = this.getCurrentContext(o3);
            if (!l3)
              return this.warn("The loading context changed while buffering fragment " + o3.sn + " of level " + o3.level + ". This chunk will not be buffered."), void this.resetStartWhenNotLoaded(o3.level);
            var u3 = l3.frag, d3 = l3.part, h3 = l3.level.details, f3 = s3.audio, p3 = s3.text, g3 = s3.id3, v3 = s3.initSegment;
            if (!this.fragContextChanged(u3) && h3) {
              if (this.state = n2.State.PARSING, this.audioSwitch && f3 && this.completeAudioSwitch(), null != v3 && v3.tracks && (this._bufferInitSegment(v3.tracks, u3, o3), i4.trigger(a2.Events.FRAG_PARSING_INIT_SEGMENT, { frag: u3, id: r5, tracks: v3.tracks })), f3) {
                var y3 = f3.startPTS, A4 = f3.endPTS, E4 = f3.startDTS, T2 = f3.endDTS;
                d3 && (d3.elementaryStreams[c2.ElementaryStreamTypes.AUDIO] = { startPTS: y3, endPTS: A4, startDTS: E4, endDTS: T2 }), u3.setElementaryStreamInfo(c2.ElementaryStreamTypes.AUDIO, y3, A4, E4, T2), this.bufferFragmentData(f3, u3, d3, o3);
              }
              if (null != g3 && null !== (t5 = g3.samples) && void 0 !== t5 && t5.length) {
                var b2 = m2({ id: r5, frag: u3, details: h3 }, g3);
                i4.trigger(a2.Events.FRAG_PARSING_METADATA, b2);
              }
              if (p3) {
                var k2 = m2({ id: r5, frag: u3, details: h3 }, p3);
                i4.trigger(a2.Events.FRAG_PARSING_USERDATA, k2);
              }
            }
          }, E3._bufferInitSegment = function(e5, t5, r5) {
            if (this.state === n2.State.PARSING) {
              e5.video && delete e5.video;
              var i4 = e5.audio;
              if (i4) {
                i4.levelCodec = i4.codec, i4.id = "audio", this.log("Init audio buffer, container:" + i4.container + ", codecs[parsed]=[" + i4.codec + "]"), this.hls.trigger(a2.Events.BUFFER_CODECS, e5);
                var s3 = i4.initSegment;
                if (null != s3 && s3.byteLength) {
                  var o3 = { type: "audio", frag: t5, part: null, chunkMeta: r5, parent: t5.type, data: s3 };
                  this.hls.trigger(a2.Events.BUFFER_APPENDING, o3);
                }
                this.tick();
              }
            }
          }, E3.loadFragment = function(t5, r5, a3) {
            var s3 = this.fragmentTracker.getState(t5);
            this.fragCurrent = t5, (this.audioSwitch || s3 === o2.FragmentState.NOT_LOADED || s3 === o2.FragmentState.PARTIAL) && ("initSegment" === t5.sn ? this._loadInitSegment(t5) : r5.live && !(0, i3.isFiniteNumber)(this.initPTS[t5.cc]) ? (this.log("Waiting for video PTS in continuity counter " + t5.cc + " of live stream before loading audio fragment " + t5.sn + " of level " + this.trackId), this.state = n2.State.WAITING_INIT_PTS) : (this.startFragRequested = true, e4.prototype.loadFragment.call(this, t5, r5, a3)));
          }, E3.completeAudioSwitch = function() {
            var t5 = this.hls, r5 = this.media, i4 = this.trackId;
            r5 && (this.log("Switching audio track : flushing all audio"), e4.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio")), this.audioSwitch = false, t5.trigger(a2.Events.AUDIO_TRACK_SWITCHED, { id: i4 });
          }, A3;
        }(n2.default);
        const E2 = A2;
      }
    ), "./src/controller/audio-track-controller.ts": (
      /*!**************************************************!*\
          !*** ./src/controller/audio-track-controller.ts ***!
          \**************************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => c2 });
        var i3 = r3(
          /*! ../events */
          "./src/events.ts"
        ), n2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), a2 = r3(
          /*! ./base-playlist-controller */
          "./src/controller/base-playlist-controller.ts"
        ), s2 = r3(
          /*! ../types/loader */
          "./src/types/loader.ts"
        );
        function o2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        function l2(e4, t4) {
          return l2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
            return e5.__proto__ = t5, e5;
          }, l2(e4, t4);
        }
        var u2 = function(e4) {
          var t4, r4;
          function a3(t5) {
            var r5;
            return (r5 = e4.call(this, t5, "[audio-track-controller]") || this).tracks = [], r5.groupId = null, r5.tracksInGroup = [], r5.trackId = -1, r5.trackName = "", r5.selectDefaultTrack = true, r5.registerListeners(), r5;
          }
          r4 = e4, (t4 = a3).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, l2(t4, r4);
          var u3, c3, d2, h2 = a3.prototype;
          return h2.registerListeners = function() {
            var e5 = this.hls;
            e5.on(i3.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.on(i3.Events.MANIFEST_PARSED, this.onManifestParsed, this), e5.on(i3.Events.LEVEL_LOADING, this.onLevelLoading, this), e5.on(i3.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), e5.on(i3.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e5.on(i3.Events.ERROR, this.onError, this);
          }, h2.unregisterListeners = function() {
            var e5 = this.hls;
            e5.off(i3.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.off(i3.Events.MANIFEST_PARSED, this.onManifestParsed, this), e5.off(i3.Events.LEVEL_LOADING, this.onLevelLoading, this), e5.off(i3.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), e5.off(i3.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e5.off(i3.Events.ERROR, this.onError, this);
          }, h2.destroy = function() {
            this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, e4.prototype.destroy.call(this);
          }, h2.onManifestLoading = function() {
            this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.trackName = "", this.selectDefaultTrack = true;
          }, h2.onManifestParsed = function(e5, t5) {
            this.tracks = t5.audioTracks || [];
          }, h2.onAudioTrackLoaded = function(e5, t5) {
            var r5 = t5.id, i4 = t5.details, n3 = this.tracksInGroup[r5];
            if (n3) {
              var a4 = n3.details;
              n3.details = t5.details, this.log("audioTrack " + r5 + " loaded [" + i4.startSN + "-" + i4.endSN + "]"), r5 === this.trackId && (this.retryCount = 0, this.playlistLoaded(r5, t5, a4));
            } else
              this.warn("Invalid audio track id " + r5);
          }, h2.onLevelLoading = function(e5, t5) {
            this.switchLevel(t5.level);
          }, h2.onLevelSwitching = function(e5, t5) {
            this.switchLevel(t5.level);
          }, h2.switchLevel = function(e5) {
            var t5 = this.hls.levels[e5];
            if (null != t5 && t5.audioGroupIds) {
              var r5 = t5.audioGroupIds[t5.urlId];
              if (this.groupId !== r5) {
                this.groupId = r5;
                var n3 = this.tracks.filter(function(e6) {
                  return !r5 || e6.groupId === r5;
                });
                this.selectDefaultTrack && !n3.some(function(e6) {
                  return e6.default;
                }) && (this.selectDefaultTrack = false), this.tracksInGroup = n3;
                var a4 = { audioTracks: n3 };
                this.log("Updating audio tracks, " + n3.length + ' track(s) found in "' + r5 + '" group-id'), this.hls.trigger(i3.Events.AUDIO_TRACKS_UPDATED, a4), this.selectInitialTrack();
              }
            }
          }, h2.onError = function(t5, r5) {
            e4.prototype.onError.call(this, t5, r5), !r5.fatal && r5.context && r5.context.type === s2.PlaylistContextType.AUDIO_TRACK && r5.context.id === this.trackId && r5.context.groupId === this.groupId && this.retryLoadingOrFail(r5);
          }, h2.setAudioTrack = function(e5) {
            var t5 = this.tracksInGroup;
            if (e5 < 0 || e5 >= t5.length)
              this.warn("Invalid id passed to audio-track controller");
            else {
              this.clearTimer();
              var r5 = t5[this.trackId];
              this.log("Now switching to audio-track index " + e5);
              var n3 = t5[e5], a4 = n3.id, s3 = n3.groupId, o3 = void 0 === s3 ? "" : s3, l3 = n3.name, u4 = n3.type, c4 = n3.url;
              if (this.trackId = e5, this.trackName = l3, this.selectDefaultTrack = false, this.hls.trigger(i3.Events.AUDIO_TRACK_SWITCHING, { id: a4, groupId: o3, name: l3, type: u4, url: c4 }), !n3.details || n3.details.live) {
                var d3 = this.switchParams(n3.url, null == r5 ? void 0 : r5.details);
                this.loadPlaylist(d3);
              }
            }
          }, h2.selectInitialTrack = function() {
            var e5 = this.tracksInGroup;
            console.assert(e5.length, "Initial audio track should be selected when tracks are known");
            var t5 = this.trackName, r5 = this.findTrackId(t5) || this.findTrackId();
            -1 !== r5 ? this.setAudioTrack(r5) : (this.warn("No track found for running audio group-ID: " + this.groupId), this.hls.trigger(i3.Events.ERROR, { type: n2.ErrorTypes.MEDIA_ERROR, details: n2.ErrorDetails.AUDIO_TRACK_LOAD_ERROR, fatal: true }));
          }, h2.findTrackId = function(e5) {
            for (var t5 = this.tracksInGroup, r5 = 0; r5 < t5.length; r5++) {
              var i4 = t5[r5];
              if ((!this.selectDefaultTrack || i4.default) && (!e5 || e5 === i4.name))
                return i4.id;
            }
            return -1;
          }, h2.loadPlaylist = function(e5) {
            var t5 = this.tracksInGroup[this.trackId];
            if (this.shouldLoadTrack(t5)) {
              var r5 = t5.id, n3 = t5.groupId, a4 = t5.url;
              if (e5)
                try {
                  a4 = e5.addDirectives(a4);
                } catch (e6) {
                  this.warn("Could not construct new URL with HLS Delivery Directives: " + e6);
                }
              this.log("loading audio-track playlist for id: " + r5), this.clearTimer(), this.hls.trigger(i3.Events.AUDIO_TRACK_LOADING, { url: a4, id: r5, groupId: n3, deliveryDirectives: e5 || null });
            }
          }, u3 = a3, (c3 = [{ key: "audioTracks", get: function() {
            return this.tracksInGroup;
          } }, { key: "audioTrack", get: function() {
            return this.trackId;
          }, set: function(e5) {
            this.selectDefaultTrack = false, this.setAudioTrack(e5);
          } }]) && o2(u3.prototype, c3), d2 && o2(u3, d2), Object.defineProperty(u3, "prototype", { writable: false }), a3;
        }(a2.default);
        const c2 = u2;
      }
    ), "./src/controller/base-playlist-controller.ts": (
      /*!****************************************************!*\
          !*** ./src/controller/base-playlist-controller.ts ***!
          \****************************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => l2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ../types/level */
          "./src/types/level.ts"
        ), a2 = r3(
          /*! ./level-helper */
          "./src/controller/level-helper.ts"
        ), s2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), o2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), l2 = function() {
          function e4(e5, t5) {
            this.hls = void 0, this.timer = -1, this.canLoad = false, this.retryCount = 0, this.log = void 0, this.warn = void 0, this.log = s2.logger.log.bind(s2.logger, t5 + ":"), this.warn = s2.logger.warn.bind(s2.logger, t5 + ":"), this.hls = e5;
          }
          var t4 = e4.prototype;
          return t4.destroy = function() {
            this.clearTimer(), this.hls = this.log = this.warn = null;
          }, t4.onError = function(e5, t5) {
            t5.fatal && t5.type === o2.ErrorTypes.NETWORK_ERROR && this.clearTimer();
          }, t4.clearTimer = function() {
            clearTimeout(this.timer), this.timer = -1;
          }, t4.startLoad = function() {
            this.canLoad = true, this.retryCount = 0, this.loadPlaylist();
          }, t4.stopLoad = function() {
            this.canLoad = false, this.clearTimer();
          }, t4.switchParams = function(e5, t5) {
            var r4 = null == t5 ? void 0 : t5.renditionReports;
            if (r4)
              for (var a3 = 0; a3 < r4.length; a3++) {
                var s3 = r4[a3], o3 = "" + s3.URI;
                if (o3 === e5.slice(-o3.length)) {
                  var l3 = parseInt(s3["LAST-MSN"]), u2 = parseInt(s3["LAST-PART"]);
                  if (t5 && this.hls.config.lowLatencyMode) {
                    var c2 = Math.min(t5.age - t5.partTarget, t5.targetduration);
                    void 0 !== u2 && c2 > t5.partTarget && (u2 += 1);
                  }
                  if ((0, i3.isFiniteNumber)(l3))
                    return new n2.HlsUrlParameters(l3, (0, i3.isFiniteNumber)(u2) ? u2 : void 0, n2.HlsSkip.No);
                }
              }
          }, t4.loadPlaylist = function(e5) {
          }, t4.shouldLoadTrack = function(e5) {
            return this.canLoad && e5 && !!e5.url && (!e5.details || e5.details.live);
          }, t4.playlistLoaded = function(e5, t5, r4) {
            var i4 = this, n3 = t5.details, s3 = t5.stats, o3 = s3.loading.end ? Math.max(0, self.performance.now() - s3.loading.end) : 0;
            if (n3.advancedDateTime = Date.now() - o3, n3.live || null != r4 && r4.live) {
              if (n3.reloaded(r4), r4 && this.log("live playlist " + e5 + " " + (n3.advanced ? "REFRESHED " + n3.lastPartSn + "-" + n3.lastPartIndex : "MISSED")), r4 && n3.fragments.length > 0 && (0, a2.mergeDetails)(r4, n3), !this.canLoad || !n3.live)
                return;
              var l3, u2 = void 0, c2 = void 0;
              if (n3.canBlockReload && n3.endSN && n3.advanced) {
                var d2 = this.hls.config.lowLatencyMode, h2 = n3.lastPartSn, f2 = n3.endSN, p2 = n3.lastPartIndex, g2 = h2 === f2;
                -1 !== p2 ? (u2 = g2 ? f2 + 1 : h2, c2 = g2 ? d2 ? 0 : p2 : p2 + 1) : u2 = f2 + 1;
                var v2 = n3.age, m2 = v2 + n3.ageHeader, y2 = Math.min(m2 - n3.partTarget, 1.5 * n3.targetduration);
                if (y2 > 0) {
                  if (r4 && y2 > r4.tuneInGoal)
                    this.warn("CDN Tune-in goal increased from: " + r4.tuneInGoal + " to: " + y2 + " with playlist age: " + n3.age), y2 = 0;
                  else {
                    var A2 = Math.floor(y2 / n3.targetduration);
                    u2 += A2, void 0 !== c2 && (c2 += Math.round(y2 % n3.targetduration / n3.partTarget)), this.log("CDN Tune-in age: " + n3.ageHeader + "s last advanced " + v2.toFixed(2) + "s goal: " + y2 + " skip sn " + A2 + " to part " + c2);
                  }
                  n3.tuneInGoal = y2;
                }
                if (l3 = this.getDeliveryDirectives(n3, t5.deliveryDirectives, u2, c2), d2 || !g2)
                  return void this.loadPlaylist(l3);
              } else
                l3 = this.getDeliveryDirectives(n3, t5.deliveryDirectives, u2, c2);
              var E2 = (0, a2.computeReloadInterval)(n3, s3);
              void 0 !== u2 && n3.canBlockReload && (E2 -= n3.partTarget || 1), this.log("reload live playlist " + e5 + " in " + Math.round(E2) + " ms"), this.timer = self.setTimeout(function() {
                return i4.loadPlaylist(l3);
              }, E2);
            } else
              this.clearTimer();
          }, t4.getDeliveryDirectives = function(e5, t5, r4, i4) {
            var a3 = (0, n2.getSkipValue)(e5, r4);
            return null != t5 && t5.skip && e5.deltaUpdateFailed && (r4 = t5.msn, i4 = t5.part, a3 = n2.HlsSkip.No), new n2.HlsUrlParameters(r4, i4, a3);
          }, t4.retryLoadingOrFail = function(e5) {
            var t5, r4 = this, i4 = this.hls.config, n3 = this.retryCount < i4.levelLoadingMaxRetry;
            if (n3)
              if (this.retryCount++, e5.details.indexOf("LoadTimeOut") > -1 && null !== (t5 = e5.context) && void 0 !== t5 && t5.deliveryDirectives)
                this.warn("retry playlist loading #" + this.retryCount + ' after "' + e5.details + '"'), this.loadPlaylist();
              else {
                var a3 = Math.min(Math.pow(2, this.retryCount) * i4.levelLoadingRetryDelay, i4.levelLoadingMaxRetryTimeout);
                this.timer = self.setTimeout(function() {
                  return r4.loadPlaylist();
                }, a3), this.warn("retry playlist loading #" + this.retryCount + " in " + a3 + ' ms after "' + e5.details + '"');
              }
            else
              this.warn('cannot recover from error "' + e5.details + '"'), this.clearTimer(), e5.fatal = true;
            return n3;
          }, e4;
        }();
      }
    ), "./src/controller/base-stream-controller.ts": (
      /*!**************************************************!*\
          !*** ./src/controller/base-stream-controller.ts ***!
          \**************************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { State: () => b2, default: () => k2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ../task-loop */
          "./src/task-loop.ts"
        ), a2 = r3(
          /*! ./fragment-tracker */
          "./src/controller/fragment-tracker.ts"
        ), s2 = r3(
          /*! ../utils/buffer-helper */
          "./src/utils/buffer-helper.ts"
        ), o2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), l2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), u2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), c2 = r3(
          /*! ../types/transmuxer */
          "./src/types/transmuxer.ts"
        ), d2 = r3(
          /*! ../utils/mp4-tools */
          "./src/utils/mp4-tools.ts"
        ), h2 = r3(
          /*! ../utils/discontinuities */
          "./src/utils/discontinuities.ts"
        ), f2 = r3(
          /*! ./fragment-finders */
          "./src/controller/fragment-finders.ts"
        ), p2 = r3(
          /*! ./level-helper */
          "./src/controller/level-helper.ts"
        ), g2 = r3(
          /*! ../loader/fragment-loader */
          "./src/loader/fragment-loader.ts"
        ), v2 = r3(
          /*! ../crypt/decrypter */
          "./src/crypt/decrypter.ts"
        ), m2 = r3(
          /*! ../utils/time-ranges */
          "./src/utils/time-ranges.ts"
        ), y2 = r3(
          /*! ../types/loader */
          "./src/types/loader.ts"
        );
        function A2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        function E2(e4) {
          if (void 0 === e4)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e4;
        }
        function T2(e4, t4) {
          return T2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
            return e5.__proto__ = t5, e5;
          }, T2(e4, t4);
        }
        var b2 = { STOPPED: "STOPPED", IDLE: "IDLE", KEY_LOADING: "KEY_LOADING", FRAG_LOADING: "FRAG_LOADING", FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY", WAITING_TRACK: "WAITING_TRACK", PARSING: "PARSING", PARSED: "PARSED", ENDED: "ENDED", ERROR: "ERROR", WAITING_INIT_PTS: "WAITING_INIT_PTS", WAITING_LEVEL: "WAITING_LEVEL" }, k2 = function(e4) {
          var t4, r4;
          function n3(t5, r5, i4) {
            var n4;
            return (n4 = e4.call(this) || this).hls = void 0, n4.fragPrevious = null, n4.fragCurrent = null, n4.fragmentTracker = void 0, n4.transmuxer = null, n4._state = b2.STOPPED, n4.media = null, n4.mediaBuffer = null, n4.config = void 0, n4.bitrateTest = false, n4.lastCurrentTime = 0, n4.nextLoadPosition = 0, n4.startPosition = 0, n4.loadedmetadata = false, n4.fragLoadError = 0, n4.retryDate = 0, n4.levels = null, n4.fragmentLoader = void 0, n4.levelLastLoaded = null, n4.startFragRequested = false, n4.decrypter = void 0, n4.initPTS = [], n4.onvseeking = null, n4.onvended = null, n4.logPrefix = "", n4.log = void 0, n4.warn = void 0, n4.logPrefix = i4, n4.log = o2.logger.log.bind(o2.logger, i4 + ":"), n4.warn = o2.logger.warn.bind(o2.logger, i4 + ":"), n4.hls = t5, n4.fragmentLoader = new g2.default(t5.config), n4.fragmentTracker = r5, n4.config = t5.config, n4.decrypter = new v2.default(t5, t5.config), t5.on(l2.Events.KEY_LOADED, n4.onKeyLoaded, E2(n4)), t5.on(l2.Events.LEVEL_SWITCHING, n4.onLevelSwitching, E2(n4)), n4;
          }
          r4 = e4, (t4 = n3).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, T2(t4, r4);
          var k3, S2, _2, C2 = n3.prototype;
          return C2.doTick = function() {
            this.onTickEnd();
          }, C2.onTickEnd = function() {
          }, C2.startLoad = function(e5) {
          }, C2.stopLoad = function() {
            this.fragmentLoader.abort();
            var e5 = this.fragCurrent;
            e5 && this.fragmentTracker.removeFragment(e5), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = b2.STOPPED;
          }, C2._streamEnded = function(e5, t5) {
            var r5 = this.fragCurrent, i4 = this.fragmentTracker;
            if (!t5.live && r5 && this.media && r5.sn >= t5.endSN && !e5.nextStart) {
              var n4 = t5.partList;
              if (null != n4 && n4.length) {
                var o3 = n4[n4.length - 1];
                return s2.BufferHelper.isBuffered(this.media, o3.start + o3.duration / 2);
              }
              var l3 = i4.getState(r5);
              return l3 === a2.FragmentState.PARTIAL || l3 === a2.FragmentState.OK;
            }
            return false;
          }, C2.onMediaAttached = function(e5, t5) {
            var r5 = this.media = this.mediaBuffer = t5.media;
            this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), r5.addEventListener("seeking", this.onvseeking), r5.addEventListener("ended", this.onvended);
            var i4 = this.config;
            this.levels && i4.autoStartLoad && this.state === b2.STOPPED && this.startLoad(i4.startPosition);
          }, C2.onMediaDetaching = function() {
            var e5 = this.media;
            null != e5 && e5.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), e5 && this.onvseeking && this.onvended && (e5.removeEventListener("seeking", this.onvseeking), e5.removeEventListener("ended", this.onvended), this.onvseeking = this.onvended = null), this.media = this.mediaBuffer = null, this.loadedmetadata = false, this.fragmentTracker.removeAllFragments(), this.stopLoad();
          }, C2.onMediaSeeking = function() {
            var e5 = this.config, t5 = this.fragCurrent, r5 = this.media, n4 = this.mediaBuffer, a3 = this.state, o3 = r5 ? r5.currentTime : 0, l3 = s2.BufferHelper.bufferInfo(n4 || r5, o3, e5.maxBufferHole);
            if (this.log("media seeking to " + ((0, i3.isFiniteNumber)(o3) ? o3.toFixed(3) : o3) + ", state: " + a3), a3 === b2.ENDED)
              this.resetLoadingState();
            else if (t5) {
              var u3 = e5.maxFragLookUpTolerance, c3 = t5.start - u3, d3 = t5.start + t5.duration + u3;
              if (!l3.len || d3 < l3.start || c3 > l3.end) {
                var h3 = o3 > d3;
                (o3 < c3 || h3) && (h3 && t5.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), t5.loader.abort()), this.resetLoadingState());
              }
            }
            r5 && (this.lastCurrentTime = o3), this.loadedmetadata || l3.len || (this.nextLoadPosition = this.startPosition = o3), this.tickImmediate();
          }, C2.onMediaEnded = function() {
            this.startPosition = this.lastCurrentTime = 0;
          }, C2.onKeyLoaded = function(e5, t5) {
            if (this.state === b2.KEY_LOADING && t5.frag === this.fragCurrent && this.levels) {
              this.state = b2.IDLE;
              var r5 = this.levels[t5.frag.level].details;
              r5 && this.loadFragment(t5.frag, r5, t5.frag.start);
            }
          }, C2.onLevelSwitching = function(e5, t5) {
            this.fragLoadError = 0;
          }, C2.onHandlerDestroying = function() {
            this.stopLoad(), e4.prototype.onHandlerDestroying.call(this);
          }, C2.onHandlerDestroyed = function() {
            this.state = b2.STOPPED, this.hls.off(l2.Events.KEY_LOADED, this.onKeyLoaded, this), this.hls.off(l2.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), this.fragmentLoader && this.fragmentLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.fragmentLoader = this.fragmentTracker = null, e4.prototype.onHandlerDestroyed.call(this);
          }, C2.loadKey = function(e5, t5) {
            this.log("Loading key for " + e5.sn + " of [" + t5.startSN + "-" + t5.endSN + "], " + ("[stream-controller]" === this.logPrefix ? "level" : "track") + " " + e5.level), this.state = b2.KEY_LOADING, this.fragCurrent = e5, this.hls.trigger(l2.Events.KEY_LOADING, { frag: e5 });
          }, C2.loadFragment = function(e5, t5, r5) {
            this._loadFragForPlayback(e5, t5, r5);
          }, C2._loadFragForPlayback = function(e5, t5, r5) {
            var i4 = this;
            this._doFragLoad(e5, t5, r5, function(t6) {
              if (i4.fragContextChanged(e5))
                return i4.warn("Fragment " + e5.sn + (t6.part ? " p: " + t6.part.index : "") + " of level " + e5.level + " was dropped during download."), void i4.fragmentTracker.removeFragment(e5);
              e5.stats.chunkCount++, i4._handleFragmentLoadProgress(t6);
            }).then(function(t6) {
              if (t6) {
                i4.fragLoadError = 0;
                var r6 = i4.state;
                i4.fragContextChanged(e5) ? (r6 === b2.FRAG_LOADING || !i4.fragCurrent && r6 === b2.PARSING) && (i4.fragmentTracker.removeFragment(e5), i4.state = b2.IDLE) : ("payload" in t6 && (i4.log("Loaded fragment " + e5.sn + " of level " + e5.level), i4.hls.trigger(l2.Events.FRAG_LOADED, t6)), i4._handleFragmentLoadComplete(t6));
              }
            }).catch(function(t6) {
              i4.state !== b2.STOPPED && i4.state !== b2.ERROR && (i4.warn(t6), i4.resetFragmentLoading(e5));
            });
          }, C2.flushMainBuffer = function(e5, t5, r5) {
            if (void 0 === r5 && (r5 = null), e5 - t5) {
              var i4 = { startOffset: e5, endOffset: t5, type: r5 };
              this.fragLoadError = 0, this.hls.trigger(l2.Events.BUFFER_FLUSHING, i4);
            }
          }, C2._loadInitSegment = function(e5) {
            var t5 = this;
            this._doFragLoad(e5).then(function(r5) {
              if (!r5 || t5.fragContextChanged(e5) || !t5.levels)
                throw new Error("init load aborted");
              return r5;
            }).then(function(r5) {
              var i4 = t5.hls, n4 = r5.payload, a3 = e5.decryptdata;
              if (n4 && n4.byteLength > 0 && a3 && a3.key && a3.iv && "AES-128" === a3.method) {
                var s3 = self.performance.now();
                return t5.decrypter.webCryptoDecrypt(new Uint8Array(n4), a3.key.buffer, a3.iv.buffer).then(function(t6) {
                  var n5 = self.performance.now();
                  return i4.trigger(l2.Events.FRAG_DECRYPTED, { frag: e5, payload: t6, stats: { tstart: s3, tdecrypt: n5 } }), r5.payload = t6, r5;
                });
              }
              return r5;
            }).then(function(r5) {
              var i4 = t5.fragCurrent, n4 = t5.hls, a3 = t5.levels;
              if (!a3)
                throw new Error("init load aborted, missing levels");
              var s3 = a3[e5.level].details;
              console.assert(s3, "Level details are defined when init segment is loaded");
              var o3 = e5.stats;
              t5.state = b2.IDLE, t5.fragLoadError = 0, e5.data = new Uint8Array(r5.payload), o3.parsing.start = o3.buffering.start = self.performance.now(), o3.parsing.end = o3.buffering.end = self.performance.now(), r5.frag === i4 && n4.trigger(l2.Events.FRAG_BUFFERED, { stats: o3, frag: i4, part: null, id: e5.type }), t5.tick();
            }).catch(function(r5) {
              t5.state !== b2.STOPPED && t5.state !== b2.ERROR && (t5.warn(r5), t5.resetFragmentLoading(e5));
            });
          }, C2.fragContextChanged = function(e5) {
            var t5 = this.fragCurrent;
            return !e5 || !t5 || e5.level !== t5.level || e5.sn !== t5.sn || e5.urlId !== t5.urlId;
          }, C2.fragBufferedComplete = function(e5, t5) {
            var r5, i4, n4 = this.mediaBuffer ? this.mediaBuffer : this.media;
            this.log("Buffered " + e5.type + " sn: " + e5.sn + (t5 ? " part: " + t5.index : "") + " of " + ("[stream-controller]" === this.logPrefix ? "level" : "track") + " " + e5.level + " " + (n4 ? m2.default.toString(s2.BufferHelper.getBuffered(n4)) : "(detached)")), this.state = b2.IDLE, n4 && (!this.loadedmetadata && e5.type == y2.PlaylistLevelType.MAIN && n4.buffered.length && (null === (r5 = this.fragCurrent) || void 0 === r5 ? void 0 : r5.sn) === (null === (i4 = this.fragPrevious) || void 0 === i4 ? void 0 : i4.sn) && (this.loadedmetadata = true, this.seekToStartPos()), this.tick());
          }, C2.seekToStartPos = function() {
          }, C2._handleFragmentLoadComplete = function(e5) {
            var t5 = this.transmuxer;
            if (t5) {
              var r5 = e5.frag, i4 = e5.part, n4 = e5.partsLoaded, a3 = !n4 || 0 === n4.length || n4.some(function(e6) {
                return !e6;
              }), s3 = new c2.ChunkMetadata(r5.level, r5.sn, r5.stats.chunkCount + 1, 0, i4 ? i4.index : -1, !a3);
              t5.flush(s3);
            }
          }, C2._handleFragmentLoadProgress = function(e5) {
          }, C2._doFragLoad = function(e5, t5, r5, n4) {
            var a3 = this;
            if (void 0 === r5 && (r5 = null), !this.levels)
              throw new Error("frag load aborted, missing levels");
            if (r5 = Math.max(e5.start, r5 || 0), this.config.lowLatencyMode && t5) {
              var s3 = t5.partList;
              if (s3 && n4) {
                r5 > e5.end && t5.fragmentHint && (e5 = t5.fragmentHint);
                var o3 = this.getNextPart(s3, e5, r5);
                if (o3 > -1) {
                  var u3 = s3[o3];
                  return this.log("Loading part sn: " + e5.sn + " p: " + u3.index + " cc: " + e5.cc + " of playlist [" + t5.startSN + "-" + t5.endSN + "] parts [0-" + o3 + "-" + (s3.length - 1) + "] " + ("[stream-controller]" === this.logPrefix ? "level" : "track") + ": " + e5.level + ", target: " + parseFloat(r5.toFixed(3))), this.nextLoadPosition = u3.start + u3.duration, this.state = b2.FRAG_LOADING, this.hls.trigger(l2.Events.FRAG_LOADING, { frag: e5, part: s3[o3], targetBufferTime: r5 }), this.doFragPartsLoad(e5, s3, o3, n4).catch(function(e6) {
                    return a3.handleFragLoadError(e6);
                  });
                }
                if (!e5.url || this.loadedEndOfParts(s3, r5))
                  return Promise.resolve(null);
              }
            }
            return this.log("Loading fragment " + e5.sn + " cc: " + e5.cc + " " + (t5 ? "of [" + t5.startSN + "-" + t5.endSN + "] " : "") + ("[stream-controller]" === this.logPrefix ? "level" : "track") + ": " + e5.level + ", target: " + parseFloat(r5.toFixed(3))), (0, i3.isFiniteNumber)(e5.sn) && !this.bitrateTest && (this.nextLoadPosition = e5.start + e5.duration), this.state = b2.FRAG_LOADING, this.hls.trigger(l2.Events.FRAG_LOADING, { frag: e5, targetBufferTime: r5 }), this.fragmentLoader.load(e5, n4).catch(function(e6) {
              return a3.handleFragLoadError(e6);
            });
          }, C2.doFragPartsLoad = function(e5, t5, r5, i4) {
            var n4 = this;
            return new Promise(function(a3, s3) {
              var o3 = [];
              !function r6(u3) {
                var c3 = t5[u3];
                n4.fragmentLoader.loadPart(e5, c3, i4).then(function(i5) {
                  o3[c3.index] = i5;
                  var s4 = i5.part;
                  n4.hls.trigger(l2.Events.FRAG_LOADED, i5);
                  var d3 = t5[u3 + 1];
                  if (!d3 || d3.fragment !== e5)
                    return a3({ frag: e5, part: s4, partsLoaded: o3 });
                  r6(u3 + 1);
                }).catch(s3);
              }(r5);
            });
          }, C2.handleFragLoadError = function(e5) {
            var t5 = e5.data;
            return t5 && t5.details === u2.ErrorDetails.INTERNAL_ABORTED ? this.handleFragLoadAborted(t5.frag, t5.part) : this.hls.trigger(l2.Events.ERROR, t5), null;
          }, C2._handleTransmuxerFlush = function(e5) {
            var t5 = this.getCurrentContext(e5);
            if (t5 && this.state === b2.PARSING) {
              var r5 = t5.frag, i4 = t5.part, n4 = t5.level, a3 = self.performance.now();
              r5.stats.parsing.end = a3, i4 && (i4.stats.parsing.end = a3), this.updateLevelTiming(r5, i4, n4, e5.partial);
            } else
              this.fragCurrent || (this.state = b2.IDLE);
          }, C2.getCurrentContext = function(e5) {
            var t5 = this.levels, r5 = e5.level, i4 = e5.sn, n4 = e5.part;
            if (!t5 || !t5[r5])
              return this.warn("Levels object was unset while buffering fragment " + i4 + " of level " + r5 + ". The current chunk will not be buffered."), null;
            var a3 = t5[r5], s3 = n4 > -1 ? (0, p2.getPartWith)(a3, i4, n4) : null, o3 = s3 ? s3.fragment : (0, p2.getFragmentWithSN)(a3, i4, this.fragCurrent);
            return o3 ? { frag: o3, part: s3, level: a3 } : null;
          }, C2.bufferFragmentData = function(e5, t5, r5, i4) {
            if (e5 && this.state === b2.PARSING) {
              var n4 = e5.data1, a3 = e5.data2, s3 = n4;
              if (n4 && a3 && (s3 = (0, d2.appendUint8Array)(n4, a3)), s3 && s3.length) {
                var o3 = { type: e5.type, frag: t5, part: r5, chunkMeta: i4, parent: t5.type, data: s3 };
                this.hls.trigger(l2.Events.BUFFER_APPENDING, o3), e5.dropped && e5.independent && !r5 && this.flushBufferGap(t5);
              }
            }
          }, C2.flushBufferGap = function(e5) {
            var t5 = this.media;
            if (t5)
              if (s2.BufferHelper.isBuffered(t5, t5.currentTime)) {
                var r5 = t5.currentTime, i4 = s2.BufferHelper.bufferInfo(t5, r5, 0), n4 = e5.duration, a3 = Math.min(2 * this.config.maxFragLookUpTolerance, 0.25 * n4), o3 = Math.max(Math.min(e5.start - a3, i4.end - a3), r5 + a3);
                e5.start - o3 > a3 && this.flushMainBuffer(o3, e5.start);
              } else
                this.flushMainBuffer(0, e5.start);
          }, C2.getFwdBufferInfo = function(e5, t5) {
            var r5 = this.config, n4 = this.getLoadPosition();
            if (!(0, i3.isFiniteNumber)(n4))
              return null;
            var a3 = s2.BufferHelper.bufferInfo(e5, n4, r5.maxBufferHole);
            if (0 === a3.len && void 0 !== a3.nextStart) {
              var o3 = this.fragmentTracker.getBufferedFrag(n4, t5);
              if (o3 && a3.nextStart < o3.end)
                return s2.BufferHelper.bufferInfo(e5, n4, Math.max(a3.nextStart, r5.maxBufferHole));
            }
            return a3;
          }, C2.getMaxBufferLength = function(e5) {
            var t5, r5 = this.config;
            return t5 = e5 ? Math.max(8 * r5.maxBufferSize / e5, r5.maxBufferLength) : r5.maxBufferLength, Math.min(t5, r5.maxMaxBufferLength);
          }, C2.reduceMaxBufferLength = function(e5) {
            var t5 = this.config, r5 = e5 || t5.maxBufferLength;
            return t5.maxMaxBufferLength >= r5 && (t5.maxMaxBufferLength /= 2, this.warn("Reduce max buffer length to " + t5.maxMaxBufferLength + "s"), true);
          }, C2.getNextFragment = function(e5, t5) {
            var r5 = t5.fragments, i4 = r5.length;
            if (!i4)
              return null;
            var n4, a3 = this.config, s3 = r5[0].start;
            if (t5.live) {
              var o3 = a3.initialLiveManifestSize;
              if (i4 < o3)
                return this.warn("Not enough fragments to start playback (have: " + i4 + ", need: " + o3 + ")"), null;
              t5.PTSKnown || this.startFragRequested || -1 !== this.startPosition || (n4 = this.getInitialLiveFragment(t5, r5), this.startPosition = n4 ? this.hls.liveSyncPosition || n4.start : e5);
            } else
              e5 <= s3 && (n4 = r5[0]);
            if (!n4) {
              var l3 = a3.lowLatencyMode ? t5.partEnd : t5.fragmentEnd;
              n4 = this.getFragmentAtPosition(e5, l3, t5);
            }
            return this.mapToInitFragWhenRequired(n4);
          }, C2.mapToInitFragWhenRequired = function(e5) {
            return null == e5 || !e5.initSegment || null != e5 && e5.initSegment.data || this.bitrateTest ? e5 : e5.initSegment;
          }, C2.getNextPart = function(e5, t5, r5) {
            for (var i4 = -1, n4 = false, a3 = true, s3 = 0, o3 = e5.length; s3 < o3; s3++) {
              var l3 = e5[s3];
              if (a3 = a3 && !l3.independent, i4 > -1 && r5 < l3.start)
                break;
              var u3 = l3.loaded;
              !u3 && (n4 || l3.independent || a3) && l3.fragment === t5 && (i4 = s3), n4 = u3;
            }
            return i4;
          }, C2.loadedEndOfParts = function(e5, t5) {
            var r5 = e5[e5.length - 1];
            return r5 && t5 > r5.start && r5.loaded;
          }, C2.getInitialLiveFragment = function(e5, t5) {
            var r5 = this.fragPrevious, i4 = null;
            if (r5) {
              if (e5.hasProgramDateTime && (this.log("Live playlist, switching playlist, load frag with same PDT: " + r5.programDateTime), i4 = (0, f2.findFragmentByPDT)(t5, r5.endProgramDateTime, this.config.maxFragLookUpTolerance)), !i4) {
                var n4 = r5.sn + 1;
                if (n4 >= e5.startSN && n4 <= e5.endSN) {
                  var a3 = t5[n4 - e5.startSN];
                  r5.cc === a3.cc && (i4 = a3, this.log("Live playlist, switching playlist, load frag with next SN: " + i4.sn));
                }
                i4 || (i4 = (0, f2.findFragWithCC)(t5, r5.cc)) && this.log("Live playlist, switching playlist, load frag with same CC: " + i4.sn);
              }
            } else {
              var s3 = this.hls.liveSyncPosition;
              null !== s3 && (i4 = this.getFragmentAtPosition(s3, this.bitrateTest ? e5.fragmentEnd : e5.edge, e5));
            }
            return i4;
          }, C2.getFragmentAtPosition = function(e5, t5, r5) {
            var i4, n4 = this.config, s3 = this.fragPrevious, o3 = r5.fragments, l3 = r5.endSN, u3 = r5.fragmentHint, c3 = n4.maxFragLookUpTolerance, d3 = !!(n4.lowLatencyMode && r5.partList && u3);
            if (d3 && u3 && !this.bitrateTest && (o3 = o3.concat(u3), l3 = u3.sn), e5 < t5) {
              var h3 = e5 > t5 - c3 ? 0 : c3;
              i4 = (0, f2.findFragmentByPTS)(s3, o3, e5, h3);
            } else
              i4 = o3[o3.length - 1];
            if (i4) {
              var p3 = i4.sn - r5.startSN;
              if (this.fragmentTracker.getState(i4) === a2.FragmentState.OK && (s3 = i4), s3 && i4.sn === s3.sn && !d3 && s3 && i4.level === s3.level) {
                var g3 = o3[p3 + 1];
                i4.sn < l3 && this.fragmentTracker.getState(g3) !== a2.FragmentState.OK ? (this.log("SN " + i4.sn + " just loaded, load next one: " + g3.sn), i4 = g3) : i4 = null;
              }
            }
            return i4;
          }, C2.synchronizeToLiveEdge = function(e5) {
            var t5 = this.config, r5 = this.media;
            if (r5) {
              var i4 = this.hls.liveSyncPosition, n4 = r5.currentTime, a3 = e5.fragments[0].start, s3 = e5.edge, o3 = n4 >= a3 - t5.maxFragLookUpTolerance && n4 <= s3;
              if (null !== i4 && r5.duration > i4 && (n4 < i4 || !o3)) {
                var l3 = void 0 !== t5.liveMaxLatencyDuration ? t5.liveMaxLatencyDuration : t5.liveMaxLatencyDurationCount * e5.targetduration;
                (!o3 && r5.readyState < 4 || n4 < s3 - l3) && (this.loadedmetadata || (this.nextLoadPosition = i4), r5.readyState && (this.warn("Playback: " + n4.toFixed(3) + " is located too far from the end of live sliding playlist: " + s3 + ", reset currentTime to : " + i4.toFixed(3)), r5.currentTime = i4));
              }
            }
          }, C2.alignPlaylists = function(e5, t5) {
            var r5 = this.levels, n4 = this.levelLastLoaded, a3 = this.fragPrevious, s3 = null !== n4 ? r5[n4] : null, o3 = e5.fragments.length;
            if (!o3)
              return this.warn("No fragments in live playlist"), 0;
            var l3 = e5.fragments[0].start, u3 = !t5, c3 = e5.alignedSliding && (0, i3.isFiniteNumber)(l3);
            if (u3 || !c3 && !l3) {
              (0, h2.alignStream)(a3, s3, e5);
              var d3 = e5.fragments[0].start;
              return this.log("Live playlist sliding: " + d3.toFixed(2) + " start-sn: " + (t5 ? t5.startSN : "na") + "->" + e5.startSN + " prev-sn: " + (a3 ? a3.sn : "na") + " fragments: " + o3), d3;
            }
            return l3;
          }, C2.waitForCdnTuneIn = function(e5) {
            return e5.live && e5.canBlockReload && e5.partTarget && e5.tuneInGoal > Math.max(e5.partHoldBack, 3 * e5.partTarget);
          }, C2.setStartPosition = function(e5, t5) {
            var r5 = this.startPosition;
            if (r5 < t5 && (r5 = -1), -1 === r5 || -1 === this.lastCurrentTime) {
              var n4 = e5.startTimeOffset;
              (0, i3.isFiniteNumber)(n4) ? (r5 = t5 + n4, n4 < 0 && (r5 += e5.totalduration), r5 = Math.min(Math.max(t5, r5), t5 + e5.totalduration), this.log("Start time offset " + n4 + " found in playlist, adjust startPosition to " + r5), this.startPosition = r5) : e5.live ? r5 = this.hls.liveSyncPosition || t5 : this.startPosition = r5 = 0, this.lastCurrentTime = r5;
            }
            this.nextLoadPosition = r5;
          }, C2.getLoadPosition = function() {
            var e5 = this.media, t5 = 0;
            return this.loadedmetadata && e5 ? t5 = e5.currentTime : this.nextLoadPosition && (t5 = this.nextLoadPosition), t5;
          }, C2.handleFragLoadAborted = function(e5, t5) {
            this.transmuxer && "initSegment" !== e5.sn && e5.stats.aborted && (this.warn("Fragment " + e5.sn + (t5 ? " part" + t5.index : "") + " of level " + e5.level + " was aborted"), this.resetFragmentLoading(e5));
          }, C2.resetFragmentLoading = function(e5) {
            this.fragCurrent && (this.fragContextChanged(e5) || this.state === b2.FRAG_LOADING_WAITING_RETRY) || (this.state = b2.IDLE);
          }, C2.onFragmentOrKeyLoadError = function(e5, t5) {
            if (!t5.fatal) {
              var r5 = t5.frag;
              if (r5 && r5.type === e5) {
                var i4 = this.fragCurrent;
                console.assert(i4 && r5.sn === i4.sn && r5.level === i4.level && r5.urlId === i4.urlId, "Frag load error must match current frag to retry");
                var n4 = this.config;
                if (this.fragLoadError + 1 <= n4.fragLoadingMaxRetry) {
                  this.loadedmetadata || (this.startFragRequested = false, this.nextLoadPosition = this.startPosition);
                  var a3 = Math.min(Math.pow(2, this.fragLoadError) * n4.fragLoadingRetryDelay, n4.fragLoadingMaxRetryTimeout);
                  this.warn("Fragment " + r5.sn + " of " + e5 + " " + r5.level + " failed to load, retrying in " + a3 + "ms"), this.retryDate = self.performance.now() + a3, this.fragLoadError++, this.state = b2.FRAG_LOADING_WAITING_RETRY;
                } else
                  t5.levelRetry ? (e5 === y2.PlaylistLevelType.AUDIO && (this.fragCurrent = null), this.fragLoadError = 0, this.state = b2.IDLE) : (o2.logger.error(t5.details + " reaches max retry, redispatch as fatal ..."), t5.fatal = true, this.hls.stopLoad(), this.state = b2.ERROR);
              }
            }
          }, C2.afterBufferFlushed = function(e5, t5, r5) {
            if (e5) {
              var i4 = s2.BufferHelper.getBuffered(e5);
              this.fragmentTracker.detectEvictedFragments(t5, i4, r5), this.state === b2.ENDED && this.resetLoadingState();
            }
          }, C2.resetLoadingState = function() {
            this.fragCurrent = null, this.fragPrevious = null, this.state = b2.IDLE;
          }, C2.resetStartWhenNotLoaded = function(e5) {
            if (!this.loadedmetadata) {
              this.startFragRequested = false;
              var t5 = this.levels ? this.levels[e5].details : null;
              null != t5 && t5.live ? (this.startPosition = -1, this.setStartPosition(t5, 0), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition;
            }
          }, C2.updateLevelTiming = function(e5, t5, r5, i4) {
            var n4 = this, a3 = r5.details;
            console.assert(!!a3, "level.details must be defined"), Object.keys(e5.elementaryStreams).reduce(function(t6, s3) {
              var o3 = e5.elementaryStreams[s3];
              if (o3) {
                var u3 = o3.endPTS - o3.startPTS;
                if (u3 <= 0)
                  return n4.warn("Could not parse fragment " + e5.sn + " " + s3 + " duration reliably (" + u3 + ")"), t6 || false;
                var c3 = i4 ? 0 : (0, p2.updateFragPTSDTS)(a3, e5, o3.startPTS, o3.endPTS, o3.startDTS, o3.endDTS);
                return n4.hls.trigger(l2.Events.LEVEL_PTS_UPDATED, { details: a3, level: r5, drift: c3, type: s3, frag: e5, start: o3.startPTS, end: o3.endPTS }), true;
              }
              return t6;
            }, false) || (this.warn("Found no media in fragment " + e5.sn + " of level " + r5.id + " resetting transmuxer to fallback to playlist timing"), this.resetTransmuxer()), this.state = b2.PARSED, this.hls.trigger(l2.Events.FRAG_PARSED, { frag: e5, part: t5 });
          }, C2.resetTransmuxer = function() {
            this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null);
          }, k3 = n3, (S2 = [{ key: "state", get: function() {
            return this._state;
          }, set: function(e5) {
            var t5 = this._state;
            t5 !== e5 && (this._state = e5, this.log(t5 + "->" + e5));
          } }]) && A2(k3.prototype, S2), _2 && A2(k3, _2), Object.defineProperty(k3, "prototype", { writable: false }), n3;
        }(n2.default);
      }
    ), "./src/controller/buffer-controller.ts": (
      /*!*********************************************!*\
          !*** ./src/controller/buffer-controller.ts ***!
          \*********************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => f2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), a2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), s2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), o2 = r3(
          /*! ../utils/buffer-helper */
          "./src/utils/buffer-helper.ts"
        ), l2 = r3(
          /*! ../utils/mediasource-helper */
          "./src/utils/mediasource-helper.ts"
        ), u2 = r3(
          /*! ../loader/fragment */
          "./src/loader/fragment.ts"
        ), c2 = r3(
          /*! ./buffer-operation-queue */
          "./src/controller/buffer-operation-queue.ts"
        ), d2 = (0, l2.getMediaSource)(), h2 = /([ha]vc.)(?:\.[^.,]+)+/, f2 = function() {
          function e4(e5) {
            var t5 = this;
            this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.appendError = 0, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this._onMediaSourceOpen = function() {
              var e6 = t5.hls, r4 = t5.media, i4 = t5.mediaSource;
              a2.logger.log("[buffer-controller]: Media source opened"), r4 && (t5.updateMediaElementDuration(), e6.trigger(n2.Events.MEDIA_ATTACHED, { media: r4 })), i4 && i4.removeEventListener("sourceopen", t5._onMediaSourceOpen), t5.checkPendingTracks();
            }, this._onMediaSourceClose = function() {
              a2.logger.log("[buffer-controller]: Media source closed");
            }, this._onMediaSourceEnded = function() {
              a2.logger.log("[buffer-controller]: Media source ended");
            }, this.hls = e5, this._initSourceBuffer(), this.registerListeners();
          }
          var t4 = e4.prototype;
          return t4.hasSourceTypes = function() {
            return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;
          }, t4.destroy = function() {
            this.unregisterListeners(), this.details = null;
          }, t4.registerListeners = function() {
            var e5 = this.hls;
            e5.on(n2.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e5.on(n2.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e5.on(n2.Events.MANIFEST_PARSED, this.onManifestParsed, this), e5.on(n2.Events.BUFFER_RESET, this.onBufferReset, this), e5.on(n2.Events.BUFFER_APPENDING, this.onBufferAppending, this), e5.on(n2.Events.BUFFER_CODECS, this.onBufferCodecs, this), e5.on(n2.Events.BUFFER_EOS, this.onBufferEos, this), e5.on(n2.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), e5.on(n2.Events.LEVEL_UPDATED, this.onLevelUpdated, this), e5.on(n2.Events.FRAG_PARSED, this.onFragParsed, this), e5.on(n2.Events.FRAG_CHANGED, this.onFragChanged, this);
          }, t4.unregisterListeners = function() {
            var e5 = this.hls;
            e5.off(n2.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e5.off(n2.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e5.off(n2.Events.MANIFEST_PARSED, this.onManifestParsed, this), e5.off(n2.Events.BUFFER_RESET, this.onBufferReset, this), e5.off(n2.Events.BUFFER_APPENDING, this.onBufferAppending, this), e5.off(n2.Events.BUFFER_CODECS, this.onBufferCodecs, this), e5.off(n2.Events.BUFFER_EOS, this.onBufferEos, this), e5.off(n2.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), e5.off(n2.Events.LEVEL_UPDATED, this.onLevelUpdated, this), e5.off(n2.Events.FRAG_PARSED, this.onFragParsed, this), e5.off(n2.Events.FRAG_CHANGED, this.onFragChanged, this);
          }, t4._initSourceBuffer = function() {
            this.sourceBuffer = {}, this.operationQueue = new c2.default(this.sourceBuffer), this.listeners = { audio: [], video: [], audiovideo: [] };
          }, t4.onManifestParsed = function(e5, t5) {
            var r4 = 2;
            (t5.audio && !t5.video || !t5.altAudio) && (r4 = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = r4, this.details = null, a2.logger.log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected");
          }, t4.onMediaAttaching = function(e5, t5) {
            var r4 = this.media = t5.media;
            if (r4 && d2) {
              var i4 = this.mediaSource = new d2();
              i4.addEventListener("sourceopen", this._onMediaSourceOpen), i4.addEventListener("sourceended", this._onMediaSourceEnded), i4.addEventListener("sourceclose", this._onMediaSourceClose), r4.src = self.URL.createObjectURL(i4), this._objectUrl = r4.src;
            }
          }, t4.onMediaDetaching = function() {
            var e5 = this.media, t5 = this.mediaSource, r4 = this._objectUrl;
            if (t5) {
              if (a2.logger.log("[buffer-controller]: media source detaching"), "open" === t5.readyState)
                try {
                  t5.endOfStream();
                } catch (e6) {
                  a2.logger.warn("[buffer-controller]: onMediaDetaching: " + e6.message + " while calling endOfStream");
                }
              this.onBufferReset(), t5.removeEventListener("sourceopen", this._onMediaSourceOpen), t5.removeEventListener("sourceended", this._onMediaSourceEnded), t5.removeEventListener("sourceclose", this._onMediaSourceClose), e5 && (r4 && self.URL.revokeObjectURL(r4), e5.src === r4 ? (e5.removeAttribute("src"), e5.load()) : a2.logger.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {};
            }
            this.hls.trigger(n2.Events.MEDIA_DETACHED, void 0);
          }, t4.onBufferReset = function() {
            var e5 = this;
            this.getSourceBufferTypes().forEach(function(t5) {
              var r4 = e5.sourceBuffer[t5];
              try {
                r4 && (e5.removeBufferListeners(t5), e5.mediaSource && e5.mediaSource.removeSourceBuffer(r4), e5.sourceBuffer[t5] = void 0);
              } catch (e6) {
                a2.logger.warn("[buffer-controller]: Failed to reset the " + t5 + " buffer", e6);
              }
            }), this._initSourceBuffer();
          }, t4.onBufferCodecs = function(e5, t5) {
            var r4 = this, i4 = this.getSourceBufferTypes().length;
            Object.keys(t5).forEach(function(e6) {
              if (i4) {
                var n3 = r4.tracks[e6];
                if (n3 && "function" == typeof n3.buffer.changeType) {
                  var s3 = t5[e6], o3 = s3.id, l3 = s3.codec, u3 = s3.levelCodec, c3 = s3.container, d3 = s3.metadata, f3 = (n3.levelCodec || n3.codec).replace(h2, "$1"), p2 = (u3 || l3).replace(h2, "$1");
                  if (f3 !== p2) {
                    var g2 = c3 + ";codecs=" + (u3 || l3);
                    r4.appendChangeType(e6, g2), a2.logger.log("[buffer-controller]: switching codec " + f3 + " to " + p2), r4.tracks[e6] = { buffer: n3.buffer, codec: l3, container: c3, levelCodec: u3, metadata: d3, id: o3 };
                  }
                }
              } else
                r4.pendingTracks[e6] = t5[e6];
            }), i4 || (this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource && "open" === this.mediaSource.readyState && this.checkPendingTracks());
          }, t4.appendChangeType = function(e5, t5) {
            var r4 = this, i4 = this.operationQueue, n3 = { execute: function() {
              var n4 = r4.sourceBuffer[e5];
              n4 && (a2.logger.log("[buffer-controller]: changing " + e5 + " sourceBuffer type to " + t5), n4.changeType(t5)), i4.shiftAndExecuteNext(e5);
            }, onStart: function() {
            }, onComplete: function() {
            }, onError: function(t6) {
              a2.logger.warn("[buffer-controller]: Failed to change " + e5 + " SourceBuffer type", t6);
            } };
            i4.append(n3, e5);
          }, t4.onBufferAppending = function(e5, t5) {
            var r4 = this, i4 = this.hls, l3 = this.operationQueue, u3 = this.tracks, c3 = t5.data, d3 = t5.type, h3 = t5.frag, f3 = t5.part, p2 = t5.chunkMeta, g2 = p2.buffering[d3], v2 = self.performance.now();
            g2.start = v2;
            var m2 = h3.stats.buffering, y2 = f3 ? f3.stats.buffering : null;
            0 === m2.start && (m2.start = v2), y2 && 0 === y2.start && (y2.start = v2);
            var A2 = u3.audio, E2 = "audio" === d3 && 1 === p2.id && "audio/mpeg" === (null == A2 ? void 0 : A2.container), T2 = { execute: function() {
              if (g2.executeStart = self.performance.now(), E2) {
                var e6 = r4.sourceBuffer[d3];
                if (e6) {
                  var t6 = h3.start - e6.timestampOffset;
                  Math.abs(t6) >= 0.1 && (a2.logger.log("[buffer-controller]: Updating audio SourceBuffer timestampOffset to " + h3.start + " (delta: " + t6 + ") sn: " + h3.sn + ")"), e6.timestampOffset = h3.start);
                }
              }
              r4.appendExecutor(c3, d3);
            }, onStart: function() {
            }, onComplete: function() {
              var e6 = self.performance.now();
              g2.executeEnd = g2.end = e6, 0 === m2.first && (m2.first = e6), y2 && 0 === y2.first && (y2.first = e6);
              var t6 = r4.sourceBuffer, i5 = {};
              for (var a3 in t6)
                i5[a3] = o2.BufferHelper.getBuffered(t6[a3]);
              r4.appendError = 0, r4.hls.trigger(n2.Events.BUFFER_APPENDED, { type: d3, frag: h3, part: f3, chunkMeta: p2, parent: h3.type, timeRanges: i5 });
            }, onError: function(e6) {
              a2.logger.error("[buffer-controller]: Error encountered while trying to append to the " + d3 + " SourceBuffer", e6);
              var t6 = { type: s2.ErrorTypes.MEDIA_ERROR, parent: h3.type, details: s2.ErrorDetails.BUFFER_APPEND_ERROR, err: e6, fatal: false };
              e6.code === DOMException.QUOTA_EXCEEDED_ERR ? t6.details = s2.ErrorDetails.BUFFER_FULL_ERROR : (r4.appendError++, t6.details = s2.ErrorDetails.BUFFER_APPEND_ERROR, r4.appendError > i4.config.appendErrorMaxRetry && (a2.logger.error("[buffer-controller]: Failed " + i4.config.appendErrorMaxRetry + " times to append segment in sourceBuffer"), t6.fatal = true, i4.stopLoad())), i4.trigger(n2.Events.ERROR, t6);
            } };
            l3.append(T2, d3);
          }, t4.onBufferFlushing = function(e5, t5) {
            var r4 = this, i4 = this.operationQueue, s3 = function(e6) {
              return { execute: r4.removeExecutor.bind(r4, e6, t5.startOffset, t5.endOffset), onStart: function() {
              }, onComplete: function() {
                r4.hls.trigger(n2.Events.BUFFER_FLUSHED, { type: e6 });
              }, onError: function(t6) {
                a2.logger.warn("[buffer-controller]: Failed to remove from " + e6 + " SourceBuffer", t6);
              } };
            };
            t5.type ? i4.append(s3(t5.type), t5.type) : this.getSourceBufferTypes().forEach(function(e6) {
              i4.append(s3(e6), e6);
            });
          }, t4.onFragParsed = function(e5, t5) {
            var r4 = this, i4 = t5.frag, s3 = t5.part, o3 = [], l3 = s3 ? s3.elementaryStreams : i4.elementaryStreams;
            l3[u2.ElementaryStreamTypes.AUDIOVIDEO] ? o3.push("audiovideo") : (l3[u2.ElementaryStreamTypes.AUDIO] && o3.push("audio"), l3[u2.ElementaryStreamTypes.VIDEO] && o3.push("video")), 0 === o3.length && a2.logger.warn("Fragments must have at least one ElementaryStreamType set. type: " + i4.type + " level: " + i4.level + " sn: " + i4.sn), this.blockBuffers(function() {
              var e6 = self.performance.now();
              i4.stats.buffering.end = e6, s3 && (s3.stats.buffering.end = e6);
              var t6 = s3 ? s3.stats : i4.stats;
              r4.hls.trigger(n2.Events.FRAG_BUFFERED, { frag: i4, part: s3, stats: t6, id: i4.type });
            }, o3);
          }, t4.onFragChanged = function(e5, t5) {
            this.flushBackBuffer();
          }, t4.onBufferEos = function(e5, t5) {
            var r4 = this;
            this.getSourceBufferTypes().reduce(function(e6, i4) {
              var n3 = r4.sourceBuffer[i4];
              return t5.type && t5.type !== i4 || n3 && !n3.ended && (n3.ended = true, a2.logger.log("[buffer-controller]: " + i4 + " sourceBuffer now EOS")), e6 && !(n3 && !n3.ended);
            }, true) && this.blockBuffers(function() {
              var e6 = r4.mediaSource;
              e6 && "open" === e6.readyState && e6.endOfStream();
            });
          }, t4.onLevelUpdated = function(e5, t5) {
            var r4 = t5.details;
            r4.fragments.length && (this.details = r4, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration());
          }, t4.flushBackBuffer = function() {
            var e5 = this.hls, t5 = this.details, r4 = this.media, a3 = this.sourceBuffer;
            if (r4 && null !== t5) {
              var s3 = this.getSourceBufferTypes();
              if (s3.length) {
                var l3 = t5.live && null !== e5.config.liveBackBufferLength ? e5.config.liveBackBufferLength : e5.config.backBufferLength;
                if ((0, i3.isFiniteNumber)(l3) && !(l3 < 0)) {
                  var u3 = r4.currentTime, c3 = t5.levelTargetDuration, d3 = Math.max(l3, c3), h3 = Math.floor(u3 / c3) * c3 - d3;
                  s3.forEach(function(r5) {
                    var i4 = a3[r5];
                    if (i4) {
                      var s4 = o2.BufferHelper.getBuffered(i4);
                      s4.length > 0 && h3 > s4.start(0) && (e5.trigger(n2.Events.BACK_BUFFER_REACHED, { bufferEnd: h3 }), t5.live && e5.trigger(n2.Events.LIVE_BACK_BUFFER_REACHED, { bufferEnd: h3 }), e5.trigger(n2.Events.BUFFER_FLUSHING, { startOffset: 0, endOffset: h3, type: r5 }));
                    }
                  });
                }
              }
            }
          }, t4.updateMediaElementDuration = function() {
            if (this.details && this.media && this.mediaSource && "open" === this.mediaSource.readyState) {
              var e5 = this.details, t5 = this.hls, r4 = this.media, n3 = this.mediaSource, s3 = e5.fragments[0].start + e5.totalduration, o3 = r4.duration, l3 = (0, i3.isFiniteNumber)(n3.duration) ? n3.duration : 0;
              e5.live && t5.config.liveDurationInfinity ? (a2.logger.log("[buffer-controller]: Media Source duration is set to Infinity"), n3.duration = 1 / 0, this.updateSeekableRange(e5)) : (s3 > l3 && s3 > o3 || !(0, i3.isFiniteNumber)(o3)) && (a2.logger.log("[buffer-controller]: Updating Media Source duration to " + s3.toFixed(3)), n3.duration = s3);
            }
          }, t4.updateSeekableRange = function(e5) {
            var t5 = this.mediaSource, r4 = e5.fragments;
            if (r4.length && e5.live && null != t5 && t5.setLiveSeekableRange) {
              var i4 = Math.max(0, r4[0].start), n3 = Math.max(i4, i4 + e5.totalduration);
              t5.setLiveSeekableRange(i4, n3);
            }
          }, t4.checkPendingTracks = function() {
            var e5 = this.bufferCodecEventsExpected, t5 = this.operationQueue, r4 = this.pendingTracks, i4 = Object.keys(r4).length;
            if (i4 && !e5 || 2 === i4) {
              this.createSourceBuffers(r4), this.pendingTracks = {};
              var a3 = this.getSourceBufferTypes();
              if (0 === a3.length)
                return void this.hls.trigger(n2.Events.ERROR, { type: s2.ErrorTypes.MEDIA_ERROR, details: s2.ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR, fatal: true, reason: "could not create source buffer for media codec(s)" });
              a3.forEach(function(e6) {
                t5.executeNext(e6);
              });
            }
          }, t4.createSourceBuffers = function(e5) {
            var t5 = this.sourceBuffer, r4 = this.mediaSource;
            if (!r4)
              throw Error("createSourceBuffers called when mediaSource was null");
            var i4 = 0;
            for (var o3 in e5)
              if (!t5[o3]) {
                var l3 = e5[o3];
                if (!l3)
                  throw Error("source buffer exists for track " + o3 + ", however track does not");
                var u3 = l3.levelCodec || l3.codec, c3 = l3.container + ";codecs=" + u3;
                a2.logger.log("[buffer-controller]: creating sourceBuffer(" + c3 + ")");
                try {
                  var d3 = t5[o3] = r4.addSourceBuffer(c3), h3 = o3;
                  this.addBufferListener(h3, "updatestart", this._onSBUpdateStart), this.addBufferListener(h3, "updateend", this._onSBUpdateEnd), this.addBufferListener(h3, "error", this._onSBUpdateError), this.tracks[o3] = { buffer: d3, codec: u3, container: l3.container, levelCodec: l3.levelCodec, metadata: l3.metadata, id: l3.id }, i4++;
                } catch (e6) {
                  a2.logger.error("[buffer-controller]: error while trying to add sourceBuffer: " + e6.message), this.hls.trigger(n2.Events.ERROR, { type: s2.ErrorTypes.MEDIA_ERROR, details: s2.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, error: e6, mimeType: c3 });
                }
              }
            i4 && this.hls.trigger(n2.Events.BUFFER_CREATED, { tracks: this.tracks });
          }, t4._onSBUpdateStart = function(e5) {
            this.operationQueue.current(e5).onStart();
          }, t4._onSBUpdateEnd = function(e5) {
            var t5 = this.operationQueue;
            t5.current(e5).onComplete(), t5.shiftAndExecuteNext(e5);
          }, t4._onSBUpdateError = function(e5, t5) {
            a2.logger.error("[buffer-controller]: " + e5 + " SourceBuffer error", t5), this.hls.trigger(n2.Events.ERROR, { type: s2.ErrorTypes.MEDIA_ERROR, details: s2.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
            var r4 = this.operationQueue.current(e5);
            r4 && r4.onError(t5);
          }, t4.removeExecutor = function(e5, t5, r4) {
            var n3 = this.media, s3 = this.mediaSource, o3 = this.operationQueue, l3 = this.sourceBuffer[e5];
            if (!n3 || !s3 || !l3)
              return a2.logger.warn("[buffer-controller]: Attempting to remove from the " + e5 + " SourceBuffer, but it does not exist"), void o3.shiftAndExecuteNext(e5);
            var u3 = (0, i3.isFiniteNumber)(n3.duration) ? n3.duration : 1 / 0, c3 = (0, i3.isFiniteNumber)(s3.duration) ? s3.duration : 1 / 0, d3 = Math.max(0, t5), h3 = Math.min(r4, u3, c3);
            h3 > d3 ? (a2.logger.log("[buffer-controller]: Removing [" + d3 + "," + h3 + "] from the " + e5 + " SourceBuffer"), console.assert(!l3.updating, e5 + " sourceBuffer must not be updating"), l3.remove(d3, h3)) : o3.shiftAndExecuteNext(e5);
          }, t4.appendExecutor = function(e5, t5) {
            var r4 = this.operationQueue, i4 = this.sourceBuffer[t5];
            if (!i4)
              return a2.logger.warn("[buffer-controller]: Attempting to append to the " + t5 + " SourceBuffer, but it does not exist"), void r4.shiftAndExecuteNext(t5);
            i4.ended = false, console.assert(!i4.updating, t5 + " sourceBuffer must not be updating"), i4.appendBuffer(e5);
          }, t4.blockBuffers = function(e5, t5) {
            var r4 = this;
            if (void 0 === t5 && (t5 = this.getSourceBufferTypes()), !t5.length)
              return a2.logger.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist"), void Promise.resolve().then(e5);
            var i4 = this.operationQueue, n3 = t5.map(function(e6) {
              return i4.appendBlocker(e6);
            });
            Promise.all(n3).then(function() {
              e5(), t5.forEach(function(e6) {
                var t6 = r4.sourceBuffer[e6];
                t6 && t6.updating || i4.shiftAndExecuteNext(e6);
              });
            });
          }, t4.getSourceBufferTypes = function() {
            return Object.keys(this.sourceBuffer);
          }, t4.addBufferListener = function(e5, t5, r4) {
            var i4 = this.sourceBuffer[e5];
            if (i4) {
              var n3 = r4.bind(this, e5);
              this.listeners[e5].push({ event: t5, listener: n3 }), i4.addEventListener(t5, n3);
            }
          }, t4.removeBufferListeners = function(e5) {
            var t5 = this.sourceBuffer[e5];
            t5 && this.listeners[e5].forEach(function(e6) {
              t5.removeEventListener(e6.event, e6.listener);
            });
          }, e4;
        }();
      }
    ), "./src/controller/buffer-operation-queue.ts": (
      /*!**************************************************!*\
          !*** ./src/controller/buffer-operation-queue.ts ***!
          \**************************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => n2 });
        var i3 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), n2 = function() {
          function e4(e5) {
            this.buffers = void 0, this.queues = { video: [], audio: [], audiovideo: [] }, this.buffers = e5;
          }
          var t4 = e4.prototype;
          return t4.append = function(e5, t5) {
            var r4 = this.queues[t5];
            r4.push(e5), 1 === r4.length && this.buffers[t5] && this.executeNext(t5);
          }, t4.insertAbort = function(e5, t5) {
            this.queues[t5].unshift(e5), this.executeNext(t5);
          }, t4.appendBlocker = function(e5) {
            var t5, r4 = new Promise(function(e6) {
              t5 = e6;
            }), i4 = { execute: t5, onStart: function() {
            }, onComplete: function() {
            }, onError: function() {
            } };
            return this.append(i4, e5), r4;
          }, t4.executeNext = function(e5) {
            var t5 = this.buffers, r4 = this.queues, n3 = t5[e5], a2 = r4[e5];
            if (a2.length) {
              var s2 = a2[0];
              try {
                s2.execute();
              } catch (t6) {
                i3.logger.warn("[buffer-operation-queue]: Unhandled exception executing the current operation"), s2.onError(t6), n3 && n3.updating || (a2.shift(), this.executeNext(e5));
              }
            }
          }, t4.shiftAndExecuteNext = function(e5) {
            this.queues[e5].shift(), this.executeNext(e5);
          }, t4.current = function(e5) {
            return this.queues[e5][0];
          }, e4;
        }();
      }
    ), "./src/controller/cap-level-controller.ts": (
      /*!************************************************!*\
          !*** ./src/controller/cap-level-controller.ts ***!
          \************************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => s2 });
        var i3 = r3(
          /*! ../events */
          "./src/events.ts"
        );
        function n2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        var a2 = function() {
          function e4(e5) {
            this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.hls = void 0, this.streamController = void 0, this.clientRect = void 0, this.hls = e5, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners();
          }
          var t4, r4, a3, s3 = e4.prototype;
          return s3.setStreamController = function(e5) {
            this.streamController = e5;
          }, s3.destroy = function() {
            this.unregisterListener(), this.hls.config.capLevelToPlayerSize && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null;
          }, s3.registerListeners = function() {
            var e5 = this.hls;
            e5.on(i3.Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e5.on(i3.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e5.on(i3.Events.MANIFEST_PARSED, this.onManifestParsed, this), e5.on(i3.Events.BUFFER_CODECS, this.onBufferCodecs, this), e5.on(i3.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          }, s3.unregisterListener = function() {
            var e5 = this.hls;
            e5.off(i3.Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e5.off(i3.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e5.off(i3.Events.MANIFEST_PARSED, this.onManifestParsed, this), e5.off(i3.Events.BUFFER_CODECS, this.onBufferCodecs, this), e5.off(i3.Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          }, s3.onFpsDropLevelCapping = function(t5, r5) {
            e4.isLevelAllowed(r5.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(r5.droppedLevel);
          }, s3.onMediaAttaching = function(e5, t5) {
            this.media = t5.media instanceof HTMLVideoElement ? t5.media : null;
          }, s3.onManifestParsed = function(e5, t5) {
            var r5 = this.hls;
            this.restrictedLevels = [], this.firstLevel = t5.firstLevel, r5.config.capLevelToPlayerSize && t5.video && this.startCapping();
          }, s3.onBufferCodecs = function(e5, t5) {
            this.hls.config.capLevelToPlayerSize && t5.video && this.startCapping();
          }, s3.onMediaDetaching = function() {
            this.stopCapping();
          }, s3.detectPlayerSize = function() {
            if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
              var e5 = this.hls.levels;
              if (e5.length) {
                var t5 = this.hls;
                t5.autoLevelCapping = this.getMaxLevel(e5.length - 1), t5.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t5.autoLevelCapping;
              }
            }
          }, s3.getMaxLevel = function(t5) {
            var r5 = this, i4 = this.hls.levels;
            if (!i4.length)
              return -1;
            var n3 = i4.filter(function(i5, n4) {
              return e4.isLevelAllowed(n4, r5.restrictedLevels) && n4 <= t5;
            });
            return this.clientRect = null, e4.getMaxLevelByMediaSize(n3, this.mediaWidth, this.mediaHeight);
          }, s3.startCapping = function() {
            this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());
          }, s3.stopCapping = function() {
            this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0);
          }, s3.getDimensions = function() {
            if (this.clientRect)
              return this.clientRect;
            var e5 = this.media, t5 = { width: 0, height: 0 };
            if (e5) {
              var r5 = e5.getBoundingClientRect();
              t5.width = r5.width, t5.height = r5.height, t5.width || t5.height || (t5.width = r5.right - r5.left || e5.width || 0, t5.height = r5.bottom - r5.top || e5.height || 0);
            }
            return this.clientRect = t5, t5;
          }, e4.isLevelAllowed = function(e5, t5) {
            return void 0 === t5 && (t5 = []), -1 === t5.indexOf(e5);
          }, e4.getMaxLevelByMediaSize = function(e5, t5, r5) {
            if (!e5 || !e5.length)
              return -1;
            for (var i4, n3, a4 = e5.length - 1, s4 = 0; s4 < e5.length; s4 += 1) {
              var o2 = e5[s4];
              if ((o2.width >= t5 || o2.height >= r5) && (i4 = o2, !(n3 = e5[s4 + 1]) || i4.width !== n3.width || i4.height !== n3.height)) {
                a4 = s4;
                break;
              }
            }
            return a4;
          }, t4 = e4, (r4 = [{ key: "mediaWidth", get: function() {
            return this.getDimensions().width * this.contentScaleFactor;
          } }, { key: "mediaHeight", get: function() {
            return this.getDimensions().height * this.contentScaleFactor;
          } }, { key: "contentScaleFactor", get: function() {
            var e5 = 1;
            if (!this.hls.config.ignoreDevicePixelRatio)
              try {
                e5 = self.devicePixelRatio;
              } catch (e6) {
              }
            return e5;
          } }]) && n2(t4.prototype, r4), a3 && n2(t4, a3), Object.defineProperty(t4, "prototype", { writable: false }), e4;
        }();
        const s2 = a2;
      }
    ), "./src/controller/cmcd-controller.ts": (
      /*!*******************************************!*\
          !*** ./src/controller/cmcd-controller.ts ***!
          \*******************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => h2 });
        var i3 = r3(
          /*! ../events */
          "./src/events.ts"
        ), n2 = r3(
          /*! ../types/cmcd */
          "./src/types/cmcd.ts"
        ), a2 = r3(
          /*! ../utils/buffer-helper */
          "./src/utils/buffer-helper.ts"
        ), s2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        );
        function o2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        function l2(e4, t4, r4) {
          return t4 && o2(e4.prototype, t4), r4 && o2(e4, r4), Object.defineProperty(e4, "prototype", { writable: false }), e4;
        }
        function u2(e4, t4) {
          var r4 = "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
          if (r4)
            return (r4 = r4.call(e4)).next.bind(r4);
          if (Array.isArray(e4) || (r4 = function(e5, t5) {
            if (e5) {
              if ("string" == typeof e5)
                return c2(e5, t5);
              var r5 = Object.prototype.toString.call(e5).slice(8, -1);
              return "Object" === r5 && e5.constructor && (r5 = e5.constructor.name), "Map" === r5 || "Set" === r5 ? Array.from(e5) : "Arguments" === r5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? c2(e5, t5) : void 0;
            }
          }(e4)) || t4 && e4 && "number" == typeof e4.length) {
            r4 && (e4 = r4);
            var i4 = 0;
            return function() {
              return i4 >= e4.length ? { done: true } : { done: false, value: e4[i4++] };
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function c2(e4, t4) {
          (null == t4 || t4 > e4.length) && (t4 = e4.length);
          for (var r4 = 0, i4 = new Array(t4); r4 < t4; r4++)
            i4[r4] = e4[r4];
          return i4;
        }
        function d2() {
          return d2 = Object.assign ? Object.assign.bind() : function(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var r4 = arguments[t4];
              for (var i4 in r4)
                Object.prototype.hasOwnProperty.call(r4, i4) && (e4[i4] = r4[i4]);
            }
            return e4;
          }, d2.apply(this, arguments);
        }
        var h2 = function() {
          function e4(t5) {
            var r4 = this;
            this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = false, this.initialized = false, this.starved = false, this.buffering = true, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = function() {
              r4.initialized && (r4.starved = true), r4.buffering = true;
            }, this.onPlaying = function() {
              r4.initialized || (r4.initialized = true), r4.buffering = false;
            }, this.applyPlaylistData = function(e5) {
              try {
                r4.apply(e5, { ot: n2.CMCDObjectType.MANIFEST, su: !r4.initialized });
              } catch (e6) {
                s2.logger.warn("Could not generate manifest CMCD data.", e6);
              }
            }, this.applyFragmentData = function(e5) {
              try {
                var t6 = e5.frag, i5 = r4.hls.levels[t6.level], a4 = r4.getObjectType(t6), o3 = { d: 1e3 * t6.duration, ot: a4 };
                a4 !== n2.CMCDObjectType.VIDEO && a4 !== n2.CMCDObjectType.AUDIO && a4 != n2.CMCDObjectType.MUXED || (o3.br = i5.bitrate / 1e3, o3.tb = r4.getTopBandwidth(a4) / 1e3, o3.bl = r4.getBufferLength(a4)), r4.apply(e5, o3);
              } catch (e6) {
                s2.logger.warn("Could not generate segment CMCD data.", e6);
              }
            }, this.hls = t5;
            var i4 = this.config = t5.config, a3 = i4.cmcd;
            null != a3 && (i4.pLoader = this.createPlaylistLoader(), i4.fLoader = this.createFragmentLoader(), this.sid = a3.sessionId || e4.uuid(), this.cid = a3.contentId, this.useHeaders = true === a3.useHeaders, this.registerListeners());
          }
          var t4 = e4.prototype;
          return t4.registerListeners = function() {
            var e5 = this.hls;
            e5.on(i3.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e5.on(i3.Events.MEDIA_DETACHED, this.onMediaDetached, this), e5.on(i3.Events.BUFFER_CREATED, this.onBufferCreated, this);
          }, t4.unregisterListeners = function() {
            var e5 = this.hls;
            e5.off(i3.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e5.off(i3.Events.MEDIA_DETACHED, this.onMediaDetached, this), e5.off(i3.Events.BUFFER_CREATED, this.onBufferCreated, this), this.onMediaDetached();
          }, t4.destroy = function() {
            this.unregisterListeners(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null;
          }, t4.onMediaAttached = function(e5, t5) {
            this.media = t5.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying);
          }, t4.onMediaDetached = function() {
            this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null);
          }, t4.onBufferCreated = function(e5, t5) {
            var r4, i4;
            this.audioBuffer = null === (r4 = t5.tracks.audio) || void 0 === r4 ? void 0 : r4.buffer, this.videoBuffer = null === (i4 = t5.tracks.video) || void 0 === i4 ? void 0 : i4.buffer;
          }, t4.createData = function() {
            var e5;
            return { v: n2.CMCDVersion, sf: n2.CMCDStreamingFormat.HLS, sid: this.sid, cid: this.cid, pr: null === (e5 = this.media) || void 0 === e5 ? void 0 : e5.playbackRate, mtp: this.hls.bandwidthEstimate / 1e3 };
          }, t4.apply = function(t5, r4) {
            void 0 === r4 && (r4 = {}), d2(r4, this.createData());
            var i4 = r4.ot === n2.CMCDObjectType.INIT || r4.ot === n2.CMCDObjectType.VIDEO || r4.ot === n2.CMCDObjectType.MUXED;
            if (this.starved && i4 && (r4.bs = true, r4.su = true, this.starved = false), null == r4.su && (r4.su = this.buffering), this.useHeaders) {
              var a3 = e4.toHeaders(r4);
              if (!Object.keys(a3).length)
                return;
              t5.headers || (t5.headers = {}), d2(t5.headers, a3);
            } else {
              var s3 = e4.toQuery(r4);
              if (!s3)
                return;
              t5.url = e4.appendQueryToUri(t5.url, s3);
            }
          }, t4.getObjectType = function(e5) {
            var t5 = e5.type;
            return "subtitle" === t5 ? n2.CMCDObjectType.TIMED_TEXT : "initSegment" === e5.sn ? n2.CMCDObjectType.INIT : "audio" === t5 ? n2.CMCDObjectType.AUDIO : "main" === t5 ? this.hls.audioTracks.length ? n2.CMCDObjectType.VIDEO : n2.CMCDObjectType.MUXED : void 0;
          }, t4.getTopBandwidth = function(e5) {
            var t5, r4 = 0, i4 = this.hls;
            if (e5 === n2.CMCDObjectType.AUDIO)
              t5 = i4.audioTracks;
            else {
              var a3 = i4.maxAutoLevel, s3 = a3 > -1 ? a3 + 1 : i4.levels.length;
              t5 = i4.levels.slice(0, s3);
            }
            for (var o3, l3 = u2(t5); !(o3 = l3()).done; ) {
              var c3 = o3.value;
              c3.bitrate > r4 && (r4 = c3.bitrate);
            }
            return r4 > 0 ? r4 : NaN;
          }, t4.getBufferLength = function(e5) {
            var t5 = this.hls.media, r4 = e5 === n2.CMCDObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;
            return r4 && t5 ? 1e3 * a2.BufferHelper.bufferInfo(r4, t5.currentTime, this.config.maxBufferHole).len : NaN;
          }, t4.createPlaylistLoader = function() {
            var e5 = this.config.pLoader, t5 = this.applyPlaylistData, r4 = e5 || this.config.loader;
            return function() {
              function e6(e7) {
                this.loader = void 0, this.loader = new r4(e7);
              }
              var i4 = e6.prototype;
              return i4.destroy = function() {
                this.loader.destroy();
              }, i4.abort = function() {
                this.loader.abort();
              }, i4.load = function(e7, r5, i5) {
                t5(e7), this.loader.load(e7, r5, i5);
              }, l2(e6, [{ key: "stats", get: function() {
                return this.loader.stats;
              } }, { key: "context", get: function() {
                return this.loader.context;
              } }]), e6;
            }();
          }, t4.createFragmentLoader = function() {
            var e5 = this.config.fLoader, t5 = this.applyFragmentData, r4 = e5 || this.config.loader;
            return function() {
              function e6(e7) {
                this.loader = void 0, this.loader = new r4(e7);
              }
              var i4 = e6.prototype;
              return i4.destroy = function() {
                this.loader.destroy();
              }, i4.abort = function() {
                this.loader.abort();
              }, i4.load = function(e7, r5, i5) {
                t5(e7), this.loader.load(e7, r5, i5);
              }, l2(e6, [{ key: "stats", get: function() {
                return this.loader.stats;
              } }, { key: "context", get: function() {
                return this.loader.context;
              } }]), e6;
            }();
          }, e4.uuid = function() {
            var e5 = URL.createObjectURL(new Blob()), t5 = e5.toString();
            return URL.revokeObjectURL(e5), t5.slice(t5.lastIndexOf("/") + 1);
          }, e4.serialize = function(e5) {
            for (var t5, r4 = [], i4 = function(e6) {
              return !Number.isNaN(e6) && null != e6 && "" !== e6 && false !== e6;
            }, n3 = function(e6) {
              return Math.round(e6);
            }, a3 = function(e6) {
              return 100 * n3(e6 / 100);
            }, s3 = { br: n3, d: n3, bl: a3, dl: a3, mtp: a3, nor: function(e6) {
              return encodeURIComponent(e6);
            }, rtp: a3, tb: n3 }, o3 = u2(Object.keys(e5 || {}).sort()); !(t5 = o3()).done; ) {
              var l3 = t5.value, c3 = e5[l3];
              if (i4(c3) && !("v" === l3 && 1 === c3 || "pr" == l3 && 1 === c3)) {
                var d3 = s3[l3];
                d3 && (c3 = d3(c3));
                var h3 = typeof c3, f2 = void 0;
                f2 = "ot" === l3 || "sf" === l3 || "st" === l3 ? l3 + "=" + c3 : "boolean" === h3 ? l3 : "number" === h3 ? l3 + "=" + c3 : l3 + "=" + JSON.stringify(c3), r4.push(f2);
              }
            }
            return r4.join(",");
          }, e4.toHeaders = function(t5) {
            for (var r4 = {}, i4 = ["Object", "Request", "Session", "Status"], n3 = [{}, {}, {}, {}], a3 = { br: 0, d: 0, ot: 0, tb: 0, bl: 1, dl: 1, mtp: 1, nor: 1, nrr: 1, su: 1, cid: 2, pr: 2, sf: 2, sid: 2, st: 2, v: 2, bs: 3, rtp: 3 }, s3 = 0, o3 = Object.keys(t5); s3 < o3.length; s3++) {
              var l3 = o3[s3];
              n3[null != a3[l3] ? a3[l3] : 1][l3] = t5[l3];
            }
            for (var u3 = 0; u3 < n3.length; u3++) {
              var c3 = e4.serialize(n3[u3]);
              c3 && (r4["CMCD-" + i4[u3]] = c3);
            }
            return r4;
          }, e4.toQuery = function(t5) {
            return "CMCD=" + encodeURIComponent(e4.serialize(t5));
          }, e4.appendQueryToUri = function(e5, t5) {
            if (!t5)
              return e5;
            var r4 = e5.includes("?") ? "&" : "?";
            return "" + e5 + r4 + t5;
          }, e4;
        }();
      }
    ), "./src/controller/eme-controller.ts": (
      /*!******************************************!*\
          !*** ./src/controller/eme-controller.ts ***!
          \******************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => u2 });
        var i3 = r3(
          /*! ../events */
          "./src/events.ts"
        ), n2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), a2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), s2 = r3(
          /*! ../utils/mediakeys-helper */
          "./src/utils/mediakeys-helper.ts"
        );
        function o2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        var l2 = function() {
          function e4(e5) {
            this.hls = void 0, this._widevineLicenseUrl = void 0, this._licenseXhrSetup = void 0, this._licenseResponseCallback = void 0, this._emeEnabled = void 0, this._requestMediaKeySystemAccess = void 0, this._drmSystemOptions = void 0, this._config = void 0, this._mediaKeysList = [], this._media = null, this._hasSetMediaKeys = false, this._requestLicenseFailureCount = 0, this.mediaKeysPromise = null, this._onMediaEncrypted = this.onMediaEncrypted.bind(this), this.hls = e5, this._config = e5.config, this._widevineLicenseUrl = this._config.widevineLicenseUrl, this._licenseXhrSetup = this._config.licenseXhrSetup, this._licenseResponseCallback = this._config.licenseResponseCallback, this._emeEnabled = this._config.emeEnabled, this._requestMediaKeySystemAccess = this._config.requestMediaKeySystemAccessFunc, this._drmSystemOptions = this._config.drmSystemOptions, this._registerListeners();
          }
          var t4, r4, l3, u3 = e4.prototype;
          return u3.destroy = function() {
            this._unregisterListeners(), this.hls = this._onMediaEncrypted = null, this._requestMediaKeySystemAccess = null;
          }, u3._registerListeners = function() {
            this.hls.on(i3.Events.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(i3.Events.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(i3.Events.MANIFEST_PARSED, this.onManifestParsed, this);
          }, u3._unregisterListeners = function() {
            this.hls.off(i3.Events.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(i3.Events.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(i3.Events.MANIFEST_PARSED, this.onManifestParsed, this);
          }, u3.getLicenseServerUrl = function(e5) {
            switch (e5) {
              case s2.KeySystems.WIDEVINE:
                if (!this._widevineLicenseUrl)
                  break;
                return this._widevineLicenseUrl;
            }
            throw new Error('no license server URL configured for key-system "' + e5 + '"');
          }, u3._attemptKeySystemAccess = function(e5, t5, r5) {
            var i4 = this, n3 = function(e6, t6, r6, i5) {
              if (e6 === s2.KeySystems.WIDEVINE)
                return function(e7, t7, r7) {
                  var i6 = { audioCapabilities: [], videoCapabilities: [] };
                  return e7.forEach(function(e8) {
                    i6.audioCapabilities.push({ contentType: 'audio/mp4; codecs="' + e8 + '"', robustness: r7.audioRobustness || "" });
                  }), t7.forEach(function(e8) {
                    i6.videoCapabilities.push({ contentType: 'video/mp4; codecs="' + e8 + '"', robustness: r7.videoRobustness || "" });
                  }), [i6];
                }(t6, r6, i5);
              throw new Error("Unknown key-system: " + e6);
            }(e5, t5, r5, this._drmSystemOptions);
            a2.logger.log("Requesting encrypted media key-system access");
            var o3 = this.requestMediaKeySystemAccess(e5, n3);
            this.mediaKeysPromise = o3.then(function(t6) {
              return i4._onMediaKeySystemAccessObtained(e5, t6);
            }), o3.catch(function(t6) {
              a2.logger.error('Failed to obtain key-system "' + e5 + '" access:', t6);
            });
          }, u3._onMediaKeySystemAccessObtained = function(e5, t5) {
            var r5 = this;
            a2.logger.log('Access for key-system "' + e5 + '" obtained');
            var i4 = { mediaKeysSessionInitialized: false, mediaKeySystemAccess: t5, mediaKeySystemDomain: e5 };
            this._mediaKeysList.push(i4);
            var n3 = Promise.resolve().then(function() {
              return t5.createMediaKeys();
            }).then(function(t6) {
              return i4.mediaKeys = t6, a2.logger.log('Media-keys created for key-system "' + e5 + '"'), r5._onMediaKeysCreated(), t6;
            });
            return n3.catch(function(e6) {
              a2.logger.error("Failed to create media-keys:", e6);
            }), n3;
          }, u3._onMediaKeysCreated = function() {
            var e5 = this;
            this._mediaKeysList.forEach(function(t5) {
              t5.mediaKeysSession || (t5.mediaKeysSession = t5.mediaKeys.createSession(), e5._onNewMediaKeySession(t5.mediaKeysSession));
            });
          }, u3._onNewMediaKeySession = function(e5) {
            var t5 = this;
            a2.logger.log("New key-system session " + e5.sessionId), e5.addEventListener("message", function(r5) {
              t5._onKeySessionMessage(e5, r5.message);
            }, false);
          }, u3._onKeySessionMessage = function(e5, t5) {
            a2.logger.log("Got EME message event, creating license request"), this._requestLicense(t5, function(t6) {
              a2.logger.log("Received license data (length: " + (t6 ? t6.byteLength : t6) + "), updating key-session"), e5.update(t6).catch(function(e6) {
                a2.logger.warn("Updating key-session failed: " + e6);
              });
            });
          }, u3.onMediaEncrypted = function(e5) {
            var t5 = this;
            if (a2.logger.log('Media is encrypted using "' + e5.initDataType + '" init data type'), !this.mediaKeysPromise)
              return a2.logger.error("Fatal: Media is encrypted but no CDM access or no keys have been requested"), void this.hls.trigger(i3.Events.ERROR, { type: n2.ErrorTypes.KEY_SYSTEM_ERROR, details: n2.ErrorDetails.KEY_SYSTEM_NO_KEYS, fatal: true });
            var r5 = function(r6) {
              t5._media && (t5._attemptSetMediaKeys(r6), t5._generateRequestWithPreferredKeySession(e5.initDataType, e5.initData));
            };
            this.mediaKeysPromise.then(r5).catch(r5);
          }, u3._attemptSetMediaKeys = function(e5) {
            if (!this._media)
              throw new Error("Attempted to set mediaKeys without first attaching a media element");
            if (!this._hasSetMediaKeys) {
              var t5 = this._mediaKeysList[0];
              if (!t5 || !t5.mediaKeys)
                return a2.logger.error("Fatal: Media is encrypted but no CDM access or no keys have been obtained yet"), void this.hls.trigger(i3.Events.ERROR, { type: n2.ErrorTypes.KEY_SYSTEM_ERROR, details: n2.ErrorDetails.KEY_SYSTEM_NO_KEYS, fatal: true });
              a2.logger.log("Setting keys for encrypted media"), this._media.setMediaKeys(t5.mediaKeys), this._hasSetMediaKeys = true;
            }
          }, u3._generateRequestWithPreferredKeySession = function(e5, t5) {
            var r5 = this, s3 = this._mediaKeysList[0];
            if (!s3)
              return a2.logger.error("Fatal: Media is encrypted but not any key-system access has been obtained yet"), void this.hls.trigger(i3.Events.ERROR, { type: n2.ErrorTypes.KEY_SYSTEM_ERROR, details: n2.ErrorDetails.KEY_SYSTEM_NO_ACCESS, fatal: true });
            if (s3.mediaKeysSessionInitialized)
              a2.logger.warn("Key-Session already initialized but requested again");
            else {
              var o3 = s3.mediaKeysSession;
              if (!o3)
                return a2.logger.error("Fatal: Media is encrypted but no key-session existing"), void this.hls.trigger(i3.Events.ERROR, { type: n2.ErrorTypes.KEY_SYSTEM_ERROR, details: n2.ErrorDetails.KEY_SYSTEM_NO_SESSION, fatal: true });
              if (!t5)
                return a2.logger.warn("Fatal: initData required for generating a key session is null"), void this.hls.trigger(i3.Events.ERROR, { type: n2.ErrorTypes.KEY_SYSTEM_ERROR, details: n2.ErrorDetails.KEY_SYSTEM_NO_INIT_DATA, fatal: true });
              a2.logger.log('Generating key-session request for "' + e5 + '" init data type'), s3.mediaKeysSessionInitialized = true, o3.generateRequest(e5, t5).then(function() {
                a2.logger.debug("Key-session generation succeeded");
              }).catch(function(e6) {
                a2.logger.error("Error generating key-session request:", e6), r5.hls.trigger(i3.Events.ERROR, { type: n2.ErrorTypes.KEY_SYSTEM_ERROR, details: n2.ErrorDetails.KEY_SYSTEM_NO_SESSION, fatal: false });
              });
            }
          }, u3._createLicenseXhr = function(e5, t5, r5) {
            var i4 = new XMLHttpRequest();
            i4.responseType = "arraybuffer", i4.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, i4, e5, t5, r5);
            var n3 = this._licenseXhrSetup;
            if (n3)
              try {
                n3.call(this.hls, i4, e5), n3 = void 0;
              } catch (e6) {
                a2.logger.error(e6);
              }
            try {
              i4.readyState || i4.open("POST", e5, true), n3 && n3.call(this.hls, i4, e5);
            } catch (e6) {
              throw new Error("issue setting up KeySystem license XHR " + e6);
            }
            return i4;
          }, u3._onLicenseRequestReadyStageChange = function(e5, t5, r5, s3) {
            if (4 === e5.readyState)
              if (200 === e5.status) {
                this._requestLicenseFailureCount = 0, a2.logger.log("License request succeeded");
                var o3 = e5.response, l4 = this._licenseResponseCallback;
                if (l4)
                  try {
                    o3 = l4.call(this.hls, e5, t5);
                  } catch (e6) {
                    a2.logger.error(e6);
                  }
                s3(o3);
              } else {
                if (a2.logger.error("License Request XHR failed (" + t5 + "). Status: " + e5.status + " (" + e5.statusText + ")"), this._requestLicenseFailureCount++, this._requestLicenseFailureCount > 3)
                  return void this.hls.trigger(i3.Events.ERROR, { type: n2.ErrorTypes.KEY_SYSTEM_ERROR, details: n2.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED, fatal: true });
                var u4 = 3 - this._requestLicenseFailureCount + 1;
                a2.logger.warn("Retrying license request, " + u4 + " attempts left"), this._requestLicense(r5, s3);
              }
          }, u3._generateLicenseRequestChallenge = function(e5, t5) {
            if (e5.mediaKeySystemDomain === s2.KeySystems.WIDEVINE)
              return t5;
            throw new Error("unsupported key-system: " + e5.mediaKeySystemDomain);
          }, u3._requestLicense = function(e5, t5) {
            a2.logger.log("Requesting content license for key-system");
            var r5 = this._mediaKeysList[0];
            if (!r5)
              return a2.logger.error("Fatal error: Media is encrypted but no key-system access has been obtained yet"), void this.hls.trigger(i3.Events.ERROR, { type: n2.ErrorTypes.KEY_SYSTEM_ERROR, details: n2.ErrorDetails.KEY_SYSTEM_NO_ACCESS, fatal: true });
            try {
              var s3 = this.getLicenseServerUrl(r5.mediaKeySystemDomain), o3 = this._createLicenseXhr(s3, e5, t5);
              a2.logger.log("Sending license request to URL: " + s3);
              var l4 = this._generateLicenseRequestChallenge(r5, e5);
              o3.send(l4);
            } catch (e6) {
              a2.logger.error("Failure requesting DRM license: " + e6), this.hls.trigger(i3.Events.ERROR, { type: n2.ErrorTypes.KEY_SYSTEM_ERROR, details: n2.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED, fatal: true });
            }
          }, u3.onMediaAttached = function(e5, t5) {
            if (this._emeEnabled) {
              var r5 = t5.media;
              this._media = r5, r5.addEventListener("encrypted", this._onMediaEncrypted);
            }
          }, u3.onMediaDetached = function() {
            var e5 = this._media, t5 = this._mediaKeysList;
            e5 && (e5.removeEventListener("encrypted", this._onMediaEncrypted), this._media = null, this._mediaKeysList = [], Promise.all(t5.map(function(e6) {
              if (e6.mediaKeysSession)
                return e6.mediaKeysSession.close().catch(function() {
                });
            })).then(function() {
              return e5.setMediaKeys(null);
            }).catch(function() {
            }));
          }, u3.onManifestParsed = function(e5, t5) {
            if (this._emeEnabled) {
              var r5 = t5.levels.map(function(e6) {
                return e6.audioCodec;
              }).filter(function(e6) {
                return !!e6;
              }), i4 = t5.levels.map(function(e6) {
                return e6.videoCodec;
              }).filter(function(e6) {
                return !!e6;
              });
              this._attemptKeySystemAccess(s2.KeySystems.WIDEVINE, r5, i4);
            }
          }, t4 = e4, (r4 = [{ key: "requestMediaKeySystemAccess", get: function() {
            if (!this._requestMediaKeySystemAccess)
              throw new Error("No requestMediaKeySystemAccess function configured");
            return this._requestMediaKeySystemAccess;
          } }]) && o2(t4.prototype, r4), l3 && o2(t4, l3), Object.defineProperty(t4, "prototype", { writable: false }), e4;
        }();
        const u2 = l2;
      }
    ), "./src/controller/fps-controller.ts": (
      /*!******************************************!*\
          !*** ./src/controller/fps-controller.ts ***!
          \******************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => s2 });
        var i3 = r3(
          /*! ../events */
          "./src/events.ts"
        ), n2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), a2 = function() {
          function e4(e5) {
            this.hls = void 0, this.isVideoPlaybackQualityAvailable = false, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e5, this.registerListeners();
          }
          var t4 = e4.prototype;
          return t4.setStreamController = function(e5) {
            this.streamController = e5;
          }, t4.registerListeners = function() {
            this.hls.on(i3.Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
          }, t4.unregisterListeners = function() {
            this.hls.off(i3.Events.MEDIA_ATTACHING, this.onMediaAttaching);
          }, t4.destroy = function() {
            this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = false, this.media = null;
          }, t4.onMediaAttaching = function(e5, t5) {
            var r4 = this.hls.config;
            if (r4.capLevelOnFPSDrop) {
              var i4 = t5.media instanceof self.HTMLVideoElement ? t5.media : null;
              this.media = i4, i4 && "function" == typeof i4.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = true), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), r4.fpsDroppedMonitoringPeriod);
            }
          }, t4.checkFPS = function(e5, t5, r4) {
            var a3 = performance.now();
            if (t5) {
              if (this.lastTime) {
                var s3 = a3 - this.lastTime, o2 = r4 - this.lastDroppedFrames, l2 = t5 - this.lastDecodedFrames, u2 = 1e3 * o2 / s3, c2 = this.hls;
                if (c2.trigger(i3.Events.FPS_DROP, { currentDropped: o2, currentDecoded: l2, totalDroppedFrames: r4 }), u2 > 0 && o2 > c2.config.fpsDroppedMonitoringThreshold * l2) {
                  var d2 = c2.currentLevel;
                  n2.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + d2), d2 > 0 && (-1 === c2.autoLevelCapping || c2.autoLevelCapping >= d2) && (d2 -= 1, c2.trigger(i3.Events.FPS_DROP_LEVEL_CAPPING, { level: d2, droppedLevel: c2.currentLevel }), c2.autoLevelCapping = d2, this.streamController.nextLevelSwitch());
                }
              }
              this.lastTime = a3, this.lastDroppedFrames = r4, this.lastDecodedFrames = t5;
            }
          }, t4.checkFPSInterval = function() {
            var e5 = this.media;
            if (e5)
              if (this.isVideoPlaybackQualityAvailable) {
                var t5 = e5.getVideoPlaybackQuality();
                this.checkFPS(e5, t5.totalVideoFrames, t5.droppedVideoFrames);
              } else
                this.checkFPS(e5, e5.webkitDecodedFrameCount, e5.webkitDroppedFrameCount);
          }, e4;
        }();
        const s2 = a2;
      }
    ), "./src/controller/fragment-finders.ts": (
      /*!********************************************!*\
          !*** ./src/controller/fragment-finders.ts ***!
          \********************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { findFragWithCC: () => u2, findFragmentByPDT: () => a2, findFragmentByPTS: () => s2, fragmentWithinToleranceTest: () => o2, pdtWithinToleranceTest: () => l2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ../utils/binary-search */
          "./src/utils/binary-search.ts"
        );
        function a2(e4, t4, r4) {
          if (null === t4 || !Array.isArray(e4) || !e4.length || !(0, i3.isFiniteNumber)(t4))
            return null;
          if (t4 < (e4[0].programDateTime || 0))
            return null;
          if (t4 >= (e4[e4.length - 1].endProgramDateTime || 0))
            return null;
          r4 = r4 || 0;
          for (var n3 = 0; n3 < e4.length; ++n3) {
            var a3 = e4[n3];
            if (l2(t4, r4, a3))
              return a3;
          }
          return null;
        }
        function s2(e4, t4, r4, i4) {
          void 0 === r4 && (r4 = 0), void 0 === i4 && (i4 = 0);
          var a3 = null;
          if (e4 ? a3 = t4[e4.sn - t4[0].sn + 1] || null : 0 === r4 && 0 === t4[0].start && (a3 = t4[0]), a3 && 0 === o2(r4, i4, a3))
            return a3;
          var s3 = n2.default.search(t4, o2.bind(null, r4, i4));
          return s3 || a3;
        }
        function o2(e4, t4, r4) {
          void 0 === e4 && (e4 = 0), void 0 === t4 && (t4 = 0);
          var i4 = Math.min(t4, r4.duration + (r4.deltaPTS ? r4.deltaPTS : 0));
          return r4.start + r4.duration - i4 <= e4 ? 1 : r4.start - i4 > e4 && r4.start ? -1 : 0;
        }
        function l2(e4, t4, r4) {
          var i4 = 1e3 * Math.min(t4, r4.duration + (r4.deltaPTS ? r4.deltaPTS : 0));
          return (r4.endProgramDateTime || 0) - i4 > e4;
        }
        function u2(e4, t4) {
          return n2.default.search(e4, function(e5) {
            return e5.cc < t4 ? 1 : e5.cc > t4 ? -1 : 0;
          });
        }
      }
    ), "./src/controller/fragment-tracker.ts": (
      /*!********************************************!*\
          !*** ./src/controller/fragment-tracker.ts ***!
          \********************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { FragmentState: () => i3, FragmentTracker: () => s2 });
        var i3, n2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), a2 = r3(
          /*! ../types/loader */
          "./src/types/loader.ts"
        );
        !function(e4) {
          e4.NOT_LOADED = "NOT_LOADED", e4.APPENDING = "APPENDING", e4.PARTIAL = "PARTIAL", e4.OK = "OK";
        }(i3 || (i3 = {}));
        var s2 = function() {
          function e4(e5) {
            this.activeFragment = null, this.activeParts = null, this.fragments = /* @__PURE__ */ Object.create(null), this.timeRanges = /* @__PURE__ */ Object.create(null), this.bufferPadding = 0.2, this.hls = void 0, this.hls = e5, this._registerListeners();
          }
          var t4 = e4.prototype;
          return t4._registerListeners = function() {
            var e5 = this.hls;
            e5.on(n2.Events.BUFFER_APPENDED, this.onBufferAppended, this), e5.on(n2.Events.FRAG_BUFFERED, this.onFragBuffered, this), e5.on(n2.Events.FRAG_LOADED, this.onFragLoaded, this);
          }, t4._unregisterListeners = function() {
            var e5 = this.hls;
            e5.off(n2.Events.BUFFER_APPENDED, this.onBufferAppended, this), e5.off(n2.Events.FRAG_BUFFERED, this.onFragBuffered, this), e5.off(n2.Events.FRAG_LOADED, this.onFragLoaded, this);
          }, t4.destroy = function() {
            this._unregisterListeners(), this.fragments = this.timeRanges = null;
          }, t4.getAppendedFrag = function(e5, t5) {
            if (t5 === a2.PlaylistLevelType.MAIN) {
              var r4 = this.activeFragment, i4 = this.activeParts;
              if (!r4)
                return null;
              if (i4)
                for (var n3 = i4.length; n3--; ) {
                  var s3 = i4[n3], o3 = s3 ? s3.end : r4.appendedPTS;
                  if (s3.start <= e5 && void 0 !== o3 && e5 <= o3)
                    return n3 > 9 && (this.activeParts = i4.slice(n3 - 9)), s3;
                }
              else if (r4.start <= e5 && void 0 !== r4.appendedPTS && e5 <= r4.appendedPTS)
                return r4;
            }
            return this.getBufferedFrag(e5, t5);
          }, t4.getBufferedFrag = function(e5, t5) {
            for (var r4 = this.fragments, i4 = Object.keys(r4), n3 = i4.length; n3--; ) {
              var a3 = r4[i4[n3]];
              if ((null == a3 ? void 0 : a3.body.type) === t5 && a3.buffered) {
                var s3 = a3.body;
                if (s3.start <= e5 && e5 <= s3.end)
                  return s3;
              }
            }
            return null;
          }, t4.detectEvictedFragments = function(e5, t5, r4) {
            var i4 = this;
            Object.keys(this.fragments).forEach(function(n3) {
              var a3 = i4.fragments[n3];
              if (a3)
                if (a3.buffered) {
                  var s3 = a3.range[e5];
                  s3 && s3.time.some(function(e6) {
                    var r5 = !i4.isTimeBuffered(e6.startPTS, e6.endPTS, t5);
                    return r5 && i4.removeFragment(a3.body), r5;
                  });
                } else
                  a3.body.type === r4 && i4.removeFragment(a3.body);
            });
          }, t4.detectPartialFragments = function(e5) {
            var t5 = this, r4 = this.timeRanges, i4 = e5.frag, n3 = e5.part;
            if (r4 && "initSegment" !== i4.sn) {
              var a3 = l2(i4), s3 = this.fragments[a3];
              s3 && (Object.keys(r4).forEach(function(e6) {
                var a4 = i4.elementaryStreams[e6];
                if (a4) {
                  var o3 = r4[e6], l3 = null !== n3 || true === a4.partial;
                  s3.range[e6] = t5.getBufferedTimes(i4, n3, l3, o3);
                }
              }), s3.loaded = null, Object.keys(s3.range).length ? s3.buffered = true : this.removeFragment(s3.body));
            }
          }, t4.fragBuffered = function(e5) {
            var t5 = l2(e5), r4 = this.fragments[t5];
            r4 && (r4.loaded = null, r4.buffered = true);
          }, t4.getBufferedTimes = function(e5, t5, r4, i4) {
            for (var n3 = { time: [], partial: r4 }, a3 = t5 ? t5.start : e5.start, s3 = t5 ? t5.end : e5.end, o3 = e5.minEndPTS || s3, l3 = e5.maxStartPTS || a3, u2 = 0; u2 < i4.length; u2++) {
              var c2 = i4.start(u2) - this.bufferPadding, d2 = i4.end(u2) + this.bufferPadding;
              if (l3 >= c2 && o3 <= d2) {
                n3.time.push({ startPTS: Math.max(a3, i4.start(u2)), endPTS: Math.min(s3, i4.end(u2)) });
                break;
              }
              if (a3 < d2 && s3 > c2)
                n3.partial = true, n3.time.push({ startPTS: Math.max(a3, i4.start(u2)), endPTS: Math.min(s3, i4.end(u2)) });
              else if (s3 <= c2)
                break;
            }
            return n3;
          }, t4.getPartialFragment = function(e5) {
            var t5, r4, i4, n3 = null, a3 = 0, s3 = this.bufferPadding, l3 = this.fragments;
            return Object.keys(l3).forEach(function(u2) {
              var c2 = l3[u2];
              c2 && o2(c2) && (r4 = c2.body.start - s3, i4 = c2.body.end + s3, e5 >= r4 && e5 <= i4 && (t5 = Math.min(e5 - r4, i4 - e5), a3 <= t5 && (n3 = c2.body, a3 = t5)));
            }), n3;
          }, t4.getState = function(e5) {
            var t5 = l2(e5), r4 = this.fragments[t5];
            return r4 ? r4.buffered ? o2(r4) ? i3.PARTIAL : i3.OK : i3.APPENDING : i3.NOT_LOADED;
          }, t4.isTimeBuffered = function(e5, t5, r4) {
            for (var i4, n3, a3 = 0; a3 < r4.length; a3++) {
              if (i4 = r4.start(a3) - this.bufferPadding, n3 = r4.end(a3) + this.bufferPadding, e5 >= i4 && t5 <= n3)
                return true;
              if (t5 <= i4)
                return false;
            }
            return false;
          }, t4.onFragLoaded = function(e5, t5) {
            var r4 = t5.frag, i4 = t5.part;
            if ("initSegment" !== r4.sn && !r4.bitrateTest && !i4) {
              var n3 = l2(r4);
              this.fragments[n3] = { body: r4, loaded: t5, buffered: false, range: /* @__PURE__ */ Object.create(null) };
            }
          }, t4.onBufferAppended = function(e5, t5) {
            var r4 = this, i4 = t5.frag, n3 = t5.part, s3 = t5.timeRanges;
            if (i4.type === a2.PlaylistLevelType.MAIN)
              if (this.activeFragment = i4, n3) {
                var o3 = this.activeParts;
                o3 || (this.activeParts = o3 = []), o3.push(n3);
              } else
                this.activeParts = null;
            this.timeRanges = s3, Object.keys(s3).forEach(function(e6) {
              var t6 = s3[e6];
              if (r4.detectEvictedFragments(e6, t6), !n3)
                for (var a3 = 0; a3 < t6.length; a3++)
                  i4.appendedPTS = Math.max(t6.end(a3), i4.appendedPTS || 0);
            });
          }, t4.onFragBuffered = function(e5, t5) {
            this.detectPartialFragments(t5);
          }, t4.hasFragment = function(e5) {
            var t5 = l2(e5);
            return !!this.fragments[t5];
          }, t4.removeFragmentsInRange = function(e5, t5, r4) {
            var i4 = this;
            Object.keys(this.fragments).forEach(function(n3) {
              var a3 = i4.fragments[n3];
              if (a3 && a3.buffered) {
                var s3 = a3.body;
                s3.type === r4 && s3.start < t5 && s3.end > e5 && i4.removeFragment(s3);
              }
            });
          }, t4.removeFragment = function(e5) {
            var t5 = l2(e5);
            e5.stats.loaded = 0, e5.clearElementaryStreamInfo(), delete this.fragments[t5];
          }, t4.removeAllFragments = function() {
            this.fragments = /* @__PURE__ */ Object.create(null), this.activeFragment = null, this.activeParts = null;
          }, e4;
        }();
        function o2(e4) {
          var t4, r4;
          return e4.buffered && ((null === (t4 = e4.range.video) || void 0 === t4 ? void 0 : t4.partial) || (null === (r4 = e4.range.audio) || void 0 === r4 ? void 0 : r4.partial));
        }
        function l2(e4) {
          return e4.type + "_" + e4.level + "_" + e4.urlId + "_" + e4.sn;
        }
      }
    ), "./src/controller/gap-controller.ts": (
      /*!******************************************!*\
          !*** ./src/controller/gap-controller.ts ***!
          \******************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { MAX_START_GAP_JUMP: () => l2, SKIP_BUFFER_HOLE_STEP_SECONDS: () => u2, SKIP_BUFFER_RANGE_START: () => c2, STALL_MINIMUM_DURATION_MS: () => o2, default: () => d2 });
        var i3 = r3(
          /*! ../utils/buffer-helper */
          "./src/utils/buffer-helper.ts"
        ), n2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), a2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), s2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), o2 = 250, l2 = 2, u2 = 0.1, c2 = 0.05, d2 = function() {
          function e4(e5, t5, r4, i4) {
            this.config = void 0, this.media = null, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = false, this.stalled = null, this.moved = false, this.seeking = false, this.config = e5, this.media = t5, this.fragmentTracker = r4, this.hls = i4;
          }
          var t4 = e4.prototype;
          return t4.destroy = function() {
            this.media = null, this.hls = this.fragmentTracker = null;
          }, t4.poll = function(e5, t5) {
            var r4 = this.config, n3 = this.media, a3 = this.stalled;
            if (null !== n3) {
              var u3 = n3.currentTime, c3 = n3.seeking, d3 = this.seeking && !c3, h2 = !this.seeking && c3;
              if (this.seeking = c3, u3 === e5) {
                if ((h2 || d3) && (this.stalled = null), !(n3.paused && !c3 || n3.ended || 0 === n3.playbackRate) && i3.BufferHelper.getBuffered(n3).length) {
                  var f2 = i3.BufferHelper.bufferInfo(n3, u3, 0), p2 = f2.len > 0, g2 = f2.nextStart || 0;
                  if (p2 || g2) {
                    if (c3) {
                      var v2 = f2.len > l2, m2 = !g2 || t5 && t5.start <= u3 || g2 - u3 > l2 && !this.fragmentTracker.getPartialFragment(u3);
                      if (v2 || m2)
                        return;
                      this.moved = false;
                    }
                    if (!this.moved && null !== this.stalled) {
                      var y2, A2 = Math.max(g2, f2.start || 0) - u3, E2 = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null, T2 = (null == E2 || null === (y2 = E2.details) || void 0 === y2 ? void 0 : y2.live) ? 2 * E2.details.targetduration : l2;
                      if (A2 > 0 && A2 <= T2)
                        return void this._trySkipBufferHole(null);
                    }
                    var b2 = self.performance.now();
                    if (null !== a3) {
                      var k2 = b2 - a3;
                      if (c3 || !(k2 >= o2) || (this._reportStall(f2), this.media)) {
                        var S2 = i3.BufferHelper.bufferInfo(n3, u3, r4.maxBufferHole);
                        this._tryFixBufferStall(S2, k2);
                      }
                    } else
                      this.stalled = b2;
                  }
                }
              } else if (this.moved = true, null !== a3) {
                if (this.stallReported) {
                  var _2 = self.performance.now() - a3;
                  s2.logger.warn("playback not stuck anymore @" + u3 + ", after " + Math.round(_2) + "ms"), this.stallReported = false;
                }
                this.stalled = null, this.nudgeRetry = 0;
              }
            }
          }, t4._tryFixBufferStall = function(e5, t5) {
            var r4 = this.config, i4 = this.fragmentTracker, n3 = this.media;
            if (null !== n3) {
              var a3 = n3.currentTime, o3 = i4.getPartialFragment(a3);
              if (o3 && (this._trySkipBufferHole(o3) || !this.media))
                return;
              e5.len > r4.maxBufferHole && t5 > 1e3 * r4.highBufferWatchdogPeriod && (s2.logger.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer());
            }
          }, t4._reportStall = function(e5) {
            var t5 = this.hls, r4 = this.media;
            !this.stallReported && r4 && (this.stallReported = true, s2.logger.warn("Playback stalling at @" + r4.currentTime + " due to low buffer (" + JSON.stringify(e5) + ")"), t5.trigger(a2.Events.ERROR, { type: n2.ErrorTypes.MEDIA_ERROR, details: n2.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false, buffer: e5.len }));
          }, t4._trySkipBufferHole = function(e5) {
            var t5 = this.config, r4 = this.hls, o3 = this.media;
            if (null === o3)
              return 0;
            for (var l3 = o3.currentTime, d3 = 0, h2 = i3.BufferHelper.getBuffered(o3), f2 = 0; f2 < h2.length; f2++) {
              var p2 = h2.start(f2);
              if (l3 + t5.maxBufferHole >= d3 && l3 < p2) {
                var g2 = Math.max(p2 + c2, o3.currentTime + u2);
                return s2.logger.warn("skipping hole, adjusting currentTime from " + l3 + " to " + g2), this.moved = true, this.stalled = null, o3.currentTime = g2, e5 && r4.trigger(a2.Events.ERROR, { type: n2.ErrorTypes.MEDIA_ERROR, details: n2.ErrorDetails.BUFFER_SEEK_OVER_HOLE, fatal: false, reason: "fragment loaded with buffer holes, seeking from " + l3 + " to " + g2, frag: e5 }), g2;
              }
              d3 = h2.end(f2);
            }
            return 0;
          }, t4._tryNudgeBuffer = function() {
            var e5 = this.config, t5 = this.hls, r4 = this.media, i4 = this.nudgeRetry;
            if (null !== r4) {
              var o3 = r4.currentTime;
              if (this.nudgeRetry++, i4 < e5.nudgeMaxRetry) {
                var l3 = o3 + (i4 + 1) * e5.nudgeOffset;
                s2.logger.warn("Nudging 'currentTime' from " + o3 + " to " + l3), r4.currentTime = l3, t5.trigger(a2.Events.ERROR, { type: n2.ErrorTypes.MEDIA_ERROR, details: n2.ErrorDetails.BUFFER_NUDGE_ON_STALL, fatal: false });
              } else
                s2.logger.error("Playhead still not moving while enough data buffered @" + o3 + " after " + e5.nudgeMaxRetry + " nudges"), t5.trigger(a2.Events.ERROR, { type: n2.ErrorTypes.MEDIA_ERROR, details: n2.ErrorDetails.BUFFER_STALLED_ERROR, fatal: true });
            }
          }, e4;
        }();
      }
    ), "./src/controller/id3-track-controller.ts": (
      /*!************************************************!*\
          !*** ./src/controller/id3-track-controller.ts ***!
          \************************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => f2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), a2 = r3(
          /*! ../utils/texttrack-utils */
          "./src/utils/texttrack-utils.ts"
        ), s2 = r3(
          /*! ../demux/id3 */
          "./src/demux/id3.ts"
        ), o2 = r3(
          /*! ../loader/date-range */
          "./src/loader/date-range.ts"
        ), l2 = r3(
          /*! ../types/demuxer */
          "./src/types/demuxer.ts"
        );
        function u2() {
          return self.WebKitDataCue || self.VTTCue || self.TextTrackCue;
        }
        var c2 = function() {
          var e4 = u2();
          try {
            new e4(0, Number.POSITIVE_INFINITY, "");
          } catch (e5) {
            return Number.MAX_VALUE;
          }
          return Number.POSITIVE_INFINITY;
        }();
        function d2(e4, t4) {
          return e4.getTime() / 1e3 - t4;
        }
        var h2 = function() {
          function e4(e5) {
            this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = e5, this._registerListeners();
          }
          var t4 = e4.prototype;
          return t4.destroy = function() {
            this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = null;
          }, t4._registerListeners = function() {
            var e5 = this.hls;
            e5.on(n2.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e5.on(n2.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e5.on(n2.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.on(n2.Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e5.on(n2.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), e5.on(n2.Events.LEVEL_UPDATED, this.onLevelUpdated, this);
          }, t4._unregisterListeners = function() {
            var e5 = this.hls;
            e5.off(n2.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e5.off(n2.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e5.off(n2.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.off(n2.Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e5.off(n2.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), e5.off(n2.Events.LEVEL_UPDATED, this.onLevelUpdated, this);
          }, t4.onMediaAttached = function(e5, t5) {
            this.media = t5.media;
          }, t4.onMediaDetaching = function() {
            this.id3Track && ((0, a2.clearCurrentCues)(this.id3Track), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {});
          }, t4.onManifestLoading = function() {
            this.dateRangeCuesAppended = {};
          }, t4.createTrack = function(e5) {
            var t5 = this.getID3Track(e5.textTracks);
            return t5.mode = "hidden", t5;
          }, t4.getID3Track = function(e5) {
            if (this.media) {
              for (var t5 = 0; t5 < e5.length; t5++) {
                var r4 = e5[t5];
                if ("metadata" === r4.kind && "id3" === r4.label)
                  return (0, a2.sendAddTrackEvent)(r4, this.media), r4;
              }
              return this.media.addTextTrack("metadata", "id3");
            }
          }, t4.onFragParsingMetadata = function(e5, t5) {
            if (this.media) {
              var r4 = this.hls.config, i4 = r4.enableEmsgMetadataCues, n3 = r4.enableID3MetadataCues;
              if (i4 || n3) {
                t5.frag;
                var a3 = t5.samples;
                t5.details, this.id3Track || (this.id3Track = this.createTrack(this.media));
                for (var o3 = u2(), d3 = 0; d3 < a3.length; d3++) {
                  var h3 = a3[d3].type;
                  if ((h3 !== l2.MetadataSchema.emsg || i4) && n3) {
                    var f3 = s2.getID3Frames(a3[d3].data);
                    if (f3) {
                      var p2 = a3[d3].pts, g2 = p2 + a3[d3].duration;
                      g2 > c2 && (g2 = c2), g2 - p2 <= 0 && (g2 = p2 + 0.25);
                      for (var v2 = 0; v2 < f3.length; v2++) {
                        var m2 = f3[v2];
                        if (!s2.isTimeStampFrame(m2)) {
                          this.updateId3CueEnds(p2);
                          var y2 = new o3(p2, g2, "");
                          y2.value = m2, h3 && (y2.type = h3), this.id3Track.addCue(y2);
                        }
                      }
                    }
                  }
                }
              }
            }
          }, t4.updateId3CueEnds = function(e5) {
            var t5, r4 = null === (t5 = this.id3Track) || void 0 === t5 ? void 0 : t5.cues;
            if (r4)
              for (var i4 = r4.length; i4--; ) {
                var n3 = r4[i4];
                n3.startTime < e5 && n3.endTime === c2 && (n3.endTime = e5);
              }
          }, t4.onBufferFlushing = function(e5, t5) {
            var r4 = t5.startOffset, i4 = t5.endOffset, n3 = t5.type, s3 = this.id3Track, o3 = this.hls;
            if (o3) {
              var u3, c3 = o3.config, d3 = c3.enableEmsgMetadataCues, h3 = c3.enableID3MetadataCues;
              s3 && (d3 || h3) && (u3 = "audio" === n3 ? function(e6) {
                return e6.type === l2.MetadataSchema.audioId3 && h3;
              } : "video" === n3 ? function(e6) {
                return e6.type === l2.MetadataSchema.emsg && d3;
              } : function(e6) {
                return e6.type === l2.MetadataSchema.audioId3 && h3 || e6.type === l2.MetadataSchema.emsg && d3;
              }, (0, a2.removeCuesInRange)(s3, r4, i4, u3));
            }
          }, t4.onLevelUpdated = function(e5, t5) {
            var r4 = this, n3 = t5.details;
            if (this.media && n3.hasProgramDateTime && this.hls.config.enableDateRangeMetadataCues) {
              var a3 = this.dateRangeCuesAppended, s3 = this.id3Track, h3 = n3.dateRanges, f3 = Object.keys(h3);
              if (s3)
                for (var p2 = Object.keys(a3).filter(function(e6) {
                  return !f3.includes(e6);
                }), g2 = function(e6) {
                  var t6 = p2[e6];
                  Object.keys(a3[t6].cues).forEach(function(e7) {
                    s3.removeCue(a3[t6].cues[e7]);
                  }), delete a3[t6];
                }, v2 = p2.length; v2--; )
                  g2(v2);
              var m2 = n3.fragments[n3.fragments.length - 1];
              if (0 !== f3.length && (0, i3.isFiniteNumber)(null == m2 ? void 0 : m2.programDateTime)) {
                this.id3Track || (this.id3Track = this.createTrack(this.media));
                for (var y2 = m2.programDateTime / 1e3 - m2.start, A2 = u2(), E2 = function(e6) {
                  var t6 = f3[e6], i4 = h3[t6], n4 = a3[t6], s4 = (null == n4 ? void 0 : n4.cues) || {}, u3 = (null == n4 ? void 0 : n4.durationKnown) || false, p3 = d2(i4.startDate, y2), g3 = c2, v3 = i4.endDate;
                  if (v3)
                    g3 = d2(v3, y2), u3 = true;
                  else if (i4.endOnNext && !u3) {
                    var m3 = f3.reduce(function(e7, t7) {
                      var r5 = h3[t7];
                      return r5.class === i4.class && r5.id !== t7 && r5.startDate > i4.startDate && e7.push(r5), e7;
                    }, []).sort(function(e7, t7) {
                      return e7.startDate.getTime() - t7.startDate.getTime();
                    })[0];
                    m3 && (g3 = d2(m3.startDate, y2), u3 = true);
                  }
                  for (var E3, T3 = Object.keys(i4.attr), b2 = 0; b2 < T3.length; b2++) {
                    var k2 = T3[b2];
                    if (k2 !== o2.DateRangeAttribute.ID && k2 !== o2.DateRangeAttribute.CLASS && k2 !== o2.DateRangeAttribute.START_DATE && k2 !== o2.DateRangeAttribute.DURATION && k2 !== o2.DateRangeAttribute.END_DATE && k2 !== o2.DateRangeAttribute.END_ON_NEXT) {
                      var S2 = s4[k2];
                      if (S2)
                        u3 && !n4.durationKnown && (S2.endTime = g3);
                      else {
                        var _2 = i4.attr[k2];
                        S2 = new A2(p3, g3, ""), k2 !== o2.DateRangeAttribute.SCTE35_OUT && k2 !== o2.DateRangeAttribute.SCTE35_IN || (E3 = _2, _2 = Uint8Array.from(E3.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer), S2.value = { key: k2, data: _2 }, S2.type = l2.MetadataSchema.dateRange, r4.id3Track.addCue(S2), s4[k2] = S2;
                      }
                    }
                  }
                  a3[t6] = { cues: s4, dateRange: i4, durationKnown: u3 };
                }, T2 = 0; T2 < f3.length; T2++)
                  E2(T2);
              }
            }
          }, e4;
        }();
        const f2 = h2;
      }
    ), "./src/controller/latency-controller.ts": (
      /*!**********************************************!*\
          !*** ./src/controller/latency-controller.ts ***!
          \**********************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => o2 });
        var i3 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), n2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), a2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        );
        function s2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        var o2 = function() {
          function e4(e5) {
            var t5 = this;
            this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = function() {
              return t5.timeupdate();
            }, this.hls = e5, this.config = e5.config, this.registerListeners();
          }
          var t4, r4, o3, l2 = e4.prototype;
          return l2.destroy = function() {
            this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null;
          }, l2.registerListeners = function() {
            this.hls.on(n2.Events.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(n2.Events.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(n2.Events.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(n2.Events.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(n2.Events.ERROR, this.onError, this);
          }, l2.unregisterListeners = function() {
            this.hls.off(n2.Events.MEDIA_ATTACHED, this.onMediaAttached), this.hls.off(n2.Events.MEDIA_DETACHING, this.onMediaDetaching), this.hls.off(n2.Events.MANIFEST_LOADING, this.onManifestLoading), this.hls.off(n2.Events.LEVEL_UPDATED, this.onLevelUpdated), this.hls.off(n2.Events.ERROR, this.onError);
          }, l2.onMediaAttached = function(e5, t5) {
            this.media = t5.media, this.media.addEventListener("timeupdate", this.timeupdateHandler);
          }, l2.onMediaDetaching = function() {
            this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler), this.media = null);
          }, l2.onManifestLoading = function() {
            this.levelDetails = null, this._latency = null, this.stallCount = 0;
          }, l2.onLevelUpdated = function(e5, t5) {
            var r5 = t5.details;
            this.levelDetails = r5, r5.advanced && this.timeupdate(), !r5.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler);
          }, l2.onError = function(e5, t5) {
            t5.details === i3.ErrorDetails.BUFFER_STALLED_ERROR && (this.stallCount++, a2.logger.warn("[playback-rate-controller]: Stall detected, adjusting target latency"));
          }, l2.timeupdate = function() {
            var e5 = this.media, t5 = this.levelDetails;
            if (e5 && t5) {
              this.currentTime = e5.currentTime;
              var r5 = this.computeLatency();
              if (null !== r5) {
                this._latency = r5;
                var i4 = this.config, n3 = i4.lowLatencyMode, a3 = i4.maxLiveSyncPlaybackRate;
                if (n3 && 1 !== a3) {
                  var s3 = this.targetLatency;
                  if (null !== s3) {
                    var o4 = r5 - s3, l3 = o4 < Math.min(this.maxLatency, s3 + t5.targetduration);
                    if (t5.live && l3 && o4 > 0.05 && this.forwardBufferLength > 1) {
                      var u2 = Math.min(2, Math.max(1, a3)), c2 = Math.round(2 / (1 + Math.exp(-0.75 * o4 - this.edgeStalled)) * 20) / 20;
                      e5.playbackRate = Math.min(u2, Math.max(1, c2));
                    } else
                      1 !== e5.playbackRate && 0 !== e5.playbackRate && (e5.playbackRate = 1);
                  }
                }
              }
            }
          }, l2.estimateLiveEdge = function() {
            var e5 = this.levelDetails;
            return null === e5 ? null : e5.edge + e5.age;
          }, l2.computeLatency = function() {
            var e5 = this.estimateLiveEdge();
            return null === e5 ? null : e5 - this.currentTime;
          }, t4 = e4, (r4 = [{ key: "latency", get: function() {
            return this._latency || 0;
          } }, { key: "maxLatency", get: function() {
            var e5 = this.config, t5 = this.levelDetails;
            return void 0 !== e5.liveMaxLatencyDuration ? e5.liveMaxLatencyDuration : t5 ? e5.liveMaxLatencyDurationCount * t5.targetduration : 0;
          } }, { key: "targetLatency", get: function() {
            var e5 = this.levelDetails;
            if (null === e5)
              return null;
            var t5 = e5.holdBack, r5 = e5.partHoldBack, i4 = e5.targetduration, n3 = this.config, a3 = n3.liveSyncDuration, s3 = n3.liveSyncDurationCount, o4 = n3.lowLatencyMode, l3 = this.hls.userConfig, u2 = o4 && r5 || t5;
            (l3.liveSyncDuration || l3.liveSyncDurationCount || 0 === u2) && (u2 = void 0 !== a3 ? a3 : s3 * i4);
            var c2 = i4;
            return u2 + Math.min(1 * this.stallCount, c2);
          } }, { key: "liveSyncPosition", get: function() {
            var e5 = this.estimateLiveEdge(), t5 = this.targetLatency, r5 = this.levelDetails;
            if (null === e5 || null === t5 || null === r5)
              return null;
            var i4 = r5.edge, n3 = e5 - t5 - this.edgeStalled, a3 = i4 - r5.totalduration, s3 = i4 - (this.config.lowLatencyMode && r5.partTarget || r5.targetduration);
            return Math.min(Math.max(a3, n3), s3);
          } }, { key: "drift", get: function() {
            var e5 = this.levelDetails;
            return null === e5 ? 1 : e5.drift;
          } }, { key: "edgeStalled", get: function() {
            var e5 = this.levelDetails;
            if (null === e5)
              return 0;
            var t5 = 3 * (this.config.lowLatencyMode && e5.partTarget || e5.targetduration);
            return Math.max(e5.age - t5, 0);
          } }, { key: "forwardBufferLength", get: function() {
            var e5 = this.media, t5 = this.levelDetails;
            if (!e5 || !t5)
              return 0;
            var r5 = e5.buffered.length;
            return (r5 ? e5.buffered.end(r5 - 1) : t5.edge) - this.currentTime;
          } }]) && s2(t4.prototype, r4), o3 && s2(t4, o3), Object.defineProperty(t4, "prototype", { writable: false }), e4;
        }();
      }
    ), "./src/controller/level-controller.ts": (
      /*!********************************************!*\
          !*** ./src/controller/level-controller.ts ***!
          \********************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => p2 });
        var i3 = r3(
          /*! ../types/level */
          "./src/types/level.ts"
        ), n2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), a2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), s2 = r3(
          /*! ../utils/codecs */
          "./src/utils/codecs.ts"
        ), o2 = r3(
          /*! ./level-helper */
          "./src/controller/level-helper.ts"
        ), l2 = r3(
          /*! ./base-playlist-controller */
          "./src/controller/base-playlist-controller.ts"
        ), u2 = r3(
          /*! ../types/loader */
          "./src/types/loader.ts"
        );
        function c2() {
          return c2 = Object.assign ? Object.assign.bind() : function(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var r4 = arguments[t4];
              for (var i4 in r4)
                Object.prototype.hasOwnProperty.call(r4, i4) && (e4[i4] = r4[i4]);
            }
            return e4;
          }, c2.apply(this, arguments);
        }
        function d2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        function h2(e4, t4) {
          return h2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
            return e5.__proto__ = t5, e5;
          }, h2(e4, t4);
        }
        var f2 = /chrome|firefox/.test(navigator.userAgent.toLowerCase()), p2 = function(e4) {
          var t4, r4;
          function l3(t5) {
            var r5;
            return (r5 = e4.call(this, t5, "[level-controller]") || this)._levels = [], r5._firstLevel = -1, r5._startLevel = void 0, r5.currentLevelIndex = -1, r5.manualLevelIndex = -1, r5.onParsedComplete = void 0, r5._registerListeners(), r5;
          }
          r4 = e4, (t4 = l3).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, h2(t4, r4);
          var p3, g2, v2, m2 = l3.prototype;
          return m2._registerListeners = function() {
            var e5 = this.hls;
            e5.on(n2.Events.MANIFEST_LOADED, this.onManifestLoaded, this), e5.on(n2.Events.LEVEL_LOADED, this.onLevelLoaded, this), e5.on(n2.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e5.on(n2.Events.FRAG_LOADED, this.onFragLoaded, this), e5.on(n2.Events.ERROR, this.onError, this);
          }, m2._unregisterListeners = function() {
            var e5 = this.hls;
            e5.off(n2.Events.MANIFEST_LOADED, this.onManifestLoaded, this), e5.off(n2.Events.LEVEL_LOADED, this.onLevelLoaded, this), e5.off(n2.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e5.off(n2.Events.FRAG_LOADED, this.onFragLoaded, this), e5.off(n2.Events.ERROR, this.onError, this);
          }, m2.destroy = function() {
            this._unregisterListeners(), this.manualLevelIndex = -1, this._levels.length = 0, e4.prototype.destroy.call(this);
          }, m2.startLoad = function() {
            this._levels.forEach(function(e5) {
              e5.loadError = 0;
            }), e4.prototype.startLoad.call(this);
          }, m2.onManifestLoaded = function(e5, t5) {
            var r5, l4, u3 = [], c3 = [], d3 = [], h3 = {}, p4 = false, g3 = false, v3 = false;
            if (t5.levels.forEach(function(e6) {
              var t6 = e6.attrs;
              p4 = p4 || !(!e6.width || !e6.height), g3 = g3 || !!e6.videoCodec, v3 = v3 || !!e6.audioCodec, f2 && e6.audioCodec && -1 !== e6.audioCodec.indexOf("mp4a.40.34") && (e6.audioCodec = void 0);
              var r6 = e6.bitrate + "-" + e6.attrs.RESOLUTION + "-" + e6.attrs.CODECS;
              (l4 = h3[r6]) ? l4.url.push(e6.url) : (l4 = new i3.Level(e6), h3[r6] = l4, u3.push(l4)), t6 && (t6.AUDIO && (0, o2.addGroupId)(l4, "audio", t6.AUDIO), t6.SUBTITLES && (0, o2.addGroupId)(l4, "text", t6.SUBTITLES));
            }), (p4 || g3) && v3 && (u3 = u3.filter(function(e6) {
              var t6 = e6.videoCodec, r6 = e6.width, i4 = e6.height;
              return !!t6 || !(!r6 || !i4);
            })), u3 = u3.filter(function(e6) {
              var t6 = e6.audioCodec, r6 = e6.videoCodec;
              return (!t6 || (0, s2.isCodecSupportedInMp4)(t6, "audio")) && (!r6 || (0, s2.isCodecSupportedInMp4)(r6, "video"));
            }), t5.audioTracks && (c3 = t5.audioTracks.filter(function(e6) {
              return !e6.audioCodec || (0, s2.isCodecSupportedInMp4)(e6.audioCodec, "audio");
            }), (0, o2.assignTrackIdsByGroup)(c3)), t5.subtitles && (d3 = t5.subtitles, (0, o2.assignTrackIdsByGroup)(d3)), u3.length > 0) {
              r5 = u3[0].bitrate, u3.sort(function(e6, t6) {
                return e6.bitrate - t6.bitrate;
              }), this._levels = u3;
              for (var m3 = 0; m3 < u3.length; m3++)
                if (u3[m3].bitrate === r5) {
                  this._firstLevel = m3, this.log("manifest loaded, " + u3.length + " level(s) found, first bitrate: " + r5);
                  break;
                }
              var y2 = v3 && !g3, A2 = { levels: u3, audioTracks: c3, subtitleTracks: d3, firstLevel: this._firstLevel, stats: t5.stats, audio: v3, video: g3, altAudio: !y2 && c3.some(function(e6) {
                return !!e6.url;
              }) };
              this.hls.trigger(n2.Events.MANIFEST_PARSED, A2), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition);
            } else
              this.hls.trigger(n2.Events.ERROR, { type: a2.ErrorTypes.MEDIA_ERROR, details: a2.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: true, url: t5.url, reason: "no level with compatible codecs found in manifest" });
          }, m2.onError = function(t5, r5) {
            var i4;
            if (e4.prototype.onError.call(this, t5, r5), !r5.fatal) {
              var n3 = r5.context, s3 = this._levels[this.currentLevelIndex];
              if (n3 && (n3.type === u2.PlaylistContextType.AUDIO_TRACK && s3.audioGroupIds && n3.groupId === s3.audioGroupIds[s3.urlId] || n3.type === u2.PlaylistContextType.SUBTITLE_TRACK && s3.textGroupIds && n3.groupId === s3.textGroupIds[s3.urlId]))
                this.redundantFailover(this.currentLevelIndex);
              else {
                var o3, l4 = false, c3 = true;
                switch (r5.details) {
                  case a2.ErrorDetails.FRAG_LOAD_ERROR:
                  case a2.ErrorDetails.FRAG_LOAD_TIMEOUT:
                  case a2.ErrorDetails.KEY_LOAD_ERROR:
                  case a2.ErrorDetails.KEY_LOAD_TIMEOUT:
                    if (r5.frag) {
                      var d3 = r5.frag.type === u2.PlaylistLevelType.MAIN ? r5.frag.level : this.currentLevelIndex, h3 = this._levels[d3];
                      h3 ? (h3.fragmentError++, h3.fragmentError > this.hls.config.fragLoadingMaxRetry && (o3 = d3)) : o3 = d3;
                    }
                    break;
                  case a2.ErrorDetails.LEVEL_LOAD_ERROR:
                  case a2.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                    n3 && (n3.deliveryDirectives && (c3 = false), o3 = n3.level), l4 = true;
                    break;
                  case a2.ErrorDetails.REMUX_ALLOC_ERROR:
                    o3 = null != (i4 = r5.level) ? i4 : this.currentLevelIndex, l4 = true;
                }
                void 0 !== o3 && this.recoverLevel(r5, o3, l4, c3);
              }
            }
          }, m2.recoverLevel = function(e5, t5, r5, i4) {
            var n3 = e5.details, a3 = this._levels[t5];
            if (a3.loadError++, r5) {
              if (!this.retryLoadingOrFail(e5))
                return void (this.currentLevelIndex = -1);
              e5.levelRetry = true;
            }
            if (i4) {
              var s3 = a3.url.length;
              if (s3 > 1 && a3.loadError < s3)
                e5.levelRetry = true, this.redundantFailover(t5);
              else if (-1 === this.manualLevelIndex) {
                for (var o3 = -1, l4 = this._levels, u3 = l4.length; u3--; ) {
                  var c3 = (u3 + this.currentLevelIndex) % l4.length;
                  if (c3 !== this.currentLevelIndex && 0 === l4[c3].loadError) {
                    o3 = c3;
                    break;
                  }
                }
                o3 > -1 && this.currentLevelIndex !== o3 && (this.warn(n3 + ": switch to " + o3), e5.levelRetry = true, this.hls.nextAutoLevel = o3);
              }
            }
          }, m2.redundantFailover = function(e5) {
            var t5 = this._levels[e5], r5 = t5.url.length;
            if (r5 > 1) {
              var i4 = (t5.urlId + 1) % r5;
              this.warn("Switching to redundant URL-id " + i4), this._levels.forEach(function(e6) {
                e6.urlId = i4;
              }), this.level = e5;
            }
          }, m2.onFragLoaded = function(e5, t5) {
            var r5 = t5.frag;
            if (void 0 !== r5 && r5.type === u2.PlaylistLevelType.MAIN) {
              var i4 = this._levels[r5.level];
              void 0 !== i4 && (i4.fragmentError = 0, i4.loadError = 0);
            }
          }, m2.onLevelLoaded = function(e5, t5) {
            var r5, i4, n3 = t5.level, a3 = t5.details, s3 = this._levels[n3];
            if (!s3)
              return this.warn("Invalid level index " + n3), void (null !== (i4 = t5.deliveryDirectives) && void 0 !== i4 && i4.skip && (a3.deltaUpdateFailed = true));
            n3 === this.currentLevelIndex ? (0 === s3.fragmentError && (s3.loadError = 0, this.retryCount = 0), this.playlistLoaded(n3, t5, s3.details)) : null !== (r5 = t5.deliveryDirectives) && void 0 !== r5 && r5.skip && (a3.deltaUpdateFailed = true);
          }, m2.onAudioTrackSwitched = function(e5, t5) {
            var r5 = this.hls.levels[this.currentLevelIndex];
            if (r5 && r5.audioGroupIds) {
              for (var i4 = -1, n3 = this.hls.audioTracks[t5.id].groupId, a3 = 0; a3 < r5.audioGroupIds.length; a3++)
                if (r5.audioGroupIds[a3] === n3) {
                  i4 = a3;
                  break;
                }
              i4 !== r5.urlId && (r5.urlId = i4, this.startLoad());
            }
          }, m2.loadPlaylist = function(e5) {
            var t5 = this.currentLevelIndex, r5 = this._levels[t5];
            if (this.canLoad && r5 && r5.url.length > 0) {
              var i4 = r5.urlId, a3 = r5.url[i4];
              if (e5)
                try {
                  a3 = e5.addDirectives(a3);
                } catch (e6) {
                  this.warn("Could not construct new URL with HLS Delivery Directives: " + e6);
                }
              this.log("Attempt loading level index " + t5 + (e5 ? " at sn " + e5.msn + " part " + e5.part : "") + " with URL-id " + i4 + " " + a3), this.clearTimer(), this.hls.trigger(n2.Events.LEVEL_LOADING, { url: a3, level: t5, id: i4, deliveryDirectives: e5 || null });
            }
          }, m2.removeLevel = function(e5, t5) {
            var r5 = function(e6, r6) {
              return r6 !== t5;
            }, i4 = this._levels.filter(function(i5, n3) {
              return n3 !== e5 || i5.url.length > 1 && void 0 !== t5 && (i5.url = i5.url.filter(r5), i5.audioGroupIds && (i5.audioGroupIds = i5.audioGroupIds.filter(r5)), i5.textGroupIds && (i5.textGroupIds = i5.textGroupIds.filter(r5)), i5.urlId = 0, true);
            }).map(function(e6, t6) {
              var r6 = e6.details;
              return null != r6 && r6.fragments && r6.fragments.forEach(function(e7) {
                e7.level = t6;
              }), e6;
            });
            this._levels = i4, this.hls.trigger(n2.Events.LEVELS_UPDATED, { levels: i4 });
          }, p3 = l3, (g2 = [{ key: "levels", get: function() {
            return 0 === this._levels.length ? null : this._levels;
          } }, { key: "level", get: function() {
            return this.currentLevelIndex;
          }, set: function(e5) {
            var t5, r5 = this._levels;
            if (0 !== r5.length && (this.currentLevelIndex !== e5 || null === (t5 = r5[e5]) || void 0 === t5 || !t5.details)) {
              if (e5 < 0 || e5 >= r5.length) {
                var i4 = e5 < 0;
                if (this.hls.trigger(n2.Events.ERROR, { type: a2.ErrorTypes.OTHER_ERROR, details: a2.ErrorDetails.LEVEL_SWITCH_ERROR, level: e5, fatal: i4, reason: "invalid level idx" }), i4)
                  return;
                e5 = Math.min(e5, r5.length - 1);
              }
              this.clearTimer();
              var s3 = this.currentLevelIndex, o3 = r5[s3], l4 = r5[e5];
              this.log("switching to level " + e5 + " from " + s3), this.currentLevelIndex = e5;
              var u3 = c2({}, l4, { level: e5, maxBitrate: l4.maxBitrate, uri: l4.uri, urlId: l4.urlId });
              delete u3._urlId, this.hls.trigger(n2.Events.LEVEL_SWITCHING, u3);
              var d3 = l4.details;
              if (!d3 || d3.live) {
                var h3 = this.switchParams(l4.uri, null == o3 ? void 0 : o3.details);
                this.loadPlaylist(h3);
              }
            }
          } }, { key: "manualLevel", get: function() {
            return this.manualLevelIndex;
          }, set: function(e5) {
            this.manualLevelIndex = e5, void 0 === this._startLevel && (this._startLevel = e5), -1 !== e5 && (this.level = e5);
          } }, { key: "firstLevel", get: function() {
            return this._firstLevel;
          }, set: function(e5) {
            this._firstLevel = e5;
          } }, { key: "startLevel", get: function() {
            if (void 0 === this._startLevel) {
              var e5 = this.hls.config.startLevel;
              return void 0 !== e5 ? e5 : this._firstLevel;
            }
            return this._startLevel;
          }, set: function(e5) {
            this._startLevel = e5;
          } }, { key: "nextLoadLevel", get: function() {
            return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel;
          }, set: function(e5) {
            this.level = e5, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e5);
          } }]) && d2(p3.prototype, g2), v2 && d2(p3, v2), Object.defineProperty(p3, "prototype", { writable: false }), l3;
        }(l2.default);
      }
    ), "./src/controller/level-helper.ts": (
      /*!****************************************!*\
          !*** ./src/controller/level-helper.ts ***!
          \****************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { addGroupId: () => o2, addSliding: () => v2, adjustSliding: () => g2, assignTrackIdsByGroup: () => l2, computeReloadInterval: () => m2, getFragmentWithSN: () => y2, getPartWith: () => A2, mapFragmentIntersection: () => p2, mapPartIntersection: () => f2, mergeDetails: () => h2, updateFragPTSDTS: () => d2, updatePTS: () => u2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), a2 = r3(
          /*! ../loader/date-range */
          "./src/loader/date-range.ts"
        );
        function s2() {
          return s2 = Object.assign ? Object.assign.bind() : function(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var r4 = arguments[t4];
              for (var i4 in r4)
                Object.prototype.hasOwnProperty.call(r4, i4) && (e4[i4] = r4[i4]);
            }
            return e4;
          }, s2.apply(this, arguments);
        }
        function o2(e4, t4, r4) {
          switch (t4) {
            case "audio":
              e4.audioGroupIds || (e4.audioGroupIds = []), e4.audioGroupIds.push(r4);
              break;
            case "text":
              e4.textGroupIds || (e4.textGroupIds = []), e4.textGroupIds.push(r4);
          }
        }
        function l2(e4) {
          var t4 = {};
          e4.forEach(function(e5) {
            var r4 = e5.groupId || "";
            e5.id = t4[r4] = t4[r4] || 0, t4[r4]++;
          });
        }
        function u2(e4, t4, r4) {
          c2(e4[t4], e4[r4]);
        }
        function c2(e4, t4) {
          var r4 = t4.startPTS;
          if ((0, i3.isFiniteNumber)(r4)) {
            var n3, a3 = 0;
            t4.sn > e4.sn ? (a3 = r4 - e4.start, n3 = e4) : (a3 = e4.start - r4, n3 = t4), n3.duration !== a3 && (n3.duration = a3);
          } else
            t4.sn > e4.sn ? e4.cc === t4.cc && e4.minEndPTS ? t4.start = e4.start + (e4.minEndPTS - e4.start) : t4.start = e4.start + e4.duration : t4.start = Math.max(e4.start - t4.duration, 0);
        }
        function d2(e4, t4, r4, a3, s3, o3) {
          a3 - r4 <= 0 && (n2.logger.warn("Fragment should have a positive duration", t4), a3 = r4 + t4.duration, o3 = s3 + t4.duration);
          var l3 = r4, u3 = a3, d3 = t4.startPTS, h3 = t4.endPTS;
          if ((0, i3.isFiniteNumber)(d3)) {
            var f3 = Math.abs(d3 - r4);
            (0, i3.isFiniteNumber)(t4.deltaPTS) ? t4.deltaPTS = Math.max(f3, t4.deltaPTS) : t4.deltaPTS = f3, l3 = Math.max(r4, d3), r4 = Math.min(r4, d3), s3 = Math.min(s3, t4.startDTS), u3 = Math.min(a3, h3), a3 = Math.max(a3, h3), o3 = Math.max(o3, t4.endDTS);
          }
          t4.duration = a3 - r4;
          var p3 = r4 - t4.start;
          t4.appendedPTS = a3, t4.start = t4.startPTS = r4, t4.maxStartPTS = l3, t4.startDTS = s3, t4.endPTS = a3, t4.minEndPTS = u3, t4.endDTS = o3;
          var g3, v3 = t4.sn;
          if (!e4 || v3 < e4.startSN || v3 > e4.endSN)
            return 0;
          var m3 = v3 - e4.startSN, y3 = e4.fragments;
          for (y3[m3] = t4, g3 = m3; g3 > 0; g3--)
            c2(y3[g3], y3[g3 - 1]);
          for (g3 = m3; g3 < y3.length - 1; g3++)
            c2(y3[g3], y3[g3 + 1]);
          return e4.fragmentHint && c2(y3[y3.length - 1], e4.fragmentHint), e4.PTSKnown = e4.alignedSliding = true, p3;
        }
        function h2(e4, t4) {
          for (var r4 = null, o3 = e4.fragments, l3 = o3.length - 1; l3 >= 0; l3--) {
            var u3 = o3[l3].initSegment;
            if (u3) {
              r4 = u3;
              break;
            }
          }
          e4.fragmentHint && delete e4.fragmentHint.endPTS;
          var c3, h3, v3, m3, y3, A3 = 0;
          if (p2(e4, t4, function(e5, n3) {
            e5.relurl && (A3 = e5.cc - n3.cc), (0, i3.isFiniteNumber)(e5.startPTS) && (0, i3.isFiniteNumber)(e5.endPTS) && (n3.start = n3.startPTS = e5.startPTS, n3.startDTS = e5.startDTS, n3.appendedPTS = e5.appendedPTS, n3.maxStartPTS = e5.maxStartPTS, n3.endPTS = e5.endPTS, n3.endDTS = e5.endDTS, n3.minEndPTS = e5.minEndPTS, n3.duration = e5.endPTS - e5.startPTS, n3.duration && (c3 = n3), t4.PTSKnown = t4.alignedSliding = true), n3.elementaryStreams = e5.elementaryStreams, n3.loader = e5.loader, n3.stats = e5.stats, n3.urlId = e5.urlId, e5.initSegment && (n3.initSegment = e5.initSegment, r4 = e5.initSegment);
          }), r4 && (t4.fragmentHint ? t4.fragments.concat(t4.fragmentHint) : t4.fragments).forEach(function(e5) {
            var t5;
            e5.initSegment && e5.initSegment.relurl !== (null === (t5 = r4) || void 0 === t5 ? void 0 : t5.relurl) || (e5.initSegment = r4);
          }), t4.skippedSegments)
            if (t4.deltaUpdateFailed = t4.fragments.some(function(e5) {
              return !e5;
            }), t4.deltaUpdateFailed) {
              n2.logger.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
              for (var E2 = t4.skippedSegments; E2--; )
                t4.fragments.shift();
              t4.startSN = t4.fragments[0].sn, t4.startCC = t4.fragments[0].cc;
            } else
              t4.canSkipDateRanges && (t4.dateRanges = (h3 = e4.dateRanges, v3 = t4.dateRanges, m3 = t4.recentlyRemovedDateranges, y3 = s2({}, h3), m3 && m3.forEach(function(e5) {
                delete y3[e5];
              }), Object.keys(v3).forEach(function(e5) {
                var t5 = new a2.DateRange(v3[e5].attr, y3[e5]);
                t5.isValid ? y3[e5] = t5 : n2.logger.warn('Ignoring invalid Playlist Delta Update DATERANGE tag: "' + JSON.stringify(v3[e5].attr) + '"');
              }), y3));
          var T2 = t4.fragments;
          if (A3) {
            n2.logger.warn("discontinuity sliding from playlist, take drift into account");
            for (var b2 = 0; b2 < T2.length; b2++)
              T2[b2].cc += A3;
          }
          t4.skippedSegments && (t4.startCC = t4.fragments[0].cc), f2(e4.partList, t4.partList, function(e5, t5) {
            t5.elementaryStreams = e5.elementaryStreams, t5.stats = e5.stats;
          }), c3 ? d2(t4, c3, c3.startPTS, c3.endPTS, c3.startDTS, c3.endDTS) : g2(e4, t4), T2.length && (t4.totalduration = t4.edge - T2[0].start), t4.driftStartTime = e4.driftStartTime, t4.driftStart = e4.driftStart;
          var k2 = t4.advancedDateTime;
          if (t4.advanced && k2) {
            var S2 = t4.edge;
            t4.driftStart || (t4.driftStartTime = k2, t4.driftStart = S2), t4.driftEndTime = k2, t4.driftEnd = S2;
          } else
            t4.driftEndTime = e4.driftEndTime, t4.driftEnd = e4.driftEnd, t4.advancedDateTime = e4.advancedDateTime;
        }
        function f2(e4, t4, r4) {
          if (e4 && t4)
            for (var i4 = 0, n3 = 0, a3 = e4.length; n3 <= a3; n3++) {
              var s3 = e4[n3], o3 = t4[n3 + i4];
              s3 && o3 && s3.index === o3.index && s3.fragment.sn === o3.fragment.sn ? r4(s3, o3) : i4--;
            }
        }
        function p2(e4, t4, r4) {
          for (var i4 = t4.skippedSegments, n3 = Math.max(e4.startSN, t4.startSN) - t4.startSN, a3 = (e4.fragmentHint ? 1 : 0) + (i4 ? t4.endSN : Math.min(e4.endSN, t4.endSN)) - t4.startSN, s3 = t4.startSN - e4.startSN, o3 = t4.fragmentHint ? t4.fragments.concat(t4.fragmentHint) : t4.fragments, l3 = e4.fragmentHint ? e4.fragments.concat(e4.fragmentHint) : e4.fragments, u3 = n3; u3 <= a3; u3++) {
            var c3 = l3[s3 + u3], d3 = o3[u3];
            i4 && !d3 && u3 < i4 && (d3 = t4.fragments[u3] = c3), c3 && d3 && r4(c3, d3);
          }
        }
        function g2(e4, t4) {
          var r4 = t4.startSN + t4.skippedSegments - e4.startSN, i4 = e4.fragments;
          r4 < 0 || r4 >= i4.length || v2(t4, i4[r4].start);
        }
        function v2(e4, t4) {
          if (t4) {
            for (var r4 = e4.fragments, i4 = e4.skippedSegments; i4 < r4.length; i4++)
              r4[i4].start += t4;
            e4.fragmentHint && (e4.fragmentHint.start += t4);
          }
        }
        function m2(e4, t4) {
          var r4, i4 = 1e3 * e4.levelTargetDuration, n3 = i4 / 2, a3 = e4.age, s3 = a3 > 0 && a3 < 3 * i4, o3 = t4.loading.end - t4.loading.start, l3 = e4.availabilityDelay;
          if (false === e4.updated)
            if (s3) {
              var u3 = 333 * e4.misses;
              r4 = Math.max(Math.min(n3, 2 * o3), u3), e4.availabilityDelay = (e4.availabilityDelay || 0) + r4;
            } else
              r4 = n3;
          else
            s3 ? (l3 = Math.min(l3 || i4 / 2, a3), e4.availabilityDelay = l3, r4 = l3 + i4 - a3) : r4 = i4 - o3;
          return Math.round(r4);
        }
        function y2(e4, t4, r4) {
          if (!e4 || !e4.details)
            return null;
          var i4 = e4.details, n3 = i4.fragments[t4 - i4.startSN];
          return n3 || ((n3 = i4.fragmentHint) && n3.sn === t4 ? n3 : t4 < i4.startSN && r4 && r4.sn === t4 ? r4 : null);
        }
        function A2(e4, t4, r4) {
          if (!e4 || !e4.details)
            return null;
          var i4 = e4.details.partList;
          if (i4)
            for (var n3 = i4.length; n3--; ) {
              var a3 = i4[n3];
              if (a3.index === r4 && a3.fragment.sn === t4)
                return a3;
            }
          return null;
        }
      }
    ), "./src/controller/stream-controller.ts": (
      /*!*********************************************!*\
          !*** ./src/controller/stream-controller.ts ***!
          \*********************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => m2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ./base-stream-controller */
          "./src/controller/base-stream-controller.ts"
        ), a2 = r3(
          /*! ../is-supported */
          "./src/is-supported.ts"
        ), s2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), o2 = r3(
          /*! ../utils/buffer-helper */
          "./src/utils/buffer-helper.ts"
        ), l2 = r3(
          /*! ./fragment-tracker */
          "./src/controller/fragment-tracker.ts"
        ), u2 = r3(
          /*! ../types/loader */
          "./src/types/loader.ts"
        ), c2 = r3(
          /*! ../loader/fragment */
          "./src/loader/fragment.ts"
        ), d2 = r3(
          /*! ../demux/transmuxer-interface */
          "./src/demux/transmuxer-interface.ts"
        ), h2 = r3(
          /*! ../types/transmuxer */
          "./src/types/transmuxer.ts"
        ), f2 = r3(
          /*! ./gap-controller */
          "./src/controller/gap-controller.ts"
        ), p2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        );
        function g2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        function v2(e4, t4) {
          return v2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
            return e5.__proto__ = t5, e5;
          }, v2(e4, t4);
        }
        var m2 = function(e4) {
          var t4, r4;
          function m3(t5, r5) {
            var i4;
            return (i4 = e4.call(this, t5, r5, "[stream-controller]") || this).audioCodecSwap = false, i4.gapController = null, i4.level = -1, i4._forceStartLoad = false, i4.altAudio = false, i4.audioOnly = false, i4.fragPlaying = null, i4.onvplaying = null, i4.onvseeked = null, i4.fragLastKbps = 0, i4.couldBacktrack = false, i4.backtrackFragment = null, i4.audioCodecSwitch = false, i4.videoBuffer = null, i4._registerListeners(), i4;
          }
          r4 = e4, (t4 = m3).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, v2(t4, r4);
          var y2, A2, E2, T2 = m3.prototype;
          return T2._registerListeners = function() {
            var e5 = this.hls;
            e5.on(s2.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e5.on(s2.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e5.on(s2.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.on(s2.Events.MANIFEST_PARSED, this.onManifestParsed, this), e5.on(s2.Events.LEVEL_LOADING, this.onLevelLoading, this), e5.on(s2.Events.LEVEL_LOADED, this.onLevelLoaded, this), e5.on(s2.Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e5.on(s2.Events.ERROR, this.onError, this), e5.on(s2.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e5.on(s2.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e5.on(s2.Events.BUFFER_CREATED, this.onBufferCreated, this), e5.on(s2.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), e5.on(s2.Events.LEVELS_UPDATED, this.onLevelsUpdated, this), e5.on(s2.Events.FRAG_BUFFERED, this.onFragBuffered, this);
          }, T2._unregisterListeners = function() {
            var e5 = this.hls;
            e5.off(s2.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e5.off(s2.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e5.off(s2.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.off(s2.Events.MANIFEST_PARSED, this.onManifestParsed, this), e5.off(s2.Events.LEVEL_LOADED, this.onLevelLoaded, this), e5.off(s2.Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e5.off(s2.Events.ERROR, this.onError, this), e5.off(s2.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e5.off(s2.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e5.off(s2.Events.BUFFER_CREATED, this.onBufferCreated, this), e5.off(s2.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), e5.off(s2.Events.LEVELS_UPDATED, this.onLevelsUpdated, this), e5.off(s2.Events.FRAG_BUFFERED, this.onFragBuffered, this);
          }, T2.onHandlerDestroying = function() {
            this._unregisterListeners(), this.onMediaDetaching();
          }, T2.startLoad = function(e5) {
            if (this.levels) {
              var t5 = this.lastCurrentTime, r5 = this.hls;
              if (this.stopLoad(), this.setInterval(100), this.level = -1, this.fragLoadError = 0, !this.startFragRequested) {
                var i4 = r5.startLevel;
                -1 === i4 && (r5.config.testBandwidth && this.levels.length > 1 ? (i4 = 0, this.bitrateTest = true) : i4 = r5.nextAutoLevel), this.level = r5.nextLoadLevel = i4, this.loadedmetadata = false;
              }
              t5 > 0 && -1 === e5 && (this.log("Override startPosition with lastCurrentTime @" + t5.toFixed(3)), e5 = t5), this.state = n2.State.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e5, this.tick();
            } else
              this._forceStartLoad = true, this.state = n2.State.STOPPED;
          }, T2.stopLoad = function() {
            this._forceStartLoad = false, e4.prototype.stopLoad.call(this);
          }, T2.doTick = function() {
            switch (this.state) {
              case n2.State.IDLE:
                this.doTickIdle();
                break;
              case n2.State.WAITING_LEVEL:
                var e5, t5 = this.levels, r5 = this.level, i4 = null == t5 || null === (e5 = t5[r5]) || void 0 === e5 ? void 0 : e5.details;
                if (i4 && (!i4.live || this.levelLastLoaded === this.level)) {
                  if (this.waitForCdnTuneIn(i4))
                    break;
                  this.state = n2.State.IDLE;
                  break;
                }
                break;
              case n2.State.FRAG_LOADING_WAITING_RETRY:
                var a3, s3 = self.performance.now(), o3 = this.retryDate;
                (!o3 || s3 >= o3 || null !== (a3 = this.media) && void 0 !== a3 && a3.seeking) && (this.log("retryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded(this.level), this.state = n2.State.IDLE);
            }
            this.onTickEnd();
          }, T2.onTickEnd = function() {
            e4.prototype.onTickEnd.call(this), this.checkBuffer(), this.checkFragmentChanged();
          }, T2.doTickIdle = function() {
            var e5, t5, r5 = this.hls, i4 = this.levelLastLoaded, a3 = this.levels, o3 = this.media, d3 = r5.config, h3 = r5.nextLoadLevel;
            if (null !== i4 && (o3 || !this.startFragRequested && d3.startFragPrefetch) && (!this.altAudio || !this.audioOnly) && a3 && a3[h3]) {
              var f3 = a3[h3];
              this.level = r5.nextLoadLevel = h3;
              var p3 = f3.details;
              if (!p3 || this.state === n2.State.WAITING_LEVEL || p3.live && this.levelLastLoaded !== h3)
                this.state = n2.State.WAITING_LEVEL;
              else {
                var g3 = this.getMainFwdBufferInfo();
                if (null !== g3 && !(g3.len >= this.getMaxBufferLength(f3.maxBitrate))) {
                  if (this._streamEnded(g3, p3)) {
                    var v3 = {};
                    return this.altAudio && (v3.type = "video"), this.hls.trigger(s2.Events.BUFFER_EOS, v3), void (this.state = n2.State.ENDED);
                  }
                  this.backtrackFragment && this.backtrackFragment.start > g3.end && (this.backtrackFragment = null);
                  var m4 = this.backtrackFragment ? this.backtrackFragment.start : g3.end, y3 = this.getNextFragment(m4, p3);
                  if (this.couldBacktrack && !this.fragPrevious && y3 && "initSegment" !== y3.sn && this.fragmentTracker.getState(y3) !== l2.FragmentState.OK) {
                    var A3, E3 = (null != (A3 = this.backtrackFragment) ? A3 : y3).sn - p3.startSN, T3 = p3.fragments[E3 - 1];
                    T3 && y3.cc === T3.cc && (y3 = T3, this.fragmentTracker.removeFragment(T3));
                  } else
                    this.backtrackFragment && g3.len && (this.backtrackFragment = null);
                  if (y3 && this.fragmentTracker.getState(y3) === l2.FragmentState.OK && this.nextLoadPosition > m4) {
                    var b2 = this.audioOnly && !this.altAudio ? c2.ElementaryStreamTypes.AUDIO : c2.ElementaryStreamTypes.VIDEO;
                    o3 && this.afterBufferFlushed(o3, b2, u2.PlaylistLevelType.MAIN), y3 = this.getNextFragment(this.nextLoadPosition, p3);
                  }
                  y3 && (!y3.initSegment || y3.initSegment.data || this.bitrateTest || (y3 = y3.initSegment), "identity" !== (null === (e5 = y3.decryptdata) || void 0 === e5 ? void 0 : e5.keyFormat) || null !== (t5 = y3.decryptdata) && void 0 !== t5 && t5.key ? this.loadFragment(y3, p3, m4) : this.loadKey(y3, p3));
                }
              }
            }
          }, T2.loadFragment = function(t5, r5, i4) {
            var n3, a3 = this.fragmentTracker.getState(t5);
            this.fragCurrent = t5, a3 === l2.FragmentState.NOT_LOADED ? "initSegment" === t5.sn ? this._loadInitSegment(t5) : this.bitrateTest ? (this.log("Fragment " + t5.sn + " of level " + t5.level + " is being downloaded to test bitrate and will not be buffered"), this._loadBitrateTestFrag(t5)) : (this.startFragRequested = true, e4.prototype.loadFragment.call(this, t5, r5, i4)) : a3 === l2.FragmentState.APPENDING ? this.reduceMaxBufferLength(t5.duration) && this.fragmentTracker.removeFragment(t5) : 0 === (null === (n3 = this.media) || void 0 === n3 ? void 0 : n3.buffered.length) && this.fragmentTracker.removeAllFragments();
          }, T2.getAppendedFrag = function(e5) {
            var t5 = this.fragmentTracker.getAppendedFrag(e5, u2.PlaylistLevelType.MAIN);
            return t5 && "fragment" in t5 ? t5.fragment : t5;
          }, T2.getBufferedFrag = function(e5) {
            return this.fragmentTracker.getBufferedFrag(e5, u2.PlaylistLevelType.MAIN);
          }, T2.followingBufferedFrag = function(e5) {
            return e5 ? this.getBufferedFrag(e5.end + 0.5) : null;
          }, T2.immediateLevelSwitch = function() {
            this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
          }, T2.nextLevelSwitch = function() {
            var e5 = this.levels, t5 = this.media;
            if (null != t5 && t5.readyState) {
              var r5, i4 = this.getAppendedFrag(t5.currentTime);
              if (i4 && i4.start > 1 && this.flushMainBuffer(0, i4.start - 1), !t5.paused && e5) {
                var n3 = e5[this.hls.nextLoadLevel], a3 = this.fragLastKbps;
                r5 = a3 && this.fragCurrent ? this.fragCurrent.duration * n3.maxBitrate / (1e3 * a3) + 1 : 0;
              } else
                r5 = 0;
              var s3 = this.getBufferedFrag(t5.currentTime + r5);
              if (s3) {
                var o3 = this.followingBufferedFrag(s3);
                if (o3) {
                  this.abortCurrentFrag();
                  var l3 = o3.maxStartPTS ? o3.maxStartPTS : o3.start, u3 = o3.duration, c3 = Math.max(s3.end, l3 + Math.min(Math.max(u3 - this.config.maxFragLookUpTolerance, 0.5 * u3), 0.75 * u3));
                  this.flushMainBuffer(c3, Number.POSITIVE_INFINITY);
                }
              }
            }
          }, T2.abortCurrentFrag = function() {
            var e5 = this.fragCurrent;
            switch (this.fragCurrent = null, this.backtrackFragment = null, null != e5 && e5.loader && e5.loader.abort(), this.state) {
              case n2.State.KEY_LOADING:
              case n2.State.FRAG_LOADING:
              case n2.State.FRAG_LOADING_WAITING_RETRY:
              case n2.State.PARSING:
              case n2.State.PARSED:
                this.state = n2.State.IDLE;
            }
            this.nextLoadPosition = this.getLoadPosition();
          }, T2.flushMainBuffer = function(t5, r5) {
            e4.prototype.flushMainBuffer.call(this, t5, r5, this.altAudio ? "video" : null);
          }, T2.onMediaAttached = function(t5, r5) {
            e4.prototype.onMediaAttached.call(this, t5, r5);
            var i4 = r5.media;
            this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), i4.addEventListener("playing", this.onvplaying), i4.addEventListener("seeked", this.onvseeked), this.gapController = new f2.default(this.config, i4, this.fragmentTracker, this.hls);
          }, T2.onMediaDetaching = function() {
            var t5 = this.media;
            t5 && this.onvplaying && this.onvseeked && (t5.removeEventListener("playing", this.onvplaying), t5.removeEventListener("seeked", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), e4.prototype.onMediaDetaching.call(this);
          }, T2.onMediaPlaying = function() {
            this.tick();
          }, T2.onMediaSeeked = function() {
            var e5 = this.media, t5 = e5 ? e5.currentTime : null;
            (0, i3.isFiniteNumber)(t5) && this.log("Media seeked to " + t5.toFixed(3)), this.tick();
          }, T2.onManifestLoading = function() {
            this.log("Trigger BUFFER_RESET"), this.hls.trigger(s2.Events.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = false, this.startPosition = this.lastCurrentTime = 0, this.fragPlaying = null, this.backtrackFragment = null;
          }, T2.onManifestParsed = function(e5, t5) {
            var r5, i4 = false, n3 = false;
            t5.levels.forEach(function(e6) {
              (r5 = e6.audioCodec) && (-1 !== r5.indexOf("mp4a.40.2") && (i4 = true), -1 !== r5.indexOf("mp4a.40.5") && (n3 = true));
            }), this.audioCodecSwitch = i4 && n3 && !(0, a2.changeTypeSupported)(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = t5.levels, this.startFragRequested = false;
          }, T2.onLevelLoading = function(e5, t5) {
            var r5 = this.levels;
            if (r5 && this.state === n2.State.IDLE) {
              var i4 = r5[t5.level];
              (!i4.details || i4.details.live && this.levelLastLoaded !== t5.level || this.waitForCdnTuneIn(i4.details)) && (this.state = n2.State.WAITING_LEVEL);
            }
          }, T2.onLevelLoaded = function(e5, t5) {
            var r5, i4 = this.levels, a3 = t5.level, o3 = t5.details, l3 = o3.totalduration;
            if (i4) {
              this.log("Level " + a3 + " loaded [" + o3.startSN + "," + o3.endSN + "], cc [" + o3.startCC + ", " + o3.endCC + "] duration:" + l3);
              var u3 = this.fragCurrent;
              !u3 || this.state !== n2.State.FRAG_LOADING && this.state !== n2.State.FRAG_LOADING_WAITING_RETRY || u3.level !== t5.level && u3.loader && (this.state = n2.State.IDLE, this.backtrackFragment = null, u3.loader.abort());
              var c3 = i4[a3], d3 = 0;
              if (o3.live || null !== (r5 = c3.details) && void 0 !== r5 && r5.live) {
                if (o3.fragments[0] || (o3.deltaUpdateFailed = true), o3.deltaUpdateFailed)
                  return;
                d3 = this.alignPlaylists(o3, c3.details);
              }
              if (c3.details = o3, this.levelLastLoaded = a3, this.hls.trigger(s2.Events.LEVEL_UPDATED, { details: o3, level: a3 }), this.state === n2.State.WAITING_LEVEL) {
                if (this.waitForCdnTuneIn(o3))
                  return;
                this.state = n2.State.IDLE;
              }
              this.startFragRequested ? o3.live && this.synchronizeToLiveEdge(o3) : this.setStartPosition(o3, d3), this.tick();
            } else
              this.warn("Levels were reset while loading level " + a3);
          }, T2._handleFragmentLoadProgress = function(e5) {
            var t5, r5 = e5.frag, i4 = e5.part, n3 = e5.payload, a3 = this.levels;
            if (a3) {
              var s3 = a3[r5.level], o3 = s3.details;
              if (o3) {
                var l3 = s3.videoCodec, c3 = o3.PTSKnown || !o3.live, f3 = null === (t5 = r5.initSegment) || void 0 === t5 ? void 0 : t5.data, p3 = this._getAudioCodec(s3), g3 = this.transmuxer = this.transmuxer || new d2.default(this.hls, u2.PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)), v3 = i4 ? i4.index : -1, m4 = -1 !== v3, y3 = new h2.ChunkMetadata(r5.level, r5.sn, r5.stats.chunkCount, n3.byteLength, v3, m4), A3 = this.initPTS[r5.cc];
                g3.push(n3, f3, p3, l3, r5, i4, o3.totalduration, c3, y3, A3);
              } else
                this.warn("Dropping fragment " + r5.sn + " of level " + r5.level + " after level details were reset");
            } else
              this.warn("Levels were reset while fragment load was in progress. Fragment " + r5.sn + " of level " + r5.level + " will not be buffered");
          }, T2.onAudioTrackSwitching = function(e5, t5) {
            var r5 = this.altAudio, i4 = !!t5.url, n3 = t5.id;
            if (!i4) {
              if (this.mediaBuffer !== this.media) {
                this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
                var a3 = this.fragCurrent;
                null != a3 && a3.loader && (this.log("Switching to main audio track, cancel main fragment load"), a3.loader.abort()), this.resetTransmuxer(), this.resetLoadingState();
              } else
                this.audioOnly && this.resetTransmuxer();
              var o3 = this.hls;
              r5 && o3.trigger(s2.Events.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" }), o3.trigger(s2.Events.AUDIO_TRACK_SWITCHED, { id: n3 });
            }
          }, T2.onAudioTrackSwitched = function(e5, t5) {
            var r5 = t5.id, i4 = !!this.hls.audioTracks[r5].url;
            if (i4) {
              var n3 = this.videoBuffer;
              n3 && this.mediaBuffer !== n3 && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = n3);
            }
            this.altAudio = i4, this.tick();
          }, T2.onBufferCreated = function(e5, t5) {
            var r5, i4, n3 = t5.tracks, a3 = false;
            for (var s3 in n3) {
              var o3 = n3[s3];
              if ("main" === o3.id) {
                if (i4 = s3, r5 = o3, "video" === s3) {
                  var l3 = n3[s3];
                  l3 && (this.videoBuffer = l3.buffer);
                }
              } else
                a3 = true;
            }
            a3 && r5 ? (this.log("Alternate track found, use " + i4 + ".buffered to schedule main fragment loading"), this.mediaBuffer = r5.buffer) : this.mediaBuffer = this.media;
          }, T2.onFragBuffered = function(e5, t5) {
            var r5 = t5.frag, i4 = t5.part;
            if (!r5 || r5.type === u2.PlaylistLevelType.MAIN) {
              if (this.fragContextChanged(r5))
                return this.warn("Fragment " + r5.sn + (i4 ? " p: " + i4.index : "") + " of level " + r5.level + " finished buffering, but was aborted. state: " + this.state), void (this.state === n2.State.PARSED && (this.state = n2.State.IDLE));
              var a3 = i4 ? i4.stats : r5.stats;
              this.fragLastKbps = Math.round(8 * a3.total / (a3.buffering.end - a3.loading.first)), "initSegment" !== r5.sn && (this.fragPrevious = r5), this.fragBufferedComplete(r5, i4);
            }
          }, T2.onError = function(e5, t5) {
            switch (t5.details) {
              case p2.ErrorDetails.FRAG_LOAD_ERROR:
              case p2.ErrorDetails.FRAG_LOAD_TIMEOUT:
              case p2.ErrorDetails.KEY_LOAD_ERROR:
              case p2.ErrorDetails.KEY_LOAD_TIMEOUT:
                this.onFragmentOrKeyLoadError(u2.PlaylistLevelType.MAIN, t5);
                break;
              case p2.ErrorDetails.LEVEL_LOAD_ERROR:
              case p2.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                this.state !== n2.State.ERROR && (t5.fatal ? (this.warn("" + t5.details), this.state = n2.State.ERROR) : t5.levelRetry || this.state !== n2.State.WAITING_LEVEL || (this.state = n2.State.IDLE));
                break;
              case p2.ErrorDetails.BUFFER_FULL_ERROR:
                if ("main" === t5.parent && (this.state === n2.State.PARSING || this.state === n2.State.PARSED)) {
                  var r5 = true, i4 = this.getFwdBufferInfo(this.media, u2.PlaylistLevelType.MAIN);
                  i4 && i4.len > 0.5 && (r5 = !this.reduceMaxBufferLength(i4.len)), r5 && (this.warn("buffer full error also media.currentTime is not buffered, flush main"), this.immediateLevelSwitch()), this.resetLoadingState();
                }
            }
          }, T2.checkBuffer = function() {
            var e5 = this.media, t5 = this.gapController;
            if (e5 && t5 && e5.readyState) {
              if (this.loadedmetadata || !o2.BufferHelper.getBuffered(e5).length) {
                var r5 = this.state !== n2.State.IDLE ? this.fragCurrent : null;
                t5.poll(this.lastCurrentTime, r5);
              }
              this.lastCurrentTime = e5.currentTime;
            }
          }, T2.onFragLoadEmergencyAborted = function() {
            this.state = n2.State.IDLE, this.loadedmetadata || (this.startFragRequested = false, this.nextLoadPosition = this.startPosition), this.tickImmediate();
          }, T2.onBufferFlushed = function(e5, t5) {
            var r5 = t5.type;
            if (r5 !== c2.ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {
              var i4 = (r5 === c2.ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
              this.afterBufferFlushed(i4, r5, u2.PlaylistLevelType.MAIN);
            }
          }, T2.onLevelsUpdated = function(e5, t5) {
            this.levels = t5.levels;
          }, T2.swapAudioCodec = function() {
            this.audioCodecSwap = !this.audioCodecSwap;
          }, T2.seekToStartPos = function() {
            var e5 = this.media;
            if (e5) {
              var t5 = e5.currentTime, r5 = this.startPosition;
              if (r5 >= 0 && t5 < r5) {
                if (e5.seeking)
                  return void this.log("could not seek to " + r5 + ", already seeking at " + t5);
                var i4 = o2.BufferHelper.getBuffered(e5), n3 = (i4.length ? i4.start(0) : 0) - r5;
                n3 > 0 && (n3 < this.config.maxBufferHole || n3 < this.config.maxFragLookUpTolerance) && (this.log("adjusting start position by " + n3 + " to match buffer start"), r5 += n3, this.startPosition = r5), this.log("seek to target start position " + r5 + " from current time " + t5), e5.currentTime = r5;
              }
            }
          }, T2._getAudioCodec = function(e5) {
            var t5 = this.config.defaultAudioCodec || e5.audioCodec;
            return this.audioCodecSwap && t5 && (this.log("Swapping audio codec"), t5 = -1 !== t5.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), t5;
          }, T2._loadBitrateTestFrag = function(e5) {
            var t5 = this;
            e5.bitrateTest = true, this._doFragLoad(e5).then(function(r5) {
              var i4 = t5.hls;
              if (r5 && !i4.nextLoadLevel && !t5.fragContextChanged(e5)) {
                t5.fragLoadError = 0, t5.state = n2.State.IDLE, t5.startFragRequested = false, t5.bitrateTest = false;
                var a3 = e5.stats;
                a3.parsing.start = a3.parsing.end = a3.buffering.start = a3.buffering.end = self.performance.now(), i4.trigger(s2.Events.FRAG_LOADED, r5), e5.bitrateTest = false;
              }
            });
          }, T2._handleTransmuxComplete = function(e5) {
            var t5, r5 = "main", a3 = this.hls, o3 = e5.remuxResult, l3 = e5.chunkMeta, u3 = this.getCurrentContext(l3);
            if (!u3)
              return this.warn("The loading context changed while buffering fragment " + l3.sn + " of level " + l3.level + ". This chunk will not be buffered."), void this.resetStartWhenNotLoaded(l3.level);
            var d3 = u3.frag, h3 = u3.part, f3 = u3.level, p3 = o3.video, g3 = o3.text, v3 = o3.id3, m4 = o3.initSegment, y3 = f3.details, A3 = this.altAudio ? void 0 : o3.audio;
            if (!this.fragContextChanged(d3)) {
              if (this.state = n2.State.PARSING, m4) {
                m4.tracks && (this._bufferInitSegment(f3, m4.tracks, d3, l3), a3.trigger(s2.Events.FRAG_PARSING_INIT_SEGMENT, { frag: d3, id: r5, tracks: m4.tracks }));
                var E3 = m4.initPTS, T3 = m4.timescale;
                (0, i3.isFiniteNumber)(E3) && (this.initPTS[d3.cc] = E3, a3.trigger(s2.Events.INIT_PTS_FOUND, { frag: d3, id: r5, initPTS: E3, timescale: T3 }));
              }
              if (p3 && false !== o3.independent) {
                if (y3) {
                  var b2 = p3.startPTS, k2 = p3.endPTS, S2 = p3.startDTS, _2 = p3.endDTS;
                  if (h3)
                    h3.elementaryStreams[p3.type] = { startPTS: b2, endPTS: k2, startDTS: S2, endDTS: _2 };
                  else if (p3.firstKeyFrame && p3.independent && (this.couldBacktrack = true), p3.dropped && p3.independent) {
                    var C2 = this.getMainFwdBufferInfo();
                    if ((C2 ? C2.end : this.getLoadPosition()) + this.config.maxBufferHole < (p3.firstKeyFramePTS ? p3.firstKeyFramePTS : b2) - this.config.maxBufferHole)
                      return void this.backtrack(d3);
                    d3.setElementaryStreamInfo(p3.type, d3.start, k2, d3.start, _2, true);
                  }
                  d3.setElementaryStreamInfo(p3.type, b2, k2, S2, _2), this.backtrackFragment && (this.backtrackFragment = d3), this.bufferFragmentData(p3, d3, h3, l3);
                }
              } else if (false === o3.independent)
                return void this.backtrack(d3);
              if (A3) {
                var L2 = A3.startPTS, D2 = A3.endPTS, R2 = A3.startDTS, I2 = A3.endDTS;
                h3 && (h3.elementaryStreams[c2.ElementaryStreamTypes.AUDIO] = { startPTS: L2, endPTS: D2, startDTS: R2, endDTS: I2 }), d3.setElementaryStreamInfo(c2.ElementaryStreamTypes.AUDIO, L2, D2, R2, I2), this.bufferFragmentData(A3, d3, h3, l3);
              }
              if (y3 && null != v3 && null !== (t5 = v3.samples) && void 0 !== t5 && t5.length) {
                var O2 = { id: r5, frag: d3, details: y3, samples: v3.samples };
                a3.trigger(s2.Events.FRAG_PARSING_METADATA, O2);
              }
              if (y3 && g3) {
                var w2 = { id: r5, frag: d3, details: y3, samples: g3.samples };
                a3.trigger(s2.Events.FRAG_PARSING_USERDATA, w2);
              }
            }
          }, T2._bufferInitSegment = function(e5, t5, r5, i4) {
            var a3 = this;
            if (this.state === n2.State.PARSING) {
              this.audioOnly = !!t5.audio && !t5.video, this.altAudio && !this.audioOnly && delete t5.audio;
              var o3 = t5.audio, l3 = t5.video, u3 = t5.audiovideo;
              if (o3) {
                var c3 = e5.audioCodec, d3 = navigator.userAgent.toLowerCase();
                this.audioCodecSwitch && (c3 && (c3 = -1 !== c3.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), 1 !== o3.metadata.channelCount && -1 === d3.indexOf("firefox") && (c3 = "mp4a.40.5")), -1 !== d3.indexOf("android") && "audio/mpeg" !== o3.container && (c3 = "mp4a.40.2", this.log("Android: force audio codec to " + c3)), e5.audioCodec && e5.audioCodec !== c3 && this.log('Swapping manifest audio codec "' + e5.audioCodec + '" for "' + c3 + '"'), o3.levelCodec = c3, o3.id = "main", this.log("Init audio buffer, container:" + o3.container + ", codecs[selected/level/parsed]=[" + (c3 || "") + "/" + (e5.audioCodec || "") + "/" + o3.codec + "]");
              }
              l3 && (l3.levelCodec = e5.videoCodec, l3.id = "main", this.log("Init video buffer, container:" + l3.container + ", codecs[level/parsed]=[" + (e5.videoCodec || "") + "/" + l3.codec + "]")), u3 && this.log("Init audiovideo buffer, container:" + u3.container + ", codecs[level/parsed]=[" + (e5.attrs.CODECS || "") + "/" + u3.codec + "]"), this.hls.trigger(s2.Events.BUFFER_CODECS, t5), Object.keys(t5).forEach(function(e6) {
                var n3 = t5[e6].initSegment;
                null != n3 && n3.byteLength && a3.hls.trigger(s2.Events.BUFFER_APPENDING, { type: e6, data: n3, frag: r5, part: null, chunkMeta: i4, parent: r5.type });
              }), this.tick();
            }
          }, T2.getMainFwdBufferInfo = function() {
            return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, u2.PlaylistLevelType.MAIN);
          }, T2.backtrack = function(e5) {
            this.couldBacktrack = true, this.backtrackFragment = e5, this.resetTransmuxer(), this.flushBufferGap(e5), this.fragmentTracker.removeFragment(e5), this.fragPrevious = null, this.nextLoadPosition = e5.start, this.state = n2.State.IDLE;
          }, T2.checkFragmentChanged = function() {
            var e5 = this.media, t5 = null;
            if (e5 && e5.readyState > 1 && false === e5.seeking) {
              var r5 = e5.currentTime;
              if (o2.BufferHelper.isBuffered(e5, r5) ? t5 = this.getAppendedFrag(r5) : o2.BufferHelper.isBuffered(e5, r5 + 0.1) && (t5 = this.getAppendedFrag(r5 + 0.1)), t5) {
                this.backtrackFragment = null;
                var i4 = this.fragPlaying, n3 = t5.level;
                i4 && t5.sn === i4.sn && i4.level === n3 && t5.urlId === i4.urlId || (this.hls.trigger(s2.Events.FRAG_CHANGED, { frag: t5 }), i4 && i4.level === n3 || this.hls.trigger(s2.Events.LEVEL_SWITCHED, { level: n3 }), this.fragPlaying = t5);
              }
            }
          }, y2 = m3, (A2 = [{ key: "nextLevel", get: function() {
            var e5 = this.nextBufferedFrag;
            return e5 ? e5.level : -1;
          } }, { key: "currentFrag", get: function() {
            var e5 = this.media;
            return e5 ? this.fragPlaying || this.getAppendedFrag(e5.currentTime) : null;
          } }, { key: "currentProgramDateTime", get: function() {
            var e5 = this.media;
            if (e5) {
              var t5 = e5.currentTime, r5 = this.currentFrag;
              if (r5 && (0, i3.isFiniteNumber)(t5) && (0, i3.isFiniteNumber)(r5.programDateTime)) {
                var n3 = r5.programDateTime + 1e3 * (t5 - r5.start);
                return new Date(n3);
              }
            }
            return null;
          } }, { key: "currentLevel", get: function() {
            var e5 = this.currentFrag;
            return e5 ? e5.level : -1;
          } }, { key: "nextBufferedFrag", get: function() {
            var e5 = this.currentFrag;
            return e5 ? this.followingBufferedFrag(e5) : null;
          } }, { key: "forceStartLoad", get: function() {
            return this._forceStartLoad;
          } }]) && g2(y2.prototype, A2), E2 && g2(y2, E2), Object.defineProperty(y2, "prototype", { writable: false }), m3;
        }(n2.default);
      }
    ), "./src/controller/subtitle-stream-controller.ts": (
      /*!******************************************************!*\
          !*** ./src/controller/subtitle-stream-controller.ts ***!
          \******************************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { SubtitleStreamController: () => p2 });
        var i3 = r3(
          /*! ../events */
          "./src/events.ts"
        ), n2 = r3(
          /*! ../utils/buffer-helper */
          "./src/utils/buffer-helper.ts"
        ), a2 = r3(
          /*! ./fragment-finders */
          "./src/controller/fragment-finders.ts"
        ), s2 = r3(
          /*! ../utils/discontinuities */
          "./src/utils/discontinuities.ts"
        ), o2 = r3(
          /*! ./level-helper */
          "./src/controller/level-helper.ts"
        ), l2 = r3(
          /*! ./fragment-tracker */
          "./src/controller/fragment-tracker.ts"
        ), u2 = r3(
          /*! ./base-stream-controller */
          "./src/controller/base-stream-controller.ts"
        ), c2 = r3(
          /*! ../types/loader */
          "./src/types/loader.ts"
        ), d2 = r3(
          /*! ../types/level */
          "./src/types/level.ts"
        );
        function h2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        function f2(e4, t4) {
          return f2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
            return e5.__proto__ = t5, e5;
          }, f2(e4, t4);
        }
        var p2 = function(e4) {
          var t4, r4;
          function p3(t5, r5) {
            var i4;
            return (i4 = e4.call(this, t5, r5, "[subtitle-stream-controller]") || this).levels = [], i4.currentTrackId = -1, i4.tracksBuffered = [], i4.mainDetails = null, i4._registerListeners(), i4;
          }
          r4 = e4, (t4 = p3).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, f2(t4, r4);
          var v2, m2, y2, A2 = p3.prototype;
          return A2.onHandlerDestroying = function() {
            this._unregisterListeners(), this.mainDetails = null;
          }, A2._registerListeners = function() {
            var e5 = this.hls;
            e5.on(i3.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e5.on(i3.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e5.on(i3.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.on(i3.Events.LEVEL_LOADED, this.onLevelLoaded, this), e5.on(i3.Events.ERROR, this.onError, this), e5.on(i3.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e5.on(i3.Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e5.on(i3.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e5.on(i3.Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e5.on(i3.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), e5.on(i3.Events.FRAG_BUFFERED, this.onFragBuffered, this);
          }, A2._unregisterListeners = function() {
            var e5 = this.hls;
            e5.off(i3.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e5.off(i3.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e5.off(i3.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.off(i3.Events.LEVEL_LOADED, this.onLevelLoaded, this), e5.off(i3.Events.ERROR, this.onError, this), e5.off(i3.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e5.off(i3.Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e5.off(i3.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e5.off(i3.Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e5.off(i3.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), e5.off(i3.Events.FRAG_BUFFERED, this.onFragBuffered, this);
          }, A2.startLoad = function(e5) {
            this.stopLoad(), this.state = u2.State.IDLE, this.setInterval(500), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e5, this.tick();
          }, A2.onManifestLoading = function() {
            this.mainDetails = null, this.fragmentTracker.removeAllFragments();
          }, A2.onLevelLoaded = function(e5, t5) {
            this.mainDetails = t5.details;
          }, A2.onSubtitleFragProcessed = function(e5, t5) {
            var r5 = t5.frag, i4 = t5.success;
            if (this.fragPrevious = r5, this.state = u2.State.IDLE, i4) {
              var n3 = this.tracksBuffered[this.currentTrackId];
              if (n3) {
                for (var a3, s3 = r5.start, o3 = 0; o3 < n3.length; o3++)
                  if (s3 >= n3[o3].start && s3 <= n3[o3].end) {
                    a3 = n3[o3];
                    break;
                  }
                var l3 = r5.start + r5.duration;
                a3 ? a3.end = l3 : (a3 = { start: s3, end: l3 }, n3.push(a3)), this.fragmentTracker.fragBuffered(r5);
              }
            }
          }, A2.onBufferFlushing = function(e5, t5) {
            var r5 = t5.startOffset, i4 = t5.endOffset;
            if (0 === r5 && i4 !== Number.POSITIVE_INFINITY) {
              var n3 = this.currentTrackId, a3 = this.levels;
              if (!a3.length || !a3[n3] || !a3[n3].details)
                return;
              var s3 = i4 - a3[n3].details.targetduration;
              if (s3 <= 0)
                return;
              t5.endOffsetSubtitles = Math.max(0, s3), this.tracksBuffered.forEach(function(e6) {
                for (var t6 = 0; t6 < e6.length; )
                  if (e6[t6].end <= s3)
                    e6.shift();
                  else {
                    if (!(e6[t6].start < s3))
                      break;
                    e6[t6].start = s3, t6++;
                  }
              }), this.fragmentTracker.removeFragmentsInRange(r5, s3, c2.PlaylistLevelType.SUBTITLE);
            }
          }, A2.onFragBuffered = function(e5, t5) {
            var r5;
            this.loadedmetadata || t5.frag.type !== c2.PlaylistLevelType.MAIN || null !== (r5 = this.media) && void 0 !== r5 && r5.buffered.length && (this.loadedmetadata = true);
          }, A2.onError = function(e5, t5) {
            var r5, i4 = t5.frag;
            i4 && i4.type === c2.PlaylistLevelType.SUBTITLE && (null !== (r5 = this.fragCurrent) && void 0 !== r5 && r5.loader && this.fragCurrent.loader.abort(), this.state = u2.State.IDLE);
          }, A2.onSubtitleTracksUpdated = function(e5, t5) {
            var r5 = this, i4 = t5.subtitleTracks;
            this.tracksBuffered = [], this.levels = i4.map(function(e6) {
              return new d2.Level(e6);
            }), this.fragmentTracker.removeAllFragments(), this.fragPrevious = null, this.levels.forEach(function(e6) {
              r5.tracksBuffered[e6.id] = [];
            }), this.mediaBuffer = null;
          }, A2.onSubtitleTrackSwitch = function(e5, t5) {
            if (this.currentTrackId = t5.id, this.levels.length && -1 !== this.currentTrackId) {
              var r5 = this.levels[this.currentTrackId];
              null != r5 && r5.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, r5 && this.setInterval(500);
            } else
              this.clearInterval();
          }, A2.onSubtitleTrackLoaded = function(e5, t5) {
            var r5, i4 = t5.details, n3 = t5.id, l3 = this.currentTrackId, c3 = this.levels;
            if (c3.length) {
              var d3 = c3[l3];
              if (!(n3 >= c3.length || n3 !== l3) && d3) {
                this.mediaBuffer = this.mediaBufferTimeRanges;
                var h3 = 0;
                if (i4.live || null !== (r5 = d3.details) && void 0 !== r5 && r5.live) {
                  var f3 = this.mainDetails;
                  if (i4.deltaUpdateFailed || !f3)
                    return;
                  var p4 = f3.fragments[0];
                  d3.details ? 0 === (h3 = this.alignPlaylists(i4, d3.details)) && p4 && (h3 = p4.start, (0, o2.addSliding)(i4, h3)) : i4.hasProgramDateTime && f3.hasProgramDateTime ? ((0, s2.alignMediaPlaylistByPDT)(i4, f3), h3 = i4.fragments[0].start) : p4 && (h3 = p4.start, (0, o2.addSliding)(i4, h3));
                }
                d3.details = i4, this.levelLastLoaded = n3, this.startFragRequested || !this.mainDetails && i4.live || this.setStartPosition(d3.details, h3), this.tick(), i4.live && !this.fragCurrent && this.media && this.state === u2.State.IDLE && ((0, a2.findFragmentByPTS)(null, i4.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), d3.details = void 0));
              }
            }
          }, A2._handleFragmentLoadComplete = function(e5) {
            var t5 = e5.frag, r5 = e5.payload, n3 = t5.decryptdata, a3 = this.hls;
            if (!this.fragContextChanged(t5) && r5 && r5.byteLength > 0 && n3 && n3.key && n3.iv && "AES-128" === n3.method) {
              var s3 = performance.now();
              this.decrypter.webCryptoDecrypt(new Uint8Array(r5), n3.key.buffer, n3.iv.buffer).then(function(e6) {
                var r6 = performance.now();
                a3.trigger(i3.Events.FRAG_DECRYPTED, { frag: t5, payload: e6, stats: { tstart: s3, tdecrypt: r6 } });
              });
            }
          }, A2.doTick = function() {
            if (this.media) {
              if (this.state === u2.State.IDLE) {
                var e5 = this.currentTrackId, t5 = this.levels;
                if (!t5.length || !t5[e5] || !t5[e5].details)
                  return;
                var r5 = t5[e5].details, i4 = r5.targetduration, s3 = this.config, o3 = this.getLoadPosition(), d3 = n2.BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], o3 - i4, s3.maxBufferHole), h3 = d3.end, f3 = d3.len, p4 = this.getFwdBufferInfo(this.media, c2.PlaylistLevelType.MAIN);
                if (f3 > this.getMaxBufferLength(null == p4 ? void 0 : p4.len) + i4)
                  return;
                console.assert(r5, "Subtitle track details are defined on idle subtitle stream controller tick");
                var g3, v3 = r5.fragments, m3 = v3.length, y3 = r5.edge, A3 = this.fragPrevious;
                if (h3 < y3) {
                  var E2 = s3.maxFragLookUpTolerance;
                  !(g3 = (0, a2.findFragmentByPTS)(A3, v3, Math.max(v3[0].start, h3), E2)) && A3 && A3.start < v3[0].start && (g3 = v3[0]);
                } else
                  g3 = v3[m3 - 1];
                if (!(g3 = this.mapToInitFragWhenRequired(g3)))
                  return;
                if (this.fragmentTracker.getState(g3) !== l2.FragmentState.NOT_LOADED)
                  return;
                g3.encrypted ? this.loadKey(g3, r5) : this.loadFragment(g3, r5, h3);
              }
            } else
              this.state = u2.State.IDLE;
          }, A2.getMaxBufferLength = function(t5) {
            var r5 = e4.prototype.getMaxBufferLength.call(this);
            return t5 ? Math.max(r5, t5) : r5;
          }, A2.loadFragment = function(t5, r5, i4) {
            this.fragCurrent = t5, "initSegment" === t5.sn ? this._loadInitSegment(t5) : (this.startFragRequested = true, e4.prototype.loadFragment.call(this, t5, r5, i4));
          }, v2 = p3, (m2 = [{ key: "mediaBufferTimeRanges", get: function() {
            return new g2(this.tracksBuffered[this.currentTrackId] || []);
          } }]) && h2(v2.prototype, m2), y2 && h2(v2, y2), Object.defineProperty(v2, "prototype", { writable: false }), p3;
        }(u2.default), g2 = function(e4) {
          this.buffered = void 0;
          var t4 = function(t5, r4, i4) {
            if ((r4 >>>= 0) > i4 - 1)
              throw new DOMException("Failed to execute '" + t5 + "' on 'TimeRanges': The index provided (" + r4 + ") is greater than the maximum bound (" + i4 + ")");
            return e4[r4][t5];
          };
          this.buffered = { get length() {
            return e4.length;
          }, end: function(r4) {
            return t4("end", r4, e4.length);
          }, start: function(r4) {
            return t4("start", r4, e4.length);
          } };
        };
      }
    ), "./src/controller/subtitle-track-controller.ts": (
      /*!*****************************************************!*\
          !*** ./src/controller/subtitle-track-controller.ts ***!
          \*****************************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => d2 });
        var i3 = r3(
          /*! ../events */
          "./src/events.ts"
        ), n2 = r3(
          /*! ../utils/texttrack-utils */
          "./src/utils/texttrack-utils.ts"
        ), a2 = r3(
          /*! ./base-playlist-controller */
          "./src/controller/base-playlist-controller.ts"
        ), s2 = r3(
          /*! ../types/loader */
          "./src/types/loader.ts"
        );
        function o2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        function l2(e4, t4) {
          return l2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
            return e5.__proto__ = t5, e5;
          }, l2(e4, t4);
        }
        var u2 = function(e4) {
          var t4, r4;
          function a3(t5) {
            var r5;
            return (r5 = e4.call(this, t5, "[subtitle-track-controller]") || this).media = null, r5.tracks = [], r5.groupId = null, r5.tracksInGroup = [], r5.trackId = -1, r5.selectDefaultTrack = true, r5.queuedDefaultTrack = -1, r5.trackChangeListener = function() {
              return r5.onTextTracksChanged();
            }, r5.asyncPollTrackChange = function() {
              return r5.pollTrackChange(0);
            }, r5.useTextTrackPolling = false, r5.subtitlePollingInterval = -1, r5._subtitleDisplay = true, r5.registerListeners(), r5;
          }
          r4 = e4, (t4 = a3).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, l2(t4, r4);
          var u3, d3, h2, f2 = a3.prototype;
          return f2.destroy = function() {
            this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.trackChangeListener = this.asyncPollTrackChange = null, e4.prototype.destroy.call(this);
          }, f2.registerListeners = function() {
            var e5 = this.hls;
            e5.on(i3.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e5.on(i3.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e5.on(i3.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.on(i3.Events.MANIFEST_PARSED, this.onManifestParsed, this), e5.on(i3.Events.LEVEL_LOADING, this.onLevelLoading, this), e5.on(i3.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), e5.on(i3.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e5.on(i3.Events.ERROR, this.onError, this);
          }, f2.unregisterListeners = function() {
            var e5 = this.hls;
            e5.off(i3.Events.MEDIA_ATTACHED, this.onMediaAttached, this), e5.off(i3.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e5.off(i3.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.off(i3.Events.MANIFEST_PARSED, this.onManifestParsed, this), e5.off(i3.Events.LEVEL_LOADING, this.onLevelLoading, this), e5.off(i3.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), e5.off(i3.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e5.off(i3.Events.ERROR, this.onError, this);
          }, f2.onMediaAttached = function(e5, t5) {
            this.media = t5.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange));
          }, f2.pollTrackChange = function(e5) {
            self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, e5);
          }, f2.onMediaDetaching = function() {
            this.media && (self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), c2(this.media.textTracks).forEach(function(e5) {
              (0, n2.clearCurrentCues)(e5);
            }), this.subtitleTrack = -1, this.media = null);
          }, f2.onManifestLoading = function() {
            this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.selectDefaultTrack = true;
          }, f2.onManifestParsed = function(e5, t5) {
            this.tracks = t5.subtitleTracks;
          }, f2.onSubtitleTrackLoaded = function(e5, t5) {
            var r5 = t5.id, i4 = t5.details, n3 = this.trackId, a4 = this.tracksInGroup[n3];
            if (a4) {
              var s3 = a4.details;
              a4.details = t5.details, this.log("subtitle track " + r5 + " loaded [" + i4.startSN + "-" + i4.endSN + "]"), r5 === this.trackId && (this.retryCount = 0, this.playlistLoaded(r5, t5, s3));
            } else
              this.warn("Invalid subtitle track id " + r5);
          }, f2.onLevelLoading = function(e5, t5) {
            this.switchLevel(t5.level);
          }, f2.onLevelSwitching = function(e5, t5) {
            this.switchLevel(t5.level);
          }, f2.switchLevel = function(e5) {
            var t5 = this.hls.levels[e5];
            if (null != t5 && t5.textGroupIds) {
              var r5 = t5.textGroupIds[t5.urlId];
              if (this.groupId !== r5) {
                var n3 = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0, a4 = this.tracks.filter(function(e6) {
                  return !r5 || e6.groupId === r5;
                });
                this.tracksInGroup = a4;
                var s3 = this.findTrackId(null == n3 ? void 0 : n3.name) || this.findTrackId();
                this.groupId = r5;
                var o3 = { subtitleTracks: a4 };
                this.log("Updating subtitle tracks, " + a4.length + ' track(s) found in "' + r5 + '" group-id'), this.hls.trigger(i3.Events.SUBTITLE_TRACKS_UPDATED, o3), -1 !== s3 && this.setSubtitleTrack(s3, n3);
              }
            }
          }, f2.findTrackId = function(e5) {
            for (var t5 = this.tracksInGroup, r5 = 0; r5 < t5.length; r5++) {
              var i4 = t5[r5];
              if ((!this.selectDefaultTrack || i4.default) && (!e5 || e5 === i4.name))
                return i4.id;
            }
            return -1;
          }, f2.onError = function(t5, r5) {
            e4.prototype.onError.call(this, t5, r5), !r5.fatal && r5.context && r5.context.type === s2.PlaylistContextType.SUBTITLE_TRACK && r5.context.id === this.trackId && r5.context.groupId === this.groupId && this.retryLoadingOrFail(r5);
          }, f2.loadPlaylist = function(e5) {
            var t5 = this.tracksInGroup[this.trackId];
            if (this.shouldLoadTrack(t5)) {
              var r5 = t5.id, n3 = t5.groupId, a4 = t5.url;
              if (e5)
                try {
                  a4 = e5.addDirectives(a4);
                } catch (e6) {
                  this.warn("Could not construct new URL with HLS Delivery Directives: " + e6);
                }
              this.log("Loading subtitle playlist for id " + r5), this.hls.trigger(i3.Events.SUBTITLE_TRACK_LOADING, { url: a4, id: r5, groupId: n3, deliveryDirectives: e5 || null });
            }
          }, f2.toggleTrackModes = function(e5) {
            var t5 = this, r5 = this.media, i4 = this.trackId;
            if (r5) {
              var n3 = c2(r5.textTracks), a4 = n3.filter(function(e6) {
                return e6.groupId === t5.groupId;
              });
              if (-1 === e5)
                [].slice.call(n3).forEach(function(e6) {
                  e6.mode = "disabled";
                });
              else {
                var s3 = a4[i4];
                s3 && (s3.mode = "disabled");
              }
              var o3 = a4[e5];
              o3 && (o3.mode = this.subtitleDisplay ? "showing" : "hidden");
            }
          }, f2.setSubtitleTrack = function(e5, t5) {
            var r5, n3 = this.tracksInGroup;
            if (this.media) {
              if (this.trackId !== e5 && this.toggleTrackModes(e5), !(this.trackId === e5 && (-1 === e5 || null !== (r5 = n3[e5]) && void 0 !== r5 && r5.details) || e5 < -1 || e5 >= n3.length)) {
                this.clearTimer();
                var a4 = n3[e5];
                if (this.log("Switching to subtitle track " + e5), this.trackId = e5, a4) {
                  var s3 = a4.id, o3 = a4.groupId, l3 = void 0 === o3 ? "" : o3, u4 = a4.name, c3 = a4.type, d4 = a4.url;
                  this.hls.trigger(i3.Events.SUBTITLE_TRACK_SWITCH, { id: s3, groupId: l3, name: u4, type: c3, url: d4 });
                  var h3 = this.switchParams(a4.url, null == t5 ? void 0 : t5.details);
                  this.loadPlaylist(h3);
                } else
                  this.hls.trigger(i3.Events.SUBTITLE_TRACK_SWITCH, { id: e5 });
              }
            } else
              this.queuedDefaultTrack = e5;
          }, f2.onTextTracksChanged = function() {
            if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), this.media && this.hls.config.renderTextTracksNatively) {
              for (var e5 = -1, t5 = c2(this.media.textTracks), r5 = 0; r5 < t5.length; r5++)
                if ("hidden" === t5[r5].mode)
                  e5 = r5;
                else if ("showing" === t5[r5].mode) {
                  e5 = r5;
                  break;
                }
              this.subtitleTrack !== e5 && (this.subtitleTrack = e5);
            }
          }, u3 = a3, (d3 = [{ key: "subtitleDisplay", get: function() {
            return this._subtitleDisplay;
          }, set: function(e5) {
            this._subtitleDisplay = e5, this.trackId > -1 && this.toggleTrackModes(this.trackId);
          } }, { key: "subtitleTracks", get: function() {
            return this.tracksInGroup;
          } }, { key: "subtitleTrack", get: function() {
            return this.trackId;
          }, set: function(e5) {
            this.selectDefaultTrack = false;
            var t5 = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
            this.setSubtitleTrack(e5, t5);
          } }]) && o2(u3.prototype, d3), h2 && o2(u3, h2), Object.defineProperty(u3, "prototype", { writable: false }), a3;
        }(a2.default);
        function c2(e4) {
          for (var t4 = [], r4 = 0; r4 < e4.length; r4++) {
            var i4 = e4[r4];
            "subtitles" === i4.kind && i4.label && t4.push(e4[r4]);
          }
          return t4;
        }
        const d2 = u2;
      }
    ), "./src/controller/timeline-controller.ts": (
      /*!***********************************************!*\
          !*** ./src/controller/timeline-controller.ts ***!
          \***********************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { TimelineController: () => f2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), a2 = r3(
          /*! ../utils/cea-608-parser */
          "./src/utils/cea-608-parser.ts"
        ), s2 = r3(
          /*! ../utils/output-filter */
          "./src/utils/output-filter.ts"
        ), o2 = r3(
          /*! ../utils/webvtt-parser */
          "./src/utils/webvtt-parser.ts"
        ), l2 = r3(
          /*! ../utils/texttrack-utils */
          "./src/utils/texttrack-utils.ts"
        ), u2 = r3(
          /*! ../utils/imsc1-ttml-parser */
          "./src/utils/imsc1-ttml-parser.ts"
        ), c2 = r3(
          /*! ../utils/mp4-tools */
          "./src/utils/mp4-tools.ts"
        ), d2 = r3(
          /*! ../types/loader */
          "./src/types/loader.ts"
        ), h2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), f2 = function() {
          function e4(e5) {
            if (this.hls = void 0, this.media = null, this.config = void 0, this.enabled = true, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.timescale = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = { ccOffset: 0, presentationOffset: 0, 0: { start: 0, prevCC: -1, new: true } }, this.captionsProperties = void 0, this.hls = e5, this.config = e5.config, this.Cues = e5.config.cueHandler, this.captionsProperties = { textTrack1: { label: this.config.captionsTextTrack1Label, languageCode: this.config.captionsTextTrack1LanguageCode }, textTrack2: { label: this.config.captionsTextTrack2Label, languageCode: this.config.captionsTextTrack2LanguageCode }, textTrack3: { label: this.config.captionsTextTrack3Label, languageCode: this.config.captionsTextTrack3LanguageCode }, textTrack4: { label: this.config.captionsTextTrack4Label, languageCode: this.config.captionsTextTrack4LanguageCode } }, this.config.enableCEA708Captions) {
              var t5 = new s2.default(this, "textTrack1"), r4 = new s2.default(this, "textTrack2"), i4 = new s2.default(this, "textTrack3"), o3 = new s2.default(this, "textTrack4");
              this.cea608Parser1 = new a2.default(1, t5, r4), this.cea608Parser2 = new a2.default(3, i4, o3);
            }
            e5.on(n2.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e5.on(n2.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e5.on(n2.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.on(n2.Events.MANIFEST_LOADED, this.onManifestLoaded, this), e5.on(n2.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e5.on(n2.Events.FRAG_LOADING, this.onFragLoading, this), e5.on(n2.Events.FRAG_LOADED, this.onFragLoaded, this), e5.on(n2.Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e5.on(n2.Events.FRAG_DECRYPTED, this.onFragDecrypted, this), e5.on(n2.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), e5.on(n2.Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e5.on(n2.Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
          }
          var t4 = e4.prototype;
          return t4.destroy = function() {
            var e5 = this.hls;
            e5.off(n2.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), e5.off(n2.Events.MEDIA_DETACHING, this.onMediaDetaching, this), e5.off(n2.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.off(n2.Events.MANIFEST_LOADED, this.onManifestLoaded, this), e5.off(n2.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e5.off(n2.Events.FRAG_LOADING, this.onFragLoading, this), e5.off(n2.Events.FRAG_LOADED, this.onFragLoaded, this), e5.off(n2.Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e5.off(n2.Events.FRAG_DECRYPTED, this.onFragDecrypted, this), e5.off(n2.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), e5.off(n2.Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e5.off(n2.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null;
          }, t4.addCues = function(e5, t5, r4, i4, a3) {
            for (var s3, o3, l3, u3, c3 = false, d3 = a3.length; d3--; ) {
              var h3 = a3[d3], f3 = (s3 = h3[0], o3 = h3[1], l3 = t5, u3 = r4, Math.min(o3, u3) - Math.max(s3, l3));
              if (f3 >= 0 && (h3[0] = Math.min(h3[0], t5), h3[1] = Math.max(h3[1], r4), c3 = true, f3 / (r4 - t5) > 0.5))
                return;
            }
            if (c3 || a3.push([t5, r4]), this.config.renderTextTracksNatively) {
              var p3 = this.captionsTracks[e5];
              this.Cues.newCue(p3, t5, r4, i4);
            } else {
              var g2 = this.Cues.newCue(null, t5, r4, i4);
              this.hls.trigger(n2.Events.CUES_PARSED, { type: "captions", cues: g2, track: e5 });
            }
          }, t4.onInitPtsFound = function(e5, t5) {
            var r4 = this, i4 = t5.frag, a3 = t5.id, s3 = t5.initPTS, o3 = t5.timescale, l3 = this.unparsedVttFrags;
            "main" === a3 && (this.initPTS[i4.cc] = s3, this.timescale[i4.cc] = o3), l3.length && (this.unparsedVttFrags = [], l3.forEach(function(e6) {
              r4.onFragLoaded(n2.Events.FRAG_LOADED, e6);
            }));
          }, t4.getExistingTrack = function(e5) {
            var t5 = this.media;
            if (t5)
              for (var r4 = 0; r4 < t5.textTracks.length; r4++) {
                var i4 = t5.textTracks[r4];
                if (i4[e5])
                  return i4;
              }
            return null;
          }, t4.createCaptionsTrack = function(e5) {
            this.config.renderTextTracksNatively ? this.createNativeTrack(e5) : this.createNonNativeTrack(e5);
          }, t4.createNativeTrack = function(e5) {
            if (!this.captionsTracks[e5]) {
              var t5 = this.captionsProperties, r4 = this.captionsTracks, i4 = this.media, n3 = t5[e5], a3 = n3.label, s3 = n3.languageCode, o3 = this.getExistingTrack(e5);
              if (o3)
                r4[e5] = o3, (0, l2.clearCurrentCues)(r4[e5]), (0, l2.sendAddTrackEvent)(r4[e5], i4);
              else {
                var u3 = this.createTextTrack("captions", a3, s3);
                u3 && (u3[e5] = true, r4[e5] = u3);
              }
            }
          }, t4.createNonNativeTrack = function(e5) {
            if (!this.nonNativeCaptionsTracks[e5]) {
              var t5 = this.captionsProperties[e5];
              if (t5) {
                var r4 = { _id: e5, label: t5.label, kind: "captions", default: !!t5.media && !!t5.media.default, closedCaptions: t5.media };
                this.nonNativeCaptionsTracks[e5] = r4, this.hls.trigger(n2.Events.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: [r4] });
              }
            }
          }, t4.createTextTrack = function(e5, t5, r4) {
            var i4 = this.media;
            if (i4)
              return i4.addTextTrack(e5, t5, r4);
          }, t4.onMediaAttaching = function(e5, t5) {
            this.media = t5.media, this._cleanTracks();
          }, t4.onMediaDetaching = function() {
            var e5 = this.captionsTracks;
            Object.keys(e5).forEach(function(t5) {
              (0, l2.clearCurrentCues)(e5[t5]), delete e5[t5];
            }), this.nonNativeCaptionsTracks = {};
          }, t4.onManifestLoading = function() {
            this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = { ccOffset: 0, presentationOffset: 0, 0: { start: 0, prevCC: -1, new: true } }, this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = [], this.timescale = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset());
          }, t4._cleanTracks = function() {
            var e5 = this.media;
            if (e5) {
              var t5 = e5.textTracks;
              if (t5)
                for (var r4 = 0; r4 < t5.length; r4++)
                  (0, l2.clearCurrentCues)(t5[r4]);
            }
          }, t4.onSubtitleTracksUpdated = function(e5, t5) {
            var r4 = this;
            this.textTracks = [];
            var i4 = t5.subtitleTracks || [], a3 = i4.some(function(e6) {
              return e6.textCodec === u2.IMSC1_CODEC;
            });
            if (this.config.enableWebVTT || a3 && this.config.enableIMSC1) {
              var s3 = this.tracks && i4 && this.tracks.length === i4.length;
              if (this.tracks = i4 || [], this.config.renderTextTracksNatively) {
                var o3 = this.media ? this.media.textTracks : [];
                this.tracks.forEach(function(e6, t6) {
                  var i5;
                  if (t6 < o3.length) {
                    for (var n3 = null, a4 = 0; a4 < o3.length; a4++)
                      if (p2(o3[a4], e6)) {
                        n3 = o3[a4];
                        break;
                      }
                    n3 && (i5 = n3);
                  }
                  if (i5)
                    (0, l2.clearCurrentCues)(i5);
                  else {
                    var s4 = r4._captionsOrSubtitlesFromCharacteristics(e6);
                    (i5 = r4.createTextTrack(s4, e6.name, e6.lang)) && (i5.mode = "disabled");
                  }
                  i5 && (i5.groupId = e6.groupId, r4.textTracks.push(i5));
                });
              } else if (!s3 && this.tracks && this.tracks.length) {
                var c3 = this.tracks.map(function(e6) {
                  return { label: e6.name, kind: e6.type.toLowerCase(), default: e6.default, subtitleTrack: e6 };
                });
                this.hls.trigger(n2.Events.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: c3 });
              }
            }
          }, t4._captionsOrSubtitlesFromCharacteristics = function(e5) {
            var t5;
            if (null !== (t5 = e5.attrs) && void 0 !== t5 && t5.CHARACTERISTICS) {
              var r4 = /transcribes-spoken-dialog/gi.test(e5.attrs.CHARACTERISTICS), i4 = /describes-music-and-sound/gi.test(e5.attrs.CHARACTERISTICS);
              if (r4 && i4)
                return "captions";
            }
            return "subtitles";
          }, t4.onManifestLoaded = function(e5, t5) {
            var r4 = this;
            this.config.enableCEA708Captions && t5.captions && t5.captions.forEach(function(e6) {
              var t6 = /(?:CC|SERVICE)([1-4])/.exec(e6.instreamId);
              if (t6) {
                var i4 = "textTrack" + t6[1], n3 = r4.captionsProperties[i4];
                n3 && (n3.label = e6.name, e6.lang && (n3.languageCode = e6.lang), n3.media = e6);
              }
            });
          }, t4.closedCaptionsForLevel = function(e5) {
            var t5 = this.hls.levels[e5.level];
            return null == t5 ? void 0 : t5.attrs["CLOSED-CAPTIONS"];
          }, t4.onFragLoading = function(e5, t5) {
            var r4 = this.cea608Parser1, i4 = this.cea608Parser2, n3 = this.lastSn, a3 = this.lastPartIndex;
            if (this.enabled && r4 && i4 && t5.frag.type === d2.PlaylistLevelType.MAIN) {
              var s3, o3, l3 = t5.frag.sn, u3 = null != (s3 = null == t5 || null === (o3 = t5.part) || void 0 === o3 ? void 0 : o3.index) ? s3 : -1;
              l3 === n3 + 1 || l3 === n3 && u3 === a3 + 1 || (r4.reset(), i4.reset()), this.lastSn = l3, this.lastPartIndex = u3;
            }
          }, t4.onFragLoaded = function(e5, t5) {
            var r4 = t5.frag, a3 = t5.payload, s3 = this.initPTS, o3 = this.unparsedVttFrags;
            if (r4.type === d2.PlaylistLevelType.SUBTITLE)
              if (a3.byteLength) {
                if (!(0, i3.isFiniteNumber)(s3[r4.cc]))
                  return o3.push(t5), void (s3.length && this.hls.trigger(n2.Events.SUBTITLE_FRAG_PROCESSED, { success: false, frag: r4, error: new Error("Missing initial subtitle PTS") }));
                var l3 = r4.decryptdata, c3 = "stats" in t5;
                if (null == l3 || null == l3.key || "AES-128" !== l3.method || c3) {
                  var h3 = this.tracks[r4.level], f3 = this.vttCCs;
                  f3[r4.cc] || (f3[r4.cc] = { start: r4.start, prevCC: this.prevCC, new: true }, this.prevCC = r4.cc), h3 && h3.textCodec === u2.IMSC1_CODEC ? this._parseIMSC1(r4, a3) : this._parseVTTs(r4, a3, f3);
                }
              } else
                this.hls.trigger(n2.Events.SUBTITLE_FRAG_PROCESSED, { success: false, frag: r4, error: new Error("Empty subtitle payload") });
          }, t4._parseIMSC1 = function(e5, t5) {
            var r4 = this, i4 = this.hls;
            (0, u2.parseIMSC1)(t5, this.initPTS[e5.cc], this.timescale[e5.cc], function(t6) {
              r4._appendCues(t6, e5.level), i4.trigger(n2.Events.SUBTITLE_FRAG_PROCESSED, { success: true, frag: e5 });
            }, function(t6) {
              h2.logger.log("Failed to parse IMSC1: " + t6), i4.trigger(n2.Events.SUBTITLE_FRAG_PROCESSED, { success: false, frag: e5, error: t6 });
            });
          }, t4._parseVTTs = function(e5, t5, r4) {
            var i4, a3 = this, s3 = this.hls, l3 = null !== (i4 = e5.initSegment) && void 0 !== i4 && i4.data ? (0, c2.appendUint8Array)(e5.initSegment.data, new Uint8Array(t5)) : t5;
            (0, o2.parseWebVTT)(l3, this.initPTS[e5.cc], this.timescale[e5.cc], r4, e5.cc, e5.start, function(t6) {
              a3._appendCues(t6, e5.level), s3.trigger(n2.Events.SUBTITLE_FRAG_PROCESSED, { success: true, frag: e5 });
            }, function(r5) {
              a3._fallbackToIMSC1(e5, t5), h2.logger.log("Failed to parse VTT cue: " + r5), s3.trigger(n2.Events.SUBTITLE_FRAG_PROCESSED, { success: false, frag: e5, error: r5 });
            });
          }, t4._fallbackToIMSC1 = function(e5, t5) {
            var r4 = this, i4 = this.tracks[e5.level];
            i4.textCodec || (0, u2.parseIMSC1)(t5, this.initPTS[e5.cc], this.timescale[e5.cc], function() {
              i4.textCodec = u2.IMSC1_CODEC, r4._parseIMSC1(e5, t5);
            }, function() {
              i4.textCodec = "wvtt";
            });
          }, t4._appendCues = function(e5, t5) {
            var r4 = this.hls;
            if (this.config.renderTextTracksNatively) {
              var i4 = this.textTracks[t5];
              if (!i4 || "disabled" === i4.mode)
                return;
              e5.forEach(function(e6) {
                return (0, l2.addCueToTrack)(i4, e6);
              });
            } else {
              var a3 = this.tracks[t5];
              if (!a3)
                return;
              var s3 = a3.default ? "default" : "subtitles" + t5;
              r4.trigger(n2.Events.CUES_PARSED, { type: "subtitles", cues: e5, track: s3 });
            }
          }, t4.onFragDecrypted = function(e5, t5) {
            var r4 = t5.frag;
            if (r4.type === d2.PlaylistLevelType.SUBTITLE) {
              if (!(0, i3.isFiniteNumber)(this.initPTS[r4.cc]))
                return void this.unparsedVttFrags.push(t5);
              this.onFragLoaded(n2.Events.FRAG_LOADED, t5);
            }
          }, t4.onSubtitleTracksCleared = function() {
            this.tracks = [], this.captionsTracks = {};
          }, t4.onFragParsingUserdata = function(e5, t5) {
            var r4 = this.cea608Parser1, i4 = this.cea608Parser2;
            if (this.enabled && r4 && i4) {
              var n3 = t5.frag, a3 = t5.samples;
              if (n3.type !== d2.PlaylistLevelType.MAIN || "NONE" !== this.closedCaptionsForLevel(n3))
                for (var s3 = 0; s3 < a3.length; s3++) {
                  var o3 = a3[s3].bytes;
                  if (o3) {
                    var l3 = this.extractCea608Data(o3);
                    r4.addData(a3[s3].pts, l3[0]), i4.addData(a3[s3].pts, l3[1]);
                  }
                }
            }
          }, t4.onBufferFlushing = function(e5, t5) {
            var r4 = t5.startOffset, i4 = t5.endOffset, n3 = t5.endOffsetSubtitles, a3 = t5.type, s3 = this.media;
            if (s3 && !(s3.currentTime < i4)) {
              if (!a3 || "video" === a3) {
                var o3 = this.captionsTracks;
                Object.keys(o3).forEach(function(e6) {
                  return (0, l2.removeCuesInRange)(o3[e6], r4, i4);
                });
              }
              if (this.config.renderTextTracksNatively && 0 === r4 && void 0 !== n3) {
                var u3 = this.textTracks;
                Object.keys(u3).forEach(function(e6) {
                  return (0, l2.removeCuesInRange)(u3[e6], r4, n3);
                });
              }
            }
          }, t4.extractCea608Data = function(e5) {
            for (var t5 = [[], []], r4 = 31 & e5[0], i4 = 2, n3 = 0; n3 < r4; n3++) {
              var a3 = e5[i4++], s3 = 127 & e5[i4++], o3 = 127 & e5[i4++];
              if ((0 !== s3 || 0 !== o3) && 0 != (4 & a3)) {
                var l3 = 3 & a3;
                0 !== l3 && 1 !== l3 || (t5[l3].push(s3), t5[l3].push(o3));
              }
            }
            return t5;
          }, e4;
        }();
        function p2(e4, t4) {
          return e4 && e4.label === t4.name && !(e4.textTrack1 || e4.textTrack2);
        }
      }
    ), "./src/crypt/aes-crypto.ts": (
      /*!*********************************!*\
          !*** ./src/crypt/aes-crypto.ts ***!
          \*********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => i3 });
        var i3 = function() {
          function e4(e5, t4) {
            this.subtle = void 0, this.aesIV = void 0, this.subtle = e5, this.aesIV = t4;
          }
          return e4.prototype.decrypt = function(e5, t4) {
            return this.subtle.decrypt({ name: "AES-CBC", iv: this.aesIV }, t4, e5);
          }, e4;
        }();
      }
    ), "./src/crypt/aes-decryptor.ts": (
      /*!************************************!*\
          !*** ./src/crypt/aes-decryptor.ts ***!
          \************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => a2, removePadding: () => n2 });
        var i3 = r3(
          /*! ../utils/typed-array */
          "./src/utils/typed-array.ts"
        );
        function n2(e4) {
          var t4 = e4.byteLength, r4 = t4 && new DataView(e4.buffer).getUint8(t4 - 1);
          return r4 ? (0, i3.sliceUint8)(e4, 0, t4 - r4) : e4;
        }
        var a2 = function() {
          function e4() {
            this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable();
          }
          var t4 = e4.prototype;
          return t4.uint8ArrayToUint32Array_ = function(e5) {
            for (var t5 = new DataView(e5), r4 = new Uint32Array(4), i4 = 0; i4 < 4; i4++)
              r4[i4] = t5.getUint32(4 * i4);
            return r4;
          }, t4.initTable = function() {
            var e5 = this.sBox, t5 = this.invSBox, r4 = this.subMix, i4 = r4[0], n3 = r4[1], a3 = r4[2], s2 = r4[3], o2 = this.invSubMix, l2 = o2[0], u2 = o2[1], c2 = o2[2], d2 = o2[3], h2 = new Uint32Array(256), f2 = 0, p2 = 0, g2 = 0;
            for (g2 = 0; g2 < 256; g2++)
              h2[g2] = g2 < 128 ? g2 << 1 : g2 << 1 ^ 283;
            for (g2 = 0; g2 < 256; g2++) {
              var v2 = p2 ^ p2 << 1 ^ p2 << 2 ^ p2 << 3 ^ p2 << 4;
              v2 = v2 >>> 8 ^ 255 & v2 ^ 99, e5[f2] = v2, t5[v2] = f2;
              var m2 = h2[f2], y2 = h2[m2], A2 = h2[y2], E2 = 257 * h2[v2] ^ 16843008 * v2;
              i4[f2] = E2 << 24 | E2 >>> 8, n3[f2] = E2 << 16 | E2 >>> 16, a3[f2] = E2 << 8 | E2 >>> 24, s2[f2] = E2, E2 = 16843009 * A2 ^ 65537 * y2 ^ 257 * m2 ^ 16843008 * f2, l2[v2] = E2 << 24 | E2 >>> 8, u2[v2] = E2 << 16 | E2 >>> 16, c2[v2] = E2 << 8 | E2 >>> 24, d2[v2] = E2, f2 ? (f2 = m2 ^ h2[h2[h2[A2 ^ m2]]], p2 ^= h2[h2[p2]]) : f2 = p2 = 1;
            }
          }, t4.expandKey = function(e5) {
            for (var t5 = this.uint8ArrayToUint32Array_(e5), r4 = true, i4 = 0; i4 < t5.length && r4; )
              r4 = t5[i4] === this.key[i4], i4++;
            if (!r4) {
              this.key = t5;
              var n3 = this.keySize = t5.length;
              if (4 !== n3 && 6 !== n3 && 8 !== n3)
                throw new Error("Invalid aes key size=" + n3);
              var a3, s2, o2, l2, u2 = this.ksRows = 4 * (n3 + 6 + 1), c2 = this.keySchedule = new Uint32Array(u2), d2 = this.invKeySchedule = new Uint32Array(u2), h2 = this.sBox, f2 = this.rcon, p2 = this.invSubMix, g2 = p2[0], v2 = p2[1], m2 = p2[2], y2 = p2[3];
              for (a3 = 0; a3 < u2; a3++)
                a3 < n3 ? o2 = c2[a3] = t5[a3] : (l2 = o2, a3 % n3 == 0 ? (l2 = h2[(l2 = l2 << 8 | l2 >>> 24) >>> 24] << 24 | h2[l2 >>> 16 & 255] << 16 | h2[l2 >>> 8 & 255] << 8 | h2[255 & l2], l2 ^= f2[a3 / n3 | 0] << 24) : n3 > 6 && a3 % n3 == 4 && (l2 = h2[l2 >>> 24] << 24 | h2[l2 >>> 16 & 255] << 16 | h2[l2 >>> 8 & 255] << 8 | h2[255 & l2]), c2[a3] = o2 = (c2[a3 - n3] ^ l2) >>> 0);
              for (s2 = 0; s2 < u2; s2++)
                a3 = u2 - s2, l2 = 3 & s2 ? c2[a3] : c2[a3 - 4], d2[s2] = s2 < 4 || a3 <= 4 ? l2 : g2[h2[l2 >>> 24]] ^ v2[h2[l2 >>> 16 & 255]] ^ m2[h2[l2 >>> 8 & 255]] ^ y2[h2[255 & l2]], d2[s2] = d2[s2] >>> 0;
            }
          }, t4.networkToHostOrderSwap = function(e5) {
            return e5 << 24 | (65280 & e5) << 8 | (16711680 & e5) >> 8 | e5 >>> 24;
          }, t4.decrypt = function(e5, t5, r4) {
            for (var i4, n3, a3, s2, o2, l2, u2, c2, d2, h2, f2, p2, g2, v2, m2 = this.keySize + 6, y2 = this.invKeySchedule, A2 = this.invSBox, E2 = this.invSubMix, T2 = E2[0], b2 = E2[1], k2 = E2[2], S2 = E2[3], _2 = this.uint8ArrayToUint32Array_(r4), C2 = _2[0], L2 = _2[1], D2 = _2[2], R2 = _2[3], I2 = new Int32Array(e5), O2 = new Int32Array(I2.length), w2 = this.networkToHostOrderSwap; t5 < I2.length; ) {
              for (d2 = w2(I2[t5]), h2 = w2(I2[t5 + 1]), f2 = w2(I2[t5 + 2]), p2 = w2(I2[t5 + 3]), o2 = d2 ^ y2[0], l2 = p2 ^ y2[1], u2 = f2 ^ y2[2], c2 = h2 ^ y2[3], g2 = 4, v2 = 1; v2 < m2; v2++)
                i4 = T2[o2 >>> 24] ^ b2[l2 >> 16 & 255] ^ k2[u2 >> 8 & 255] ^ S2[255 & c2] ^ y2[g2], n3 = T2[l2 >>> 24] ^ b2[u2 >> 16 & 255] ^ k2[c2 >> 8 & 255] ^ S2[255 & o2] ^ y2[g2 + 1], a3 = T2[u2 >>> 24] ^ b2[c2 >> 16 & 255] ^ k2[o2 >> 8 & 255] ^ S2[255 & l2] ^ y2[g2 + 2], s2 = T2[c2 >>> 24] ^ b2[o2 >> 16 & 255] ^ k2[l2 >> 8 & 255] ^ S2[255 & u2] ^ y2[g2 + 3], o2 = i4, l2 = n3, u2 = a3, c2 = s2, g2 += 4;
              i4 = A2[o2 >>> 24] << 24 ^ A2[l2 >> 16 & 255] << 16 ^ A2[u2 >> 8 & 255] << 8 ^ A2[255 & c2] ^ y2[g2], n3 = A2[l2 >>> 24] << 24 ^ A2[u2 >> 16 & 255] << 16 ^ A2[c2 >> 8 & 255] << 8 ^ A2[255 & o2] ^ y2[g2 + 1], a3 = A2[u2 >>> 24] << 24 ^ A2[c2 >> 16 & 255] << 16 ^ A2[o2 >> 8 & 255] << 8 ^ A2[255 & l2] ^ y2[g2 + 2], s2 = A2[c2 >>> 24] << 24 ^ A2[o2 >> 16 & 255] << 16 ^ A2[l2 >> 8 & 255] << 8 ^ A2[255 & u2] ^ y2[g2 + 3], O2[t5] = w2(i4 ^ C2), O2[t5 + 1] = w2(s2 ^ L2), O2[t5 + 2] = w2(a3 ^ D2), O2[t5 + 3] = w2(n3 ^ R2), C2 = d2, L2 = h2, D2 = f2, R2 = p2, t5 += 4;
            }
            return O2.buffer;
          }, e4;
        }();
      }
    ), "./src/crypt/decrypter.ts": (
      /*!********************************!*\
          !*** ./src/crypt/decrypter.ts ***!
          \********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => u2 });
        var i3 = r3(
          /*! ./aes-crypto */
          "./src/crypt/aes-crypto.ts"
        ), n2 = r3(
          /*! ./fast-aes-key */
          "./src/crypt/fast-aes-key.ts"
        ), a2 = r3(
          /*! ./aes-decryptor */
          "./src/crypt/aes-decryptor.ts"
        ), s2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), o2 = r3(
          /*! ../utils/mp4-tools */
          "./src/utils/mp4-tools.ts"
        ), l2 = r3(
          /*! ../utils/typed-array */
          "./src/utils/typed-array.ts"
        ), u2 = function() {
          function e4(e5, t5, r4) {
            var i4 = (void 0 === r4 ? {} : r4).removePKCS7Padding, n3 = void 0 === i4 || i4;
            if (this.logEnabled = true, this.observer = void 0, this.config = void 0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.observer = e5, this.config = t5, this.removePKCS7Padding = n3, n3)
              try {
                var a3 = self.crypto;
                a3 && (this.subtle = a3.subtle || a3.webkitSubtle);
              } catch (e6) {
              }
            null === this.subtle && (this.config.enableSoftwareAES = true);
          }
          var t4 = e4.prototype;
          return t4.destroy = function() {
            this.observer = null;
          }, t4.isSync = function() {
            return this.config.enableSoftwareAES;
          }, t4.flush = function() {
            var e5 = this.currentResult;
            if (e5) {
              var t5 = new Uint8Array(e5);
              return this.reset(), this.removePKCS7Padding ? (0, a2.removePadding)(t5) : t5;
            }
            this.reset();
          }, t4.reset = function() {
            this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null);
          }, t4.decrypt = function(e5, t5, r4, i4) {
            if (this.config.enableSoftwareAES) {
              this.softwareDecrypt(new Uint8Array(e5), t5, r4);
              var n3 = this.flush();
              n3 && i4(n3.buffer);
            } else
              this.webCryptoDecrypt(new Uint8Array(e5), t5, r4).then(i4);
          }, t4.softwareDecrypt = function(e5, t5, r4) {
            var i4 = this.currentIV, n3 = this.currentResult, s3 = this.remainderData;
            this.logOnce("JS AES decrypt"), s3 && (e5 = (0, o2.appendUint8Array)(s3, e5), this.remainderData = null);
            var u3 = this.getValidChunk(e5);
            if (!u3.length)
              return null;
            i4 && (r4 = i4);
            var c2 = this.softwareDecrypter;
            c2 || (c2 = this.softwareDecrypter = new a2.default()), c2.expandKey(t5);
            var d2 = n3;
            return this.currentResult = c2.decrypt(u3.buffer, 0, r4), this.currentIV = (0, l2.sliceUint8)(u3, -16).buffer, d2 || null;
          }, t4.webCryptoDecrypt = function(e5, t5, r4) {
            var a3 = this, s3 = this.subtle;
            return this.key === t5 && this.fastAesKey || (this.key = t5, this.fastAesKey = new n2.default(s3, t5)), this.fastAesKey.expandKey().then(function(t6) {
              return s3 ? new i3.default(s3, r4).decrypt(e5.buffer, t6) : Promise.reject(new Error("web crypto not initialized"));
            }).catch(function(i4) {
              return a3.onWebCryptoError(i4, e5, t5, r4);
            });
          }, t4.onWebCryptoError = function(e5, t5, r4, i4) {
            return s2.logger.warn("[decrypter.ts]: WebCrypto Error, disable WebCrypto API:", e5), this.config.enableSoftwareAES = true, this.logEnabled = true, this.softwareDecrypt(t5, r4, i4);
          }, t4.getValidChunk = function(e5) {
            var t5 = e5, r4 = e5.length - e5.length % 16;
            return r4 !== e5.length && (t5 = (0, l2.sliceUint8)(e5, 0, r4), this.remainderData = (0, l2.sliceUint8)(e5, r4)), t5;
          }, t4.logOnce = function(e5) {
            this.logEnabled && (s2.logger.log("[decrypter.ts]: " + e5), this.logEnabled = false);
          }, e4;
        }();
      }
    ), "./src/crypt/fast-aes-key.ts": (
      /*!***********************************!*\
          !*** ./src/crypt/fast-aes-key.ts ***!
          \***********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => i3 });
        var i3 = function() {
          function e4(e5, t4) {
            this.subtle = void 0, this.key = void 0, this.subtle = e5, this.key = t4;
          }
          return e4.prototype.expandKey = function() {
            return this.subtle.importKey("raw", this.key, { name: "AES-CBC" }, false, ["encrypt", "decrypt"]);
          }, e4;
        }();
      }
    ), "./src/demux/aacdemuxer.ts": (
      /*!*********************************!*\
          !*** ./src/demux/aacdemuxer.ts ***!
          \*********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => l2 });
        var i3 = r3(
          /*! ./base-audio-demuxer */
          "./src/demux/base-audio-demuxer.ts"
        ), n2 = r3(
          /*! ./adts */
          "./src/demux/adts.ts"
        ), a2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), s2 = r3(
          /*! ../demux/id3 */
          "./src/demux/id3.ts"
        );
        function o2(e4, t4) {
          return o2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
            return e5.__proto__ = t5, e5;
          }, o2(e4, t4);
        }
        const l2 = function(e4) {
          var t4, r4;
          function i4(t5, r5) {
            var i5;
            return (i5 = e4.call(this) || this).observer = void 0, i5.config = void 0, i5.observer = t5, i5.config = r5, i5;
          }
          r4 = e4, (t4 = i4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, o2(t4, r4);
          var l3 = i4.prototype;
          return l3.resetInitSegment = function(t5, r5, i5, n3) {
            e4.prototype.resetInitSegment.call(this, t5, r5, i5, n3), this._audioTrack = { container: "audio/adts", type: "audio", id: 2, pid: -1, sequenceNumber: 0, segmentCodec: "aac", samples: [], manifestCodec: r5, duration: n3, inputTimeScale: 9e4, dropped: 0 };
          }, i4.probe = function(e5) {
            if (!e5)
              return false;
            for (var t5 = (s2.getID3Data(e5, 0) || []).length, r5 = e5.length; t5 < r5; t5++)
              if (n2.probe(e5, t5))
                return a2.logger.log("ADTS sync word found !"), true;
            return false;
          }, l3.canParse = function(e5, t5) {
            return n2.canParse(e5, t5);
          }, l3.appendFrame = function(e5, t5, r5) {
            n2.initTrackConfig(e5, this.observer, t5, r5, e5.manifestCodec);
            var i5 = n2.appendFrame(e5, t5, r5, this.basePTS, this.frameIndex);
            if (i5 && 0 === i5.missing)
              return i5;
          }, i4;
        }(i3.default);
      }
    ), "./src/demux/adts.ts": (
      /*!***************************!*\
          !*** ./src/demux/adts.ts ***!
          \***************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { appendFrame: () => m2, canGetFrameLength: () => c2, canParse: () => h2, getAudioConfig: () => s2, getFrameDuration: () => g2, getFullFrameLength: () => u2, getHeaderLength: () => l2, initTrackConfig: () => p2, isHeader: () => d2, isHeaderPattern: () => o2, parseFrameHeader: () => v2, probe: () => f2 });
        var i3 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), n2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), a2 = r3(
          /*! ../events */
          "./src/events.ts"
        );
        function s2(e4, t4, r4, s3) {
          var o3, l3, u3, c3, d3 = navigator.userAgent.toLowerCase(), h3 = s3, f3 = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
          o3 = 1 + ((192 & t4[r4 + 2]) >>> 6);
          var p3 = (60 & t4[r4 + 2]) >>> 2;
          if (!(p3 > f3.length - 1))
            return u3 = (1 & t4[r4 + 2]) << 2, u3 |= (192 & t4[r4 + 3]) >>> 6, i3.logger.log("manifest codec:" + s3 + ", ADTS type:" + o3 + ", samplingIndex:" + p3), /firefox/i.test(d3) ? p3 >= 6 ? (o3 = 5, c3 = new Array(4), l3 = p3 - 3) : (o3 = 2, c3 = new Array(2), l3 = p3) : -1 !== d3.indexOf("android") ? (o3 = 2, c3 = new Array(2), l3 = p3) : (o3 = 5, c3 = new Array(4), s3 && (-1 !== s3.indexOf("mp4a.40.29") || -1 !== s3.indexOf("mp4a.40.5")) || !s3 && p3 >= 6 ? l3 = p3 - 3 : ((s3 && -1 !== s3.indexOf("mp4a.40.2") && (p3 >= 6 && 1 === u3 || /vivaldi/i.test(d3)) || !s3 && 1 === u3) && (o3 = 2, c3 = new Array(2)), l3 = p3)), c3[0] = o3 << 3, c3[0] |= (14 & p3) >> 1, c3[1] |= (1 & p3) << 7, c3[1] |= u3 << 3, 5 === o3 && (c3[1] |= (14 & l3) >> 1, c3[2] = (1 & l3) << 7, c3[2] |= 8, c3[3] = 0), { config: c3, samplerate: f3[p3], channelCount: u3, codec: "mp4a.40." + o3, manifestCodec: h3 };
          e4.trigger(a2.Events.ERROR, { type: n2.ErrorTypes.MEDIA_ERROR, details: n2.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: "invalid ADTS sampling index:" + p3 });
        }
        function o2(e4, t4) {
          return 255 === e4[t4] && 240 == (246 & e4[t4 + 1]);
        }
        function l2(e4, t4) {
          return 1 & e4[t4 + 1] ? 7 : 9;
        }
        function u2(e4, t4) {
          return (3 & e4[t4 + 3]) << 11 | e4[t4 + 4] << 3 | (224 & e4[t4 + 5]) >>> 5;
        }
        function c2(e4, t4) {
          return t4 + 5 < e4.length;
        }
        function d2(e4, t4) {
          return t4 + 1 < e4.length && o2(e4, t4);
        }
        function h2(e4, t4) {
          return c2(e4, t4) && o2(e4, t4) && u2(e4, t4) <= e4.length - t4;
        }
        function f2(e4, t4) {
          if (d2(e4, t4)) {
            var r4 = l2(e4, t4);
            if (t4 + r4 >= e4.length)
              return false;
            var i4 = u2(e4, t4);
            if (i4 <= r4)
              return false;
            var n3 = t4 + i4;
            return n3 === e4.length || d2(e4, n3);
          }
          return false;
        }
        function p2(e4, t4, r4, n3, a3) {
          if (!e4.samplerate) {
            var o3 = s2(t4, r4, n3, a3);
            if (!o3)
              return;
            e4.config = o3.config, e4.samplerate = o3.samplerate, e4.channelCount = o3.channelCount, e4.codec = o3.codec, e4.manifestCodec = o3.manifestCodec, i3.logger.log("parsed codec:" + e4.codec + ", rate:" + o3.samplerate + ", channels:" + o3.channelCount);
          }
        }
        function g2(e4) {
          return 9216e4 / e4;
        }
        function v2(e4, t4) {
          var r4 = l2(e4, t4);
          if (t4 + r4 <= e4.length) {
            var i4 = u2(e4, t4) - r4;
            if (i4 > 0)
              return { headerLength: r4, frameLength: i4 };
          }
        }
        function m2(e4, t4, r4, i4, n3) {
          var a3, s3 = i4 + n3 * g2(e4.samplerate), o3 = v2(t4, r4);
          if (o3) {
            var l3 = o3.frameLength, u3 = o3.headerLength, c3 = u3 + l3, d3 = Math.max(0, r4 + c3 - t4.length);
            d3 ? (a3 = new Uint8Array(c3 - u3)).set(t4.subarray(r4 + u3, t4.length), 0) : a3 = t4.subarray(r4 + u3, r4 + c3);
            var h3 = { unit: a3, pts: s3 };
            return d3 || e4.samples.push(h3), { sample: h3, length: c3, missing: d3 };
          }
          var f3 = t4.length - r4;
          return (a3 = new Uint8Array(f3)).set(t4.subarray(r4, t4.length), 0), { sample: { unit: a3, pts: s3 }, length: f3, missing: -1 };
        }
      }
    ), "./src/demux/base-audio-demuxer.ts": (
      /*!*****************************************!*\
          !*** ./src/demux/base-audio-demuxer.ts ***!
          \*****************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => d2, initPTSFn: () => c2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ../demux/id3 */
          "./src/demux/id3.ts"
        ), a2 = r3(
          /*! ../types/demuxer */
          "./src/types/demuxer.ts"
        ), s2 = r3(
          /*! ./dummy-demuxed-track */
          "./src/demux/dummy-demuxed-track.ts"
        ), o2 = r3(
          /*! ../utils/mp4-tools */
          "./src/utils/mp4-tools.ts"
        ), l2 = r3(
          /*! ../utils/typed-array */
          "./src/utils/typed-array.ts"
        ), u2 = function() {
          function e4() {
            this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null;
          }
          var t4 = e4.prototype;
          return t4.resetInitSegment = function(e5, t5, r4, i4) {
            this._id3Track = { type: "id3", id: 3, pid: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], dropped: 0 };
          }, t4.resetTimeStamp = function(e5) {
            this.initPTS = e5, this.resetContiguity();
          }, t4.resetContiguity = function() {
            this.basePTS = null, this.lastPTS = null, this.frameIndex = 0;
          }, t4.canParse = function(e5, t5) {
            return false;
          }, t4.appendFrame = function(e5, t5, r4) {
          }, t4.demux = function(e5, t5) {
            this.cachedData && (e5 = (0, o2.appendUint8Array)(this.cachedData, e5), this.cachedData = null);
            var r4, u3 = n2.getID3Data(e5, 0), d3 = u3 ? u3.length : 0, h2 = this._audioTrack, f2 = this._id3Track, p2 = u3 ? n2.getTimeStamp(u3) : void 0, g2 = e5.length;
            for ((null === this.basePTS || 0 === this.frameIndex && (0, i3.isFiniteNumber)(p2)) && (this.basePTS = c2(p2, t5, this.initPTS), this.lastPTS = this.basePTS), null === this.lastPTS && (this.lastPTS = this.basePTS), u3 && u3.length > 0 && f2.samples.push({ pts: this.lastPTS, dts: this.lastPTS, data: u3, type: a2.MetadataSchema.audioId3, duration: Number.POSITIVE_INFINITY }); d3 < g2; ) {
              if (this.canParse(e5, d3)) {
                var v2 = this.appendFrame(h2, e5, d3);
                v2 ? (this.frameIndex++, this.lastPTS = v2.sample.pts, r4 = d3 += v2.length) : d3 = g2;
              } else
                n2.canParse(e5, d3) ? (u3 = n2.getID3Data(e5, d3), f2.samples.push({ pts: this.lastPTS, dts: this.lastPTS, data: u3, type: a2.MetadataSchema.audioId3, duration: Number.POSITIVE_INFINITY }), r4 = d3 += u3.length) : d3++;
              if (d3 === g2 && r4 !== g2) {
                var m2 = (0, l2.sliceUint8)(e5, r4);
                this.cachedData ? this.cachedData = (0, o2.appendUint8Array)(this.cachedData, m2) : this.cachedData = m2;
              }
            }
            return { audioTrack: h2, videoTrack: (0, s2.dummyTrack)(), id3Track: f2, textTrack: (0, s2.dummyTrack)() };
          }, t4.demuxSampleAes = function(e5, t5, r4) {
            return Promise.reject(new Error("[" + this + "] This demuxer does not support Sample-AES decryption"));
          }, t4.flush = function(e5) {
            var t5 = this.cachedData;
            return t5 && (this.cachedData = null, this.demux(t5, 0)), { audioTrack: this._audioTrack, videoTrack: (0, s2.dummyTrack)(), id3Track: this._id3Track, textTrack: (0, s2.dummyTrack)() };
          }, t4.destroy = function() {
          }, e4;
        }(), c2 = function(e4, t4, r4) {
          return (0, i3.isFiniteNumber)(e4) ? 90 * e4 : 9e4 * t4 + (r4 || 0);
        };
        const d2 = u2;
      }
    ), "./src/demux/chunk-cache.ts": (
      /*!**********************************!*\
          !*** ./src/demux/chunk-cache.ts ***!
          \**********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => i3 });
        var i3 = function() {
          function e4() {
            this.chunks = [], this.dataLength = 0;
          }
          var t4 = e4.prototype;
          return t4.push = function(e5) {
            this.chunks.push(e5), this.dataLength += e5.length;
          }, t4.flush = function() {
            var e5, t5 = this.chunks, r4 = this.dataLength;
            return t5.length ? (e5 = 1 === t5.length ? t5[0] : function(e6, t6) {
              for (var r5 = new Uint8Array(t6), i4 = 0, n2 = 0; n2 < e6.length; n2++) {
                var a2 = e6[n2];
                r5.set(a2, i4), i4 += a2.length;
              }
              return r5;
            }(t5, r4), this.reset(), e5) : new Uint8Array(0);
          }, t4.reset = function() {
            this.chunks.length = 0, this.dataLength = 0;
          }, e4;
        }();
      }
    ), "./src/demux/dummy-demuxed-track.ts": (
      /*!******************************************!*\
          !*** ./src/demux/dummy-demuxed-track.ts ***!
          \******************************************/
      (e3, t3, r3) => {
        function i3(e4, t4) {
          return void 0 === e4 && (e4 = ""), void 0 === t4 && (t4 = 9e4), { type: e4, id: -1, pid: -1, inputTimeScale: t4, sequenceNumber: -1, samples: [], dropped: 0 };
        }
        r3.r(t3), r3.d(t3, { dummyTrack: () => i3 });
      }
    ), "./src/demux/exp-golomb.ts": (
      /*!*********************************!*\
          !*** ./src/demux/exp-golomb.ts ***!
          \*********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => n2 });
        var i3 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        );
        const n2 = function() {
          function e4(e5) {
            this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e5, this.bytesAvailable = e5.byteLength, this.word = 0, this.bitsAvailable = 0;
          }
          var t4 = e4.prototype;
          return t4.loadWord = function() {
            var e5 = this.data, t5 = this.bytesAvailable, r4 = e5.byteLength - t5, i4 = new Uint8Array(4), n3 = Math.min(4, t5);
            if (0 === n3)
              throw new Error("no bytes available");
            i4.set(e5.subarray(r4, r4 + n3)), this.word = new DataView(i4.buffer).getUint32(0), this.bitsAvailable = 8 * n3, this.bytesAvailable -= n3;
          }, t4.skipBits = function(e5) {
            var t5;
            this.bitsAvailable > e5 ? (this.word <<= e5, this.bitsAvailable -= e5) : (e5 -= this.bitsAvailable, e5 -= (t5 = e5 >> 3) >> 3, this.bytesAvailable -= t5, this.loadWord(), this.word <<= e5, this.bitsAvailable -= e5);
          }, t4.readBits = function(e5) {
            var t5 = Math.min(this.bitsAvailable, e5), r4 = this.word >>> 32 - t5;
            return e5 > 32 && i3.logger.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t5, this.bitsAvailable > 0 ? this.word <<= t5 : this.bytesAvailable > 0 && this.loadWord(), (t5 = e5 - t5) > 0 && this.bitsAvailable ? r4 << t5 | this.readBits(t5) : r4;
          }, t4.skipLZ = function() {
            var e5;
            for (e5 = 0; e5 < this.bitsAvailable; ++e5)
              if (0 != (this.word & 2147483648 >>> e5))
                return this.word <<= e5, this.bitsAvailable -= e5, e5;
            return this.loadWord(), e5 + this.skipLZ();
          }, t4.skipUEG = function() {
            this.skipBits(1 + this.skipLZ());
          }, t4.skipEG = function() {
            this.skipBits(1 + this.skipLZ());
          }, t4.readUEG = function() {
            var e5 = this.skipLZ();
            return this.readBits(e5 + 1) - 1;
          }, t4.readEG = function() {
            var e5 = this.readUEG();
            return 1 & e5 ? 1 + e5 >>> 1 : -1 * (e5 >>> 1);
          }, t4.readBoolean = function() {
            return 1 === this.readBits(1);
          }, t4.readUByte = function() {
            return this.readBits(8);
          }, t4.readUShort = function() {
            return this.readBits(16);
          }, t4.readUInt = function() {
            return this.readBits(32);
          }, t4.skipScalingList = function(e5) {
            for (var t5 = 8, r4 = 8, i4 = 0; i4 < e5; i4++)
              0 !== r4 && (r4 = (t5 + this.readEG() + 256) % 256), t5 = 0 === r4 ? t5 : r4;
          }, t4.readSPS = function() {
            var e5, t5, r4, i4 = 0, n3 = 0, a2 = 0, s2 = 0, o2 = this.readUByte.bind(this), l2 = this.readBits.bind(this), u2 = this.readUEG.bind(this), c2 = this.readBoolean.bind(this), d2 = this.skipBits.bind(this), h2 = this.skipEG.bind(this), f2 = this.skipUEG.bind(this), p2 = this.skipScalingList.bind(this);
            o2();
            var g2 = o2();
            if (l2(5), d2(3), o2(), f2(), 100 === g2 || 110 === g2 || 122 === g2 || 244 === g2 || 44 === g2 || 83 === g2 || 86 === g2 || 118 === g2 || 128 === g2) {
              var v2 = u2();
              if (3 === v2 && d2(1), f2(), f2(), d2(1), c2())
                for (t5 = 3 !== v2 ? 8 : 12, r4 = 0; r4 < t5; r4++)
                  c2() && p2(r4 < 6 ? 16 : 64);
            }
            f2();
            var m2 = u2();
            if (0 === m2)
              u2();
            else if (1 === m2)
              for (d2(1), h2(), h2(), e5 = u2(), r4 = 0; r4 < e5; r4++)
                h2();
            f2(), d2(1);
            var y2 = u2(), A2 = u2(), E2 = l2(1);
            0 === E2 && d2(1), d2(1), c2() && (i4 = u2(), n3 = u2(), a2 = u2(), s2 = u2());
            var T2 = [1, 1];
            if (c2() && c2())
              switch (o2()) {
                case 1:
                  T2 = [1, 1];
                  break;
                case 2:
                  T2 = [12, 11];
                  break;
                case 3:
                  T2 = [10, 11];
                  break;
                case 4:
                  T2 = [16, 11];
                  break;
                case 5:
                  T2 = [40, 33];
                  break;
                case 6:
                  T2 = [24, 11];
                  break;
                case 7:
                  T2 = [20, 11];
                  break;
                case 8:
                  T2 = [32, 11];
                  break;
                case 9:
                  T2 = [80, 33];
                  break;
                case 10:
                  T2 = [18, 11];
                  break;
                case 11:
                  T2 = [15, 11];
                  break;
                case 12:
                  T2 = [64, 33];
                  break;
                case 13:
                  T2 = [160, 99];
                  break;
                case 14:
                  T2 = [4, 3];
                  break;
                case 15:
                  T2 = [3, 2];
                  break;
                case 16:
                  T2 = [2, 1];
                  break;
                case 255:
                  T2 = [o2() << 8 | o2(), o2() << 8 | o2()];
              }
            return { width: Math.ceil(16 * (y2 + 1) - 2 * i4 - 2 * n3), height: (2 - E2) * (A2 + 1) * 16 - (E2 ? 2 : 4) * (a2 + s2), pixelRatio: T2 };
          }, t4.readSliceType = function() {
            return this.readUByte(), this.readUEG(), this.readUEG();
          }, e4;
        }();
      }
    ), "./src/demux/id3.ts": (
      /*!**************************!*\
          !*** ./src/demux/id3.ts ***!
          \**************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { canParse: () => l2, decodeFrame: () => f2, getID3Data: () => s2, getID3Frames: () => h2, getTimeStamp: () => u2, isFooter: () => a2, isHeader: () => n2, isTimeStampFrame: () => c2, testables: () => A2, utf8ArrayToStr: () => y2 });
        var i3, n2 = function(e4, t4) {
          return t4 + 10 <= e4.length && 73 === e4[t4] && 68 === e4[t4 + 1] && 51 === e4[t4 + 2] && e4[t4 + 3] < 255 && e4[t4 + 4] < 255 && e4[t4 + 6] < 128 && e4[t4 + 7] < 128 && e4[t4 + 8] < 128 && e4[t4 + 9] < 128;
        }, a2 = function(e4, t4) {
          return t4 + 10 <= e4.length && 51 === e4[t4] && 68 === e4[t4 + 1] && 73 === e4[t4 + 2] && e4[t4 + 3] < 255 && e4[t4 + 4] < 255 && e4[t4 + 6] < 128 && e4[t4 + 7] < 128 && e4[t4 + 8] < 128 && e4[t4 + 9] < 128;
        }, s2 = function(e4, t4) {
          for (var r4 = t4, i4 = 0; n2(e4, t4); )
            i4 += 10, i4 += o2(e4, t4 + 6), a2(e4, t4 + 10) && (i4 += 10), t4 += i4;
          if (i4 > 0)
            return e4.subarray(r4, r4 + i4);
        }, o2 = function(e4, t4) {
          var r4 = 0;
          return r4 = (127 & e4[t4]) << 21, r4 |= (127 & e4[t4 + 1]) << 14, r4 |= (127 & e4[t4 + 2]) << 7, r4 |= 127 & e4[t4 + 3];
        }, l2 = function(e4, t4) {
          return n2(e4, t4) && o2(e4, t4 + 6) + 10 <= e4.length - t4;
        }, u2 = function(e4) {
          for (var t4 = h2(e4), r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            if (c2(i4))
              return m2(i4);
          }
        }, c2 = function(e4) {
          return e4 && "PRIV" === e4.key && "com.apple.streaming.transportStreamTimestamp" === e4.info;
        }, d2 = function(e4) {
          var t4 = String.fromCharCode(e4[0], e4[1], e4[2], e4[3]), r4 = o2(e4, 4);
          return { type: t4, size: r4, data: e4.subarray(10, 10 + r4) };
        }, h2 = function(e4) {
          for (var t4 = 0, r4 = []; n2(e4, t4); ) {
            for (var i4 = o2(e4, t4 + 6), s3 = (t4 += 10) + i4; t4 + 8 < s3; ) {
              var l3 = d2(e4.subarray(t4)), u3 = f2(l3);
              u3 && r4.push(u3), t4 += l3.size + 10;
            }
            a2(e4, t4) && (t4 += 10);
          }
          return r4;
        }, f2 = function(e4) {
          return "PRIV" === e4.type ? p2(e4) : "W" === e4.type[0] ? v2(e4) : g2(e4);
        }, p2 = function(e4) {
          if (!(e4.size < 2)) {
            var t4 = y2(e4.data, true), r4 = new Uint8Array(e4.data.subarray(t4.length + 1));
            return { key: e4.type, info: t4, data: r4.buffer };
          }
        }, g2 = function(e4) {
          if (!(e4.size < 2)) {
            if ("TXXX" === e4.type) {
              var t4 = 1, r4 = y2(e4.data.subarray(t4), true);
              t4 += r4.length + 1;
              var i4 = y2(e4.data.subarray(t4));
              return { key: e4.type, info: r4, data: i4 };
            }
            var n3 = y2(e4.data.subarray(1));
            return { key: e4.type, data: n3 };
          }
        }, v2 = function(e4) {
          if ("WXXX" === e4.type) {
            if (e4.size < 2)
              return;
            var t4 = 1, r4 = y2(e4.data.subarray(t4), true);
            t4 += r4.length + 1;
            var i4 = y2(e4.data.subarray(t4));
            return { key: e4.type, info: r4, data: i4 };
          }
          var n3 = y2(e4.data);
          return { key: e4.type, data: n3 };
        }, m2 = function(e4) {
          if (8 === e4.data.byteLength) {
            var t4 = new Uint8Array(e4.data), r4 = 1 & t4[3], i4 = (t4[4] << 23) + (t4[5] << 15) + (t4[6] << 7) + t4[7];
            return i4 /= 45, r4 && (i4 += 4772185884e-2), Math.round(i4);
          }
        }, y2 = function(e4, t4) {
          void 0 === t4 && (t4 = false);
          var r4 = E2();
          if (r4) {
            var i4 = r4.decode(e4);
            if (t4) {
              var n3 = i4.indexOf("\0");
              return -1 !== n3 ? i4.substring(0, n3) : i4;
            }
            return i4.replace(/\0/g, "");
          }
          for (var a3, s3, o3, l3 = e4.length, u3 = "", c3 = 0; c3 < l3; ) {
            if (0 === (a3 = e4[c3++]) && t4)
              return u3;
            if (0 !== a3 && 3 !== a3)
              switch (a3 >> 4) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                  u3 += String.fromCharCode(a3);
                  break;
                case 12:
                case 13:
                  s3 = e4[c3++], u3 += String.fromCharCode((31 & a3) << 6 | 63 & s3);
                  break;
                case 14:
                  s3 = e4[c3++], o3 = e4[c3++], u3 += String.fromCharCode((15 & a3) << 12 | (63 & s3) << 6 | (63 & o3) << 0);
              }
          }
          return u3;
        }, A2 = { decodeTextFrame: g2 };
        function E2() {
          return i3 || void 0 === self.TextDecoder || (i3 = new self.TextDecoder("utf-8")), i3;
        }
      }
    ), "./src/demux/mp3demuxer.ts": (
      /*!*********************************!*\
          !*** ./src/demux/mp3demuxer.ts ***!
          \*********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => u2 });
        var i3 = r3(
          /*! ./base-audio-demuxer */
          "./src/demux/base-audio-demuxer.ts"
        ), n2 = r3(
          /*! ../demux/id3 */
          "./src/demux/id3.ts"
        ), a2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), s2 = r3(
          /*! ./mpegaudio */
          "./src/demux/mpegaudio.ts"
        );
        function o2(e4, t4) {
          return o2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
            return e5.__proto__ = t5, e5;
          }, o2(e4, t4);
        }
        var l2 = function(e4) {
          var t4, r4;
          function i4() {
            return e4.apply(this, arguments) || this;
          }
          r4 = e4, (t4 = i4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, o2(t4, r4);
          var l3 = i4.prototype;
          return l3.resetInitSegment = function(t5, r5, i5, n3) {
            e4.prototype.resetInitSegment.call(this, t5, r5, i5, n3), this._audioTrack = { container: "audio/mpeg", type: "audio", id: 2, pid: -1, sequenceNumber: 0, segmentCodec: "mp3", samples: [], manifestCodec: r5, duration: n3, inputTimeScale: 9e4, dropped: 0 };
          }, i4.probe = function(e5) {
            if (!e5)
              return false;
            for (var t5 = (n2.getID3Data(e5, 0) || []).length, r5 = e5.length; t5 < r5; t5++)
              if (s2.probe(e5, t5))
                return a2.logger.log("MPEG Audio sync word found !"), true;
            return false;
          }, l3.canParse = function(e5, t5) {
            return s2.canParse(e5, t5);
          }, l3.appendFrame = function(e5, t5, r5) {
            if (null !== this.basePTS)
              return s2.appendFrame(e5, t5, r5, this.basePTS, this.frameIndex);
          }, i4;
        }(i3.default);
        const u2 = l2;
      }
    ), "./src/demux/mp4demuxer.ts": (
      /*!*********************************!*\
          !*** ./src/demux/mp4demuxer.ts ***!
          \*********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => l2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ../types/demuxer */
          "./src/types/demuxer.ts"
        ), a2 = r3(
          /*! ../utils/mp4-tools */
          "./src/utils/mp4-tools.ts"
        ), s2 = r3(
          /*! ./dummy-demuxed-track */
          "./src/demux/dummy-demuxed-track.ts"
        ), o2 = /\/emsg[-/]ID3/i;
        const l2 = function() {
          function e4(e5, t5) {
            this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t5;
          }
          var t4 = e4.prototype;
          return t4.resetTimeStamp = function() {
          }, t4.resetInitSegment = function(e5, t5, r4, i4) {
            var n3 = (0, a2.parseInitSegment)(e5), o3 = this.videoTrack = (0, s2.dummyTrack)("video", 1), l3 = this.audioTrack = (0, s2.dummyTrack)("audio", 1), u2 = this.txtTrack = (0, s2.dummyTrack)("text", 1);
            if (this.id3Track = (0, s2.dummyTrack)("id3", 1), this.timeOffset = 0, n3.video) {
              var c2 = n3.video, d2 = c2.id, h2 = c2.timescale, f2 = c2.codec;
              o3.id = d2, o3.timescale = u2.timescale = h2, o3.codec = f2;
            }
            if (n3.audio) {
              var p2 = n3.audio, g2 = p2.id, v2 = p2.timescale, m2 = p2.codec;
              l3.id = g2, l3.timescale = v2, l3.codec = m2;
            }
            u2.id = a2.RemuxerTrackIdConfig.text, o3.sampleDuration = 0, o3.duration = l3.duration = i4;
          }, t4.resetContiguity = function() {
          }, e4.probe = function(e5) {
            return e5 = e5.length > 16384 ? e5.subarray(0, 16384) : e5, (0, a2.findBox)(e5, ["moof"]).length > 0;
          }, t4.demux = function(e5, t5) {
            this.timeOffset = t5;
            var r4 = e5, i4 = this.videoTrack, n3 = this.txtTrack;
            if (this.config.progressive) {
              this.remainderData && (r4 = (0, a2.appendUint8Array)(this.remainderData, e5));
              var s3 = (0, a2.segmentValidRange)(r4);
              this.remainderData = s3.remainder, i4.samples = s3.valid || new Uint8Array();
            } else
              i4.samples = r4;
            var o3 = this.extractID3Track(i4, t5);
            return n3.samples = (0, a2.parseSamples)(t5, i4), { videoTrack: i4, audioTrack: this.audioTrack, id3Track: o3, textTrack: this.txtTrack };
          }, t4.flush = function() {
            var e5 = this.timeOffset, t5 = this.videoTrack, r4 = this.txtTrack;
            t5.samples = this.remainderData || new Uint8Array(), this.remainderData = null;
            var i4 = this.extractID3Track(t5, this.timeOffset);
            return r4.samples = (0, a2.parseSamples)(e5, t5), { videoTrack: t5, audioTrack: (0, s2.dummyTrack)(), id3Track: i4, textTrack: (0, s2.dummyTrack)() };
          }, t4.extractID3Track = function(e5, t5) {
            var r4 = this.id3Track;
            if (e5.samples.length) {
              var s3 = (0, a2.findBox)(e5.samples, ["emsg"]);
              s3 && s3.forEach(function(e6) {
                var s4 = (0, a2.parseEmsg)(e6);
                if (o2.test(s4.schemeIdUri)) {
                  var l3 = (0, i3.isFiniteNumber)(s4.presentationTime) ? s4.presentationTime / s4.timeScale : t5 + s4.presentationTimeDelta / s4.timeScale, u2 = 4294967295 === s4.eventDuration ? Number.POSITIVE_INFINITY : s4.eventDuration / s4.timeScale;
                  u2 <= 1e-3 && (u2 = Number.POSITIVE_INFINITY);
                  var c2 = s4.payload;
                  r4.samples.push({ data: c2, len: c2.byteLength, dts: l3, pts: l3, type: n2.MetadataSchema.emsg, duration: u2 });
                }
              });
            }
            return r4;
          }, t4.demuxSampleAes = function(e5, t5, r4) {
            return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
          }, t4.destroy = function() {
          }, e4;
        }();
      }
    ), "./src/demux/mpegaudio.ts": (
      /*!********************************!*\
          !*** ./src/demux/mpegaudio.ts ***!
          \********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { appendFrame: () => l2, canParse: () => h2, isHeader: () => d2, isHeaderPattern: () => c2, parseHeader: () => u2, probe: () => f2 });
        var i3 = null, n2 = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160], a2 = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3], s2 = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]], o2 = [0, 1, 1, 4];
        function l2(e4, t4, r4, i4, n3) {
          if (!(r4 + 24 > t4.length)) {
            var a3 = u2(t4, r4);
            if (a3 && r4 + a3.frameLength <= t4.length) {
              var s3 = i4 + n3 * (9e4 * a3.samplesPerFrame / a3.sampleRate), o3 = { unit: t4.subarray(r4, r4 + a3.frameLength), pts: s3, dts: s3 };
              return e4.config = [], e4.channelCount = a3.channelCount, e4.samplerate = a3.sampleRate, e4.samples.push(o3), { sample: o3, length: a3.frameLength, missing: 0 };
            }
          }
        }
        function u2(e4, t4) {
          var r4 = e4[t4 + 1] >> 3 & 3, l3 = e4[t4 + 1] >> 1 & 3, u3 = e4[t4 + 2] >> 4 & 15, c3 = e4[t4 + 2] >> 2 & 3;
          if (1 !== r4 && 0 !== u3 && 15 !== u3 && 3 !== c3) {
            var d3 = e4[t4 + 2] >> 1 & 1, h3 = e4[t4 + 3] >> 6, f3 = 1e3 * n2[14 * (3 === r4 ? 3 - l3 : 3 === l3 ? 3 : 4) + u3 - 1], p2 = a2[3 * (3 === r4 ? 0 : 2 === r4 ? 1 : 2) + c3], g2 = 3 === h3 ? 1 : 2, v2 = s2[r4][l3], m2 = o2[l3], y2 = 8 * v2 * m2, A2 = Math.floor(v2 * f3 / p2 + d3) * m2;
            if (null === i3) {
              var E2 = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
              i3 = E2 ? parseInt(E2[1]) : 0;
            }
            return !!i3 && i3 <= 87 && 2 === l3 && f3 >= 224e3 && 0 === h3 && (e4[t4 + 3] = 128 | e4[t4 + 3]), { sampleRate: p2, channelCount: g2, frameLength: A2, samplesPerFrame: y2 };
          }
        }
        function c2(e4, t4) {
          return 255 === e4[t4] && 224 == (224 & e4[t4 + 1]) && 0 != (6 & e4[t4 + 1]);
        }
        function d2(e4, t4) {
          return t4 + 1 < e4.length && c2(e4, t4);
        }
        function h2(e4, t4) {
          return c2(e4, t4) && 4 <= e4.length - t4;
        }
        function f2(e4, t4) {
          if (t4 + 1 < e4.length && c2(e4, t4)) {
            var r4 = u2(e4, t4), i4 = 4;
            null != r4 && r4.frameLength && (i4 = r4.frameLength);
            var n3 = t4 + i4;
            return n3 === e4.length || d2(e4, n3);
          }
          return false;
        }
      }
    ), "./src/demux/sample-aes.ts": (
      /*!*********************************!*\
          !*** ./src/demux/sample-aes.ts ***!
          \*********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => a2 });
        var i3 = r3(
          /*! ../crypt/decrypter */
          "./src/crypt/decrypter.ts"
        ), n2 = r3(
          /*! ../utils/mp4-tools */
          "./src/utils/mp4-tools.ts"
        );
        const a2 = function() {
          function e4(e5, t5, r4) {
            this.keyData = void 0, this.decrypter = void 0, this.keyData = r4, this.decrypter = new i3.default(e5, t5, { removePKCS7Padding: false });
          }
          var t4 = e4.prototype;
          return t4.decryptBuffer = function(e5, t5) {
            this.decrypter.decrypt(e5, this.keyData.key.buffer, this.keyData.iv.buffer, t5);
          }, t4.decryptAacSample = function(e5, t5, r4, i4) {
            var n3 = e5[t5].unit;
            if (!(n3.length <= 16)) {
              var a3 = n3.subarray(16, n3.length - n3.length % 16), s2 = a3.buffer.slice(a3.byteOffset, a3.byteOffset + a3.length), o2 = this;
              this.decryptBuffer(s2, function(a4) {
                var s3 = new Uint8Array(a4);
                n3.set(s3, 16), i4 || o2.decryptAacSamples(e5, t5 + 1, r4);
              });
            }
          }, t4.decryptAacSamples = function(e5, t5, r4) {
            for (; ; t5++) {
              if (t5 >= e5.length)
                return void r4();
              if (!(e5[t5].unit.length < 32)) {
                var i4 = this.decrypter.isSync();
                if (this.decryptAacSample(e5, t5, r4, i4), !i4)
                  return;
              }
            }
          }, t4.getAvcEncryptedData = function(e5) {
            for (var t5 = 16 * Math.floor((e5.length - 48) / 160) + 16, r4 = new Int8Array(t5), i4 = 0, n3 = 32; n3 < e5.length - 16; n3 += 160, i4 += 16)
              r4.set(e5.subarray(n3, n3 + 16), i4);
            return r4;
          }, t4.getAvcDecryptedUnit = function(e5, t5) {
            for (var r4 = new Uint8Array(t5), i4 = 0, n3 = 32; n3 < e5.length - 16; n3 += 160, i4 += 16)
              e5.set(r4.subarray(i4, i4 + 16), n3);
            return e5;
          }, t4.decryptAvcSample = function(e5, t5, r4, i4, a3, s2) {
            var o2 = (0, n2.discardEPB)(a3.data), l2 = this.getAvcEncryptedData(o2), u2 = this;
            this.decryptBuffer(l2.buffer, function(n3) {
              a3.data = u2.getAvcDecryptedUnit(o2, n3), s2 || u2.decryptAvcSamples(e5, t5, r4 + 1, i4);
            });
          }, t4.decryptAvcSamples = function(e5, t5, r4, i4) {
            if (e5 instanceof Uint8Array)
              throw new Error("Cannot decrypt samples of type Uint8Array");
            for (; ; t5++, r4 = 0) {
              if (t5 >= e5.length)
                return void i4();
              for (var n3 = e5[t5].units; !(r4 >= n3.length); r4++) {
                var a3 = n3[r4];
                if (!(a3.data.length <= 48 || 1 !== a3.type && 5 !== a3.type)) {
                  var s2 = this.decrypter.isSync();
                  if (this.decryptAvcSample(e5, t5, r4, i4, a3, s2), !s2)
                    return;
                }
              }
            }
          }, e4;
        }();
      }
    ), "./src/demux/transmuxer-interface.ts": (
      /*!*******************************************!*\
          !*** ./src/demux/transmuxer-interface.ts ***!
          \*******************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => d2 });
        var i3 = r3(
          /*! ./webworkify-webpack */
          "./src/demux/webworkify-webpack.js"
        ), n2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), a2 = r3(
          /*! ../demux/transmuxer */
          "./src/demux/transmuxer.ts"
        ), s2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), o2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), l2 = r3(
          /*! ../utils/mediasource-helper */
          "./src/utils/mediasource-helper.ts"
        ), u2 = r3(
          /*! eventemitter3 */
          "./node_modules/eventemitter3/index.js"
        ), c2 = (0, l2.getMediaSource)() || { isTypeSupported: function() {
          return false;
        } }, d2 = function() {
          function e4(e5, t5, r4, l3) {
            var d3 = this;
            this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.worker = void 0, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0;
            var h2 = e5.config;
            this.hls = e5, this.id = t5, this.useWorker = !!h2.enableWorker, this.onTransmuxComplete = r4, this.onFlush = l3;
            var f2 = function(e6, t6) {
              (t6 = t6 || {}).frag = d3.frag, t6.id = d3.id, d3.hls.trigger(e6, t6);
            };
            this.observer = new u2.EventEmitter(), this.observer.on(n2.Events.FRAG_DECRYPTED, f2), this.observer.on(n2.Events.ERROR, f2);
            var p2 = { mp4: c2.isTypeSupported("video/mp4"), mpeg: c2.isTypeSupported("audio/mpeg"), mp3: c2.isTypeSupported('audio/mp4; codecs="mp3"') }, g2 = navigator.vendor;
            if (this.useWorker && "undefined" != typeof Worker) {
              var v2;
              s2.logger.log("demuxing in webworker");
              try {
                v2 = this.worker = (0, i3.default)(
                  /*! ../demux/transmuxer-worker.ts */
                  "./src/demux/transmuxer-worker.ts"
                ), this.onwmsg = this.onWorkerMessage.bind(this), v2.addEventListener("message", this.onwmsg), v2.onerror = function(e6) {
                  d3.useWorker = false, s2.logger.warn("Exception in webworker, fallback to inline"), d3.hls.trigger(n2.Events.ERROR, { type: o2.ErrorTypes.OTHER_ERROR, details: o2.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: "demuxerWorker", error: new Error(e6.message + "  (" + e6.filename + ":" + e6.lineno + ")") });
                }, v2.postMessage({ cmd: "init", typeSupported: p2, vendor: g2, id: t5, config: JSON.stringify(h2) });
              } catch (e6) {
                s2.logger.warn("Error in worker:", e6), s2.logger.error("Error while initializing DemuxerWorker, fallback to inline"), v2 && self.URL.revokeObjectURL(v2.objectURL), this.transmuxer = new a2.default(this.observer, p2, h2, g2, t5), this.worker = null;
              }
            } else
              this.transmuxer = new a2.default(this.observer, p2, h2, g2, t5);
          }
          var t4 = e4.prototype;
          return t4.destroy = function() {
            var e5 = this.worker;
            if (e5)
              e5.removeEventListener("message", this.onwmsg), e5.terminate(), this.worker = null, this.onwmsg = void 0;
            else {
              var t5 = this.transmuxer;
              t5 && (t5.destroy(), this.transmuxer = null);
            }
            var r4 = this.observer;
            r4 && r4.removeAllListeners(), this.frag = null, this.observer = null, this.hls = null;
          }, t4.push = function(e5, t5, r4, i4, n3, o3, l3, u3, c3, d3) {
            var h2, f2, p2 = this;
            c3.transmuxing.start = self.performance.now();
            var g2 = this.transmuxer, v2 = this.worker, m2 = o3 ? o3.start : n3.start, y2 = n3.decryptdata, A2 = this.frag, E2 = !(A2 && n3.cc === A2.cc), T2 = !(A2 && c3.level === A2.level), b2 = A2 ? c3.sn - A2.sn : -1, k2 = this.part ? c3.part - this.part.index : -1, S2 = 0 === b2 && c3.id > 1 && c3.id === (null == A2 ? void 0 : A2.stats.chunkCount), _2 = !T2 && (1 === b2 || 0 === b2 && (1 === k2 || S2 && k2 <= 0)), C2 = self.performance.now();
            (T2 || b2 || 0 === n3.stats.parsing.start) && (n3.stats.parsing.start = C2), !o3 || !k2 && _2 || (o3.stats.parsing.start = C2);
            var L2 = !(A2 && (null === (h2 = n3.initSegment) || void 0 === h2 ? void 0 : h2.url) === (null === (f2 = A2.initSegment) || void 0 === f2 ? void 0 : f2.url)), D2 = new a2.TransmuxState(E2, _2, u3, T2, m2, L2);
            if (!_2 || E2 || L2) {
              s2.logger.log("[transmuxer-interface, " + n3.type + "]: Starting new transmux session for sn: " + c3.sn + " p: " + c3.part + " level: " + c3.level + " id: " + c3.id + "\n        discontinuity: " + E2 + "\n        trackSwitch: " + T2 + "\n        contiguous: " + _2 + "\n        accurateTimeOffset: " + u3 + "\n        timeOffset: " + m2 + "\n        initSegmentChange: " + L2);
              var R2 = new a2.TransmuxConfig(r4, i4, t5, l3, d3);
              this.configureTransmuxer(R2);
            }
            if (this.frag = n3, this.part = o3, v2)
              v2.postMessage({ cmd: "demux", data: e5, decryptdata: y2, chunkMeta: c3, state: D2 }, e5 instanceof ArrayBuffer ? [e5] : []);
            else if (g2) {
              var I2 = g2.push(e5, y2, c3, D2);
              (0, a2.isPromise)(I2) ? I2.then(function(e6) {
                p2.handleTransmuxComplete(e6);
              }) : this.handleTransmuxComplete(I2);
            }
          }, t4.flush = function(e5) {
            var t5 = this;
            e5.transmuxing.start = self.performance.now();
            var r4 = this.transmuxer, i4 = this.worker;
            if (i4)
              i4.postMessage({ cmd: "flush", chunkMeta: e5 });
            else if (r4) {
              var n3 = r4.flush(e5);
              (0, a2.isPromise)(n3) ? n3.then(function(r5) {
                t5.handleFlushResult(r5, e5);
              }) : this.handleFlushResult(n3, e5);
            }
          }, t4.handleFlushResult = function(e5, t5) {
            var r4 = this;
            e5.forEach(function(e6) {
              r4.handleTransmuxComplete(e6);
            }), this.onFlush(t5);
          }, t4.onWorkerMessage = function(e5) {
            var t5 = e5.data, r4 = this.hls;
            switch (t5.event) {
              case "init":
                self.URL.revokeObjectURL(this.worker.objectURL);
                break;
              case "transmuxComplete":
                this.handleTransmuxComplete(t5.data);
                break;
              case "flush":
                this.onFlush(t5.data);
                break;
              case "workerLog":
                s2.logger[t5.data.logType] && s2.logger[t5.data.logType](t5.data.message);
                break;
              default:
                t5.data = t5.data || {}, t5.data.frag = this.frag, t5.data.id = this.id, r4.trigger(t5.event, t5.data);
            }
          }, t4.configureTransmuxer = function(e5) {
            var t5 = this.worker, r4 = this.transmuxer;
            t5 ? t5.postMessage({ cmd: "configure", config: e5 }) : r4 && r4.configure(e5);
          }, t4.handleTransmuxComplete = function(e5) {
            e5.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e5);
          }, e4;
        }();
      }
    ), "./src/demux/transmuxer-worker.ts": (
      /*!****************************************!*\
          !*** ./src/demux/transmuxer-worker.ts ***!
          \****************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => o2 });
        var i3 = r3(
          /*! ../demux/transmuxer */
          "./src/demux/transmuxer.ts"
        ), n2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), a2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), s2 = r3(
          /*! eventemitter3 */
          "./node_modules/eventemitter3/index.js"
        );
        function o2(e4) {
          var t4 = new s2.EventEmitter(), r4 = function(t5, r5) {
            e4.postMessage({ event: t5, data: r5 });
          };
          t4.on(n2.Events.FRAG_DECRYPTED, r4), t4.on(n2.Events.ERROR, r4), e4.addEventListener("message", function(n3) {
            var s3 = n3.data;
            switch (s3.cmd) {
              case "init":
                var o3 = JSON.parse(s3.config);
                e4.transmuxer = new i3.default(t4, s3.typeSupported, o3, s3.vendor, s3.id), (0, a2.enableLogs)(o3.debug, s3.id), function() {
                  var e5 = function(e6) {
                    a2.logger[e6] = function(t6) {
                      r4("workerLog", { logType: e6, message: t6 });
                    };
                  };
                  for (var t5 in a2.logger)
                    e5(t5);
                }(), r4("init", null);
                break;
              case "configure":
                e4.transmuxer.configure(s3.config);
                break;
              case "demux":
                var u3 = e4.transmuxer.push(s3.data, s3.decryptdata, s3.chunkMeta, s3.state);
                (0, i3.isPromise)(u3) ? u3.then(function(t5) {
                  l2(e4, t5);
                }) : l2(e4, u3);
                break;
              case "flush":
                var d2 = s3.chunkMeta, h2 = e4.transmuxer.flush(d2);
                (0, i3.isPromise)(h2) ? h2.then(function(t5) {
                  c2(e4, t5, d2);
                }) : c2(e4, h2, d2);
            }
          });
        }
        function l2(e4, t4) {
          if (!((r4 = t4.remuxResult).audio || r4.video || r4.text || r4.id3 || r4.initSegment))
            return false;
          var r4, i4 = [], n3 = t4.remuxResult, a3 = n3.audio, s3 = n3.video;
          return a3 && u2(i4, a3), s3 && u2(i4, s3), e4.postMessage({ event: "transmuxComplete", data: t4 }, i4), true;
        }
        function u2(e4, t4) {
          t4.data1 && e4.push(t4.data1.buffer), t4.data2 && e4.push(t4.data2.buffer);
        }
        function c2(e4, t4, r4) {
          t4.reduce(function(t5, r5) {
            return l2(e4, r5) || t5;
          }, false) || e4.postMessage({ event: "transmuxComplete", data: t4[0] }), e4.postMessage({ event: "flush", data: r4 });
        }
      }
    ), "./src/demux/transmuxer.ts": (
      /*!*********************************!*\
          !*** ./src/demux/transmuxer.ts ***!
          \*********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { TransmuxConfig: () => y2, TransmuxState: () => A2, default: () => g2, isPromise: () => m2 });
        var i3, n2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), a2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), s2 = r3(
          /*! ../crypt/decrypter */
          "./src/crypt/decrypter.ts"
        ), o2 = r3(
          /*! ../demux/aacdemuxer */
          "./src/demux/aacdemuxer.ts"
        ), l2 = r3(
          /*! ../demux/mp4demuxer */
          "./src/demux/mp4demuxer.ts"
        ), u2 = r3(
          /*! ../demux/tsdemuxer */
          "./src/demux/tsdemuxer.ts"
        ), c2 = r3(
          /*! ../demux/mp3demuxer */
          "./src/demux/mp3demuxer.ts"
        ), d2 = r3(
          /*! ../remux/mp4-remuxer */
          "./src/remux/mp4-remuxer.ts"
        ), h2 = r3(
          /*! ../remux/passthrough-remuxer */
          "./src/remux/passthrough-remuxer.ts"
        ), f2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        );
        try {
          i3 = self.performance.now.bind(self.performance);
        } catch (e4) {
          f2.logger.debug("Unable to use Performance API on this environment"), i3 = self.Date.now;
        }
        var p2 = [{ demux: u2.default, remux: d2.default }, { demux: l2.default, remux: h2.default }, { demux: o2.default, remux: d2.default }, { demux: c2.default, remux: d2.default }], g2 = function() {
          function e4(e5, t5, r4, i4, n3) {
            this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e5, this.typeSupported = t5, this.config = r4, this.vendor = i4, this.id = n3;
          }
          var t4 = e4.prototype;
          return t4.configure = function(e5) {
            this.transmuxConfig = e5, this.decrypter && this.decrypter.reset();
          }, t4.push = function(e5, t5, r4, n3) {
            var a3 = this, s3 = r4.transmuxing;
            s3.executeStart = i3();
            var o3 = new Uint8Array(e5), l3 = this.config, u3 = this.currentTransmuxState, c3 = this.transmuxConfig;
            n3 && (this.currentTransmuxState = n3);
            var d3 = n3 || u3, h3 = d3.contiguous, f3 = d3.discontinuity, p3 = d3.trackSwitch, g3 = d3.accurateTimeOffset, m3 = d3.timeOffset, y3 = d3.initSegmentChange, A3 = c3.audioCodec, E2 = c3.videoCodec, T2 = c3.defaultInitPts, b2 = c3.duration, k2 = c3.initSegmentData;
            (f3 || p3 || y3) && this.resetInitSegment(k2, A3, E2, b2), (f3 || y3) && this.resetInitialTimestamp(T2), h3 || this.resetContiguity();
            var S2 = function(e6, t6) {
              var r5 = null;
              return e6.byteLength > 0 && null != t6 && null != t6.key && null !== t6.iv && null != t6.method && (r5 = t6), r5;
            }(o3, t5);
            if (S2 && "AES-128" === S2.method) {
              var _2 = this.getDecrypter();
              if (!l3.enableSoftwareAES)
                return this.decryptionPromise = _2.webCryptoDecrypt(o3, S2.key.buffer, S2.iv.buffer).then(function(e6) {
                  var t6 = a3.push(e6, null, r4);
                  return a3.decryptionPromise = null, t6;
                }), this.decryptionPromise;
              var C2 = _2.softwareDecrypt(o3, S2.key.buffer, S2.iv.buffer);
              if (!C2)
                return s3.executeEnd = i3(), v2(r4);
              o3 = new Uint8Array(C2);
            }
            this.needsProbing(o3, f3, p3) && this.configureTransmuxer(o3, c3);
            var L2 = this.transmux(o3, S2, m3, g3, r4), D2 = this.currentTransmuxState;
            return D2.contiguous = true, D2.discontinuity = false, D2.trackSwitch = false, s3.executeEnd = i3(), L2;
          }, t4.flush = function(e5) {
            var t5 = this, r4 = e5.transmuxing;
            r4.executeStart = i3();
            var s3 = this.decrypter, o3 = this.currentTransmuxState, l3 = this.decryptionPromise;
            if (l3)
              return l3.then(function() {
                return t5.flush(e5);
              });
            var u3 = [], c3 = o3.timeOffset;
            if (s3) {
              var d3 = s3.flush();
              d3 && u3.push(this.push(d3, null, e5));
            }
            var h3 = this.demuxer, f3 = this.remuxer;
            if (!h3 || !f3)
              return this.observer.emit(n2.Events.ERROR, n2.Events.ERROR, { type: a2.ErrorTypes.MEDIA_ERROR, details: a2.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: "no demux matching with content found" }), r4.executeEnd = i3(), [v2(e5)];
            var p3 = h3.flush(c3);
            return m2(p3) ? p3.then(function(r5) {
              return t5.flushRemux(u3, r5, e5), u3;
            }) : (this.flushRemux(u3, p3, e5), u3);
          }, t4.flushRemux = function(e5, t5, r4) {
            var n3 = t5.audioTrack, a3 = t5.videoTrack, s3 = t5.id3Track, o3 = t5.textTrack, l3 = this.currentTransmuxState, u3 = l3.accurateTimeOffset, c3 = l3.timeOffset;
            f2.logger.log("[transmuxer.ts]: Flushed fragment " + r4.sn + (r4.part > -1 ? " p: " + r4.part : "") + " of level " + r4.level);
            var d3 = this.remuxer.remux(n3, a3, s3, o3, c3, u3, true, this.id);
            e5.push({ remuxResult: d3, chunkMeta: r4 }), r4.transmuxing.executeEnd = i3();
          }, t4.resetInitialTimestamp = function(e5) {
            var t5 = this.demuxer, r4 = this.remuxer;
            t5 && r4 && (t5.resetTimeStamp(e5), r4.resetTimeStamp(e5));
          }, t4.resetContiguity = function() {
            var e5 = this.demuxer, t5 = this.remuxer;
            e5 && t5 && (e5.resetContiguity(), t5.resetNextTimestamp());
          }, t4.resetInitSegment = function(e5, t5, r4, i4) {
            var n3 = this.demuxer, a3 = this.remuxer;
            n3 && a3 && (n3.resetInitSegment(e5, t5, r4, i4), a3.resetInitSegment(e5, t5, r4));
          }, t4.destroy = function() {
            this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0);
          }, t4.transmux = function(e5, t5, r4, i4, n3) {
            return t5 && "SAMPLE-AES" === t5.method ? this.transmuxSampleAes(e5, t5, r4, i4, n3) : this.transmuxUnencrypted(e5, r4, i4, n3);
          }, t4.transmuxUnencrypted = function(e5, t5, r4, i4) {
            var n3 = this.demuxer.demux(e5, t5, false, !this.config.progressive), a3 = n3.audioTrack, s3 = n3.videoTrack, o3 = n3.id3Track, l3 = n3.textTrack;
            return { remuxResult: this.remuxer.remux(a3, s3, o3, l3, t5, r4, false, this.id), chunkMeta: i4 };
          }, t4.transmuxSampleAes = function(e5, t5, r4, i4, n3) {
            var a3 = this;
            return this.demuxer.demuxSampleAes(e5, t5, r4).then(function(e6) {
              return { remuxResult: a3.remuxer.remux(e6.audioTrack, e6.videoTrack, e6.id3Track, e6.textTrack, r4, i4, false, a3.id), chunkMeta: n3 };
            });
          }, t4.configureTransmuxer = function(e5, t5) {
            for (var r4, i4 = this.config, n3 = this.observer, a3 = this.typeSupported, s3 = this.vendor, o3 = t5.audioCodec, u3 = t5.defaultInitPts, c3 = t5.duration, d3 = t5.initSegmentData, g3 = t5.videoCodec, v3 = 0, m3 = p2.length; v3 < m3; v3++)
              if (p2[v3].demux.probe(e5)) {
                r4 = p2[v3];
                break;
              }
            r4 || (f2.logger.warn("Failed to find demuxer by probing frag, treating as mp4 passthrough"), r4 = { demux: l2.default, remux: h2.default });
            var y3 = this.demuxer, A3 = this.remuxer, E2 = r4.remux, T2 = r4.demux;
            A3 && A3 instanceof E2 || (this.remuxer = new E2(n3, i4, a3, s3)), y3 && y3 instanceof T2 || (this.demuxer = new T2(n3, i4, a3), this.probe = T2.probe), this.resetInitSegment(d3, o3, g3, c3), this.resetInitialTimestamp(u3);
          }, t4.needsProbing = function(e5, t5, r4) {
            return !this.demuxer || !this.remuxer || t5 || r4;
          }, t4.getDecrypter = function() {
            var e5 = this.decrypter;
            return e5 || (e5 = this.decrypter = new s2.default(this.observer, this.config)), e5;
          }, e4;
        }(), v2 = function(e4) {
          return { remuxResult: {}, chunkMeta: e4 };
        };
        function m2(e4) {
          return "then" in e4 && e4.then instanceof Function;
        }
        var y2 = function(e4, t4, r4, i4, n3) {
          this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e4, this.videoCodec = t4, this.initSegmentData = r4, this.duration = i4, this.defaultInitPts = n3;
        }, A2 = function(e4, t4, r4, i4, n3, a3) {
          this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e4, this.contiguous = t4, this.accurateTimeOffset = r4, this.trackSwitch = i4, this.timeOffset = n3, this.initSegmentChange = a3;
        };
      }
    ), "./src/demux/tsdemuxer.ts": (
      /*!********************************!*\
          !*** ./src/demux/tsdemuxer.ts ***!
          \********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => A2 });
        var i3 = r3(
          /*! ./adts */
          "./src/demux/adts.ts"
        ), n2 = r3(
          /*! ./mpegaudio */
          "./src/demux/mpegaudio.ts"
        ), a2 = r3(
          /*! ./exp-golomb */
          "./src/demux/exp-golomb.ts"
        ), s2 = r3(
          /*! ./sample-aes */
          "./src/demux/sample-aes.ts"
        ), o2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), l2 = r3(
          /*! ../utils/mp4-tools */
          "./src/utils/mp4-tools.ts"
        ), u2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), c2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), d2 = r3(
          /*! ../types/demuxer */
          "./src/types/demuxer.ts"
        );
        function h2() {
          return h2 = Object.assign ? Object.assign.bind() : function(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var r4 = arguments[t4];
              for (var i4 in r4)
                Object.prototype.hasOwnProperty.call(r4, i4) && (e4[i4] = r4[i4]);
            }
            return e4;
          }, h2.apply(this, arguments);
        }
        var f2 = 188;
        function p2(e4, t4, r4, i4) {
          return { key: e4, frame: false, pts: t4, dts: r4, units: [], debug: i4, length: 0 };
        }
        function g2(e4, t4) {
          return (31 & e4[t4 + 10]) << 8 | e4[t4 + 11];
        }
        function v2(e4, t4, r4, i4) {
          var n3 = { audio: -1, avc: -1, id3: -1, segmentCodec: "aac" }, a3 = t4 + 3 + ((15 & e4[t4 + 1]) << 8 | e4[t4 + 2]) - 4;
          for (t4 += 12 + ((15 & e4[t4 + 10]) << 8 | e4[t4 + 11]); t4 < a3; ) {
            var s3 = (31 & e4[t4 + 1]) << 8 | e4[t4 + 2];
            switch (e4[t4]) {
              case 207:
                if (!i4) {
                  u2.logger.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
                  break;
                }
              case 15:
                -1 === n3.audio && (n3.audio = s3);
                break;
              case 21:
                -1 === n3.id3 && (n3.id3 = s3);
                break;
              case 219:
                if (!i4) {
                  u2.logger.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
                  break;
                }
              case 27:
                -1 === n3.avc && (n3.avc = s3);
                break;
              case 3:
              case 4:
                true !== r4.mpeg && true !== r4.mp3 ? u2.logger.log("MPEG audio found, not supported in this browser") : -1 === n3.audio && (n3.audio = s3, n3.segmentCodec = "mp3");
                break;
              case 36:
                u2.logger.warn("Unsupported HEVC stream type found");
            }
            t4 += 5 + ((15 & e4[t4 + 3]) << 8 | e4[t4 + 4]);
          }
          return n3;
        }
        function m2(e4) {
          var t4, r4, i4, n3, a3, s3 = 0, o3 = e4.data;
          if (!e4 || 0 === e4.size)
            return null;
          for (; o3[0].length < 19 && o3.length > 1; ) {
            var l3 = new Uint8Array(o3[0].length + o3[1].length);
            l3.set(o3[0]), l3.set(o3[1], o3[0].length), o3[0] = l3, o3.splice(1, 1);
          }
          if (1 === ((t4 = o3[0])[0] << 16) + (t4[1] << 8) + t4[2]) {
            if ((r4 = (t4[4] << 8) + t4[5]) && r4 > e4.size - 6)
              return null;
            var c3 = t4[7];
            192 & c3 && (n3 = 536870912 * (14 & t4[9]) + 4194304 * (255 & t4[10]) + 16384 * (254 & t4[11]) + 128 * (255 & t4[12]) + (254 & t4[13]) / 2, 64 & c3 ? n3 - (a3 = 536870912 * (14 & t4[14]) + 4194304 * (255 & t4[15]) + 16384 * (254 & t4[16]) + 128 * (255 & t4[17]) + (254 & t4[18]) / 2) > 54e5 && (u2.logger.warn(Math.round((n3 - a3) / 9e4) + "s delta between PTS and DTS, align them"), n3 = a3) : a3 = n3);
            var d3 = (i4 = t4[8]) + 9;
            if (e4.size <= d3)
              return null;
            e4.size -= d3;
            for (var h3 = new Uint8Array(e4.size), f3 = 0, p3 = o3.length; f3 < p3; f3++) {
              var g3 = (t4 = o3[f3]).byteLength;
              if (d3) {
                if (d3 > g3) {
                  d3 -= g3;
                  continue;
                }
                t4 = t4.subarray(d3), g3 -= d3, d3 = 0;
              }
              h3.set(t4, s3), s3 += g3;
            }
            return r4 && (r4 -= i4 + 3), { data: h3, pts: n3, dts: a3, len: r4 };
          }
          return null;
        }
        function y2(e4, t4) {
          if (e4.units.length && e4.frame) {
            if (void 0 === e4.pts) {
              var r4 = t4.samples, i4 = r4.length;
              if (!i4)
                return void t4.dropped++;
              var n3 = r4[i4 - 1];
              e4.pts = n3.pts, e4.dts = n3.dts;
            }
            t4.samples.push(e4);
          }
          e4.debug.length && u2.logger.log(e4.pts + "/" + e4.dts + ":" + e4.debug);
        }
        const A2 = function() {
          function e4(e5, t5, r4) {
            this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = false, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this._pmtId = -1, this._avcTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.observer = e5, this.config = t5, this.typeSupported = r4;
          }
          e4.probe = function(t5) {
            var r4 = e4.syncOffset(t5);
            return r4 > 0 && u2.logger.warn("MPEG2-TS detected but first sync word found @ offset " + r4), -1 !== r4;
          }, e4.syncOffset = function(e5) {
            for (var t5 = Math.min(940, e5.length - 376) + 1, r4 = 0; r4 < t5; ) {
              if (71 === e5[r4] && 71 === e5[r4 + f2])
                return r4;
              r4++;
            }
            return -1;
          }, e4.createTrack = function(e5, t5) {
            return { container: "video" === e5 || "audio" === e5 ? "video/mp2t" : void 0, type: e5, id: l2.RemuxerTrackIdConfig[e5], pid: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], dropped: 0, duration: "audio" === e5 ? t5 : void 0 };
          };
          var t4 = e4.prototype;
          return t4.resetInitSegment = function(t5, r4, i4, n3) {
            this.pmtParsed = false, this._pmtId = -1, this._avcTrack = e4.createTrack("video"), this._audioTrack = e4.createTrack("audio", n3), this._id3Track = e4.createTrack("id3"), this._txtTrack = e4.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.audioCodec = r4, this.videoCodec = i4, this._duration = n3;
          }, t4.resetTimeStamp = function() {
          }, t4.resetContiguity = function() {
            var e5 = this._audioTrack, t5 = this._avcTrack, r4 = this._id3Track;
            e5 && (e5.pesData = null), t5 && (t5.pesData = null), r4 && (r4.pesData = null), this.aacOverFlow = null, this.avcSample = null, this.remainderData = null;
          }, t4.demux = function(t5, r4, i4, n3) {
            var a3;
            void 0 === i4 && (i4 = false), void 0 === n3 && (n3 = false), i4 || (this.sampleAes = null);
            var s3 = this._avcTrack, d3 = this._audioTrack, h3 = this._id3Track, p3 = this._txtTrack, y3 = s3.pid, A3 = s3.pesData, E2 = d3.pid, T2 = h3.pid, b2 = d3.pesData, k2 = h3.pesData, S2 = null, _2 = this.pmtParsed, C2 = this._pmtId, L2 = t5.length;
            if (this.remainderData && (L2 = (t5 = (0, l2.appendUint8Array)(this.remainderData, t5)).length, this.remainderData = null), L2 < f2 && !n3)
              return this.remainderData = t5, { audioTrack: d3, videoTrack: s3, id3Track: h3, textTrack: p3 };
            var D2 = Math.max(0, e4.syncOffset(t5));
            (L2 -= (L2 - D2) % f2) < t5.byteLength && !n3 && (this.remainderData = new Uint8Array(t5.buffer, L2, t5.buffer.byteLength - L2));
            for (var R2 = 0, I2 = D2; I2 < L2; I2 += f2)
              if (71 === t5[I2]) {
                var O2 = !!(64 & t5[I2 + 1]), w2 = ((31 & t5[I2 + 1]) << 8) + t5[I2 + 2], P2 = void 0;
                if ((48 & t5[I2 + 3]) >> 4 > 1) {
                  if ((P2 = I2 + 5 + t5[I2 + 4]) === I2 + f2)
                    continue;
                } else
                  P2 = I2 + 4;
                switch (w2) {
                  case y3:
                    O2 && (A3 && (a3 = m2(A3)) && this.parseAVCPES(s3, p3, a3, false), A3 = { data: [], size: 0 }), A3 && (A3.data.push(t5.subarray(P2, I2 + f2)), A3.size += I2 + f2 - P2);
                    break;
                  case E2:
                    if (O2) {
                      if (b2 && (a3 = m2(b2)))
                        switch (d3.segmentCodec) {
                          case "aac":
                            this.parseAACPES(d3, a3);
                            break;
                          case "mp3":
                            this.parseMPEGPES(d3, a3);
                        }
                      b2 = { data: [], size: 0 };
                    }
                    b2 && (b2.data.push(t5.subarray(P2, I2 + f2)), b2.size += I2 + f2 - P2);
                    break;
                  case T2:
                    O2 && (k2 && (a3 = m2(k2)) && this.parseID3PES(h3, a3), k2 = { data: [], size: 0 }), k2 && (k2.data.push(t5.subarray(P2, I2 + f2)), k2.size += I2 + f2 - P2);
                    break;
                  case 0:
                    O2 && (P2 += t5[P2] + 1), C2 = this._pmtId = g2(t5, P2);
                    break;
                  case C2:
                    O2 && (P2 += t5[P2] + 1);
                    var x2 = v2(t5, P2, this.typeSupported, i4);
                    (y3 = x2.avc) > 0 && (s3.pid = y3), (E2 = x2.audio) > 0 && (d3.pid = E2, d3.segmentCodec = x2.segmentCodec), (T2 = x2.id3) > 0 && (h3.pid = T2), null === S2 || _2 || (u2.logger.log("unknown PID '" + S2 + "' in TS found"), S2 = null, I2 = D2 - 188), _2 = this.pmtParsed = true;
                    break;
                  case 17:
                  case 8191:
                    break;
                  default:
                    S2 = w2;
                }
              } else
                R2++;
            R2 > 0 && this.observer.emit(o2.Events.ERROR, o2.Events.ERROR, { type: c2.ErrorTypes.MEDIA_ERROR, details: c2.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: "Found " + R2 + " TS packet/s that do not start with 0x47" }), s3.pesData = A3, d3.pesData = b2, h3.pesData = k2;
            var N2 = { audioTrack: d3, videoTrack: s3, id3Track: h3, textTrack: p3 };
            return n3 && this.extractRemainingSamples(N2), N2;
          }, t4.flush = function() {
            var e5, t5 = this.remainderData;
            return this.remainderData = null, e5 = t5 ? this.demux(t5, -1, false, true) : { videoTrack: this._avcTrack, audioTrack: this._audioTrack, id3Track: this._id3Track, textTrack: this._txtTrack }, this.extractRemainingSamples(e5), this.sampleAes ? this.decrypt(e5, this.sampleAes) : e5;
          }, t4.extractRemainingSamples = function(e5) {
            var t5, r4 = e5.audioTrack, i4 = e5.videoTrack, n3 = e5.id3Track, a3 = e5.textTrack, s3 = i4.pesData, o3 = r4.pesData, l3 = n3.pesData;
            if (s3 && (t5 = m2(s3)) ? (this.parseAVCPES(i4, a3, t5, true), i4.pesData = null) : i4.pesData = s3, o3 && (t5 = m2(o3))) {
              switch (r4.segmentCodec) {
                case "aac":
                  this.parseAACPES(r4, t5);
                  break;
                case "mp3":
                  this.parseMPEGPES(r4, t5);
              }
              r4.pesData = null;
            } else
              null != o3 && o3.size && u2.logger.log("last AAC PES packet truncated,might overlap between fragments"), r4.pesData = o3;
            l3 && (t5 = m2(l3)) ? (this.parseID3PES(n3, t5), n3.pesData = null) : n3.pesData = l3;
          }, t4.demuxSampleAes = function(e5, t5, r4) {
            var i4 = this.demux(e5, r4, true, !this.config.progressive), n3 = this.sampleAes = new s2.default(this.observer, this.config, t5);
            return this.decrypt(i4, n3);
          }, t4.decrypt = function(e5, t5) {
            return new Promise(function(r4) {
              var i4 = e5.audioTrack, n3 = e5.videoTrack;
              i4.samples && "aac" === i4.segmentCodec ? t5.decryptAacSamples(i4.samples, 0, function() {
                n3.samples ? t5.decryptAvcSamples(n3.samples, 0, 0, function() {
                  r4(e5);
                }) : r4(e5);
              }) : n3.samples && t5.decryptAvcSamples(n3.samples, 0, 0, function() {
                r4(e5);
              });
            });
          }, t4.destroy = function() {
            this._duration = 0;
          }, t4.parseAVCPES = function(e5, t5, r4, i4) {
            var n3, s3 = this, o3 = this.parseAVCNALu(e5, r4.data), u3 = this.avcSample, c3 = false;
            r4.data = null, u3 && o3.length && !e5.audFound && (y2(u3, e5), u3 = this.avcSample = p2(false, r4.pts, r4.dts, "")), o3.forEach(function(i5) {
              switch (i5.type) {
                case 1:
                  n3 = true, u3 || (u3 = s3.avcSample = p2(true, r4.pts, r4.dts, "")), u3.frame = true;
                  var o4 = i5.data;
                  if (c3 && o4.length > 4) {
                    var d3 = new a2.default(o4).readSliceType();
                    2 !== d3 && 4 !== d3 && 7 !== d3 && 9 !== d3 || (u3.key = true);
                  }
                  break;
                case 5:
                  n3 = true, u3 || (u3 = s3.avcSample = p2(true, r4.pts, r4.dts, "")), u3.key = true, u3.frame = true;
                  break;
                case 6:
                  n3 = true, (0, l2.parseSEIMessageFromNALu)(i5.data, 1, r4.pts, t5.samples);
                  break;
                case 7:
                  if (n3 = true, c3 = true, !e5.sps) {
                    var h3 = new a2.default(i5.data).readSPS();
                    e5.width = h3.width, e5.height = h3.height, e5.pixelRatio = h3.pixelRatio, e5.sps = [i5.data], e5.duration = s3._duration;
                    for (var f3 = i5.data.subarray(1, 4), g3 = "avc1.", v3 = 0; v3 < 3; v3++) {
                      var m3 = f3[v3].toString(16);
                      m3.length < 2 && (m3 = "0" + m3), g3 += m3;
                    }
                    e5.codec = g3;
                  }
                  break;
                case 8:
                  n3 = true, e5.pps || (e5.pps = [i5.data]);
                  break;
                case 9:
                  n3 = false, e5.audFound = true, u3 && y2(u3, e5), u3 = s3.avcSample = p2(false, r4.pts, r4.dts, "");
                  break;
                case 12:
                  n3 = true;
                  break;
                default:
                  n3 = false, u3 && (u3.debug += "unknown NAL " + i5.type + " ");
              }
              u3 && n3 && u3.units.push(i5);
            }), i4 && u3 && (y2(u3, e5), this.avcSample = null);
          }, t4.getLastNalUnit = function(e5) {
            var t5, r4, i4 = this.avcSample;
            if (i4 && 0 !== i4.units.length || (i4 = e5[e5.length - 1]), null !== (t5 = i4) && void 0 !== t5 && t5.units) {
              var n3 = i4.units;
              r4 = n3[n3.length - 1];
            }
            return r4;
          }, t4.parseAVCNALu = function(e5, t5) {
            var r4, i4, n3 = t5.byteLength, a3 = e5.naluState || 0, s3 = a3, o3 = [], l3 = 0, u3 = -1, c3 = 0;
            for (-1 === a3 && (u3 = 0, c3 = 31 & t5[0], a3 = 0, l3 = 1); l3 < n3; )
              if (r4 = t5[l3++], a3)
                if (1 !== a3)
                  if (r4)
                    if (1 === r4) {
                      if (u3 >= 0) {
                        var d3 = { data: t5.subarray(u3, l3 - a3 - 1), type: c3 };
                        o3.push(d3);
                      } else {
                        var h3 = this.getLastNalUnit(e5.samples);
                        if (h3 && (s3 && l3 <= 4 - s3 && h3.state && (h3.data = h3.data.subarray(0, h3.data.byteLength - s3)), (i4 = l3 - a3 - 1) > 0)) {
                          var f3 = new Uint8Array(h3.data.byteLength + i4);
                          f3.set(h3.data, 0), f3.set(t5.subarray(0, i4), h3.data.byteLength), h3.data = f3, h3.state = 0;
                        }
                      }
                      l3 < n3 ? (u3 = l3, c3 = 31 & t5[l3], a3 = 0) : a3 = -1;
                    } else
                      a3 = 0;
                  else
                    a3 = 3;
                else
                  a3 = r4 ? 0 : 2;
              else
                a3 = r4 ? 0 : 1;
            if (u3 >= 0 && a3 >= 0) {
              var p3 = { data: t5.subarray(u3, n3), type: c3, state: a3 };
              o3.push(p3);
            }
            if (0 === o3.length) {
              var g3 = this.getLastNalUnit(e5.samples);
              if (g3) {
                var v3 = new Uint8Array(g3.data.byteLength + t5.byteLength);
                v3.set(g3.data, 0), v3.set(t5, g3.data.byteLength), g3.data = v3;
              }
            }
            return e5.naluState = a3, o3;
          }, t4.parseAACPES = function(e5, t5) {
            var r4, n3, a3, s3, l3, d3 = 0, h3 = this.aacOverFlow, f3 = t5.data;
            if (h3) {
              this.aacOverFlow = null;
              var p3 = h3.missing, g3 = h3.sample.unit.byteLength;
              if (-1 === p3) {
                var v3 = new Uint8Array(g3 + f3.byteLength);
                v3.set(h3.sample.unit, 0), v3.set(f3, g3), f3 = v3;
              } else {
                var m3 = g3 - p3;
                h3.sample.unit.set(f3.subarray(0, p3), m3), e5.samples.push(h3.sample), d3 = h3.missing;
              }
            }
            for (r4 = d3, n3 = f3.length; r4 < n3 - 1 && !i3.isHeader(f3, r4); r4++)
              ;
            if (r4 === d3 || (r4 < n3 - 1 ? (a3 = "AAC PES did not start with ADTS header,offset:" + r4, s3 = false) : (a3 = "no ADTS header found in AAC PES", s3 = true), u2.logger.warn("parsing error:" + a3), this.observer.emit(o2.Events.ERROR, o2.Events.ERROR, { type: c2.ErrorTypes.MEDIA_ERROR, details: c2.ErrorDetails.FRAG_PARSING_ERROR, fatal: s3, reason: a3 }), !s3)) {
              if (i3.initTrackConfig(e5, this.observer, f3, r4, this.audioCodec), void 0 !== t5.pts)
                l3 = t5.pts;
              else {
                if (!h3)
                  return void u2.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
                var y3 = i3.getFrameDuration(e5.samplerate);
                l3 = h3.sample.pts + y3;
              }
              for (var A3, E2 = 0; r4 < n3; ) {
                if (r4 += (A3 = i3.appendFrame(e5, f3, r4, l3, E2)).length, A3.missing) {
                  this.aacOverFlow = A3;
                  break;
                }
                for (E2++; r4 < n3 - 1 && !i3.isHeader(f3, r4); r4++)
                  ;
              }
            }
          }, t4.parseMPEGPES = function(e5, t5) {
            var r4 = t5.data, i4 = r4.length, a3 = 0, s3 = 0, o3 = t5.pts;
            if (void 0 !== o3)
              for (; s3 < i4; )
                if (n2.isHeader(r4, s3)) {
                  var l3 = n2.appendFrame(e5, r4, s3, o3, a3);
                  if (!l3)
                    break;
                  s3 += l3.length, a3++;
                } else
                  s3++;
            else
              u2.logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
          }, t4.parseID3PES = function(e5, t5) {
            if (void 0 !== t5.pts) {
              var r4 = h2({}, t5, { type: this._avcTrack ? d2.MetadataSchema.emsg : d2.MetadataSchema.audioId3, duration: Number.POSITIVE_INFINITY });
              e5.samples.push(r4);
            } else
              u2.logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
          }, e4;
        }();
      }
    ), "./src/demux/webworkify-webpack.js": (
      /*!*****************************************!*\
          !*** ./src/demux/webworkify-webpack.js ***!
          \*****************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => c2 });
        var i3 = (function() {
          var e4 = ENTRY_MODULE, t4 = {}, r4 = function r5(i5) {
            var n3 = t4[i5];
            if (void 0 !== n3)
              return n3.exports;
            var a3 = t4[i5] = { exports: {} };
            return e4[i5].call(a3.exports, a3, a3.exports, r5), a3.exports;
          };
          r4.m = e4, r4.n = function(e5) {
            var t5 = e5 && e5.__esModule ? function() {
              return e5.default;
            } : function() {
              return e5;
            };
            return r4.d(t5, { a: t5 }), t5;
          }, r4.d = function(e5, t5) {
            for (var i5 in t5)
              r4.o(t5, i5) && !r4.o(e5, i5) && Object.defineProperty(e5, i5, { enumerable: true, get: t5[i5] });
          }, r4.o = function(e5, t5) {
            return Object.prototype.hasOwnProperty.call(e5, t5);
          }, r4.r = function(e5) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e5, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e5, "__esModule", { value: true });
          };
          var i4 = r4(ENTRY_MODULE);
          return i4.default || i4;
        }).toString().split("ENTRY_MODULE"), n2 = "[\\.|\\-|\\+|\\w|/|@]+", a2 = "\\(\\s*(/\\*.*?\\*/)?\\s*.*?(" + n2 + ").*?\\)";
        function s2(e4) {
          return (e4 + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
        }
        function o2(e4, t4, i4) {
          var o3 = {};
          o3[i4] = [];
          var l3 = t4.toString().replace(/^"[^"]+"/, "function"), u3 = l3.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/) || l3.match(/^\(\w+,\s*\w+,\s*(\w+)\)\s?\=\s?\>/);
          if (!u3)
            return o3;
          for (var c3, d2 = u3[1], h2 = new RegExp("(\\\\n|\\W)" + s2(d2) + a2, "g"); c3 = h2.exec(l3); )
            "dll-reference" !== c3[3] && o3[i4].push(c3[3]);
          for (h2 = new RegExp("\\(" + s2(d2) + '\\("(dll-reference\\s(' + n2 + '))"\\)\\)' + a2, "g"); c3 = h2.exec(l3); )
            e4[c3[2]] || (o3[i4].push(c3[1]), e4[c3[2]] = r3(c3[1]).m), o3[c3[2]] = o3[c3[2]] || [], o3[c3[2]].push(c3[4]);
          for (var f2, p2 = Object.keys(o3), g2 = 0; g2 < p2.length; g2++)
            for (var v2 = 0; v2 < o3[p2[g2]].length; v2++)
              f2 = o3[p2[g2]][v2], isNaN(1 * f2) || (o3[p2[g2]][v2] = 1 * o3[p2[g2]][v2]);
          return o3;
        }
        function l2(e4) {
          return Object.keys(e4).reduce(function(t4, r4) {
            return t4 || e4[r4].length > 0;
          }, false);
        }
        function u2(e4, t4, r4, n3) {
          var a3 = e4[n3].map(function(e5) {
            return '"' + e5 + '": ' + t4[n3][e5].toString().replace(/^"[^"]+"/, "function");
          }).join(",");
          return i3[0] + "{" + a3 + "}" + i3[1] + '"' + r4 + '"' + i3[2];
        }
        function c2(e4, t4) {
          t4 = t4 || {};
          var i4 = { main: r3.m }, n3 = t4.all ? { main: Object.keys(i4.main) } : function(e5, t5) {
            for (var r4 = { main: [t5] }, i5 = { main: [] }, n4 = { main: {} }; l2(r4); )
              for (var a4 = Object.keys(r4), s4 = 0; s4 < a4.length; s4++) {
                var u3 = a4[s4], c4 = r4[u3].pop();
                if (n4[u3] = n4[u3] || {}, !n4[u3][c4] && e5[u3][c4]) {
                  n4[u3][c4] = true, i5[u3] = i5[u3] || [], i5[u3].push(c4);
                  for (var d3 = o2(e5, e5[u3][c4], u3), h2 = Object.keys(d3), f2 = 0; f2 < h2.length; f2++)
                    r4[h2[f2]] = r4[h2[f2]] || [], r4[h2[f2]] = r4[h2[f2]].concat(d3[h2[f2]]);
                }
              }
            return i5;
          }(i4, e4), a3 = "";
          Object.keys(n3).filter(function(e5) {
            return "main" !== e5;
          }).forEach(function(e5) {
            for (var t5 = 0; n3[e5][t5]; )
              t5++;
            n3[e5].push(t5), i4[e5][t5] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })", a3 = a3 + "var " + e5 + " = (" + u2(n3, i4, t5, modules) + ")();\n";
          }), a3 = a3 + "new ((" + u2(n3, i4, e4, "main") + ")())(self);";
          var s3 = new window.Blob([a3], { type: "text/javascript" }), c3 = (window.URL || window.webkitURL || window.mozURL || window.msURL).createObjectURL(s3), d2 = new window.Worker(c3);
          return d2.objectURL = c3, d2;
        }
      }
    ), "./src/errors.ts": (
      /*!***********************!*\
          !*** ./src/errors.ts ***!
          \***********************/
      (e3, t3, r3) => {
        var i3, n2;
        r3.r(t3), r3.d(t3, { ErrorDetails: () => n2, ErrorTypes: () => i3 }), function(e4) {
          e4.NETWORK_ERROR = "networkError", e4.MEDIA_ERROR = "mediaError", e4.KEY_SYSTEM_ERROR = "keySystemError", e4.MUX_ERROR = "muxError", e4.OTHER_ERROR = "otherError";
        }(i3 || (i3 = {})), function(e4) {
          e4.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", e4.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", e4.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", e4.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", e4.KEY_SYSTEM_NO_INIT_DATA = "keySystemNoInitData", e4.MANIFEST_LOAD_ERROR = "manifestLoadError", e4.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", e4.MANIFEST_PARSING_ERROR = "manifestParsingError", e4.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", e4.LEVEL_EMPTY_ERROR = "levelEmptyError", e4.LEVEL_LOAD_ERROR = "levelLoadError", e4.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", e4.LEVEL_SWITCH_ERROR = "levelSwitchError", e4.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", e4.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", e4.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", e4.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", e4.FRAG_LOAD_ERROR = "fragLoadError", e4.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", e4.FRAG_DECRYPT_ERROR = "fragDecryptError", e4.FRAG_PARSING_ERROR = "fragParsingError", e4.REMUX_ALLOC_ERROR = "remuxAllocError", e4.KEY_LOAD_ERROR = "keyLoadError", e4.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", e4.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", e4.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", e4.BUFFER_APPEND_ERROR = "bufferAppendError", e4.BUFFER_APPENDING_ERROR = "bufferAppendingError", e4.BUFFER_STALLED_ERROR = "bufferStalledError", e4.BUFFER_FULL_ERROR = "bufferFullError", e4.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", e4.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", e4.INTERNAL_EXCEPTION = "internalException", e4.INTERNAL_ABORTED = "aborted", e4.UNKNOWN = "unknown";
        }(n2 || (n2 = {}));
      }
    ), "./src/events.ts": (
      /*!***********************!*\
          !*** ./src/events.ts ***!
          \***********************/
      (e3, t3, r3) => {
        var i3;
        r3.r(t3), r3.d(t3, { Events: () => i3 }), function(e4) {
          e4.MEDIA_ATTACHING = "hlsMediaAttaching", e4.MEDIA_ATTACHED = "hlsMediaAttached", e4.MEDIA_DETACHING = "hlsMediaDetaching", e4.MEDIA_DETACHED = "hlsMediaDetached", e4.BUFFER_RESET = "hlsBufferReset", e4.BUFFER_CODECS = "hlsBufferCodecs", e4.BUFFER_CREATED = "hlsBufferCreated", e4.BUFFER_APPENDING = "hlsBufferAppending", e4.BUFFER_APPENDED = "hlsBufferAppended", e4.BUFFER_EOS = "hlsBufferEos", e4.BUFFER_FLUSHING = "hlsBufferFlushing", e4.BUFFER_FLUSHED = "hlsBufferFlushed", e4.MANIFEST_LOADING = "hlsManifestLoading", e4.MANIFEST_LOADED = "hlsManifestLoaded", e4.MANIFEST_PARSED = "hlsManifestParsed", e4.LEVEL_SWITCHING = "hlsLevelSwitching", e4.LEVEL_SWITCHED = "hlsLevelSwitched", e4.LEVEL_LOADING = "hlsLevelLoading", e4.LEVEL_LOADED = "hlsLevelLoaded", e4.LEVEL_UPDATED = "hlsLevelUpdated", e4.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", e4.LEVELS_UPDATED = "hlsLevelsUpdated", e4.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", e4.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", e4.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", e4.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", e4.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", e4.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", e4.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", e4.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", e4.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", e4.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", e4.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", e4.CUES_PARSED = "hlsCuesParsed", e4.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", e4.INIT_PTS_FOUND = "hlsInitPtsFound", e4.FRAG_LOADING = "hlsFragLoading", e4.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", e4.FRAG_LOADED = "hlsFragLoaded", e4.FRAG_DECRYPTED = "hlsFragDecrypted", e4.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", e4.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", e4.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", e4.FRAG_PARSED = "hlsFragParsed", e4.FRAG_BUFFERED = "hlsFragBuffered", e4.FRAG_CHANGED = "hlsFragChanged", e4.FPS_DROP = "hlsFpsDrop", e4.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", e4.ERROR = "hlsError", e4.DESTROYING = "hlsDestroying", e4.KEY_LOADING = "hlsKeyLoading", e4.KEY_LOADED = "hlsKeyLoaded", e4.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", e4.BACK_BUFFER_REACHED = "hlsBackBufferReached";
        }(i3 || (i3 = {}));
      }
    ), "./src/hls.ts": (
      /*!********************!*\
          !*** ./src/hls.ts ***!
          \********************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => y2 });
        var i3 = r3(
          /*! url-toolkit */
          "./node_modules/url-toolkit/src/url-toolkit.js"
        ), n2 = r3(
          /*! ./loader/playlist-loader */
          "./src/loader/playlist-loader.ts"
        ), a2 = r3(
          /*! ./loader/key-loader */
          "./src/loader/key-loader.ts"
        ), s2 = r3(
          /*! ./controller/id3-track-controller */
          "./src/controller/id3-track-controller.ts"
        ), o2 = r3(
          /*! ./controller/latency-controller */
          "./src/controller/latency-controller.ts"
        ), l2 = r3(
          /*! ./controller/level-controller */
          "./src/controller/level-controller.ts"
        ), u2 = r3(
          /*! ./controller/fragment-tracker */
          "./src/controller/fragment-tracker.ts"
        ), c2 = r3(
          /*! ./controller/stream-controller */
          "./src/controller/stream-controller.ts"
        ), d2 = r3(
          /*! ./is-supported */
          "./src/is-supported.ts"
        ), h2 = r3(
          /*! ./utils/logger */
          "./src/utils/logger.ts"
        ), f2 = r3(
          /*! ./config */
          "./src/config.ts"
        ), p2 = r3(
          /*! eventemitter3 */
          "./node_modules/eventemitter3/index.js"
        ), g2 = r3(
          /*! ./events */
          "./src/events.ts"
        ), v2 = r3(
          /*! ./errors */
          "./src/errors.ts"
        );
        function m2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        var y2 = function() {
          function e4(t5) {
            void 0 === t5 && (t5 = {}), this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new p2.EventEmitter(), this._autoLevelCapping = void 0, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null;
            var r5 = this.config = (0, f2.mergeConfig)(e4.DefaultConfig, t5);
            this.userConfig = t5, (0, h2.enableLogs)(r5.debug, "Hls instance"), this._autoLevelCapping = -1, r5.progressive && (0, f2.enableStreamingMode)(r5);
            var i4 = r5.abrController, d3 = r5.bufferController, g3 = r5.capLevelController, v3 = r5.fpsController, m3 = this.abrController = new i4(this), y4 = this.bufferController = new d3(this), A3 = this.capLevelController = new g3(this), E2 = new v3(this), T2 = new n2.default(this), b2 = new a2.default(this), k2 = new s2.default(this), S2 = this.levelController = new l2.default(this), _2 = new u2.FragmentTracker(this), C2 = this.streamController = new c2.default(this, _2);
            A3.setStreamController(C2), E2.setStreamController(C2);
            var L2 = [T2, b2, S2, C2];
            this.networkControllers = L2;
            var D2 = [m3, y4, A3, E2, k2, _2];
            this.audioTrackController = this.createController(r5.audioTrackController, null, L2), this.createController(r5.audioStreamController, _2, L2), this.subtitleTrackController = this.createController(r5.subtitleTrackController, null, L2), this.createController(r5.subtitleStreamController, _2, L2), this.createController(r5.timelineController, null, D2), this.emeController = this.createController(r5.emeController, null, D2), this.cmcdController = this.createController(r5.cmcdController, null, D2), this.latencyController = this.createController(o2.default, null, D2), this.coreComponents = D2;
          }
          e4.isSupported = function() {
            return (0, d2.isSupported)();
          };
          var t4, r4, y3, A2 = e4.prototype;
          return A2.createController = function(e5, t5, r5) {
            if (e5) {
              var i4 = t5 ? new e5(this, t5) : new e5(this);
              return r5 && r5.push(i4), i4;
            }
            return null;
          }, A2.on = function(e5, t5, r5) {
            void 0 === r5 && (r5 = this), this._emitter.on(e5, t5, r5);
          }, A2.once = function(e5, t5, r5) {
            void 0 === r5 && (r5 = this), this._emitter.once(e5, t5, r5);
          }, A2.removeAllListeners = function(e5) {
            this._emitter.removeAllListeners(e5);
          }, A2.off = function(e5, t5, r5, i4) {
            void 0 === r5 && (r5 = this), this._emitter.off(e5, t5, r5, i4);
          }, A2.listeners = function(e5) {
            return this._emitter.listeners(e5);
          }, A2.emit = function(e5, t5, r5) {
            return this._emitter.emit(e5, t5, r5);
          }, A2.trigger = function(e5, t5) {
            if (this.config.debug)
              return this.emit(e5, e5, t5);
            try {
              return this.emit(e5, e5, t5);
            } catch (t6) {
              h2.logger.error("An internal error happened while handling event " + e5 + '. Error message: "' + t6.message + '". Here is a stacktrace:', t6), this.trigger(g2.Events.ERROR, { type: v2.ErrorTypes.OTHER_ERROR, details: v2.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: e5, error: t6 });
            }
            return false;
          }, A2.listenerCount = function(e5) {
            return this._emitter.listenerCount(e5);
          }, A2.destroy = function() {
            h2.logger.log("destroy"), this.trigger(g2.Events.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach(function(e5) {
              return e5.destroy();
            }), this.networkControllers.length = 0, this.coreComponents.forEach(function(e5) {
              return e5.destroy();
            }), this.coreComponents.length = 0;
          }, A2.attachMedia = function(e5) {
            h2.logger.log("attachMedia"), this._media = e5, this.trigger(g2.Events.MEDIA_ATTACHING, { media: e5 });
          }, A2.detachMedia = function() {
            h2.logger.log("detachMedia"), this.trigger(g2.Events.MEDIA_DETACHING, void 0), this._media = null;
          }, A2.loadSource = function(e5) {
            this.stopLoad();
            var t5 = this.media, r5 = this.url, n3 = this.url = i3.buildAbsoluteURL(self.location.href, e5, { alwaysNormalize: true });
            h2.logger.log("loadSource:" + n3), t5 && r5 && r5 !== n3 && this.bufferController.hasSourceTypes() && (this.detachMedia(), this.attachMedia(t5)), this.trigger(g2.Events.MANIFEST_LOADING, { url: e5 });
          }, A2.startLoad = function(e5) {
            void 0 === e5 && (e5 = -1), h2.logger.log("startLoad(" + e5 + ")"), this.networkControllers.forEach(function(t5) {
              t5.startLoad(e5);
            });
          }, A2.stopLoad = function() {
            h2.logger.log("stopLoad"), this.networkControllers.forEach(function(e5) {
              e5.stopLoad();
            });
          }, A2.swapAudioCodec = function() {
            h2.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec();
          }, A2.recoverMediaError = function() {
            h2.logger.log("recoverMediaError");
            var e5 = this._media;
            this.detachMedia(), e5 && this.attachMedia(e5);
          }, A2.removeLevel = function(e5, t5) {
            void 0 === t5 && (t5 = 0), this.levelController.removeLevel(e5, t5);
          }, t4 = e4, y3 = [{ key: "version", get: function() {
            return "1.2.9";
          } }, { key: "Events", get: function() {
            return g2.Events;
          } }, { key: "ErrorTypes", get: function() {
            return v2.ErrorTypes;
          } }, { key: "ErrorDetails", get: function() {
            return v2.ErrorDetails;
          } }, { key: "DefaultConfig", get: function() {
            return e4.defaultConfig ? e4.defaultConfig : f2.hlsDefaultConfig;
          }, set: function(t5) {
            e4.defaultConfig = t5;
          } }], (r4 = [{ key: "levels", get: function() {
            var e5 = this.levelController.levels;
            return e5 || [];
          } }, { key: "currentLevel", get: function() {
            return this.streamController.currentLevel;
          }, set: function(e5) {
            h2.logger.log("set currentLevel:" + e5), this.loadLevel = e5, this.abrController.clearTimer(), this.streamController.immediateLevelSwitch();
          } }, { key: "nextLevel", get: function() {
            return this.streamController.nextLevel;
          }, set: function(e5) {
            h2.logger.log("set nextLevel:" + e5), this.levelController.manualLevel = e5, this.streamController.nextLevelSwitch();
          } }, { key: "loadLevel", get: function() {
            return this.levelController.level;
          }, set: function(e5) {
            h2.logger.log("set loadLevel:" + e5), this.levelController.manualLevel = e5;
          } }, { key: "nextLoadLevel", get: function() {
            return this.levelController.nextLoadLevel;
          }, set: function(e5) {
            this.levelController.nextLoadLevel = e5;
          } }, { key: "firstLevel", get: function() {
            return Math.max(this.levelController.firstLevel, this.minAutoLevel);
          }, set: function(e5) {
            h2.logger.log("set firstLevel:" + e5), this.levelController.firstLevel = e5;
          } }, { key: "startLevel", get: function() {
            return this.levelController.startLevel;
          }, set: function(e5) {
            h2.logger.log("set startLevel:" + e5), -1 !== e5 && (e5 = Math.max(e5, this.minAutoLevel)), this.levelController.startLevel = e5;
          } }, { key: "capLevelToPlayerSize", get: function() {
            return this.config.capLevelToPlayerSize;
          }, set: function(e5) {
            var t5 = !!e5;
            t5 !== this.config.capLevelToPlayerSize && (t5 ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t5);
          } }, { key: "autoLevelCapping", get: function() {
            return this._autoLevelCapping;
          }, set: function(e5) {
            this._autoLevelCapping !== e5 && (h2.logger.log("set autoLevelCapping:" + e5), this._autoLevelCapping = e5);
          } }, { key: "bandwidthEstimate", get: function() {
            var e5 = this.abrController.bwEstimator;
            return e5 ? e5.getEstimate() : NaN;
          } }, { key: "autoLevelEnabled", get: function() {
            return -1 === this.levelController.manualLevel;
          } }, { key: "manualLevel", get: function() {
            return this.levelController.manualLevel;
          } }, { key: "minAutoLevel", get: function() {
            var e5 = this.levels, t5 = this.config.minAutoBitrate;
            if (!e5)
              return 0;
            for (var r5 = e5.length, i4 = 0; i4 < r5; i4++)
              if (e5[i4].maxBitrate >= t5)
                return i4;
            return 0;
          } }, { key: "maxAutoLevel", get: function() {
            var e5 = this.levels, t5 = this.autoLevelCapping;
            return -1 === t5 && e5 && e5.length ? e5.length - 1 : t5;
          } }, { key: "nextAutoLevel", get: function() {
            return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);
          }, set: function(e5) {
            this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, e5);
          } }, { key: "playingDate", get: function() {
            return this.streamController.currentProgramDateTime;
          } }, { key: "mainForwardBufferInfo", get: function() {
            return this.streamController.getMainFwdBufferInfo();
          } }, { key: "audioTracks", get: function() {
            var e5 = this.audioTrackController;
            return e5 ? e5.audioTracks : [];
          } }, { key: "audioTrack", get: function() {
            var e5 = this.audioTrackController;
            return e5 ? e5.audioTrack : -1;
          }, set: function(e5) {
            var t5 = this.audioTrackController;
            t5 && (t5.audioTrack = e5);
          } }, { key: "subtitleTracks", get: function() {
            var e5 = this.subtitleTrackController;
            return e5 ? e5.subtitleTracks : [];
          } }, { key: "subtitleTrack", get: function() {
            var e5 = this.subtitleTrackController;
            return e5 ? e5.subtitleTrack : -1;
          }, set: function(e5) {
            var t5 = this.subtitleTrackController;
            t5 && (t5.subtitleTrack = e5);
          } }, { key: "media", get: function() {
            return this._media;
          } }, { key: "subtitleDisplay", get: function() {
            var e5 = this.subtitleTrackController;
            return !!e5 && e5.subtitleDisplay;
          }, set: function(e5) {
            var t5 = this.subtitleTrackController;
            t5 && (t5.subtitleDisplay = e5);
          } }, { key: "lowLatencyMode", get: function() {
            return this.config.lowLatencyMode;
          }, set: function(e5) {
            this.config.lowLatencyMode = e5;
          } }, { key: "liveSyncPosition", get: function() {
            return this.latencyController.liveSyncPosition;
          } }, { key: "latency", get: function() {
            return this.latencyController.latency;
          } }, { key: "maxLatency", get: function() {
            return this.latencyController.maxLatency;
          } }, { key: "targetLatency", get: function() {
            return this.latencyController.targetLatency;
          } }, { key: "drift", get: function() {
            return this.latencyController.drift;
          } }, { key: "forceStartLoad", get: function() {
            return this.streamController.forceStartLoad;
          } }]) && m2(t4.prototype, r4), y3 && m2(t4, y3), Object.defineProperty(t4, "prototype", { writable: false }), e4;
        }();
        y2.defaultConfig = void 0;
      }
    ), "./src/is-supported.ts": (
      /*!*****************************!*\
          !*** ./src/is-supported.ts ***!
          \*****************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { changeTypeSupported: () => s2, isSupported: () => a2 });
        var i3 = r3(
          /*! ./utils/mediasource-helper */
          "./src/utils/mediasource-helper.ts"
        );
        function n2() {
          return self.SourceBuffer || self.WebKitSourceBuffer;
        }
        function a2() {
          var e4 = (0, i3.getMediaSource)();
          if (!e4)
            return false;
          var t4 = n2(), r4 = e4 && "function" == typeof e4.isTypeSupported && e4.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'), a3 = !t4 || t4.prototype && "function" == typeof t4.prototype.appendBuffer && "function" == typeof t4.prototype.remove;
          return !!r4 && !!a3;
        }
        function s2() {
          var e4, t4 = n2();
          return "function" == typeof (null == t4 || null === (e4 = t4.prototype) || void 0 === e4 ? void 0 : e4.changeType);
        }
      }
    ), "./src/loader/date-range.ts": (
      /*!**********************************!*\
          !*** ./src/loader/date-range.ts ***!
          \**********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { DateRange: () => u2, DateRangeAttribute: () => i3 });
        var i3, n2 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), a2 = r3(
          /*! ../utils/attr-list */
          "./src/utils/attr-list.ts"
        ), s2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        );
        function o2() {
          return o2 = Object.assign ? Object.assign.bind() : function(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var r4 = arguments[t4];
              for (var i4 in r4)
                Object.prototype.hasOwnProperty.call(r4, i4) && (e4[i4] = r4[i4]);
            }
            return e4;
          }, o2.apply(this, arguments);
        }
        function l2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        !function(e4) {
          e4.ID = "ID", e4.CLASS = "CLASS", e4.START_DATE = "START-DATE", e4.DURATION = "DURATION", e4.END_DATE = "END-DATE", e4.END_ON_NEXT = "END-ON-NEXT", e4.PLANNED_DURATION = "PLANNED-DURATION", e4.SCTE35_OUT = "SCTE35-OUT", e4.SCTE35_IN = "SCTE35-IN";
        }(i3 || (i3 = {}));
        var u2 = function() {
          function e4(e5, t5) {
            if (this.attr = void 0, this._startDate = void 0, this._endDate = void 0, this._badValueForSameId = void 0, t5) {
              var r5 = t5.attr;
              for (var l3 in r5)
                if (Object.prototype.hasOwnProperty.call(e5, l3) && e5[l3] !== r5[l3]) {
                  s2.logger.warn('DATERANGE tag attribute: "' + l3 + '" does not match for tags with ID: "' + e5.ID + '"'), this._badValueForSameId = l3;
                  break;
                }
              e5 = o2(new a2.AttrList({}), r5, e5);
            }
            if (this.attr = e5, this._startDate = new Date(e5[i3.START_DATE]), i3.END_DATE in this.attr) {
              var u4 = new Date(this.attr[i3.END_DATE]);
              (0, n2.isFiniteNumber)(u4.getTime()) && (this._endDate = u4);
            }
          }
          var t4, r4, u3;
          return t4 = e4, (r4 = [{ key: "id", get: function() {
            return this.attr.ID;
          } }, { key: "class", get: function() {
            return this.attr.CLASS;
          } }, { key: "startDate", get: function() {
            return this._startDate;
          } }, { key: "endDate", get: function() {
            if (this._endDate)
              return this._endDate;
            var e5 = this.duration;
            return null !== e5 ? new Date(this._startDate.getTime() + 1e3 * e5) : null;
          } }, { key: "duration", get: function() {
            if (i3.DURATION in this.attr) {
              var e5 = this.attr.decimalFloatingPoint(i3.DURATION);
              if ((0, n2.isFiniteNumber)(e5))
                return e5;
            } else if (this._endDate)
              return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
            return null;
          } }, { key: "plannedDuration", get: function() {
            return i3.PLANNED_DURATION in this.attr ? this.attr.decimalFloatingPoint(i3.PLANNED_DURATION) : null;
          } }, { key: "endOnNext", get: function() {
            return this.attr.bool(i3.END_ON_NEXT);
          } }, { key: "isValid", get: function() {
            return !!this.id && !this._badValueForSameId && (0, n2.isFiniteNumber)(this.startDate.getTime()) && (null === this.duration || this.duration >= 0) && (!this.endOnNext || !!this.class);
          } }]) && l2(t4.prototype, r4), u3 && l2(t4, u3), Object.defineProperty(t4, "prototype", { writable: false }), e4;
        }();
      }
    ), "./src/loader/fragment-loader.ts": (
      /*!***************************************!*\
          !*** ./src/loader/fragment-loader.ts ***!
          \***************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { LoadError: () => f2, default: () => d2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        );
        function a2(e4) {
          var t4 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
          return a2 = function(e5) {
            if (null === e5 || (r4 = e5, -1 === Function.toString.call(r4).indexOf("[native code]")))
              return e5;
            var r4;
            if ("function" != typeof e5)
              throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== t4) {
              if (t4.has(e5))
                return t4.get(e5);
              t4.set(e5, i4);
            }
            function i4() {
              return s2(e5, arguments, u2(this).constructor);
            }
            return i4.prototype = Object.create(e5.prototype, { constructor: { value: i4, enumerable: false, writable: true, configurable: true } }), l2(i4, e5);
          }, a2(e4);
        }
        function s2(e4, t4, r4) {
          return s2 = o2() ? Reflect.construct.bind() : function(e5, t5, r5) {
            var i4 = [null];
            i4.push.apply(i4, t5);
            var n3 = new (Function.bind.apply(e5, i4))();
            return r5 && l2(n3, r5.prototype), n3;
          }, s2.apply(null, arguments);
        }
        function o2() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (e4) {
            return false;
          }
        }
        function l2(e4, t4) {
          return l2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
            return e5.__proto__ = t5, e5;
          }, l2(e4, t4);
        }
        function u2(e4) {
          return u2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e5) {
            return e5.__proto__ || Object.getPrototypeOf(e5);
          }, u2(e4);
        }
        var c2 = Math.pow(2, 17), d2 = function() {
          function e4(e5) {
            this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e5;
          }
          var t4 = e4.prototype;
          return t4.destroy = function() {
            this.loader && (this.loader.destroy(), this.loader = null);
          }, t4.abort = function() {
            this.loader && this.loader.abort();
          }, t4.load = function(e5, t5) {
            var r4 = this, i4 = e5.url;
            if (!i4)
              return Promise.reject(new f2({ type: n2.ErrorTypes.NETWORK_ERROR, details: n2.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: e5, networkDetails: null }, "Fragment does not have a " + (i4 ? "part list" : "url")));
            this.abort();
            var a3 = this.config, s3 = a3.fLoader, o3 = a3.loader;
            return new Promise(function(i5, l3) {
              r4.loader && r4.loader.destroy();
              var u3 = r4.loader = e5.loader = s3 ? new s3(a3) : new o3(a3), d3 = h2(e5), p2 = { timeout: a3.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: a3.fragLoadingMaxRetryTimeout, highWaterMark: "initSegment" === e5.sn ? 1 / 0 : c2 };
              e5.stats = u3.stats, u3.load(d3, p2, { onSuccess: function(t6, n3, a4, s4) {
                r4.resetLoader(e5, u3), i5({ frag: e5, part: null, payload: t6.data, networkDetails: s4 });
              }, onError: function(t6, i6, a4) {
                r4.resetLoader(e5, u3), l3(new f2({ type: n2.ErrorTypes.NETWORK_ERROR, details: n2.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: e5, response: t6, networkDetails: a4 }));
              }, onAbort: function(t6, i6, a4) {
                r4.resetLoader(e5, u3), l3(new f2({ type: n2.ErrorTypes.NETWORK_ERROR, details: n2.ErrorDetails.INTERNAL_ABORTED, fatal: false, frag: e5, networkDetails: a4 }));
              }, onTimeout: function(t6, i6, a4) {
                r4.resetLoader(e5, u3), l3(new f2({ type: n2.ErrorTypes.NETWORK_ERROR, details: n2.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: e5, networkDetails: a4 }));
              }, onProgress: function(r5, i6, n3, a4) {
                t5 && t5({ frag: e5, part: null, payload: n3, networkDetails: a4 });
              } });
            });
          }, t4.loadPart = function(e5, t5, r4) {
            var i4 = this;
            this.abort();
            var a3 = this.config, s3 = a3.fLoader, o3 = a3.loader;
            return new Promise(function(l3, u3) {
              i4.loader && i4.loader.destroy();
              var d3 = i4.loader = e5.loader = s3 ? new s3(a3) : new o3(a3), p2 = h2(e5, t5), g2 = { timeout: a3.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: a3.fragLoadingMaxRetryTimeout, highWaterMark: c2 };
              t5.stats = d3.stats, d3.load(p2, g2, { onSuccess: function(n3, a4, s4, o4) {
                i4.resetLoader(e5, d3), i4.updateStatsFromPart(e5, t5);
                var u4 = { frag: e5, part: t5, payload: n3.data, networkDetails: o4 };
                r4(u4), l3(u4);
              }, onError: function(r5, a4, s4) {
                i4.resetLoader(e5, d3), u3(new f2({ type: n2.ErrorTypes.NETWORK_ERROR, details: n2.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: e5, part: t5, response: r5, networkDetails: s4 }));
              }, onAbort: function(r5, a4, s4) {
                e5.stats.aborted = t5.stats.aborted, i4.resetLoader(e5, d3), u3(new f2({ type: n2.ErrorTypes.NETWORK_ERROR, details: n2.ErrorDetails.INTERNAL_ABORTED, fatal: false, frag: e5, part: t5, networkDetails: s4 }));
              }, onTimeout: function(r5, a4, s4) {
                i4.resetLoader(e5, d3), u3(new f2({ type: n2.ErrorTypes.NETWORK_ERROR, details: n2.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: e5, part: t5, networkDetails: s4 }));
              } });
            });
          }, t4.updateStatsFromPart = function(e5, t5) {
            var r4 = e5.stats, i4 = t5.stats, n3 = i4.total;
            if (r4.loaded += i4.loaded, n3) {
              var a3 = Math.round(e5.duration / t5.duration), s3 = Math.min(Math.round(r4.loaded / n3), a3), o3 = (a3 - s3) * Math.round(r4.loaded / s3);
              r4.total = r4.loaded + o3;
            } else
              r4.total = Math.max(r4.loaded, r4.total);
            var l3 = r4.loading, u3 = i4.loading;
            l3.start ? l3.first += u3.first - u3.start : (l3.start = u3.start, l3.first = u3.first), l3.end = u3.end;
          }, t4.resetLoader = function(e5, t5) {
            e5.loader = null, this.loader === t5 && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t5.destroy();
          }, e4;
        }();
        function h2(e4, t4) {
          void 0 === t4 && (t4 = null);
          var r4 = t4 || e4, n3 = { frag: e4, part: t4, responseType: "arraybuffer", url: r4.url, headers: {}, rangeStart: 0, rangeEnd: 0 }, a3 = r4.byteRangeStartOffset, s3 = r4.byteRangeEndOffset;
          return (0, i3.isFiniteNumber)(a3) && (0, i3.isFiniteNumber)(s3) && (n3.rangeStart = a3, n3.rangeEnd = s3), n3;
        }
        var f2 = function(e4) {
          var t4, r4;
          function i4(t5) {
            for (var r5, i5 = arguments.length, n3 = new Array(i5 > 1 ? i5 - 1 : 0), a3 = 1; a3 < i5; a3++)
              n3[a3 - 1] = arguments[a3];
            return (r5 = e4.call.apply(e4, [this].concat(n3)) || this).data = void 0, r5.data = t5, r5;
          }
          return r4 = e4, (t4 = i4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, l2(t4, r4), i4;
        }(a2(Error));
      }
    ), "./src/loader/fragment.ts": (
      /*!********************************!*\
          !*** ./src/loader/fragment.ts ***!
          \********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { BaseSegment: () => f2, ElementaryStreamTypes: () => i3, Fragment: () => p2, Part: () => g2 });
        var i3, n2 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), a2 = r3(
          /*! url-toolkit */
          "./node_modules/url-toolkit/src/url-toolkit.js"
        ), s2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), o2 = r3(
          /*! ./level-key */
          "./src/loader/level-key.ts"
        ), l2 = r3(
          /*! ./load-stats */
          "./src/loader/load-stats.ts"
        );
        function u2(e4, t4) {
          e4.prototype = Object.create(t4.prototype), e4.prototype.constructor = e4, c2(e4, t4);
        }
        function c2(e4, t4) {
          return c2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
            return e5.__proto__ = t5, e5;
          }, c2(e4, t4);
        }
        function d2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        function h2(e4, t4, r4) {
          return t4 && d2(e4.prototype, t4), r4 && d2(e4, r4), Object.defineProperty(e4, "prototype", { writable: false }), e4;
        }
        !function(e4) {
          e4.AUDIO = "audio", e4.VIDEO = "video", e4.AUDIOVIDEO = "audiovideo";
        }(i3 || (i3 = {}));
        var f2 = function() {
          function e4(e5) {
            var t4;
            this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = ((t4 = {})[i3.AUDIO] = null, t4[i3.VIDEO] = null, t4[i3.AUDIOVIDEO] = null, t4), this.baseurl = e5;
          }
          return e4.prototype.setByteRange = function(e5, t4) {
            var r4 = e5.split("@", 2), i4 = [];
            1 === r4.length ? i4[0] = t4 ? t4.byteRangeEndOffset : 0 : i4[0] = parseInt(r4[1]), i4[1] = parseInt(r4[0]) + i4[0], this._byteRange = i4;
          }, h2(e4, [{ key: "byteRange", get: function() {
            return this._byteRange ? this._byteRange : [];
          } }, { key: "byteRangeStartOffset", get: function() {
            return this.byteRange[0];
          } }, { key: "byteRangeEndOffset", get: function() {
            return this.byteRange[1];
          } }, { key: "url", get: function() {
            return !this._url && this.baseurl && this.relurl && (this._url = (0, a2.buildAbsoluteURL)(this.baseurl, this.relurl, { alwaysNormalize: true })), this._url || "";
          }, set: function(e5) {
            this._url = e5;
          } }]), e4;
        }(), p2 = function(e4) {
          function t4(t5, r5) {
            var i4;
            return (i4 = e4.call(this, r5) || this)._decryptdata = null, i4.rawProgramDateTime = null, i4.programDateTime = null, i4.tagList = [], i4.duration = 0, i4.sn = 0, i4.levelkey = void 0, i4.type = void 0, i4.loader = null, i4.level = -1, i4.cc = 0, i4.startPTS = void 0, i4.endPTS = void 0, i4.appendedPTS = void 0, i4.startDTS = void 0, i4.endDTS = void 0, i4.start = 0, i4.deltaPTS = void 0, i4.maxStartPTS = void 0, i4.minEndPTS = void 0, i4.stats = new l2.LoadStats(), i4.urlId = 0, i4.data = void 0, i4.bitrateTest = false, i4.title = null, i4.initSegment = null, i4.type = t5, i4;
          }
          u2(t4, e4);
          var r4 = t4.prototype;
          return r4.createInitializationVector = function(e5) {
            for (var t5 = new Uint8Array(16), r5 = 12; r5 < 16; r5++)
              t5[r5] = e5 >> 8 * (15 - r5) & 255;
            return t5;
          }, r4.setDecryptDataFromLevelKey = function(e5, t5) {
            var r5 = e5;
            return "AES-128" === (null == e5 ? void 0 : e5.method) && e5.uri && !e5.iv && ((r5 = o2.LevelKey.fromURI(e5.uri)).method = e5.method, r5.iv = this.createInitializationVector(t5), r5.keyFormat = "identity"), r5;
          }, r4.setElementaryStreamInfo = function(e5, t5, r5, i4, n3, a3) {
            void 0 === a3 && (a3 = false);
            var s3 = this.elementaryStreams, o3 = s3[e5];
            o3 ? (o3.startPTS = Math.min(o3.startPTS, t5), o3.endPTS = Math.max(o3.endPTS, r5), o3.startDTS = Math.min(o3.startDTS, i4), o3.endDTS = Math.max(o3.endDTS, n3)) : s3[e5] = { startPTS: t5, endPTS: r5, startDTS: i4, endDTS: n3, partial: a3 };
          }, r4.clearElementaryStreamInfo = function() {
            var e5 = this.elementaryStreams;
            e5[i3.AUDIO] = null, e5[i3.VIDEO] = null, e5[i3.AUDIOVIDEO] = null;
          }, h2(t4, [{ key: "decryptdata", get: function() {
            if (!this.levelkey && !this._decryptdata)
              return null;
            if (!this._decryptdata && this.levelkey) {
              var e5 = this.sn;
              "number" != typeof e5 && (this.levelkey && "AES-128" === this.levelkey.method && !this.levelkey.iv && s2.logger.warn('missing IV for initialization segment with method="' + this.levelkey.method + '" - compliance issue'), e5 = 0), this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, e5);
            }
            return this._decryptdata;
          } }, { key: "end", get: function() {
            return this.start + this.duration;
          } }, { key: "endProgramDateTime", get: function() {
            if (null === this.programDateTime)
              return null;
            if (!(0, n2.isFiniteNumber)(this.programDateTime))
              return null;
            var e5 = (0, n2.isFiniteNumber)(this.duration) ? this.duration : 0;
            return this.programDateTime + 1e3 * e5;
          } }, { key: "encrypted", get: function() {
            var e5;
            return !(null === (e5 = this.decryptdata) || void 0 === e5 || !e5.keyFormat || !this.decryptdata.uri);
          } }]), t4;
        }(f2), g2 = function(e4) {
          function t4(t5, r4, i4, n3, a3) {
            var s3;
            (s3 = e4.call(this, i4) || this).fragOffset = 0, s3.duration = 0, s3.gap = false, s3.independent = false, s3.relurl = void 0, s3.fragment = void 0, s3.index = void 0, s3.stats = new l2.LoadStats(), s3.duration = t5.decimalFloatingPoint("DURATION"), s3.gap = t5.bool("GAP"), s3.independent = t5.bool("INDEPENDENT"), s3.relurl = t5.enumeratedString("URI"), s3.fragment = r4, s3.index = n3;
            var o3 = t5.enumeratedString("BYTERANGE");
            return o3 && s3.setByteRange(o3, a3), a3 && (s3.fragOffset = a3.fragOffset + a3.duration), s3;
          }
          return u2(t4, e4), h2(t4, [{ key: "start", get: function() {
            return this.fragment.start + this.fragOffset;
          } }, { key: "end", get: function() {
            return this.start + this.duration;
          } }, { key: "loaded", get: function() {
            var e5 = this.elementaryStreams;
            return !!(e5.audio || e5.video || e5.audiovideo);
          } }]), t4;
        }(f2);
      }
    ), "./src/loader/key-loader.ts": (
      /*!**********************************!*\
          !*** ./src/loader/key-loader.ts ***!
          \**********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => s2 });
        var i3 = r3(
          /*! ../events */
          "./src/events.ts"
        ), n2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), a2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), s2 = function() {
          function e4(e5) {
            this.hls = void 0, this.loaders = {}, this.decryptkey = null, this.decrypturl = null, this.hls = e5, this.registerListeners();
          }
          var t4 = e4.prototype;
          return t4.startLoad = function(e5) {
          }, t4.stopLoad = function() {
            this.destroyInternalLoaders();
          }, t4.registerListeners = function() {
            this.hls.on(i3.Events.KEY_LOADING, this.onKeyLoading, this);
          }, t4.unregisterListeners = function() {
            this.hls.off(i3.Events.KEY_LOADING, this.onKeyLoading);
          }, t4.destroyInternalLoaders = function() {
            for (var e5 in this.loaders) {
              var t5 = this.loaders[e5];
              t5 && t5.destroy();
            }
            this.loaders = {};
          }, t4.destroy = function() {
            this.unregisterListeners(), this.destroyInternalLoaders();
          }, t4.onKeyLoading = function(e5, t5) {
            var r4 = t5.frag, n3 = r4.type, s3 = this.loaders[n3];
            if (r4.decryptdata) {
              var o2 = r4.decryptdata.uri;
              if (o2 !== this.decrypturl || null === this.decryptkey) {
                var l2 = this.hls.config;
                if (s3 && (a2.logger.warn("abort previous key loader for type:" + n3), s3.abort()), !o2)
                  return void a2.logger.warn("key uri is falsy");
                var u2 = l2.loader, c2 = r4.loader = this.loaders[n3] = new u2(l2);
                this.decrypturl = o2, this.decryptkey = null;
                var d2 = { url: o2, frag: r4, responseType: "arraybuffer" }, h2 = { timeout: l2.fragLoadingTimeOut, maxRetry: 0, retryDelay: l2.fragLoadingRetryDelay, maxRetryDelay: l2.fragLoadingMaxRetryTimeout, highWaterMark: 0 }, f2 = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
                c2.load(d2, h2, f2);
              } else
                this.decryptkey && (r4.decryptdata.key = this.decryptkey, this.hls.trigger(i3.Events.KEY_LOADED, { frag: r4 }));
            } else
              a2.logger.warn("Missing decryption data on fragment in onKeyLoading");
          }, t4.loadsuccess = function(e5, t5, r4) {
            var n3 = r4.frag;
            n3.decryptdata ? (this.decryptkey = n3.decryptdata.key = new Uint8Array(e5.data), n3.loader = null, delete this.loaders[n3.type], this.hls.trigger(i3.Events.KEY_LOADED, { frag: n3 })) : a2.logger.error("after key load, decryptdata unset");
          }, t4.loaderror = function(e5, t5) {
            var r4 = t5.frag, a3 = r4.loader;
            a3 && a3.abort(), delete this.loaders[r4.type], this.hls.trigger(i3.Events.ERROR, { type: n2.ErrorTypes.NETWORK_ERROR, details: n2.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: r4, response: e5 });
          }, t4.loadtimeout = function(e5, t5) {
            var r4 = t5.frag, a3 = r4.loader;
            a3 && a3.abort(), delete this.loaders[r4.type], this.hls.trigger(i3.Events.ERROR, { type: n2.ErrorTypes.NETWORK_ERROR, details: n2.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: r4 });
          }, e4;
        }();
      }
    ), "./src/loader/level-details.ts": (
      /*!*************************************!*\
          !*** ./src/loader/level-details.ts ***!
          \*************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { LevelDetails: () => a2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        );
        function n2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        var a2 = function() {
          function e4(e5) {
            this.PTSKnown = false, this.alignedSliding = false, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.live = true, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = true, this.advanced = true, this.availabilityDelay = void 0, this.misses = 0, this.needSidxRanges = false, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = false, this.canSkipUntil = 0, this.canSkipDateRanges = false, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.fragments = [], this.dateRanges = {}, this.url = e5;
          }
          var t4, r4, a3;
          return e4.prototype.reloaded = function(e5) {
            if (!e5)
              return this.advanced = true, void (this.updated = true);
            var t5 = this.lastPartSn - e5.lastPartSn, r5 = this.lastPartIndex - e5.lastPartIndex;
            this.updated = this.endSN !== e5.endSN || !!r5 || !!t5, this.advanced = this.endSN > e5.endSN || t5 > 0 || 0 === t5 && r5 > 0, this.updated || this.advanced ? this.misses = Math.floor(0.6 * e5.misses) : this.misses = e5.misses + 1, this.availabilityDelay = e5.availabilityDelay;
          }, t4 = e4, (r4 = [{ key: "hasProgramDateTime", get: function() {
            return !!this.fragments.length && (0, i3.isFiniteNumber)(this.fragments[this.fragments.length - 1].programDateTime);
          } }, { key: "levelTargetDuration", get: function() {
            return this.averagetargetduration || this.targetduration || 10;
          } }, { key: "drift", get: function() {
            var e5 = this.driftEndTime - this.driftStartTime;
            return e5 > 0 ? 1e3 * (this.driftEnd - this.driftStart) / e5 : 1;
          } }, { key: "edge", get: function() {
            return this.partEnd || this.fragmentEnd;
          } }, { key: "partEnd", get: function() {
            var e5;
            return null !== (e5 = this.partList) && void 0 !== e5 && e5.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd;
          } }, { key: "fragmentEnd", get: function() {
            var e5;
            return null !== (e5 = this.fragments) && void 0 !== e5 && e5.length ? this.fragments[this.fragments.length - 1].end : 0;
          } }, { key: "age", get: function() {
            return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0;
          } }, { key: "lastPartIndex", get: function() {
            var e5;
            return null !== (e5 = this.partList) && void 0 !== e5 && e5.length ? this.partList[this.partList.length - 1].index : -1;
          } }, { key: "lastPartSn", get: function() {
            var e5;
            return null !== (e5 = this.partList) && void 0 !== e5 && e5.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN;
          } }]) && n2(t4.prototype, r4), a3 && n2(t4, a3), Object.defineProperty(t4, "prototype", { writable: false }), e4;
        }();
      }
    ), "./src/loader/level-key.ts": (
      /*!*********************************!*\
          !*** ./src/loader/level-key.ts ***!
          \*********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { LevelKey: () => a2 });
        var i3 = r3(
          /*! url-toolkit */
          "./node_modules/url-toolkit/src/url-toolkit.js"
        );
        function n2(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        var a2 = function() {
          function e4(e5, t5) {
            this._uri = null, this.method = null, this.keyFormat = null, this.keyFormatVersions = null, this.keyID = null, this.key = null, this.iv = null, this._uri = t5 ? (0, i3.buildAbsoluteURL)(e5, t5, { alwaysNormalize: true }) : e5;
          }
          var t4, r4, a3;
          return e4.fromURL = function(t5, r5) {
            return new e4(t5, r5);
          }, e4.fromURI = function(t5) {
            return new e4(t5);
          }, t4 = e4, (r4 = [{ key: "uri", get: function() {
            return this._uri;
          } }]) && n2(t4.prototype, r4), a3 && n2(t4, a3), Object.defineProperty(t4, "prototype", { writable: false }), e4;
        }();
      }
    ), "./src/loader/load-stats.ts": (
      /*!**********************************!*\
          !*** ./src/loader/load-stats.ts ***!
          \**********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { LoadStats: () => i3 });
        var i3 = function() {
          this.aborted = false, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = { start: 0, first: 0, end: 0 }, this.parsing = { start: 0, end: 0 }, this.buffering = { start: 0, first: 0, end: 0 };
        };
      }
    ), "./src/loader/m3u8-parser.ts": (
      /*!***********************************!*\
          !*** ./src/loader/m3u8-parser.ts ***!
          \***********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => m2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! url-toolkit */
          "./node_modules/url-toolkit/src/url-toolkit.js"
        ), a2 = r3(
          /*! ./date-range */
          "./src/loader/date-range.ts"
        ), s2 = r3(
          /*! ./fragment */
          "./src/loader/fragment.ts"
        ), o2 = r3(
          /*! ./level-details */
          "./src/loader/level-details.ts"
        ), l2 = r3(
          /*! ./level-key */
          "./src/loader/level-key.ts"
        ), u2 = r3(
          /*! ../utils/attr-list */
          "./src/utils/attr-list.ts"
        ), c2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), d2 = r3(
          /*! ../utils/codecs */
          "./src/utils/codecs.ts"
        ), h2 = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-SESSION-DATA:([^\r\n]*)[\r\n]+/g, f2 = /#EXT-X-MEDIA:(.*)/g, p2 = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"), "g"), g2 = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|"0.5.0"): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|")), v2 = /\.(mp4|m4s|m4v|m4a)$/i, m2 = function() {
          function e4() {
          }
          return e4.findGroup = function(e5, t4) {
            for (var r4 = 0; r4 < e5.length; r4++) {
              var i4 = e5[r4];
              if (i4.id === t4)
                return i4;
            }
          }, e4.convertAVC1ToAVCOTI = function(e5) {
            var t4 = e5.split(".");
            if (t4.length > 2) {
              var r4 = t4.shift() + ".";
              return r4 += parseInt(t4.shift()).toString(16), r4 += ("000" + parseInt(t4.shift()).toString(16)).slice(-4);
            }
            return e5;
          }, e4.resolve = function(e5, t4) {
            return n2.buildAbsoluteURL(t4, e5, { alwaysNormalize: true });
          }, e4.parseMasterPlaylist = function(t4, r4) {
            var i4, n3 = [], a3 = [], s3 = {}, o3 = false;
            for (h2.lastIndex = 0; null != (i4 = h2.exec(t4)); )
              if (i4[1]) {
                var l3, c3 = new u2.AttrList(i4[1]), d3 = { attrs: c3, bitrate: c3.decimalInteger("AVERAGE-BANDWIDTH") || c3.decimalInteger("BANDWIDTH"), name: c3.NAME, url: e4.resolve(i4[2], r4) }, f3 = c3.decimalResolution("RESOLUTION");
                f3 && (d3.width = f3.width, d3.height = f3.height), y2((c3.CODECS || "").split(/[ ,]+/).filter(function(e5) {
                  return e5;
                }), d3), d3.videoCodec && -1 !== d3.videoCodec.indexOf("avc1") && (d3.videoCodec = e4.convertAVC1ToAVCOTI(d3.videoCodec)), null !== (l3 = d3.unknownCodecs) && void 0 !== l3 && l3.length || a3.push(d3), n3.push(d3);
              } else if (i4[3]) {
                var p3 = new u2.AttrList(i4[3]);
                p3["DATA-ID"] && (o3 = true, s3[p3["DATA-ID"]] = p3);
              }
            return { levels: a3.length > 0 && a3.length < n3.length ? a3 : n3, sessionData: o3 ? s3 : null };
          }, e4.parseMasterPlaylistMedia = function(t4, r4, i4, n3) {
            var a3;
            void 0 === n3 && (n3 = []);
            var s3 = [], o3 = 0;
            for (f2.lastIndex = 0; null !== (a3 = f2.exec(t4)); ) {
              var l3 = new u2.AttrList(a3[1]);
              if (l3.TYPE === i4) {
                var c3 = { attrs: l3, bitrate: 0, id: o3++, groupId: l3["GROUP-ID"], instreamId: l3["INSTREAM-ID"], name: l3.NAME || l3.LANGUAGE || "", type: i4, default: l3.bool("DEFAULT"), autoselect: l3.bool("AUTOSELECT"), forced: l3.bool("FORCED"), lang: l3.LANGUAGE, url: l3.URI ? e4.resolve(l3.URI, r4) : "" };
                if (n3.length) {
                  var d3 = e4.findGroup(n3, c3.groupId) || n3[0];
                  A2(c3, d3, "audioCodec"), A2(c3, d3, "textCodec");
                }
                s3.push(c3);
              }
            }
            return s3;
          }, e4.parseLevelPlaylist = function(e5, t4, r4, d3, h3) {
            var f3, m3, y3, A3 = new o2.LevelDetails(t4), b2 = A3.fragments, k2 = null, S2 = 0, _2 = 0, C2 = 0, L2 = 0, D2 = null, R2 = new s2.Fragment(d3, t4), I2 = -1, O2 = false;
            for (p2.lastIndex = 0, A3.m3u8 = e5; null !== (f3 = p2.exec(e5)); ) {
              O2 && (O2 = false, (R2 = new s2.Fragment(d3, t4)).start = C2, R2.sn = S2, R2.cc = L2, R2.level = r4, k2 && (R2.initSegment = k2, R2.rawProgramDateTime = k2.rawProgramDateTime, k2.rawProgramDateTime = null));
              var w2 = f3[1];
              if (w2) {
                R2.duration = parseFloat(w2);
                var P2 = (" " + f3[2]).slice(1);
                R2.title = P2 || null, R2.tagList.push(P2 ? ["INF", w2, P2] : ["INF", w2]);
              } else if (f3[3])
                (0, i3.isFiniteNumber)(R2.duration) && (R2.start = C2, y3 && (R2.levelkey = y3), R2.sn = S2, R2.level = r4, R2.cc = L2, R2.urlId = h3, b2.push(R2), R2.relurl = (" " + f3[3]).slice(1), E2(R2, D2), D2 = R2, C2 += R2.duration, S2++, _2 = 0, O2 = true);
              else if (f3[4]) {
                var x2 = (" " + f3[4]).slice(1);
                D2 ? R2.setByteRange(x2, D2) : R2.setByteRange(x2);
              } else if (f3[5])
                R2.rawProgramDateTime = (" " + f3[5]).slice(1), R2.tagList.push(["PROGRAM-DATE-TIME", R2.rawProgramDateTime]), -1 === I2 && (I2 = b2.length);
              else {
                if (!(f3 = f3[0].match(g2))) {
                  c2.logger.warn("No matches on slow regex match for level playlist!");
                  continue;
                }
                for (m3 = 1; m3 < f3.length && void 0 === f3[m3]; m3++)
                  ;
                var N2 = (" " + f3[m3]).slice(1), F2 = (" " + f3[m3 + 1]).slice(1), M2 = f3[m3 + 2] ? (" " + f3[m3 + 2]).slice(1) : "";
                switch (N2) {
                  case "PLAYLIST-TYPE":
                    A3.type = F2.toUpperCase();
                    break;
                  case "MEDIA-SEQUENCE":
                    S2 = A3.startSN = parseInt(F2);
                    break;
                  case "SKIP":
                    var B2 = new u2.AttrList(F2), U2 = B2.decimalInteger("SKIPPED-SEGMENTS");
                    if ((0, i3.isFiniteNumber)(U2)) {
                      A3.skippedSegments = U2;
                      for (var G2 = U2; G2--; )
                        b2.unshift(null);
                      S2 += U2;
                    }
                    var V2 = B2.enumeratedString("RECENTLY-REMOVED-DATERANGES");
                    V2 && (A3.recentlyRemovedDateranges = V2.split("	"));
                    break;
                  case "TARGETDURATION":
                    A3.targetduration = parseFloat(F2);
                    break;
                  case '"0.5.0"':
                    A3.version = parseInt(F2);
                    break;
                  case "EXTM3U":
                    break;
                  case "ENDLIST":
                    A3.live = false;
                    break;
                  case "#":
                    (F2 || M2) && R2.tagList.push(M2 ? [F2, M2] : [F2]);
                    break;
                  case "DISCONTINUITY":
                    L2++, R2.tagList.push(["DIS"]);
                    break;
                  case "GAP":
                    R2.tagList.push([N2]);
                    break;
                  case "BITRATE":
                    R2.tagList.push([N2, F2]);
                    break;
                  case "DATERANGE":
                    var K2 = new u2.AttrList(F2), j2 = new a2.DateRange(K2, A3.dateRanges[K2.ID]);
                    j2.isValid || A3.skippedSegments ? A3.dateRanges[j2.id] = j2 : c2.logger.warn('Ignoring invalid DATERANGE tag: "' + F2 + '"'), R2.tagList.push(["EXT-X-DATERANGE", F2]);
                    break;
                  case "DISCONTINUITY-SEQUENCE":
                    L2 = parseInt(F2);
                    break;
                  case "KEY":
                    var H2, Y2 = new u2.AttrList(F2), W2 = Y2.enumeratedString("METHOD"), $2 = Y2.URI, z2 = Y2.hexadecimalInteger("IV"), q2 = Y2.enumeratedString("KEYFORMATVERSIONS"), X2 = Y2.enumeratedString("KEYID"), Z2 = null != (H2 = Y2.enumeratedString("KEYFORMAT")) ? H2 : "identity";
                    if (["com.apple.streamingkeydelivery", "com.microsoft.playready", "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed", "com.widevine"].indexOf(Z2) > -1) {
                      c2.logger.warn("Keyformat " + Z2 + " is not supported from the manifest");
                      continue;
                    }
                    if ("identity" !== Z2)
                      continue;
                    W2 && (y3 = l2.LevelKey.fromURL(t4, $2), $2 && ["AES-128", "SAMPLE-AES", "SAMPLE-AES-CENC"].indexOf(W2) >= 0 && (y3.method = W2, y3.keyFormat = Z2, X2 && (y3.keyID = X2), q2 && (y3.keyFormatVersions = q2), y3.iv = z2));
                    break;
                  case "START":
                    var Q2 = new u2.AttrList(F2).decimalFloatingPoint("TIME-OFFSET");
                    (0, i3.isFiniteNumber)(Q2) && (A3.startTimeOffset = Q2);
                    break;
                  case "MAP":
                    var J2 = new u2.AttrList(F2);
                    if (R2.duration) {
                      var ee2 = new s2.Fragment(d3, t4);
                      T2(ee2, J2, r4, y3), k2 = ee2, R2.initSegment = k2, k2.rawProgramDateTime && !R2.rawProgramDateTime && (R2.rawProgramDateTime = k2.rawProgramDateTime);
                    } else
                      T2(R2, J2, r4, y3), k2 = R2, O2 = true;
                    break;
                  case "SERVER-CONTROL":
                    var te2 = new u2.AttrList(F2);
                    A3.canBlockReload = te2.bool("CAN-BLOCK-RELOAD"), A3.canSkipUntil = te2.optionalFloat("CAN-SKIP-UNTIL", 0), A3.canSkipDateRanges = A3.canSkipUntil > 0 && te2.bool("CAN-SKIP-DATERANGES"), A3.partHoldBack = te2.optionalFloat("PART-HOLD-BACK", 0), A3.holdBack = te2.optionalFloat("HOLD-BACK", 0);
                    break;
                  case "PART-INF":
                    var re2 = new u2.AttrList(F2);
                    A3.partTarget = re2.decimalFloatingPoint("PART-TARGET");
                    break;
                  case "PART":
                    var ie2 = A3.partList;
                    ie2 || (ie2 = A3.partList = []);
                    var ne2 = _2 > 0 ? ie2[ie2.length - 1] : void 0, ae2 = _2++, se2 = new s2.Part(new u2.AttrList(F2), R2, t4, ae2, ne2);
                    ie2.push(se2), R2.duration += se2.duration;
                    break;
                  case "PRELOAD-HINT":
                    var oe2 = new u2.AttrList(F2);
                    A3.preloadHint = oe2;
                    break;
                  case "RENDITION-REPORT":
                    var le2 = new u2.AttrList(F2);
                    A3.renditionReports = A3.renditionReports || [], A3.renditionReports.push(le2);
                    break;
                  default:
                    c2.logger.warn("line parsed but not handled: " + f3);
                }
              }
            }
            D2 && !D2.relurl ? (b2.pop(), C2 -= D2.duration, A3.partList && (A3.fragmentHint = D2)) : A3.partList && (E2(R2, D2), R2.cc = L2, A3.fragmentHint = R2);
            var ue2 = b2.length, ce2 = b2[0], de2 = b2[ue2 - 1];
            if ((C2 += A3.skippedSegments * A3.targetduration) > 0 && ue2 && de2) {
              A3.averagetargetduration = C2 / ue2;
              var he2 = de2.sn;
              A3.endSN = "initSegment" !== he2 ? he2 : 0, ce2 && (A3.startCC = ce2.cc, ce2.initSegment || A3.fragments.every(function(e6) {
                return e6.relurl && (t5 = e6.relurl, v2.test(null != (r5 = null === (i4 = n2.parseURL(t5)) || void 0 === i4 ? void 0 : i4.path) ? r5 : ""));
                var t5, r5, i4;
              }) && (c2.logger.warn("MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX"), (R2 = new s2.Fragment(d3, t4)).relurl = de2.relurl, R2.level = r4, R2.sn = "initSegment", ce2.initSegment = R2, A3.needSidxRanges = true));
            } else
              A3.endSN = 0, A3.startCC = 0;
            return A3.fragmentHint && (C2 += A3.fragmentHint.duration), A3.totalduration = C2, A3.endCC = L2, I2 > 0 && function(e6, t5) {
              for (var r5 = e6[t5], i4 = t5; i4--; ) {
                var n3 = e6[i4];
                if (!n3)
                  return;
                n3.programDateTime = r5.programDateTime - 1e3 * n3.duration, r5 = n3;
              }
            }(b2, I2), A3;
          }, e4;
        }();
        function y2(e4, t4) {
          ["video", "audio", "text"].forEach(function(r4) {
            var i4 = e4.filter(function(e5) {
              return (0, d2.isCodecType)(e5, r4);
            });
            if (i4.length) {
              var n3 = i4.filter(function(e5) {
                return 0 === e5.lastIndexOf("avc1", 0) || 0 === e5.lastIndexOf("mp4a", 0);
              });
              t4[r4 + "Codec"] = n3.length > 0 ? n3[0] : i4[0], e4 = e4.filter(function(e5) {
                return -1 === i4.indexOf(e5);
              });
            }
          }), t4.unknownCodecs = e4;
        }
        function A2(e4, t4, r4) {
          var i4 = t4[r4];
          i4 && (e4[r4] = i4);
        }
        function E2(e4, t4) {
          e4.rawProgramDateTime ? e4.programDateTime = Date.parse(e4.rawProgramDateTime) : null != t4 && t4.programDateTime && (e4.programDateTime = t4.endProgramDateTime), (0, i3.isFiniteNumber)(e4.programDateTime) || (e4.programDateTime = null, e4.rawProgramDateTime = null);
        }
        function T2(e4, t4, r4, i4) {
          e4.relurl = t4.URI, t4.BYTERANGE && e4.setByteRange(t4.BYTERANGE), e4.level = r4, e4.sn = "initSegment", i4 && (e4.levelkey = i4), e4.initSegment = null;
        }
      }
    ), "./src/loader/playlist-loader.ts": (
      /*!***************************************!*\
          !*** ./src/loader/playlist-loader.ts ***!
          \***************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => f2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), a2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), s2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), o2 = r3(
          /*! ../utils/mp4-tools */
          "./src/utils/mp4-tools.ts"
        ), l2 = r3(
          /*! ./m3u8-parser */
          "./src/loader/m3u8-parser.ts"
        ), u2 = r3(
          /*! ../types/loader */
          "./src/types/loader.ts"
        ), c2 = r3(
          /*! ../utils/attr-list */
          "./src/utils/attr-list.ts"
        );
        function d2(e4, t4) {
          var r4 = e4.url;
          return void 0 !== r4 && 0 !== r4.indexOf("data:") || (r4 = t4.url), r4;
        }
        var h2 = function() {
          function e4(e5) {
            this.hls = void 0, this.loaders = /* @__PURE__ */ Object.create(null), this.hls = e5, this.registerListeners();
          }
          var t4 = e4.prototype;
          return t4.startLoad = function(e5) {
          }, t4.stopLoad = function() {
            this.destroyInternalLoaders();
          }, t4.registerListeners = function() {
            var e5 = this.hls;
            e5.on(n2.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.on(n2.Events.LEVEL_LOADING, this.onLevelLoading, this), e5.on(n2.Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e5.on(n2.Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
          }, t4.unregisterListeners = function() {
            var e5 = this.hls;
            e5.off(n2.Events.MANIFEST_LOADING, this.onManifestLoading, this), e5.off(n2.Events.LEVEL_LOADING, this.onLevelLoading, this), e5.off(n2.Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e5.off(n2.Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
          }, t4.createInternalLoader = function(e5) {
            var t5 = this.hls.config, r4 = t5.pLoader, i4 = t5.loader, n3 = new (r4 || i4)(t5);
            return e5.loader = n3, this.loaders[e5.type] = n3, n3;
          }, t4.getInternalLoader = function(e5) {
            return this.loaders[e5.type];
          }, t4.resetInternalLoader = function(e5) {
            this.loaders[e5] && delete this.loaders[e5];
          }, t4.destroyInternalLoaders = function() {
            for (var e5 in this.loaders) {
              var t5 = this.loaders[e5];
              t5 && t5.destroy(), this.resetInternalLoader(e5);
            }
          }, t4.destroy = function() {
            this.unregisterListeners(), this.destroyInternalLoaders();
          }, t4.onManifestLoading = function(e5, t5) {
            var r4 = t5.url;
            this.load({ id: null, groupId: null, level: 0, responseType: "text", type: u2.PlaylistContextType.MANIFEST, url: r4, deliveryDirectives: null });
          }, t4.onLevelLoading = function(e5, t5) {
            var r4 = t5.id, i4 = t5.level, n3 = t5.url, a3 = t5.deliveryDirectives;
            this.load({ id: r4, groupId: null, level: i4, responseType: "text", type: u2.PlaylistContextType.LEVEL, url: n3, deliveryDirectives: a3 });
          }, t4.onAudioTrackLoading = function(e5, t5) {
            var r4 = t5.id, i4 = t5.groupId, n3 = t5.url, a3 = t5.deliveryDirectives;
            this.load({ id: r4, groupId: i4, level: null, responseType: "text", type: u2.PlaylistContextType.AUDIO_TRACK, url: n3, deliveryDirectives: a3 });
          }, t4.onSubtitleTrackLoading = function(e5, t5) {
            var r4 = t5.id, i4 = t5.groupId, n3 = t5.url, a3 = t5.deliveryDirectives;
            this.load({ id: r4, groupId: i4, level: null, responseType: "text", type: u2.PlaylistContextType.SUBTITLE_TRACK, url: n3, deliveryDirectives: a3 });
          }, t4.load = function(e5) {
            var t5, r4, i4, n3, a3, o3, l3 = this.hls.config, c3 = this.getInternalLoader(e5);
            if (c3) {
              var d3 = c3.context;
              if (d3 && d3.url === e5.url)
                return void s2.logger.trace("[playlist-loader]: playlist request ongoing");
              s2.logger.log("[playlist-loader]: aborting previous loader for type: " + e5.type), c3.abort();
            }
            switch (e5.type) {
              case u2.PlaylistContextType.MANIFEST:
                r4 = l3.manifestLoadingMaxRetry, i4 = l3.manifestLoadingTimeOut, n3 = l3.manifestLoadingRetryDelay, a3 = l3.manifestLoadingMaxRetryTimeout;
                break;
              case u2.PlaylistContextType.LEVEL:
              case u2.PlaylistContextType.AUDIO_TRACK:
              case u2.PlaylistContextType.SUBTITLE_TRACK:
                r4 = 0, i4 = l3.levelLoadingTimeOut;
                break;
              default:
                r4 = l3.levelLoadingMaxRetry, i4 = l3.levelLoadingTimeOut, n3 = l3.levelLoadingRetryDelay, a3 = l3.levelLoadingMaxRetryTimeout;
            }
            if (c3 = this.createInternalLoader(e5), null !== (t5 = e5.deliveryDirectives) && void 0 !== t5 && t5.part && (e5.type === u2.PlaylistContextType.LEVEL && null !== e5.level ? o3 = this.hls.levels[e5.level].details : e5.type === u2.PlaylistContextType.AUDIO_TRACK && null !== e5.id ? o3 = this.hls.audioTracks[e5.id].details : e5.type === u2.PlaylistContextType.SUBTITLE_TRACK && null !== e5.id && (o3 = this.hls.subtitleTracks[e5.id].details), o3)) {
              var h3 = o3.partTarget, f3 = o3.targetduration;
              h3 && f3 && (i4 = Math.min(1e3 * Math.max(3 * h3, 0.8 * f3), i4));
            }
            var p2 = { timeout: i4, maxRetry: r4, retryDelay: n3, maxRetryDelay: a3, highWaterMark: 0 }, g2 = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
            c3.load(e5, p2, g2);
          }, t4.loadsuccess = function(e5, t5, r4, i4) {
            if (void 0 === i4 && (i4 = null), r4.isSidxRequest)
              return this.handleSidxRequest(e5, r4), void this.handlePlaylistLoaded(e5, t5, r4, i4);
            this.resetInternalLoader(r4.type);
            var n3 = e5.data;
            0 === n3.indexOf("#EXTM3U") ? (t5.parsing.start = performance.now(), n3.indexOf("#EXTINF:") > 0 || n3.indexOf("#EXT-X-TARGETDURATION:") > 0 ? this.handleTrackOrLevelPlaylist(e5, t5, r4, i4) : this.handleMasterPlaylist(e5, t5, r4, i4)) : this.handleManifestParsingError(e5, r4, "no EXTM3U delimiter", i4);
          }, t4.loaderror = function(e5, t5, r4) {
            void 0 === r4 && (r4 = null), this.handleNetworkError(t5, r4, false, e5);
          }, t4.loadtimeout = function(e5, t5, r4) {
            void 0 === r4 && (r4 = null), this.handleNetworkError(t5, r4, true);
          }, t4.handleMasterPlaylist = function(e5, t5, r4, i4) {
            var a3 = this.hls, o3 = e5.data, u3 = d2(e5, r4), h3 = l2.default.parseMasterPlaylist(o3, u3), f3 = h3.levels, p2 = h3.sessionData;
            if (f3.length) {
              var g2 = f3.map(function(e6) {
                return { id: e6.attrs.AUDIO, audioCodec: e6.audioCodec };
              }), v2 = f3.map(function(e6) {
                return { id: e6.attrs.SUBTITLES, textCodec: e6.textCodec };
              }), m2 = l2.default.parseMasterPlaylistMedia(o3, u3, "AUDIO", g2), y2 = l2.default.parseMasterPlaylistMedia(o3, u3, "SUBTITLES", v2), A2 = l2.default.parseMasterPlaylistMedia(o3, u3, "CLOSED-CAPTIONS");
              m2.length && (m2.some(function(e6) {
                return !e6.url;
              }) || !f3[0].audioCodec || f3[0].attrs.AUDIO || (s2.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), m2.unshift({ type: "main", name: "main", default: false, autoselect: false, forced: false, id: -1, attrs: new c2.AttrList({}), bitrate: 0, url: "" }))), a3.trigger(n2.Events.MANIFEST_LOADED, { levels: f3, audioTracks: m2, subtitles: y2, captions: A2, url: u3, stats: t5, networkDetails: i4, sessionData: p2 });
            } else
              this.handleManifestParsingError(e5, r4, "no level found in manifest", i4);
          }, t4.handleTrackOrLevelPlaylist = function(e5, t5, r4, s3) {
            var o3 = this.hls, h3 = r4.id, f3 = r4.level, p2 = r4.type, g2 = d2(e5, r4), v2 = (0, i3.isFiniteNumber)(h3) ? h3 : 0, m2 = (0, i3.isFiniteNumber)(f3) ? f3 : v2, y2 = function(e6) {
              switch (e6.type) {
                case u2.PlaylistContextType.AUDIO_TRACK:
                  return u2.PlaylistLevelType.AUDIO;
                case u2.PlaylistContextType.SUBTITLE_TRACK:
                  return u2.PlaylistLevelType.SUBTITLE;
                default:
                  return u2.PlaylistLevelType.MAIN;
              }
            }(r4), A2 = l2.default.parseLevelPlaylist(e5.data, g2, m2, y2, v2);
            if (A2.fragments.length) {
              if (p2 === u2.PlaylistContextType.MANIFEST) {
                var E2 = { attrs: new c2.AttrList({}), bitrate: 0, details: A2, name: "", url: g2 };
                o3.trigger(n2.Events.MANIFEST_LOADED, { levels: [E2], audioTracks: [], url: g2, stats: t5, networkDetails: s3, sessionData: null });
              }
              if (t5.parsing.end = performance.now(), A2.needSidxRanges) {
                var T2, b2 = null === (T2 = A2.fragments[0].initSegment) || void 0 === T2 ? void 0 : T2.url;
                this.load({ url: b2, isSidxRequest: true, type: p2, level: f3, levelDetails: A2, id: h3, groupId: null, rangeStart: 0, rangeEnd: 2048, responseType: "arraybuffer", deliveryDirectives: null });
              } else
                r4.levelDetails = A2, this.handlePlaylistLoaded(e5, t5, r4, s3);
            } else
              o3.trigger(n2.Events.ERROR, { type: a2.ErrorTypes.NETWORK_ERROR, details: a2.ErrorDetails.LEVEL_EMPTY_ERROR, fatal: false, url: g2, reason: "no fragments found in level", level: "number" == typeof r4.level ? r4.level : void 0 });
          }, t4.handleSidxRequest = function(e5, t5) {
            var r4 = new Uint8Array(e5.data), i4 = (0, o2.findBox)(r4, ["sidx"])[0];
            if (i4) {
              var n3 = (0, o2.parseSegmentIndex)(i4);
              if (n3) {
                var a3 = n3.references, s3 = t5.levelDetails;
                a3.forEach(function(e6, t6) {
                  var i5 = e6.info, n4 = s3.fragments[t6];
                  if (0 === n4.byteRange.length && n4.setByteRange(String(1 + i5.end - i5.start) + "@" + String(i5.start)), n4.initSegment) {
                    var a4 = (0, o2.findBox)(r4, ["moov"])[0], l3 = a4 ? a4.length : null;
                    n4.initSegment.setByteRange(String(l3) + "@0");
                  }
                });
              }
            }
          }, t4.handleManifestParsingError = function(e5, t5, r4, i4) {
            this.hls.trigger(n2.Events.ERROR, { type: a2.ErrorTypes.NETWORK_ERROR, details: a2.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: t5.type === u2.PlaylistContextType.MANIFEST, url: e5.url, reason: r4, response: e5, context: t5, networkDetails: i4 });
          }, t4.handleNetworkError = function(e5, t5, r4, i4) {
            void 0 === r4 && (r4 = false), s2.logger.warn("[playlist-loader]: A network " + (r4 ? "timeout" : "error") + " occurred while loading " + e5.type + " level: " + e5.level + " id: " + e5.id + ' group-id: "' + e5.groupId + '"');
            var o3 = a2.ErrorDetails.UNKNOWN, l3 = false, c3 = this.getInternalLoader(e5);
            switch (e5.type) {
              case u2.PlaylistContextType.MANIFEST:
                o3 = r4 ? a2.ErrorDetails.MANIFEST_LOAD_TIMEOUT : a2.ErrorDetails.MANIFEST_LOAD_ERROR, l3 = true;
                break;
              case u2.PlaylistContextType.LEVEL:
                o3 = r4 ? a2.ErrorDetails.LEVEL_LOAD_TIMEOUT : a2.ErrorDetails.LEVEL_LOAD_ERROR, l3 = false;
                break;
              case u2.PlaylistContextType.AUDIO_TRACK:
                o3 = r4 ? a2.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : a2.ErrorDetails.AUDIO_TRACK_LOAD_ERROR, l3 = false;
                break;
              case u2.PlaylistContextType.SUBTITLE_TRACK:
                o3 = r4 ? a2.ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : a2.ErrorDetails.SUBTITLE_LOAD_ERROR, l3 = false;
            }
            c3 && this.resetInternalLoader(e5.type);
            var d3 = { type: a2.ErrorTypes.NETWORK_ERROR, details: o3, fatal: l3, url: e5.url, loader: c3, context: e5, networkDetails: t5 };
            i4 && (d3.response = i4), this.hls.trigger(n2.Events.ERROR, d3);
          }, t4.handlePlaylistLoaded = function(e5, t5, r4, i4) {
            var a3 = r4.type, s3 = r4.level, o3 = r4.id, l3 = r4.groupId, c3 = r4.loader, d3 = r4.levelDetails, h3 = r4.deliveryDirectives;
            if (null != d3 && d3.targetduration) {
              if (c3)
                switch (d3.live && (c3.getCacheAge && (d3.ageHeader = c3.getCacheAge() || 0), c3.getCacheAge && !isNaN(d3.ageHeader) || (d3.ageHeader = 0)), a3) {
                  case u2.PlaylistContextType.MANIFEST:
                  case u2.PlaylistContextType.LEVEL:
                    this.hls.trigger(n2.Events.LEVEL_LOADED, { details: d3, level: s3 || 0, id: o3 || 0, stats: t5, networkDetails: i4, deliveryDirectives: h3 });
                    break;
                  case u2.PlaylistContextType.AUDIO_TRACK:
                    this.hls.trigger(n2.Events.AUDIO_TRACK_LOADED, { details: d3, id: o3 || 0, groupId: l3 || "", stats: t5, networkDetails: i4, deliveryDirectives: h3 });
                    break;
                  case u2.PlaylistContextType.SUBTITLE_TRACK:
                    this.hls.trigger(n2.Events.SUBTITLE_TRACK_LOADED, { details: d3, id: o3 || 0, groupId: l3 || "", stats: t5, networkDetails: i4, deliveryDirectives: h3 });
                }
            } else
              this.handleManifestParsingError(e5, r4, "invalid target duration", i4);
          }, e4;
        }();
        const f2 = h2;
      }
    ), "./src/polyfills/number.ts": (
      /*!*********************************!*\
          !*** ./src/polyfills/number.ts ***!
          \*********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { MAX_SAFE_INTEGER: () => n2, isFiniteNumber: () => i3 });
        var i3 = Number.isFinite || function(e4) {
          return "number" == typeof e4 && isFinite(e4);
        }, n2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
      }
    ), "./src/remux/aac-helper.ts": (
      /*!*********************************!*\
          !*** ./src/remux/aac-helper.ts ***!
          \*********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => i3 });
        const i3 = function() {
          function e4() {
          }
          return e4.getSilentFrame = function(e5, t4) {
            if ("mp4a.40.2" === e5) {
              if (1 === t4)
                return new Uint8Array([0, 200, 0, 128, 35, 128]);
              if (2 === t4)
                return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
              if (3 === t4)
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
              if (4 === t4)
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
              if (5 === t4)
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
              if (6 === t4)
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
            } else {
              if (1 === t4)
                return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
              if (2 === t4)
                return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
              if (3 === t4)
                return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
            }
          }, e4;
        }();
      }
    ), "./src/remux/mp4-generator.ts": (
      /*!************************************!*\
          !*** ./src/remux/mp4-generator.ts ***!
          \************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => a2 });
        var i3 = Math.pow(2, 32) - 1, n2 = function() {
          function e4() {
          }
          return e4.init = function() {
            var t4;
            for (t4 in e4.types = { avc1: [], avcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], ".mp3": [], mvex: [], mvhd: [], pasp: [], sdtp: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [], smhd: [] }, e4.types)
              e4.types.hasOwnProperty(t4) && (e4.types[t4] = [t4.charCodeAt(0), t4.charCodeAt(1), t4.charCodeAt(2), t4.charCodeAt(3)]);
            var r4 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), i4 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
            e4.HDLR_TYPES = { video: r4, audio: i4 };
            var n3 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), a3 = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
            e4.STTS = e4.STSC = e4.STCO = a3, e4.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e4.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), e4.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), e4.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
            var s2 = new Uint8Array([105, 115, 111, 109]), o2 = new Uint8Array([97, 118, 99, 49]), l2 = new Uint8Array([0, 0, 0, 1]);
            e4.FTYP = e4.box(e4.types.ftyp, s2, l2, s2, o2), e4.DINF = e4.box(e4.types.dinf, e4.box(e4.types.dref, n3));
          }, e4.box = function(e5) {
            for (var t4 = 8, r4 = arguments.length, i4 = new Array(r4 > 1 ? r4 - 1 : 0), n3 = 1; n3 < r4; n3++)
              i4[n3 - 1] = arguments[n3];
            for (var a3 = i4.length, s2 = a3; a3--; )
              t4 += i4[a3].byteLength;
            var o2 = new Uint8Array(t4);
            for (o2[0] = t4 >> 24 & 255, o2[1] = t4 >> 16 & 255, o2[2] = t4 >> 8 & 255, o2[3] = 255 & t4, o2.set(e5, 4), a3 = 0, t4 = 8; a3 < s2; a3++)
              o2.set(i4[a3], t4), t4 += i4[a3].byteLength;
            return o2;
          }, e4.hdlr = function(t4) {
            return e4.box(e4.types.hdlr, e4.HDLR_TYPES[t4]);
          }, e4.mdat = function(t4) {
            return e4.box(e4.types.mdat, t4);
          }, e4.mdhd = function(t4, r4) {
            r4 *= t4;
            var n3 = Math.floor(r4 / (i3 + 1)), a3 = Math.floor(r4 % (i3 + 1));
            return e4.box(e4.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t4 >> 24 & 255, t4 >> 16 & 255, t4 >> 8 & 255, 255 & t4, n3 >> 24, n3 >> 16 & 255, n3 >> 8 & 255, 255 & n3, a3 >> 24, a3 >> 16 & 255, a3 >> 8 & 255, 255 & a3, 85, 196, 0, 0]));
          }, e4.mdia = function(t4) {
            return e4.box(e4.types.mdia, e4.mdhd(t4.timescale, t4.duration), e4.hdlr(t4.type), e4.minf(t4));
          }, e4.mfhd = function(t4) {
            return e4.box(e4.types.mfhd, new Uint8Array([0, 0, 0, 0, t4 >> 24, t4 >> 16 & 255, t4 >> 8 & 255, 255 & t4]));
          }, e4.minf = function(t4) {
            return "audio" === t4.type ? e4.box(e4.types.minf, e4.box(e4.types.smhd, e4.SMHD), e4.DINF, e4.stbl(t4)) : e4.box(e4.types.minf, e4.box(e4.types.vmhd, e4.VMHD), e4.DINF, e4.stbl(t4));
          }, e4.moof = function(t4, r4, i4) {
            return e4.box(e4.types.moof, e4.mfhd(t4), e4.traf(i4, r4));
          }, e4.moov = function(t4) {
            for (var r4 = t4.length, i4 = []; r4--; )
              i4[r4] = e4.trak(t4[r4]);
            return e4.box.apply(null, [e4.types.moov, e4.mvhd(t4[0].timescale, t4[0].duration)].concat(i4).concat(e4.mvex(t4)));
          }, e4.mvex = function(t4) {
            for (var r4 = t4.length, i4 = []; r4--; )
              i4[r4] = e4.trex(t4[r4]);
            return e4.box.apply(null, [e4.types.mvex].concat(i4));
          }, e4.mvhd = function(t4, r4) {
            r4 *= t4;
            var n3 = Math.floor(r4 / (i3 + 1)), a3 = Math.floor(r4 % (i3 + 1)), s2 = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t4 >> 24 & 255, t4 >> 16 & 255, t4 >> 8 & 255, 255 & t4, n3 >> 24, n3 >> 16 & 255, n3 >> 8 & 255, 255 & n3, a3 >> 24, a3 >> 16 & 255, a3 >> 8 & 255, 255 & a3, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
            return e4.box(e4.types.mvhd, s2);
          }, e4.sdtp = function(t4) {
            var r4, i4, n3 = t4.samples || [], a3 = new Uint8Array(4 + n3.length);
            for (r4 = 0; r4 < n3.length; r4++)
              i4 = n3[r4].flags, a3[r4 + 4] = i4.dependsOn << 4 | i4.isDependedOn << 2 | i4.hasRedundancy;
            return e4.box(e4.types.sdtp, a3);
          }, e4.stbl = function(t4) {
            return e4.box(e4.types.stbl, e4.stsd(t4), e4.box(e4.types.stts, e4.STTS), e4.box(e4.types.stsc, e4.STSC), e4.box(e4.types.stsz, e4.STSZ), e4.box(e4.types.stco, e4.STCO));
          }, e4.avc1 = function(t4) {
            var r4, i4, n3, a3 = [], s2 = [];
            for (r4 = 0; r4 < t4.sps.length; r4++)
              n3 = (i4 = t4.sps[r4]).byteLength, a3.push(n3 >>> 8 & 255), a3.push(255 & n3), a3 = a3.concat(Array.prototype.slice.call(i4));
            for (r4 = 0; r4 < t4.pps.length; r4++)
              n3 = (i4 = t4.pps[r4]).byteLength, s2.push(n3 >>> 8 & 255), s2.push(255 & n3), s2 = s2.concat(Array.prototype.slice.call(i4));
            var o2 = e4.box(e4.types.avcC, new Uint8Array([1, a3[3], a3[4], a3[5], 255, 224 | t4.sps.length].concat(a3).concat([t4.pps.length]).concat(s2))), l2 = t4.width, u2 = t4.height, c2 = t4.pixelRatio[0], d2 = t4.pixelRatio[1];
            return e4.box(e4.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l2 >> 8 & 255, 255 & l2, u2 >> 8 & 255, 255 & u2, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o2, e4.box(e4.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), e4.box(e4.types.pasp, new Uint8Array([c2 >> 24, c2 >> 16 & 255, c2 >> 8 & 255, 255 & c2, d2 >> 24, d2 >> 16 & 255, d2 >> 8 & 255, 255 & d2])));
          }, e4.esds = function(e5) {
            var t4 = e5.config.length;
            return new Uint8Array([0, 0, 0, 0, 3, 23 + t4, 0, 1, 0, 4, 15 + t4, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t4]).concat(e5.config).concat([6, 1, 2]));
          }, e4.mp4a = function(t4) {
            var r4 = t4.samplerate;
            return e4.box(e4.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t4.channelCount, 0, 16, 0, 0, 0, 0, r4 >> 8 & 255, 255 & r4, 0, 0]), e4.box(e4.types.esds, e4.esds(t4)));
          }, e4.mp3 = function(t4) {
            var r4 = t4.samplerate;
            return e4.box(e4.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t4.channelCount, 0, 16, 0, 0, 0, 0, r4 >> 8 & 255, 255 & r4, 0, 0]));
          }, e4.stsd = function(t4) {
            return "audio" === t4.type ? "mp3" === t4.segmentCodec && "mp3" === t4.codec ? e4.box(e4.types.stsd, e4.STSD, e4.mp3(t4)) : e4.box(e4.types.stsd, e4.STSD, e4.mp4a(t4)) : e4.box(e4.types.stsd, e4.STSD, e4.avc1(t4));
          }, e4.tkhd = function(t4) {
            var r4 = t4.id, n3 = t4.duration * t4.timescale, a3 = t4.width, s2 = t4.height, o2 = Math.floor(n3 / (i3 + 1)), l2 = Math.floor(n3 % (i3 + 1));
            return e4.box(e4.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, r4 >> 24 & 255, r4 >> 16 & 255, r4 >> 8 & 255, 255 & r4, 0, 0, 0, 0, o2 >> 24, o2 >> 16 & 255, o2 >> 8 & 255, 255 & o2, l2 >> 24, l2 >> 16 & 255, l2 >> 8 & 255, 255 & l2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, a3 >> 8 & 255, 255 & a3, 0, 0, s2 >> 8 & 255, 255 & s2, 0, 0]));
          }, e4.traf = function(t4, r4) {
            var n3 = e4.sdtp(t4), a3 = t4.id, s2 = Math.floor(r4 / (i3 + 1)), o2 = Math.floor(r4 % (i3 + 1));
            return e4.box(e4.types.traf, e4.box(e4.types.tfhd, new Uint8Array([0, 0, 0, 0, a3 >> 24, a3 >> 16 & 255, a3 >> 8 & 255, 255 & a3])), e4.box(e4.types.tfdt, new Uint8Array([1, 0, 0, 0, s2 >> 24, s2 >> 16 & 255, s2 >> 8 & 255, 255 & s2, o2 >> 24, o2 >> 16 & 255, o2 >> 8 & 255, 255 & o2])), e4.trun(t4, n3.length + 16 + 20 + 8 + 16 + 8 + 8), n3);
          }, e4.trak = function(t4) {
            return t4.duration = t4.duration || 4294967295, e4.box(e4.types.trak, e4.tkhd(t4), e4.mdia(t4));
          }, e4.trex = function(t4) {
            var r4 = t4.id;
            return e4.box(e4.types.trex, new Uint8Array([0, 0, 0, 0, r4 >> 24, r4 >> 16 & 255, r4 >> 8 & 255, 255 & r4, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]));
          }, e4.trun = function(t4, r4) {
            var i4, n3, a3, s2, o2, l2, u2 = t4.samples || [], c2 = u2.length, d2 = 12 + 16 * c2, h2 = new Uint8Array(d2);
            for (r4 += 8 + d2, h2.set(["video" === t4.type ? 1 : 0, 0, 15, 1, c2 >>> 24 & 255, c2 >>> 16 & 255, c2 >>> 8 & 255, 255 & c2, r4 >>> 24 & 255, r4 >>> 16 & 255, r4 >>> 8 & 255, 255 & r4], 0), i4 = 0; i4 < c2; i4++)
              a3 = (n3 = u2[i4]).duration, s2 = n3.size, o2 = n3.flags, l2 = n3.cts, h2.set([a3 >>> 24 & 255, a3 >>> 16 & 255, a3 >>> 8 & 255, 255 & a3, s2 >>> 24 & 255, s2 >>> 16 & 255, s2 >>> 8 & 255, 255 & s2, o2.isLeading << 2 | o2.dependsOn, o2.isDependedOn << 6 | o2.hasRedundancy << 4 | o2.paddingValue << 1 | o2.isNonSync, 61440 & o2.degradPrio, 15 & o2.degradPrio, l2 >>> 24 & 255, l2 >>> 16 & 255, l2 >>> 8 & 255, 255 & l2], 12 + 16 * i4);
            return e4.box(e4.types.trun, h2);
          }, e4.initSegment = function(t4) {
            e4.types || e4.init();
            var r4 = e4.moov(t4), i4 = new Uint8Array(e4.FTYP.byteLength + r4.byteLength);
            return i4.set(e4.FTYP), i4.set(r4, e4.FTYP.byteLength), i4;
          }, e4;
        }();
        n2.types = void 0, n2.HDLR_TYPES = void 0, n2.STTS = void 0, n2.STSC = void 0, n2.STCO = void 0, n2.STSZ = void 0, n2.VMHD = void 0, n2.SMHD = void 0, n2.STSD = void 0, n2.FTYP = void 0, n2.DINF = void 0;
        const a2 = n2;
      }
    ), "./src/remux/mp4-remuxer.ts": (
      /*!**********************************!*\
          !*** ./src/remux/mp4-remuxer.ts ***!
          \**********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => p2, flushTextTrackMetadataCueSamples: () => v2, flushTextTrackUserdataCueSamples: () => m2, normalizePts: () => g2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ./aac-helper */
          "./src/remux/aac-helper.ts"
        ), a2 = r3(
          /*! ./mp4-generator */
          "./src/remux/mp4-generator.ts"
        ), s2 = r3(
          /*! ../events */
          "./src/events.ts"
        ), o2 = r3(
          /*! ../errors */
          "./src/errors.ts"
        ), l2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), u2 = r3(
          /*! ../types/loader */
          "./src/types/loader.ts"
        ), c2 = r3(
          /*! ../utils/timescale-conversion */
          "./src/utils/timescale-conversion.ts"
        );
        function d2() {
          return d2 = Object.assign ? Object.assign.bind() : function(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var r4 = arguments[t4];
              for (var i4 in r4)
                Object.prototype.hasOwnProperty.call(r4, i4) && (e4[i4] = r4[i4]);
            }
            return e4;
          }, d2.apply(this, arguments);
        }
        var h2 = null, f2 = null, p2 = function() {
          function e4(e5, t5, r4, i4) {
            if (this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = false, this._initPTS = void 0, this._initDTS = void 0, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = false, this.isVideoContiguous = false, this.observer = e5, this.config = t5, this.typeSupported = r4, this.ISGenerated = false, null === h2) {
              var n3 = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
              h2 = n3 ? parseInt(n3[1]) : 0;
            }
            if (null === f2) {
              var a3 = navigator.userAgent.match(/Safari\/(\d+)/i);
              f2 = a3 ? parseInt(a3[1]) : 0;
            }
          }
          var t4 = e4.prototype;
          return t4.destroy = function() {
          }, t4.resetTimeStamp = function(e5) {
            l2.logger.log("[mp4-remuxer]: initPTS & initDTS reset"), this._initPTS = this._initDTS = e5;
          }, t4.resetNextTimestamp = function() {
            l2.logger.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = false, this.isAudioContiguous = false;
          }, t4.resetInitSegment = function() {
            l2.logger.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = false;
          }, t4.getVideoStartPts = function(e5) {
            var t5 = false, r4 = e5.reduce(function(e6, r5) {
              var i4 = r5.pts - e6;
              return i4 < -4294967296 ? (t5 = true, g2(e6, r5.pts)) : i4 > 0 ? e6 : r5.pts;
            }, e5[0].pts);
            return t5 && l2.logger.debug("PTS rollover detected"), r4;
          }, t4.remux = function(e5, t5, r4, i4, n3, a3, s3, o3) {
            var c3, d3, h3, f3, p3, y3, A3 = n3, E2 = n3, T2 = e5.pid > -1, b2 = t5.pid > -1, k2 = t5.samples.length, S2 = e5.samples.length > 0, _2 = s3 && k2 > 0 || k2 > 1;
            if ((!T2 || S2) && (!b2 || _2) || this.ISGenerated || s3) {
              this.ISGenerated || (h3 = this.generateIS(e5, t5, n3));
              var C2, L2 = this.isVideoContiguous, D2 = -1;
              if (_2 && (D2 = function(e6) {
                for (var t6 = 0; t6 < e6.length; t6++)
                  if (e6[t6].key)
                    return t6;
                return -1;
              }(t5.samples), !L2 && this.config.forceKeyFrameOnDiscontinuity))
                if (y3 = true, D2 > 0) {
                  l2.logger.warn("[mp4-remuxer]: Dropped " + D2 + " out of " + k2 + " video samples due to a missing keyframe");
                  var R2 = this.getVideoStartPts(t5.samples);
                  t5.samples = t5.samples.slice(D2), t5.dropped += D2, C2 = E2 += (t5.samples[0].pts - R2) / t5.inputTimeScale;
                } else
                  -1 === D2 && (l2.logger.warn("[mp4-remuxer]: No keyframe found out of " + k2 + " video samples"), y3 = false);
              if (this.ISGenerated) {
                if (S2 && _2) {
                  var I2 = this.getVideoStartPts(t5.samples), O2 = (g2(e5.samples[0].pts, I2) - I2) / t5.inputTimeScale;
                  A3 += Math.max(0, O2), E2 += Math.max(0, -O2);
                }
                if (S2) {
                  if (e5.samplerate || (l2.logger.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), h3 = this.generateIS(e5, t5, n3)), d3 = this.remuxAudio(e5, A3, this.isAudioContiguous, a3, b2 || _2 || o3 === u2.PlaylistLevelType.AUDIO ? E2 : void 0), _2) {
                    var w2 = d3 ? d3.endPTS - d3.startPTS : 0;
                    t5.inputTimeScale || (l2.logger.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), h3 = this.generateIS(e5, t5, n3)), c3 = this.remuxVideo(t5, E2, L2, w2);
                  }
                } else
                  _2 && (c3 = this.remuxVideo(t5, E2, L2, 0));
                c3 && (c3.firstKeyFrame = D2, c3.independent = -1 !== D2, c3.firstKeyFramePTS = C2);
              }
            }
            return this.ISGenerated && (r4.samples.length && (p3 = v2(r4, n3, this._initPTS, this._initDTS)), i4.samples.length && (f3 = m2(i4, n3, this._initPTS))), { audio: d3, video: c3, initSegment: h3, independent: y3, text: f3, id3: p3 };
          }, t4.generateIS = function(e5, t5, r4) {
            var n3, s3, o3, l3 = e5.samples, u3 = t5.samples, c3 = this.typeSupported, d3 = {}, h3 = !(0, i3.isFiniteNumber)(this._initPTS), f3 = "audio/mp4";
            if (h3 && (n3 = s3 = 1 / 0), e5.config && l3.length && (e5.timescale = e5.samplerate, "mp3" === e5.segmentCodec && (c3.mpeg ? (f3 = "audio/mpeg", e5.codec = "") : c3.mp3 && (e5.codec = "mp3")), d3.audio = { id: "audio", container: f3, codec: e5.codec, initSegment: "mp3" === e5.segmentCodec && c3.mpeg ? new Uint8Array(0) : a2.default.initSegment([e5]), metadata: { channelCount: e5.channelCount } }, h3 && (o3 = e5.inputTimeScale, n3 = s3 = l3[0].pts - Math.round(o3 * r4))), t5.sps && t5.pps && u3.length && (t5.timescale = t5.inputTimeScale, d3.video = { id: "main", container: "video/mp4", codec: t5.codec, initSegment: a2.default.initSegment([t5]), metadata: { width: t5.width, height: t5.height } }, h3)) {
              o3 = t5.inputTimeScale;
              var p3 = this.getVideoStartPts(u3), v3 = Math.round(o3 * r4);
              s3 = Math.min(s3, g2(u3[0].dts, p3) - v3), n3 = Math.min(n3, p3 - v3);
            }
            if (Object.keys(d3).length)
              return this.ISGenerated = true, h3 && (this._initPTS = n3, this._initDTS = s3), { tracks: d3, initPTS: n3, timescale: o3 };
          }, t4.remuxVideo = function(e5, t5, r4, i4) {
            var n3, u3, p3 = e5.inputTimeScale, v3 = e5.samples, m3 = [], A3 = v3.length, E2 = this._initPTS, T2 = this.nextAvcDts, b2 = 8, k2 = this.videoSampleDuration, S2 = Number.POSITIVE_INFINITY, _2 = Number.NEGATIVE_INFINITY, C2 = false;
            r4 && null !== T2 || (T2 = t5 * p3 - (v3[0].pts - g2(v3[0].dts, v3[0].pts)));
            for (var L2 = 0; L2 < A3; L2++) {
              var D2 = v3[L2];
              D2.pts = g2(D2.pts - E2, T2), D2.dts = g2(D2.dts - E2, T2), D2.dts < v3[L2 > 0 ? L2 - 1 : L2].dts && (C2 = true);
            }
            C2 && v3.sort(function(e6, t6) {
              var r5 = e6.dts - t6.dts, i5 = e6.pts - t6.pts;
              return r5 || i5;
            }), n3 = v3[0].dts;
            var R2 = (u3 = v3[v3.length - 1].dts) - n3, I2 = R2 ? Math.round(R2 / (A3 - 1)) : k2 || e5.inputTimeScale / 30;
            if (r4) {
              var O2 = n3 - T2, w2 = O2 > I2, P2 = O2 < -1;
              if ((w2 || P2) && (w2 ? l2.logger.warn("AVC: " + (0, c2.toMsFromMpegTsClock)(O2, true) + " ms (" + O2 + "dts) hole between fragments detected, filling it") : l2.logger.warn("AVC: " + (0, c2.toMsFromMpegTsClock)(-O2, true) + " ms (" + O2 + "dts) overlapping between fragments detected"), !P2 || T2 > v3[0].pts)) {
                n3 = T2;
                var x2 = v3[0].pts - O2;
                v3[0].dts = n3, v3[0].pts = x2, l2.logger.log("Video: First PTS/DTS adjusted: " + (0, c2.toMsFromMpegTsClock)(x2, true) + "/" + (0, c2.toMsFromMpegTsClock)(n3, true) + ", delta: " + (0, c2.toMsFromMpegTsClock)(O2, true) + " ms");
              }
            }
            n3 = Math.max(0, n3);
            for (var N2 = 0, F2 = 0, M2 = 0; M2 < A3; M2++) {
              for (var B2 = v3[M2], U2 = B2.units, G2 = U2.length, V2 = 0, K2 = 0; K2 < G2; K2++)
                V2 += U2[K2].data.length;
              F2 += V2, N2 += G2, B2.length = V2, B2.dts = Math.max(B2.dts, n3), S2 = Math.min(B2.pts, S2), _2 = Math.max(B2.pts, _2);
            }
            u3 = v3[A3 - 1].dts;
            var j2, H2 = F2 + 4 * N2 + 8;
            try {
              j2 = new Uint8Array(H2);
            } catch (e6) {
              return void this.observer.emit(s2.Events.ERROR, s2.Events.ERROR, { type: o2.ErrorTypes.MUX_ERROR, details: o2.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: H2, reason: "fail allocating video mdat " + H2 });
            }
            var Y2 = new DataView(j2.buffer);
            Y2.setUint32(0, H2), j2.set(a2.default.types.mdat, 4);
            for (var W2 = false, $2 = Number.POSITIVE_INFINITY, z2 = Number.POSITIVE_INFINITY, q2 = Number.NEGATIVE_INFINITY, X2 = Number.NEGATIVE_INFINITY, Z2 = 0; Z2 < A3; Z2++) {
              for (var Q2 = v3[Z2], J2 = Q2.units, ee2 = 0, te2 = 0, re2 = J2.length; te2 < re2; te2++) {
                var ie2 = J2[te2], ne2 = ie2.data, ae2 = ie2.data.byteLength;
                Y2.setUint32(b2, ae2), b2 += 4, j2.set(ne2, b2), b2 += ae2, ee2 += 4 + ae2;
              }
              var se2 = void 0;
              if (Z2 < A3 - 1)
                k2 = v3[Z2 + 1].dts - Q2.dts, se2 = v3[Z2 + 1].pts - Q2.pts;
              else {
                var oe2 = this.config, le2 = Z2 > 0 ? Q2.dts - v3[Z2 - 1].dts : I2;
                if (se2 = Z2 > 0 ? Q2.pts - v3[Z2 - 1].pts : I2, oe2.stretchShortVideoTrack && null !== this.nextAudioPts) {
                  var ue2 = Math.floor(oe2.maxBufferHole * p3), ce2 = (i4 ? S2 + i4 * p3 : this.nextAudioPts) - Q2.pts;
                  ce2 > ue2 ? ((k2 = ce2 - le2) < 0 ? k2 = le2 : W2 = true, l2.logger.log("[mp4-remuxer]: It is approximately " + ce2 / 90 + " ms to the next segment; using duration " + k2 / 90 + " ms for the last video frame.")) : k2 = le2;
                } else
                  k2 = le2;
              }
              var de2 = Math.round(Q2.pts - Q2.dts);
              $2 = Math.min($2, k2), q2 = Math.max(q2, k2), z2 = Math.min(z2, se2), X2 = Math.max(X2, se2), m3.push(new y2(Q2.key, k2, ee2, de2));
            }
            if (m3.length) {
              if (h2) {
                if (h2 < 70) {
                  var he2 = m3[0].flags;
                  he2.dependsOn = 2, he2.isNonSync = 0;
                }
              } else if (f2 && X2 - z2 < q2 - $2 && I2 / q2 < 0.025 && 0 === m3[0].cts) {
                l2.logger.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
                for (var fe2 = n3, pe2 = 0, ge2 = m3.length; pe2 < ge2; pe2++) {
                  var ve2 = fe2 + m3[pe2].duration, me2 = fe2 + m3[pe2].cts;
                  if (pe2 < ge2 - 1) {
                    var ye2 = ve2 + m3[pe2 + 1].cts;
                    m3[pe2].duration = ye2 - me2;
                  } else
                    m3[pe2].duration = pe2 ? m3[pe2 - 1].duration : I2;
                  m3[pe2].cts = 0, fe2 = ve2;
                }
              }
            }
            console.assert(null !== k2, "mp4SampleDuration must be computed"), k2 = W2 || !k2 ? I2 : k2, this.nextAvcDts = T2 = u3 + k2, this.videoSampleDuration = k2, this.isVideoContiguous = true;
            var Ae2 = { data1: a2.default.moof(e5.sequenceNumber++, n3, d2({}, e5, { samples: m3 })), data2: j2, startPTS: S2 / p3, endPTS: (_2 + k2) / p3, startDTS: n3 / p3, endDTS: T2 / p3, type: "video", hasAudio: false, hasVideo: true, nb: m3.length, dropped: e5.dropped };
            return e5.samples = [], e5.dropped = 0, console.assert(j2.length, "MDAT length must not be zero"), Ae2;
          }, t4.remuxAudio = function(e5, t5, r4, i4, u3) {
            var c3 = e5.inputTimeScale, h3 = c3 / (e5.samplerate ? e5.samplerate : c3), f3 = "aac" === e5.segmentCodec ? 1024 : 1152, p3 = f3 * h3, v3 = this._initPTS, m3 = "mp3" === e5.segmentCodec && this.typeSupported.mpeg, A3 = [], E2 = void 0 !== u3, T2 = e5.samples, b2 = m3 ? 0 : 8, k2 = this.nextAudioPts || -1, S2 = t5 * c3;
            if (this.isAudioContiguous = r4 = r4 || T2.length && k2 > 0 && (i4 && Math.abs(S2 - k2) < 9e3 || Math.abs(g2(T2[0].pts - v3, S2) - k2) < 20 * p3), T2.forEach(function(e6) {
              e6.pts = g2(e6.pts - v3, S2);
            }), !r4 || k2 < 0) {
              if (T2 = T2.filter(function(e6) {
                return e6.pts >= 0;
              }), !T2.length)
                return;
              k2 = 0 === u3 ? 0 : i4 && !E2 ? Math.max(0, S2) : T2[0].pts;
            }
            if ("aac" === e5.segmentCodec)
              for (var _2 = this.config.maxAudioFramesDrift, C2 = 0, L2 = k2; C2 < T2.length; C2++) {
                var D2 = T2[C2], R2 = D2.pts, I2 = R2 - L2, O2 = Math.abs(1e3 * I2 / c3);
                if (I2 <= -_2 * p3 && E2)
                  0 === C2 && (l2.logger.warn("Audio frame @ " + (R2 / c3).toFixed(3) + "s overlaps nextAudioPts by " + Math.round(1e3 * I2 / c3) + " ms."), this.nextAudioPts = k2 = L2 = R2);
                else if (I2 >= _2 * p3 && O2 < 1e4 && E2) {
                  var w2 = Math.round(I2 / p3);
                  (L2 = R2 - w2 * p3) < 0 && (w2--, L2 += p3), 0 === C2 && (this.nextAudioPts = k2 = L2), l2.logger.warn("[mp4-remuxer]: Injecting " + w2 + " audio frame @ " + (L2 / c3).toFixed(3) + "s due to " + Math.round(1e3 * I2 / c3) + " ms gap.");
                  for (var P2 = 0; P2 < w2; P2++) {
                    var x2 = Math.max(L2, 0), N2 = n2.default.getSilentFrame(e5.manifestCodec || e5.codec, e5.channelCount);
                    N2 || (l2.logger.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), N2 = D2.unit.subarray()), T2.splice(C2, 0, { unit: N2, pts: x2 }), L2 += p3, C2++;
                  }
                }
                D2.pts = L2, L2 += p3;
              }
            for (var F2, M2 = null, B2 = null, U2 = 0, G2 = T2.length; G2--; )
              U2 += T2[G2].unit.byteLength;
            for (var V2 = 0, K2 = T2.length; V2 < K2; V2++) {
              var j2 = T2[V2], H2 = j2.unit, Y2 = j2.pts;
              if (null !== B2)
                A3[V2 - 1].duration = Math.round((Y2 - B2) / h3);
              else {
                if (r4 && "aac" === e5.segmentCodec && (Y2 = k2), M2 = Y2, !(U2 > 0))
                  return;
                U2 += b2;
                try {
                  F2 = new Uint8Array(U2);
                } catch (e6) {
                  return void this.observer.emit(s2.Events.ERROR, s2.Events.ERROR, { type: o2.ErrorTypes.MUX_ERROR, details: o2.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: U2, reason: "fail allocating audio mdat " + U2 });
                }
                m3 || (new DataView(F2.buffer).setUint32(0, U2), F2.set(a2.default.types.mdat, 4));
              }
              F2.set(H2, b2);
              var W2 = H2.byteLength;
              b2 += W2, A3.push(new y2(true, f3, W2, 0)), B2 = Y2;
            }
            var $2 = A3.length;
            if ($2) {
              var z2 = A3[A3.length - 1];
              this.nextAudioPts = k2 = B2 + h3 * z2.duration;
              var q2 = m3 ? new Uint8Array(0) : a2.default.moof(e5.sequenceNumber++, M2 / h3, d2({}, e5, { samples: A3 }));
              e5.samples = [];
              var X2 = M2 / c3, Z2 = k2 / c3, Q2 = { data1: q2, data2: F2, startPTS: X2, endPTS: Z2, startDTS: X2, endDTS: Z2, type: "audio", hasAudio: true, hasVideo: false, nb: $2 };
              return this.isAudioContiguous = true, console.assert(F2.length, "MDAT length must not be zero"), Q2;
            }
          }, t4.remuxEmptyAudio = function(e5, t5, r4, i4) {
            var a3 = e5.inputTimeScale, s3 = a3 / (e5.samplerate ? e5.samplerate : a3), o3 = this.nextAudioPts, u3 = (null !== o3 ? o3 : i4.startDTS * a3) + this._initDTS, c3 = i4.endDTS * a3 + this._initDTS, d3 = 1024 * s3, h3 = Math.ceil((c3 - u3) / d3), f3 = n2.default.getSilentFrame(e5.manifestCodec || e5.codec, e5.channelCount);
            if (l2.logger.warn("[mp4-remuxer]: remux empty Audio"), f3) {
              for (var p3 = [], g3 = 0; g3 < h3; g3++) {
                var v3 = u3 + g3 * d3;
                p3.push({ unit: f3, pts: v3, dts: v3 });
              }
              return e5.samples = p3, this.remuxAudio(e5, t5, r4, false);
            }
            l2.logger.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
          }, e4;
        }();
        function g2(e4, t4) {
          var r4;
          if (null === t4)
            return e4;
          for (r4 = t4 < e4 ? -8589934592 : 8589934592; Math.abs(e4 - t4) > 4294967296; )
            e4 += r4;
          return e4;
        }
        function v2(e4, t4, r4, i4) {
          var n3 = e4.samples.length;
          if (n3) {
            for (var a3 = e4.inputTimeScale, s3 = 0; s3 < n3; s3++) {
              var o3 = e4.samples[s3];
              o3.pts = g2(o3.pts - r4, t4 * a3) / a3, o3.dts = g2(o3.dts - i4, t4 * a3) / a3;
            }
            var l3 = e4.samples;
            return e4.samples = [], { samples: l3 };
          }
        }
        function m2(e4, t4, r4) {
          var i4 = e4.samples.length;
          if (i4) {
            for (var n3 = e4.inputTimeScale, a3 = 0; a3 < i4; a3++) {
              var s3 = e4.samples[a3];
              s3.pts = g2(s3.pts - r4, t4 * n3) / n3;
            }
            e4.samples.sort(function(e5, t5) {
              return e5.pts - t5.pts;
            });
            var o3 = e4.samples;
            return e4.samples = [], { samples: o3 };
          }
        }
        var y2 = function(e4, t4, r4, i4) {
          this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = t4, this.size = r4, this.cts = i4, this.flags = new A2(e4);
        }, A2 = function(e4) {
          this.isLeading = 0, this.isDependedOn = 0, this.hasRedundancy = 0, this.degradPrio = 0, this.dependsOn = 1, this.isNonSync = 1, this.dependsOn = e4 ? 2 : 1, this.isNonSync = e4 ? 0 : 1;
        };
      }
    ), "./src/remux/passthrough-remuxer.ts": (
      /*!******************************************!*\
          !*** ./src/remux/passthrough-remuxer.ts ***!
          \******************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => u2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ./mp4-remuxer */
          "./src/remux/mp4-remuxer.ts"
        ), a2 = r3(
          /*! ../utils/mp4-tools */
          "./src/utils/mp4-tools.ts"
        ), s2 = r3(
          /*! ../loader/fragment */
          "./src/loader/fragment.ts"
        ), o2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        );
        function l2(e4, t4) {
          var r4 = null == e4 ? void 0 : e4.codec;
          return r4 && r4.length > 4 ? r4 : "hvc1" === r4 || "hev1" === r4 ? "hvc1.1.c.L120.90" : "av01" === r4 ? "av01.0.04M.08" : "avc1" === r4 || t4 === s2.ElementaryStreamTypes.VIDEO ? "avc1.42e01e" : "mp4a.40.5";
        }
        const u2 = function() {
          function e4() {
            this.emitInitSegment = false, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = void 0, this.initTracks = void 0, this.lastEndTime = null;
          }
          var t4 = e4.prototype;
          return t4.destroy = function() {
          }, t4.resetTimeStamp = function(e5) {
            this.initPTS = e5, this.lastEndTime = null;
          }, t4.resetNextTimestamp = function() {
            this.lastEndTime = null;
          }, t4.resetInitSegment = function(e5, t5, r4) {
            this.audioCodec = t5, this.videoCodec = r4, this.generateInitSegment(e5), this.emitInitSegment = true;
          }, t4.generateInitSegment = function(e5) {
            var t5 = this.audioCodec, r4 = this.videoCodec;
            if (!e5 || !e5.byteLength)
              return this.initTracks = void 0, void (this.initData = void 0);
            var i4 = this.initData = (0, a2.parseInitSegment)(e5);
            t5 || (t5 = l2(i4.audio, s2.ElementaryStreamTypes.AUDIO)), r4 || (r4 = l2(i4.video, s2.ElementaryStreamTypes.VIDEO));
            var n3 = {};
            i4.audio && i4.video ? n3.audiovideo = { container: "video/mp4", codec: t5 + "," + r4, initSegment: e5, id: "main" } : i4.audio ? n3.audio = { container: "audio/mp4", codec: t5, initSegment: e5, id: "audio" } : i4.video ? n3.video = { container: "video/mp4", codec: r4, initSegment: e5, id: "main" } : o2.logger.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = n3;
          }, t4.remux = function(e5, t5, r4, s3, l3) {
            var u3, c2 = this.initPTS, d2 = this.lastEndTime, h2 = { audio: void 0, video: void 0, text: s3, id3: r4, initSegment: void 0 };
            (0, i3.isFiniteNumber)(d2) || (d2 = this.lastEndTime = l3 || 0);
            var f2 = t5.samples;
            if (!f2 || !f2.length)
              return h2;
            var p2 = { initPTS: void 0, timescale: 1 }, g2 = this.initData;
            if (g2 && g2.length || (this.generateInitSegment(f2), g2 = this.initData), !g2 || !g2.length)
              return o2.logger.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."), h2;
            this.emitInitSegment && (p2.tracks = this.initTracks, this.emitInitSegment = false);
            var v2 = (0, a2.getStartDTS)(g2, f2);
            (0, i3.isFiniteNumber)(c2) || (this.initPTS = p2.initPTS = c2 = v2 - l3);
            var m2 = (0, a2.getDuration)(f2, g2), y2 = e5 ? v2 - c2 : d2, A2 = y2 + m2;
            (0, a2.offsetStartDTS)(g2, f2, c2), m2 > 0 ? this.lastEndTime = A2 : (o2.logger.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
            var E2 = !!g2.audio, T2 = !!g2.video, b2 = "";
            E2 && (b2 += "audio"), T2 && (b2 += "video");
            var k2 = { data1: f2, startPTS: y2, startDTS: y2, endPTS: A2, endDTS: A2, type: b2, hasAudio: E2, hasVideo: T2, nb: 1, dropped: 0 };
            h2.audio = "audio" === k2.type ? k2 : void 0, h2.video = "audio" !== k2.type ? k2 : void 0, h2.initSegment = p2;
            var S2 = null != (u3 = this.initPTS) ? u3 : 0;
            return h2.id3 = (0, n2.flushTextTrackMetadataCueSamples)(r4, l3, S2, S2), s3.samples.length && (h2.text = (0, n2.flushTextTrackUserdataCueSamples)(s3, l3, S2)), h2;
          }, e4;
        }();
      }
    ), "./src/task-loop.ts": (
      /*!**************************!*\
          !*** ./src/task-loop.ts ***!
          \**************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => i3 });
        var i3 = function() {
          function e4() {
            this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this);
          }
          var t4 = e4.prototype;
          return t4.destroy = function() {
            this.onHandlerDestroying(), this.onHandlerDestroyed();
          }, t4.onHandlerDestroying = function() {
            this.clearNextTick(), this.clearInterval();
          }, t4.onHandlerDestroyed = function() {
          }, t4.hasInterval = function() {
            return !!this._tickInterval;
          }, t4.hasNextTick = function() {
            return !!this._tickTimer;
          }, t4.setInterval = function(e5) {
            return !this._tickInterval && (this._tickInterval = self.setInterval(this._boundTick, e5), true);
          }, t4.clearInterval = function() {
            return !!this._tickInterval && (self.clearInterval(this._tickInterval), this._tickInterval = null, true);
          }, t4.clearNextTick = function() {
            return !!this._tickTimer && (self.clearTimeout(this._tickTimer), this._tickTimer = null, true);
          }, t4.tick = function() {
            this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0);
          }, t4.tickImmediate = function() {
            this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0);
          }, t4.doTick = function() {
          }, e4;
        }();
      }
    ), "./src/types/cmcd.ts": (
      /*!***************************!*\
          !*** ./src/types/cmcd.ts ***!
          \***************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { CMCDObjectType: () => i3, CMCDStreamType: () => a2, CMCDStreamingFormat: () => n2, CMCDVersion: () => s2 });
        var i3, n2, a2, s2 = 1;
        !function(e4) {
          e4.MANIFEST = "m", e4.AUDIO = "a", e4.VIDEO = "v", e4.MUXED = "av", e4.INIT = "i", e4.CAPTION = "c", e4.TIMED_TEXT = "tt", e4.KEY = "k", e4.OTHER = "o";
        }(i3 || (i3 = {})), function(e4) {
          e4.DASH = "d", e4.HLS = "h", e4.SMOOTH = "s", e4.OTHER = "o";
        }(n2 || (n2 = {})), function(e4) {
          e4.VOD = "v", e4.LIVE = "l";
        }(a2 || (a2 = {}));
      }
    ), "./src/types/demuxer.ts": (
      /*!******************************!*\
          !*** ./src/types/demuxer.ts ***!
          \******************************/
      (e3, t3, r3) => {
        var i3;
        r3.r(t3), r3.d(t3, { MetadataSchema: () => i3 }), function(e4) {
          e4.audioId3 = "org.id3", e4.dateRange = "com.apple.quicktime.HLS", e4.emsg = "https://aomedia.org/emsg/ID3";
        }(i3 || (i3 = {}));
      }
    ), "./src/types/level.ts": (
      /*!****************************!*\
          !*** ./src/types/level.ts ***!
          \****************************/
      (e3, t3, r3) => {
        function i3(e4, t4) {
          for (var r4 = 0; r4 < t4.length; r4++) {
            var i4 = t4[r4];
            i4.enumerable = i4.enumerable || false, i4.configurable = true, "value" in i4 && (i4.writable = true), Object.defineProperty(e4, i4.key, i4);
          }
        }
        var n2;
        function a2(e4, t4) {
          var r4 = e4.canSkipUntil, i4 = e4.canSkipDateRanges, a3 = e4.endSN;
          return r4 && (void 0 !== t4 ? t4 - a3 : 0) < r4 ? i4 ? n2.v2 : n2.Yes : n2.No;
        }
        r3.r(t3), r3.d(t3, { HlsSkip: () => n2, HlsUrlParameters: () => s2, Level: () => o2, getSkipValue: () => a2 }), function(e4) {
          e4.No = "", e4.Yes = "YES", e4.v2 = "v2";
        }(n2 || (n2 = {}));
        var s2 = function() {
          function e4(e5, t4, r4) {
            this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e5, this.part = t4, this.skip = r4;
          }
          return e4.prototype.addDirectives = function(e5) {
            var t4 = new self.URL(e5);
            return void 0 !== this.msn && t4.searchParams.set("_HLS_msn", this.msn.toString()), void 0 !== this.part && t4.searchParams.set("_HLS_part", this.part.toString()), this.skip && t4.searchParams.set("_HLS_skip", this.skip), t4.toString();
          }, e4;
        }(), o2 = function() {
          function e4(e5) {
            this.attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.unknownCodecs = void 0, this.audioGroupIds = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.textGroupIds = void 0, this.url = void 0, this._urlId = 0, this.url = [e5.url], this.attrs = e5.attrs, this.bitrate = e5.bitrate, e5.details && (this.details = e5.details), this.id = e5.id || 0, this.name = e5.name, this.width = e5.width || 0, this.height = e5.height || 0, this.audioCodec = e5.audioCodec, this.videoCodec = e5.videoCodec, this.unknownCodecs = e5.unknownCodecs, this.codecSet = [e5.videoCodec, e5.audioCodec].filter(function(e6) {
              return e6;
            }).join(",").replace(/\.[^.,]+/g, "");
          }
          var t4, r4, n3;
          return t4 = e4, (r4 = [{ key: "maxBitrate", get: function() {
            return Math.max(this.realBitrate, this.bitrate);
          } }, { key: "uri", get: function() {
            return this.url[this._urlId] || "";
          } }, { key: "urlId", get: function() {
            return this._urlId;
          }, set: function(e5) {
            var t5 = e5 % this.url.length;
            this._urlId !== t5 && (this.details = void 0, this._urlId = t5);
          } }]) && i3(t4.prototype, r4), n3 && i3(t4, n3), Object.defineProperty(t4, "prototype", { writable: false }), e4;
        }();
      }
    ), "./src/types/loader.ts": (
      /*!*****************************!*\
          !*** ./src/types/loader.ts ***!
          \*****************************/
      (e3, t3, r3) => {
        var i3, n2;
        r3.r(t3), r3.d(t3, { PlaylistContextType: () => i3, PlaylistLevelType: () => n2 }), function(e4) {
          e4.MANIFEST = "manifest", e4.LEVEL = "level", e4.AUDIO_TRACK = "audioTrack", e4.SUBTITLE_TRACK = "subtitleTrack";
        }(i3 || (i3 = {})), function(e4) {
          e4.MAIN = "main", e4.AUDIO = "audio", e4.SUBTITLE = "subtitle";
        }(n2 || (n2 = {}));
      }
    ), "./src/types/transmuxer.ts": (
      /*!*********************************!*\
          !*** ./src/types/transmuxer.ts ***!
          \*********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { ChunkMetadata: () => i3 });
        var i3 = function(e4, t4, r4, i4, n2, a2) {
          void 0 === i4 && (i4 = 0), void 0 === n2 && (n2 = -1), void 0 === a2 && (a2 = false), this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = { start: 0, executeStart: 0, executeEnd: 0, end: 0 }, this.buffering = { audio: { start: 0, executeStart: 0, executeEnd: 0, end: 0 }, video: { start: 0, executeStart: 0, executeEnd: 0, end: 0 }, audiovideo: { start: 0, executeStart: 0, executeEnd: 0, end: 0 } }, this.level = e4, this.sn = t4, this.id = r4, this.size = i4, this.part = n2, this.partial = a2;
        };
      }
    ), "./src/utils/attr-list.ts": (
      /*!********************************!*\
          !*** ./src/utils/attr-list.ts ***!
          \********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { AttrList: () => a2 });
        var i3 = /^(\d+)x(\d+)$/, n2 = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g, a2 = function() {
          function e4(t5) {
            for (var r4 in "string" == typeof t5 && (t5 = e4.parseAttrList(t5)), t5)
              t5.hasOwnProperty(r4) && (this[r4] = t5[r4]);
          }
          var t4 = e4.prototype;
          return t4.decimalInteger = function(e5) {
            var t5 = parseInt(this[e5], 10);
            return t5 > Number.MAX_SAFE_INTEGER ? 1 / 0 : t5;
          }, t4.hexadecimalInteger = function(e5) {
            if (this[e5]) {
              var t5 = (this[e5] || "0x").slice(2);
              t5 = (1 & t5.length ? "0" : "") + t5;
              for (var r4 = new Uint8Array(t5.length / 2), i4 = 0; i4 < t5.length / 2; i4++)
                r4[i4] = parseInt(t5.slice(2 * i4, 2 * i4 + 2), 16);
              return r4;
            }
            return null;
          }, t4.hexadecimalIntegerAsNumber = function(e5) {
            var t5 = parseInt(this[e5], 16);
            return t5 > Number.MAX_SAFE_INTEGER ? 1 / 0 : t5;
          }, t4.decimalFloatingPoint = function(e5) {
            return parseFloat(this[e5]);
          }, t4.optionalFloat = function(e5, t5) {
            var r4 = this[e5];
            return r4 ? parseFloat(r4) : t5;
          }, t4.enumeratedString = function(e5) {
            return this[e5];
          }, t4.bool = function(e5) {
            return "YES" === this[e5];
          }, t4.decimalResolution = function(e5) {
            var t5 = i3.exec(this[e5]);
            if (null !== t5)
              return { width: parseInt(t5[1], 10), height: parseInt(t5[2], 10) };
          }, e4.parseAttrList = function(e5) {
            var t5, r4 = {};
            for (n2.lastIndex = 0; null !== (t5 = n2.exec(e5)); ) {
              var i4 = t5[2];
              0 === i4.indexOf('"') && i4.lastIndexOf('"') === i4.length - 1 && (i4 = i4.slice(1, -1)), r4[t5[1]] = i4;
            }
            return r4;
          }, e4;
        }();
      }
    ), "./src/utils/binary-search.ts": (
      /*!************************************!*\
          !*** ./src/utils/binary-search.ts ***!
          \************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => i3 });
        const i3 = { search: function(e4, t4) {
          for (var r4 = 0, i4 = e4.length - 1, n2 = null, a2 = null; r4 <= i4; ) {
            var s2 = t4(a2 = e4[n2 = (r4 + i4) / 2 | 0]);
            if (s2 > 0)
              r4 = n2 + 1;
            else {
              if (!(s2 < 0))
                return a2;
              i4 = n2 - 1;
            }
          }
          return null;
        } };
      }
    ), "./src/utils/buffer-helper.ts": (
      /*!************************************!*\
          !*** ./src/utils/buffer-helper.ts ***!
          \************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { BufferHelper: () => a2 });
        var i3 = r3(
          /*! ./logger */
          "./src/utils/logger.ts"
        ), n2 = { length: 0, start: function() {
          return 0;
        }, end: function() {
          return 0;
        } }, a2 = function() {
          function e4() {
          }
          return e4.isBuffered = function(t4, r4) {
            try {
              if (t4) {
                for (var i4 = e4.getBuffered(t4), n3 = 0; n3 < i4.length; n3++)
                  if (r4 >= i4.start(n3) && r4 <= i4.end(n3))
                    return true;
              }
            } catch (e5) {
            }
            return false;
          }, e4.bufferInfo = function(t4, r4, i4) {
            try {
              if (t4) {
                var n3, a3 = e4.getBuffered(t4), s2 = [];
                for (n3 = 0; n3 < a3.length; n3++)
                  s2.push({ start: a3.start(n3), end: a3.end(n3) });
                return this.bufferedInfo(s2, r4, i4);
              }
            } catch (e5) {
            }
            return { len: 0, start: r4, end: r4, nextStart: void 0 };
          }, e4.bufferedInfo = function(e5, t4, r4) {
            t4 = Math.max(0, t4), e5.sort(function(e6, t5) {
              var r5 = e6.start - t5.start;
              return r5 || t5.end - e6.end;
            });
            var i4 = [];
            if (r4)
              for (var n3 = 0; n3 < e5.length; n3++) {
                var a3 = i4.length;
                if (a3) {
                  var s2 = i4[a3 - 1].end;
                  e5[n3].start - s2 < r4 ? e5[n3].end > s2 && (i4[a3 - 1].end = e5[n3].end) : i4.push(e5[n3]);
                } else
                  i4.push(e5[n3]);
              }
            else
              i4 = e5;
            for (var o2, l2 = 0, u2 = t4, c2 = t4, d2 = 0; d2 < i4.length; d2++) {
              var h2 = i4[d2].start, f2 = i4[d2].end;
              if (t4 + r4 >= h2 && t4 < f2)
                u2 = h2, l2 = (c2 = f2) - t4;
              else if (t4 + r4 < h2) {
                o2 = h2;
                break;
              }
            }
            return { len: l2, start: u2 || 0, end: c2 || 0, nextStart: o2 };
          }, e4.getBuffered = function(e5) {
            try {
              return e5.buffered;
            } catch (e6) {
              return i3.logger.log("failed to get media.buffered", e6), n2;
            }
          }, e4;
        }();
      }
    ), "./src/utils/cea-608-parser.ts": (
      /*!*************************************!*\
          !*** ./src/utils/cea-608-parser.ts ***!
          \*************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { CaptionScreen: () => A2, Row: () => y2, default: () => S2 });
        var i3, n2 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), a2 = { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 128: 174, 129: 176, 130: 189, 131: 191, 132: 8482, 133: 162, 134: 163, 135: 9834, 136: 224, 137: 32, 138: 232, 139: 226, 140: 234, 141: 238, 142: 244, 143: 251, 144: 193, 145: 201, 146: 211, 147: 218, 148: 220, 149: 252, 150: 8216, 151: 161, 152: 42, 153: 8217, 154: 9473, 155: 169, 156: 8480, 157: 8226, 158: 8220, 159: 8221, 160: 192, 161: 194, 162: 199, 163: 200, 164: 202, 165: 203, 166: 235, 167: 206, 168: 207, 169: 239, 170: 212, 171: 217, 172: 249, 173: 219, 174: 171, 175: 187, 176: 195, 177: 227, 178: 205, 179: 204, 180: 236, 181: 210, 182: 242, 183: 213, 184: 245, 185: 123, 186: 125, 187: 92, 188: 94, 189: 95, 190: 124, 191: 8764, 192: 196, 193: 228, 194: 214, 195: 246, 196: 223, 197: 165, 198: 164, 199: 9475, 200: 197, 201: 229, 202: 216, 203: 248, 204: 9487, 205: 9491, 206: 9495, 207: 9499 }, s2 = function(e4) {
          var t4 = e4;
          return a2.hasOwnProperty(e4) && (t4 = a2[e4]), String.fromCharCode(t4);
        }, o2 = 15, l2 = 100, u2 = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 }, c2 = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 }, d2 = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 }, h2 = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 }, f2 = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
        !function(e4) {
          e4[e4.ERROR = 0] = "ERROR", e4[e4.TEXT = 1] = "TEXT", e4[e4.WARNING = 2] = "WARNING", e4[e4.INFO = 2] = "INFO", e4[e4.DEBUG = 3] = "DEBUG", e4[e4.DATA = 3] = "DATA";
        }(i3 || (i3 = {}));
        var p2 = function() {
          function e4() {
            this.time = null, this.verboseLevel = i3.ERROR;
          }
          return e4.prototype.log = function(e5, t4) {
            this.verboseLevel >= e5 && n2.logger.log(this.time + " [" + e5 + "] " + t4);
          }, e4;
        }(), g2 = function(e4) {
          for (var t4 = [], r4 = 0; r4 < e4.length; r4++)
            t4.push(e4[r4].toString(16));
          return t4;
        }, v2 = function() {
          function e4(e5, t5, r4, i4, n3) {
            this.foreground = void 0, this.underline = void 0, this.italics = void 0, this.background = void 0, this.flash = void 0, this.foreground = e5 || "white", this.underline = t5 || false, this.italics = r4 || false, this.background = i4 || "black", this.flash = n3 || false;
          }
          var t4 = e4.prototype;
          return t4.reset = function() {
            this.foreground = "white", this.underline = false, this.italics = false, this.background = "black", this.flash = false;
          }, t4.setStyles = function(e5) {
            for (var t5 = ["foreground", "underline", "italics", "background", "flash"], r4 = 0; r4 < t5.length; r4++) {
              var i4 = t5[r4];
              e5.hasOwnProperty(i4) && (this[i4] = e5[i4]);
            }
          }, t4.isDefault = function() {
            return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash;
          }, t4.equals = function(e5) {
            return this.foreground === e5.foreground && this.underline === e5.underline && this.italics === e5.italics && this.background === e5.background && this.flash === e5.flash;
          }, t4.copy = function(e5) {
            this.foreground = e5.foreground, this.underline = e5.underline, this.italics = e5.italics, this.background = e5.background, this.flash = e5.flash;
          }, t4.toString = function() {
            return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
          }, e4;
        }(), m2 = function() {
          function e4(e5, t5, r4, i4, n3, a3) {
            this.uchar = void 0, this.penState = void 0, this.uchar = e5 || " ", this.penState = new v2(t5, r4, i4, n3, a3);
          }
          var t4 = e4.prototype;
          return t4.reset = function() {
            this.uchar = " ", this.penState.reset();
          }, t4.setChar = function(e5, t5) {
            this.uchar = e5, this.penState.copy(t5);
          }, t4.setPenState = function(e5) {
            this.penState.copy(e5);
          }, t4.equals = function(e5) {
            return this.uchar === e5.uchar && this.penState.equals(e5.penState);
          }, t4.copy = function(e5) {
            this.uchar = e5.uchar, this.penState.copy(e5.penState);
          }, t4.isEmpty = function() {
            return " " === this.uchar && this.penState.isDefault();
          }, e4;
        }(), y2 = function() {
          function e4(e5) {
            this.chars = void 0, this.pos = void 0, this.currPenState = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chars = [];
            for (var t5 = 0; t5 < l2; t5++)
              this.chars.push(new m2());
            this.logger = e5, this.pos = 0, this.currPenState = new v2();
          }
          var t4 = e4.prototype;
          return t4.equals = function(e5) {
            for (var t5 = true, r4 = 0; r4 < l2; r4++)
              if (!this.chars[r4].equals(e5.chars[r4])) {
                t5 = false;
                break;
              }
            return t5;
          }, t4.copy = function(e5) {
            for (var t5 = 0; t5 < l2; t5++)
              this.chars[t5].copy(e5.chars[t5]);
          }, t4.isEmpty = function() {
            for (var e5 = true, t5 = 0; t5 < l2; t5++)
              if (!this.chars[t5].isEmpty()) {
                e5 = false;
                break;
              }
            return e5;
          }, t4.setCursor = function(e5) {
            this.pos !== e5 && (this.pos = e5), this.pos < 0 ? (this.logger.log(i3.DEBUG, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > l2 && (this.logger.log(i3.DEBUG, "Too large cursor position " + this.pos), this.pos = l2);
          }, t4.moveCursor = function(e5) {
            var t5 = this.pos + e5;
            if (e5 > 1)
              for (var r4 = this.pos + 1; r4 < t5 + 1; r4++)
                this.chars[r4].setPenState(this.currPenState);
            this.setCursor(t5);
          }, t4.backSpace = function() {
            this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState);
          }, t4.insertChar = function(e5) {
            e5 >= 144 && this.backSpace();
            var t5 = s2(e5);
            this.pos >= l2 ? this.logger.log(i3.ERROR, "Cannot insert " + e5.toString(16) + " (" + t5 + ") at position " + this.pos + ". Skipping it!") : (this.chars[this.pos].setChar(t5, this.currPenState), this.moveCursor(1));
          }, t4.clearFromPos = function(e5) {
            var t5;
            for (t5 = e5; t5 < l2; t5++)
              this.chars[t5].reset();
          }, t4.clear = function() {
            this.clearFromPos(0), this.pos = 0, this.currPenState.reset();
          }, t4.clearToEndOfRow = function() {
            this.clearFromPos(this.pos);
          }, t4.getTextString = function() {
            for (var e5 = [], t5 = true, r4 = 0; r4 < l2; r4++) {
              var i4 = this.chars[r4].uchar;
              " " !== i4 && (t5 = false), e5.push(i4);
            }
            return t5 ? "" : e5.join("");
          }, t4.setPenStyles = function(e5) {
            this.currPenState.setStyles(e5), this.chars[this.pos].setPenState(this.currPenState);
          }, e4;
        }(), A2 = function() {
          function e4(e5) {
            this.rows = void 0, this.currRow = void 0, this.nrRollUpRows = void 0, this.lastOutputScreen = void 0, this.logger = void 0, this.rows = [];
            for (var t5 = 0; t5 < o2; t5++)
              this.rows.push(new y2(e5));
            this.logger = e5, this.currRow = 14, this.nrRollUpRows = null, this.lastOutputScreen = null, this.reset();
          }
          var t4 = e4.prototype;
          return t4.reset = function() {
            for (var e5 = 0; e5 < o2; e5++)
              this.rows[e5].clear();
            this.currRow = 14;
          }, t4.equals = function(e5) {
            for (var t5 = true, r4 = 0; r4 < o2; r4++)
              if (!this.rows[r4].equals(e5.rows[r4])) {
                t5 = false;
                break;
              }
            return t5;
          }, t4.copy = function(e5) {
            for (var t5 = 0; t5 < o2; t5++)
              this.rows[t5].copy(e5.rows[t5]);
          }, t4.isEmpty = function() {
            for (var e5 = true, t5 = 0; t5 < o2; t5++)
              if (!this.rows[t5].isEmpty()) {
                e5 = false;
                break;
              }
            return e5;
          }, t4.backSpace = function() {
            this.rows[this.currRow].backSpace();
          }, t4.clearToEndOfRow = function() {
            this.rows[this.currRow].clearToEndOfRow();
          }, t4.insertChar = function(e5) {
            this.rows[this.currRow].insertChar(e5);
          }, t4.setPen = function(e5) {
            this.rows[this.currRow].setPenStyles(e5);
          }, t4.moveCursor = function(e5) {
            this.rows[this.currRow].moveCursor(e5);
          }, t4.setCursor = function(e5) {
            this.logger.log(i3.INFO, "setCursor: " + e5), this.rows[this.currRow].setCursor(e5);
          }, t4.setPAC = function(e5) {
            this.logger.log(i3.INFO, "pacData = " + JSON.stringify(e5));
            var t5 = e5.row - 1;
            if (this.nrRollUpRows && t5 < this.nrRollUpRows - 1 && (t5 = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t5) {
              for (var r4 = 0; r4 < o2; r4++)
                this.rows[r4].clear();
              var n3 = this.currRow + 1 - this.nrRollUpRows, a3 = this.lastOutputScreen;
              if (a3) {
                var s3 = a3.rows[n3].cueStartTime, l3 = this.logger.time;
                if (s3 && null !== l3 && s3 < l3)
                  for (var u3 = 0; u3 < this.nrRollUpRows; u3++)
                    this.rows[t5 - this.nrRollUpRows + u3 + 1].copy(a3.rows[n3 + u3]);
              }
            }
            this.currRow = t5;
            var c3 = this.rows[this.currRow];
            if (null !== e5.indent) {
              var d3 = e5.indent, h3 = Math.max(d3 - 1, 0);
              c3.setCursor(e5.indent), e5.color = c3.chars[h3].penState.foreground;
            }
            var f3 = { foreground: e5.color, underline: e5.underline, italics: e5.italics, background: "black", flash: false };
            this.setPen(f3);
          }, t4.setBkgData = function(e5) {
            this.logger.log(i3.INFO, "bkgData = " + JSON.stringify(e5)), this.backSpace(), this.setPen(e5), this.insertChar(32);
          }, t4.setRollUpRows = function(e5) {
            this.nrRollUpRows = e5;
          }, t4.rollUp = function() {
            if (null !== this.nrRollUpRows) {
              this.logger.log(i3.TEXT, this.getDisplayText());
              var e5 = this.currRow + 1 - this.nrRollUpRows, t5 = this.rows.splice(e5, 1)[0];
              t5.clear(), this.rows.splice(this.currRow, 0, t5), this.logger.log(i3.INFO, "Rolling up");
            } else
              this.logger.log(i3.DEBUG, "roll_up but nrRollUpRows not set yet");
          }, t4.getDisplayText = function(e5) {
            e5 = e5 || false;
            for (var t5 = [], r4 = "", i4 = -1, n3 = 0; n3 < o2; n3++) {
              var a3 = this.rows[n3].getTextString();
              a3 && (i4 = n3 + 1, e5 ? t5.push("Row " + i4 + ": '" + a3 + "'") : t5.push(a3.trim()));
            }
            return t5.length > 0 && (r4 = e5 ? "[" + t5.join(" | ") + "]" : t5.join("\n")), r4;
          }, t4.getTextAndFormat = function() {
            return this.rows;
          }, e4;
        }(), E2 = function() {
          function e4(e5, t5, r4) {
            this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e5, this.outputFilter = t5, this.mode = null, this.verbose = 0, this.displayedMemory = new A2(r4), this.nonDisplayedMemory = new A2(r4), this.lastOutputScreen = new A2(r4), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = r4;
          }
          var t4 = e4.prototype;
          return t4.reset = function() {
            this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;
          }, t4.getHandler = function() {
            return this.outputFilter;
          }, t4.setHandler = function(e5) {
            this.outputFilter = e5;
          }, t4.setPAC = function(e5) {
            this.writeScreen.setPAC(e5);
          }, t4.setBkgData = function(e5) {
            this.writeScreen.setBkgData(e5);
          }, t4.setMode = function(e5) {
            e5 !== this.mode && (this.mode = e5, this.logger.log(i3.INFO, "MODE=" + e5), "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e5);
          }, t4.insertChars = function(e5) {
            for (var t5 = 0; t5 < e5.length; t5++)
              this.writeScreen.insertChar(e5[t5]);
            var r4 = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
            this.logger.log(i3.INFO, r4 + ": " + this.writeScreen.getDisplayText(true)), "MODE_PAINT-ON" !== this.mode && "MODE_ROLL-UP" !== this.mode || (this.logger.log(i3.TEXT, "DISPLAYED: " + this.displayedMemory.getDisplayText(true)), this.outputDataUpdate());
          }, t4.ccRCL = function() {
            this.logger.log(i3.INFO, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON");
          }, t4.ccBS = function() {
            this.logger.log(i3.INFO, "BS - BackSpace"), "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate());
          }, t4.ccAOF = function() {
          }, t4.ccAON = function() {
          }, t4.ccDER = function() {
            this.logger.log(i3.INFO, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();
          }, t4.ccRU = function(e5) {
            this.logger.log(i3.INFO, "RU(" + e5 + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e5);
          }, t4.ccFON = function() {
            this.logger.log(i3.INFO, "FON - Flash On"), this.writeScreen.setPen({ flash: true });
          }, t4.ccRDC = function() {
            this.logger.log(i3.INFO, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON");
          }, t4.ccTR = function() {
            this.logger.log(i3.INFO, "TR"), this.setMode("MODE_TEXT");
          }, t4.ccRTD = function() {
            this.logger.log(i3.INFO, "RTD"), this.setMode("MODE_TEXT");
          }, t4.ccEDM = function() {
            this.logger.log(i3.INFO, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(true);
          }, t4.ccCR = function() {
            this.logger.log(i3.INFO, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(true);
          }, t4.ccENM = function() {
            this.logger.log(i3.INFO, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset();
          }, t4.ccEOC = function() {
            if (this.logger.log(i3.INFO, "EOC - End Of Caption"), "MODE_POP-ON" === this.mode) {
              var e5 = this.displayedMemory;
              this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e5, this.writeScreen = this.nonDisplayedMemory, this.logger.log(i3.TEXT, "DISP: " + this.displayedMemory.getDisplayText());
            }
            this.outputDataUpdate(true);
          }, t4.ccTO = function(e5) {
            this.logger.log(i3.INFO, "TO(" + e5 + ") - Tab Offset"), this.writeScreen.moveCursor(e5);
          }, t4.ccMIDROW = function(e5) {
            var t5 = { flash: false };
            if (t5.underline = e5 % 2 == 1, t5.italics = e5 >= 46, t5.italics)
              t5.foreground = "white";
            else {
              var r4 = Math.floor(e5 / 2) - 16;
              t5.foreground = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"][r4];
            }
            this.logger.log(i3.INFO, "MIDROW: " + JSON.stringify(t5)), this.writeScreen.setPen(t5);
          }, t4.outputDataUpdate = function(e5) {
            void 0 === e5 && (e5 = false);
            var t5 = this.logger.time;
            null !== t5 && this.outputFilter && (null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t5, this.lastOutputScreen), e5 && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t5) : this.cueStartTime = t5, this.lastOutputScreen.copy(this.displayedMemory));
          }, t4.cueSplitAtTime = function(e5) {
            this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e5, this.displayedMemory), this.cueStartTime = e5));
          }, e4;
        }(), T2 = function() {
          function e4(e5, t5, r4) {
            this.channels = void 0, this.currentChannel = 0, this.cmdHistory = void 0, this.logger = void 0;
            var i4 = new p2();
            this.channels = [null, new E2(e5, t5, i4), new E2(e5 + 1, r4, i4)], this.cmdHistory = { a: null, b: null }, this.logger = i4;
          }
          var t4 = e4.prototype;
          return t4.getHandler = function(e5) {
            return this.channels[e5].getHandler();
          }, t4.setHandler = function(e5, t5) {
            this.channels[e5].setHandler(t5);
          }, t4.addData = function(e5, t5) {
            var r4, n3, a3, s3 = false;
            this.logger.time = e5;
            for (var o3 = 0; o3 < t5.length; o3 += 2)
              if (n3 = 127 & t5[o3], a3 = 127 & t5[o3 + 1], 0 !== n3 || 0 !== a3) {
                if (this.logger.log(i3.DATA, "[" + g2([t5[o3], t5[o3 + 1]]) + "] -> (" + g2([n3, a3]) + ")"), (r4 = this.parseCmd(n3, a3)) || (r4 = this.parseMidrow(n3, a3)), r4 || (r4 = this.parsePAC(n3, a3)), r4 || (r4 = this.parseBackgroundAttributes(n3, a3)), !r4 && (s3 = this.parseChars(n3, a3))) {
                  var l3 = this.currentChannel;
                  l3 && l3 > 0 ? this.channels[l3].insertChars(s3) : this.logger.log(i3.WARNING, "No channel found yet. TEXT-MODE?");
                }
                r4 || s3 || this.logger.log(i3.WARNING, "Couldn't parse cleaned data " + g2([n3, a3]) + " orig: " + g2([t5[o3], t5[o3 + 1]]));
              }
          }, t4.parseCmd = function(e5, t5) {
            var r4 = this.cmdHistory;
            if (!((20 === e5 || 28 === e5 || 21 === e5 || 29 === e5) && t5 >= 32 && t5 <= 47 || (23 === e5 || 31 === e5) && t5 >= 33 && t5 <= 35))
              return false;
            if (k2(e5, t5, r4))
              return b2(null, null, r4), this.logger.log(i3.DEBUG, "Repeated command (" + g2([e5, t5]) + ") is dropped"), true;
            var n3 = 20 === e5 || 21 === e5 || 23 === e5 ? 1 : 2, a3 = this.channels[n3];
            return 20 === e5 || 21 === e5 || 28 === e5 || 29 === e5 ? 32 === t5 ? a3.ccRCL() : 33 === t5 ? a3.ccBS() : 34 === t5 ? a3.ccAOF() : 35 === t5 ? a3.ccAON() : 36 === t5 ? a3.ccDER() : 37 === t5 ? a3.ccRU(2) : 38 === t5 ? a3.ccRU(3) : 39 === t5 ? a3.ccRU(4) : 40 === t5 ? a3.ccFON() : 41 === t5 ? a3.ccRDC() : 42 === t5 ? a3.ccTR() : 43 === t5 ? a3.ccRTD() : 44 === t5 ? a3.ccEDM() : 45 === t5 ? a3.ccCR() : 46 === t5 ? a3.ccENM() : 47 === t5 && a3.ccEOC() : a3.ccTO(t5 - 32), b2(e5, t5, r4), this.currentChannel = n3, true;
          }, t4.parseMidrow = function(e5, t5) {
            var r4 = 0;
            if ((17 === e5 || 25 === e5) && t5 >= 32 && t5 <= 47) {
              if ((r4 = 17 === e5 ? 1 : 2) !== this.currentChannel)
                return this.logger.log(i3.ERROR, "Mismatch channel in midrow parsing"), false;
              var n3 = this.channels[r4];
              return !!n3 && (n3.ccMIDROW(t5), this.logger.log(i3.DEBUG, "MIDROW (" + g2([e5, t5]) + ")"), true);
            }
            return false;
          }, t4.parsePAC = function(e5, t5) {
            var r4, i4 = this.cmdHistory;
            if (!((e5 >= 17 && e5 <= 23 || e5 >= 25 && e5 <= 31) && t5 >= 64 && t5 <= 127 || (16 === e5 || 24 === e5) && t5 >= 64 && t5 <= 95))
              return false;
            if (k2(e5, t5, i4))
              return b2(null, null, i4), true;
            var n3 = e5 <= 23 ? 1 : 2;
            r4 = t5 >= 64 && t5 <= 95 ? 1 === n3 ? u2[e5] : d2[e5] : 1 === n3 ? c2[e5] : h2[e5];
            var a3 = this.channels[n3];
            return !!a3 && (a3.setPAC(this.interpretPAC(r4, t5)), b2(e5, t5, i4), this.currentChannel = n3, true);
          }, t4.interpretPAC = function(e5, t5) {
            var r4, i4 = { color: null, italics: false, indent: null, underline: false, row: e5 };
            return r4 = t5 > 95 ? t5 - 96 : t5 - 64, i4.underline = 1 == (1 & r4), r4 <= 13 ? i4.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(r4 / 2)] : r4 <= 15 ? (i4.italics = true, i4.color = "white") : i4.indent = 4 * Math.floor((r4 - 16) / 2), i4;
          }, t4.parseChars = function(e5, t5) {
            var r4, n3, a3 = null, o3 = null;
            if (e5 >= 25 ? (r4 = 2, o3 = e5 - 8) : (r4 = 1, o3 = e5), o3 >= 17 && o3 <= 19 ? (n3 = 17 === o3 ? t5 + 80 : 18 === o3 ? t5 + 112 : t5 + 144, this.logger.log(i3.INFO, "Special char '" + s2(n3) + "' in channel " + r4), a3 = [n3]) : e5 >= 32 && e5 <= 127 && (a3 = 0 === t5 ? [e5] : [e5, t5]), a3) {
              var l3 = g2(a3);
              this.logger.log(i3.DEBUG, "Char codes =  " + l3.join(",")), b2(e5, t5, this.cmdHistory);
            }
            return a3;
          }, t4.parseBackgroundAttributes = function(e5, t5) {
            var r4;
            if (!((16 === e5 || 24 === e5) && t5 >= 32 && t5 <= 47 || (23 === e5 || 31 === e5) && t5 >= 45 && t5 <= 47))
              return false;
            var i4 = {};
            16 === e5 || 24 === e5 ? (r4 = Math.floor((t5 - 32) / 2), i4.background = f2[r4], t5 % 2 == 1 && (i4.background = i4.background + "_semi")) : 45 === t5 ? i4.background = "transparent" : (i4.foreground = "black", 47 === t5 && (i4.underline = true));
            var n3 = e5 <= 23 ? 1 : 2;
            return this.channels[n3].setBkgData(i4), b2(e5, t5, this.cmdHistory), true;
          }, t4.reset = function() {
            for (var e5 = 0; e5 < Object.keys(this.channels).length; e5++) {
              var t5 = this.channels[e5];
              t5 && t5.reset();
            }
            this.cmdHistory = { a: null, b: null };
          }, t4.cueSplitAtTime = function(e5) {
            for (var t5 = 0; t5 < this.channels.length; t5++) {
              var r4 = this.channels[t5];
              r4 && r4.cueSplitAtTime(e5);
            }
          }, e4;
        }();
        function b2(e4, t4, r4) {
          r4.a = e4, r4.b = t4;
        }
        function k2(e4, t4, r4) {
          return r4.a === e4 && r4.b === t4;
        }
        const S2 = T2;
      }
    ), "./src/utils/codecs.ts": (
      /*!*****************************!*\
          !*** ./src/utils/codecs.ts ***!
          \*****************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { isCodecSupportedInMp4: () => a2, isCodecType: () => n2 });
        var i3 = { audio: { a3ds: true, "ac-3": true, "ac-4": true, alac: true, alaw: true, dra1: true, "dts+": true, "dts-": true, dtsc: true, dtse: true, dtsh: true, "ec-3": true, enca: true, g719: true, g726: true, m4ae: true, mha1: true, mha2: true, mhm1: true, mhm2: true, mlpa: true, mp4a: true, "raw ": true, Opus: true, opus: true, samr: true, sawb: true, sawp: true, sevc: true, sqcp: true, ssmv: true, twos: true, ulaw: true }, video: { avc1: true, avc2: true, avc3: true, avc4: true, avcp: true, av01: true, drac: true, dva1: true, dvav: true, dvh1: true, dvhe: true, encv: true, hev1: true, hvc1: true, mjp2: true, mp4v: true, mvc1: true, mvc2: true, mvc3: true, mvc4: true, resv: true, rv60: true, s263: true, svc1: true, svc2: true, "vc-1": true, vp08: true, vp09: true }, text: { stpp: true, wvtt: true } };
        function n2(e4, t4) {
          var r4 = i3[t4];
          return !!r4 && true === r4[e4.slice(0, 4)];
        }
        function a2(e4, t4) {
          return MediaSource.isTypeSupported((t4 || "video") + '/mp4;codecs="' + e4 + '"');
        }
      }
    ), "./src/utils/cues.ts": (
      /*!***************************!*\
          !*** ./src/utils/cues.ts ***!
          \***************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => o2 });
        var i3 = r3(
          /*! ./vttparser */
          "./src/utils/vttparser.ts"
        ), n2 = r3(
          /*! ./webvtt-parser */
          "./src/utils/webvtt-parser.ts"
        ), a2 = r3(
          /*! ./texttrack-utils */
          "./src/utils/texttrack-utils.ts"
        ), s2 = /\s/;
        const o2 = { newCue: function(e4, t4, r4, o3) {
          for (var l2, u2, c2, d2, h2, f2 = [], p2 = self.VTTCue || self.TextTrackCue, g2 = 0; g2 < o3.rows.length; g2++)
            if (c2 = true, d2 = 0, h2 = "", !(l2 = o3.rows[g2]).isEmpty()) {
              for (var v2 = 0; v2 < l2.chars.length; v2++)
                s2.test(l2.chars[v2].uchar) && c2 ? d2++ : (h2 += l2.chars[v2].uchar, c2 = false);
              l2.cueStartTime = t4, t4 === r4 && (r4 += 1e-4), d2 >= 16 ? d2-- : d2++;
              var m2 = (0, i3.fixLineBreaks)(h2.trim()), y2 = (0, n2.generateCueId)(t4, r4, m2);
              e4 && e4.cues && e4.cues.getCueById(y2) || ((u2 = new p2(t4, r4, m2)).id = y2, u2.line = g2 + 1, u2.align = "left", u2.position = 10 + Math.min(80, 10 * Math.floor(8 * d2 / 32)), f2.push(u2));
            }
          return e4 && f2.length && (f2.sort(function(e5, t5) {
            return "auto" === e5.line || "auto" === t5.line ? 0 : e5.line > 8 && t5.line > 8 ? t5.line - e5.line : e5.line - t5.line;
          }), f2.forEach(function(t5) {
            return (0, a2.addCueToTrack)(e4, t5);
          })), f2;
        } };
      }
    ), "./src/utils/discontinuities.ts": (
      /*!**************************************!*\
          !*** ./src/utils/discontinuities.ts ***!
          \**************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { adjustSlidingStart: () => c2, alignMediaPlaylistByPDT: () => f2, alignPDT: () => h2, alignStream: () => d2, findDiscontinuousReferenceFrag: () => l2, findFirstFragWithCC: () => s2, shouldAlignOnDiscontinuities: () => o2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ./logger */
          "./src/utils/logger.ts"
        ), a2 = r3(
          /*! ../controller/level-helper */
          "./src/controller/level-helper.ts"
        );
        function s2(e4, t4) {
          for (var r4 = null, i4 = 0, n3 = e4.length; i4 < n3; i4++) {
            var a3 = e4[i4];
            if (a3 && a3.cc === t4) {
              r4 = a3;
              break;
            }
          }
          return r4;
        }
        function o2(e4, t4, r4) {
          return !(!t4.details || !(r4.endCC > r4.startCC || e4 && e4.cc < r4.startCC));
        }
        function l2(e4, t4, r4) {
          var i4 = e4.fragments, a3 = t4.fragments;
          if (a3.length && i4.length) {
            var o3 = s2(i4, a3[0].cc);
            if (o3 && (!o3 || o3.startPTS))
              return o3;
            n2.logger.log("No frag in previous level to align on");
          } else
            n2.logger.log("No fragments to align");
        }
        function u2(e4, t4) {
          if (e4) {
            var r4 = e4.start + t4;
            e4.start = e4.startPTS = r4, e4.endPTS = r4 + e4.duration;
          }
        }
        function c2(e4, t4) {
          for (var r4 = t4.fragments, i4 = 0, n3 = r4.length; i4 < n3; i4++)
            u2(r4[i4], e4);
          t4.fragmentHint && u2(t4.fragmentHint, e4), t4.alignedSliding = true;
        }
        function d2(e4, t4, r4) {
          t4 && (function(e5, t5, r5) {
            if (o2(e5, r5, t5)) {
              var a3 = l2(r5.details, t5);
              a3 && (0, i3.isFiniteNumber)(a3.start) && (n2.logger.log("Adjusting PTS using last level due to CC increase within current level " + t5.url), c2(a3.start, t5));
            }
          }(e4, r4, t4), !r4.alignedSliding && t4.details && h2(r4, t4.details), r4.alignedSliding || !t4.details || r4.skippedSegments || (0, a2.adjustSliding)(t4.details, r4));
        }
        function h2(e4, t4) {
          if (t4.fragments.length && e4.hasProgramDateTime && t4.hasProgramDateTime) {
            var r4 = t4.fragments[0].programDateTime, a3 = e4.fragments[0].programDateTime, s3 = (a3 - r4) / 1e3 + t4.fragments[0].start;
            s3 && (0, i3.isFiniteNumber)(s3) && (n2.logger.log("Adjusting PTS using programDateTime delta " + (a3 - r4) + "ms, sliding:" + s3.toFixed(3) + " " + e4.url + " "), c2(s3, e4));
          }
        }
        function f2(e4, t4) {
          if (e4.hasProgramDateTime && t4.hasProgramDateTime) {
            var r4 = e4.fragments, i4 = t4.fragments;
            if (r4.length && i4.length) {
              var n3 = i4[Math.round(i4.length / 2) - 1], a3 = s2(r4, n3.cc) || r4[Math.round(r4.length / 2) - 1], o3 = n3.programDateTime, l3 = a3.programDateTime;
              null !== o3 && null !== l3 && c2((l3 - o3) / 1e3 - (a3.start - n3.start), e4);
            }
          }
        }
      }
    ), "./src/utils/ewma-bandwidth-estimator.ts": (
      /*!***********************************************!*\
          !*** ./src/utils/ewma-bandwidth-estimator.ts ***!
          \***********************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => n2 });
        var i3 = r3(
          /*! ../utils/ewma */
          "./src/utils/ewma.ts"
        );
        const n2 = function() {
          function e4(e5, t5, r4) {
            this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultEstimate_ = r4, this.minWeight_ = 1e-3, this.minDelayMs_ = 50, this.slow_ = new i3.default(e5), this.fast_ = new i3.default(t5);
          }
          var t4 = e4.prototype;
          return t4.update = function(e5, t5) {
            var r4 = this.slow_, n3 = this.fast_;
            this.slow_.halfLife !== e5 && (this.slow_ = new i3.default(e5, r4.getEstimate(), r4.getTotalWeight())), this.fast_.halfLife !== t5 && (this.fast_ = new i3.default(t5, n3.getEstimate(), n3.getTotalWeight()));
          }, t4.sample = function(e5, t5) {
            var r4 = (e5 = Math.max(e5, this.minDelayMs_)) / 1e3, i4 = 8 * t5 / r4;
            this.fast_.sample(r4, i4), this.slow_.sample(r4, i4);
          }, t4.canEstimate = function() {
            var e5 = this.fast_;
            return e5 && e5.getTotalWeight() >= this.minWeight_;
          }, t4.getEstimate = function() {
            return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;
          }, t4.destroy = function() {
          }, e4;
        }();
      }
    ), "./src/utils/ewma.ts": (
      /*!***************************!*\
          !*** ./src/utils/ewma.ts ***!
          \***************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => i3 });
        const i3 = function() {
          function e4(e5, t5, r4) {
            void 0 === t5 && (t5 = 0), void 0 === r4 && (r4 = 0), this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e5, this.alpha_ = e5 ? Math.exp(Math.log(0.5) / e5) : 0, this.estimate_ = t5, this.totalWeight_ = r4;
          }
          var t4 = e4.prototype;
          return t4.sample = function(e5, t5) {
            var r4 = Math.pow(this.alpha_, e5);
            this.estimate_ = t5 * (1 - r4) + r4 * this.estimate_, this.totalWeight_ += e5;
          }, t4.getTotalWeight = function() {
            return this.totalWeight_;
          }, t4.getEstimate = function() {
            if (this.alpha_) {
              var e5 = 1 - Math.pow(this.alpha_, this.totalWeight_);
              if (e5)
                return this.estimate_ / e5;
            }
            return this.estimate_;
          }, e4;
        }();
      }
    ), "./src/utils/fetch-loader.ts": (
      /*!***********************************!*\
          !*** ./src/utils/fetch-loader.ts ***!
          \***********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => v2, fetchSupported: () => h2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ../loader/load-stats */
          "./src/loader/load-stats.ts"
        ), a2 = r3(
          /*! ../demux/chunk-cache */
          "./src/demux/chunk-cache.ts"
        );
        function s2(e4) {
          var t4 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
          return s2 = function(e5) {
            if (null === e5 || (r4 = e5, -1 === Function.toString.call(r4).indexOf("[native code]")))
              return e5;
            var r4;
            if ("function" != typeof e5)
              throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== t4) {
              if (t4.has(e5))
                return t4.get(e5);
              t4.set(e5, i4);
            }
            function i4() {
              return o2(e5, arguments, c2(this).constructor);
            }
            return i4.prototype = Object.create(e5.prototype, { constructor: { value: i4, enumerable: false, writable: true, configurable: true } }), u2(i4, e5);
          }, s2(e4);
        }
        function o2(e4, t4, r4) {
          return o2 = l2() ? Reflect.construct.bind() : function(e5, t5, r5) {
            var i4 = [null];
            i4.push.apply(i4, t5);
            var n3 = new (Function.bind.apply(e5, i4))();
            return r5 && u2(n3, r5.prototype), n3;
          }, o2.apply(null, arguments);
        }
        function l2() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (e4) {
            return false;
          }
        }
        function u2(e4, t4) {
          return u2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
            return e5.__proto__ = t5, e5;
          }, u2(e4, t4);
        }
        function c2(e4) {
          return c2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e5) {
            return e5.__proto__ || Object.getPrototypeOf(e5);
          }, c2(e4);
        }
        function d2() {
          return d2 = Object.assign ? Object.assign.bind() : function(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var r4 = arguments[t4];
              for (var i4 in r4)
                Object.prototype.hasOwnProperty.call(r4, i4) && (e4[i4] = r4[i4]);
            }
            return e4;
          }, d2.apply(this, arguments);
        }
        function h2() {
          if (self.fetch && self.AbortController && self.ReadableStream && self.Request)
            try {
              return new self.ReadableStream({}), true;
            } catch (e4) {
            }
          return false;
        }
        var f2 = function() {
          function e4(e5) {
            this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = void 0, this.response = void 0, this.controller = void 0, this.context = void 0, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e5.fetchSetup || p2, this.controller = new self.AbortController(), this.stats = new n2.LoadStats();
          }
          var t4 = e4.prototype;
          return t4.destroy = function() {
            this.loader = this.callbacks = null, this.abortInternal();
          }, t4.abortInternal = function() {
            var e5 = this.response;
            e5 && e5.ok || (this.stats.aborted = true, this.controller.abort());
          }, t4.abort = function() {
            var e5;
            this.abortInternal(), null !== (e5 = this.callbacks) && void 0 !== e5 && e5.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response);
          }, t4.load = function(e5, t5, r4) {
            var n3 = this, a3 = this.stats;
            if (a3.loading.start)
              throw new Error("Loader can only be used once.");
            a3.loading.start = self.performance.now();
            var s3 = function(e6, t6) {
              var r5 = { method: "GET", mode: "cors", credentials: "same-origin", signal: t6, headers: new self.Headers(d2({}, e6.headers)) };
              return e6.rangeEnd && r5.headers.set("Range", "bytes=" + e6.rangeStart + "-" + String(e6.rangeEnd - 1)), r5;
            }(e5, this.controller.signal), o3 = r4.onProgress, l3 = "arraybuffer" === e5.responseType, u3 = l3 ? "byteLength" : "length";
            this.context = e5, this.config = t5, this.callbacks = r4, this.request = this.fetchSetup(e5, s3), self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(function() {
              n3.abortInternal(), r4.onTimeout(a3, e5, n3.response);
            }, t5.timeout), self.fetch(this.request).then(function(r5) {
              if (n3.response = n3.loader = r5, !r5.ok) {
                var s4 = r5.status, u4 = r5.statusText;
                throw new g2(u4 || "fetch, bad network response", s4, r5);
              }
              return a3.loading.first = Math.max(self.performance.now(), a3.loading.start), a3.total = parseInt(r5.headers.get("Content-Length") || "0"), o3 && (0, i3.isFiniteNumber)(t5.highWaterMark) ? n3.loadProgressively(r5, a3, e5, t5.highWaterMark, o3) : l3 ? r5.arrayBuffer() : r5.text();
            }).then(function(s4) {
              var l4 = n3.response;
              self.clearTimeout(n3.requestTimeout), a3.loading.end = Math.max(self.performance.now(), a3.loading.first);
              var c3 = s4[u3];
              c3 && (a3.loaded = a3.total = c3);
              var d3 = { url: l4.url, data: s4 };
              o3 && !(0, i3.isFiniteNumber)(t5.highWaterMark) && o3(a3, e5, s4, l4), r4.onSuccess(d3, a3, e5, l4);
            }).catch(function(t6) {
              if (self.clearTimeout(n3.requestTimeout), !a3.aborted) {
                var i4 = t6 && t6.code || 0, s4 = t6 ? t6.message : null;
                r4.onError({ code: i4, text: s4 }, e5, t6 ? t6.details : null);
              }
            });
          }, t4.getCacheAge = function() {
            var e5 = null;
            if (this.response) {
              var t5 = this.response.headers.get("age");
              e5 = t5 ? parseFloat(t5) : null;
            }
            return e5;
          }, t4.loadProgressively = function(e5, t5, r4, i4, n3) {
            void 0 === i4 && (i4 = 0);
            var s3 = new a2.default(), o3 = e5.body.getReader();
            return function a3() {
              return o3.read().then(function(o4) {
                if (o4.done)
                  return s3.dataLength && n3(t5, r4, s3.flush(), e5), Promise.resolve(new ArrayBuffer(0));
                var l3 = o4.value, u3 = l3.length;
                return t5.loaded += u3, u3 < i4 || s3.dataLength ? (s3.push(l3), s3.dataLength >= i4 && n3(t5, r4, s3.flush(), e5)) : n3(t5, r4, l3, e5), a3();
              }).catch(function() {
                return Promise.reject();
              });
            }();
          }, e4;
        }();
        function p2(e4, t4) {
          return new self.Request(e4.url, t4);
        }
        var g2 = function(e4) {
          var t4, r4;
          function i4(t5, r5, i5) {
            var n3;
            return (n3 = e4.call(this, t5) || this).code = void 0, n3.details = void 0, n3.code = r5, n3.details = i5, n3;
          }
          return r4 = e4, (t4 = i4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, u2(t4, r4), i4;
        }(s2(Error));
        const v2 = f2;
      }
    ), "./src/utils/imsc1-ttml-parser.ts": (
      /*!****************************************!*\
          !*** ./src/utils/imsc1-ttml-parser.ts ***!
          \****************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { IMSC1_CODEC: () => c2, parseIMSC1: () => p2 });
        var i3 = r3(
          /*! ./mp4-tools */
          "./src/utils/mp4-tools.ts"
        ), n2 = r3(
          /*! ./vttparser */
          "./src/utils/vttparser.ts"
        ), a2 = r3(
          /*! ./vttcue */
          "./src/utils/vttcue.ts"
        ), s2 = r3(
          /*! ../demux/id3 */
          "./src/demux/id3.ts"
        ), o2 = r3(
          /*! ./timescale-conversion */
          "./src/utils/timescale-conversion.ts"
        ), l2 = r3(
          /*! ./webvtt-parser */
          "./src/utils/webvtt-parser.ts"
        );
        function u2() {
          return u2 = Object.assign ? Object.assign.bind() : function(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var r4 = arguments[t4];
              for (var i4 in r4)
                Object.prototype.hasOwnProperty.call(r4, i4) && (e4[i4] = r4[i4]);
            }
            return e4;
          }, u2.apply(this, arguments);
        }
        var c2 = "stpp.ttml.im1t", d2 = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, h2 = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/, f2 = { left: "start", center: "center", right: "end", start: "start", end: "end" };
        function p2(e4, t4, r4, n3, c3) {
          var d3 = (0, i3.findBox)(new Uint8Array(e4), ["mdat"]);
          if (0 !== d3.length) {
            var h3 = d3.map(function(e5) {
              return (0, s2.utf8ArrayToStr)(e5);
            }), p3 = (0, o2.toTimescaleFromScale)(t4, 1, r4);
            try {
              h3.forEach(function(e5) {
                return n3(function(e6, t5) {
                  var r5 = new DOMParser().parseFromString(e6, "text/xml"), i4 = r5.getElementsByTagName("tt")[0];
                  if (!i4)
                    throw new Error("Invalid ttml");
                  var n4 = { frameRate: 30, subFrameRate: 1, frameRateMultiplier: 0, tickRate: 0 }, s3 = Object.keys(n4).reduce(function(e7, t6) {
                    return e7[t6] = i4.getAttribute("ttp:" + t6) || n4[t6], e7;
                  }, {}), o3 = "preserve" !== i4.getAttribute("xml:space"), c4 = v2(g2(i4, "styling", "style")), d4 = v2(g2(i4, "layout", "region")), h4 = g2(i4, "body", "[begin]");
                  return [].map.call(h4, function(e7) {
                    var r6 = m2(e7, o3);
                    if (!r6 || !e7.hasAttribute("begin"))
                      return null;
                    var i5 = E2(e7.getAttribute("begin"), s3), n5 = E2(e7.getAttribute("dur"), s3), h5 = E2(e7.getAttribute("end"), s3);
                    if (null === i5)
                      throw A2(e7);
                    if (null === h5) {
                      if (null === n5)
                        throw A2(e7);
                      h5 = i5 + n5;
                    }
                    var p4 = new a2.default(i5 - t5, h5 - t5, r6);
                    p4.id = (0, l2.generateCueId)(p4.startTime, p4.endTime, p4.text);
                    var g3 = d4[e7.getAttribute("region")], v3 = c4[e7.getAttribute("style")];
                    p4.position = 10, p4.size = 80;
                    var T2 = function(e8, t6, r7) {
                      var i6 = "http://www.w3.org/ns/ttml#styling", n6 = null, a3 = ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"], s4 = null != e8 && e8.hasAttribute("style") ? e8.getAttribute("style") : null;
                      return s4 && r7.hasOwnProperty(s4) && (n6 = r7[s4]), a3.reduce(function(r8, a4) {
                        var s5 = y2(t6, i6, a4) || y2(e8, i6, a4) || y2(n6, i6, a4);
                        return s5 && (r8[a4] = s5), r8;
                      }, {});
                    }(g3, v3, c4), b2 = T2.textAlign;
                    if (b2) {
                      var k2 = f2[b2];
                      k2 && (p4.lineAlign = k2), p4.align = b2;
                    }
                    return u2(p4, T2), p4;
                  }).filter(function(e7) {
                    return null !== e7;
                  });
                }(e5, p3));
              });
            } catch (e5) {
              c3(e5);
            }
          } else
            c3(new Error("Could not parse IMSC1 mdat"));
        }
        function g2(e4, t4, r4) {
          var i4 = e4.getElementsByTagName(t4)[0];
          return i4 ? [].slice.call(i4.querySelectorAll(r4)) : [];
        }
        function v2(e4) {
          return e4.reduce(function(e5, t4) {
            var r4 = t4.getAttribute("xml:id");
            return r4 && (e5[r4] = t4), e5;
          }, {});
        }
        function m2(e4, t4) {
          return [].slice.call(e4.childNodes).reduce(function(e5, r4, i4) {
            var n3;
            return "br" === r4.nodeName && i4 ? e5 + "\n" : null !== (n3 = r4.childNodes) && void 0 !== n3 && n3.length ? m2(r4, t4) : t4 ? e5 + r4.textContent.trim().replace(/\s+/g, " ") : e5 + r4.textContent;
          }, "");
        }
        function y2(e4, t4, r4) {
          return e4 && e4.hasAttributeNS(t4, r4) ? e4.getAttributeNS(t4, r4) : null;
        }
        function A2(e4) {
          return new Error("Could not parse ttml timestamp " + e4);
        }
        function E2(e4, t4) {
          if (!e4)
            return null;
          var r4 = (0, n2.parseTimeStamp)(e4);
          return null === r4 && (d2.test(e4) ? r4 = function(e5, t5) {
            var r5 = d2.exec(e5), i4 = (0 | r5[4]) + (0 | r5[5]) / t5.subFrameRate;
            return 3600 * (0 | r5[1]) + 60 * (0 | r5[2]) + (0 | r5[3]) + i4 / t5.frameRate;
          }(e4, t4) : h2.test(e4) && (r4 = function(e5, t5) {
            var r5 = h2.exec(e5), i4 = Number(r5[1]);
            switch (r5[2]) {
              case "h":
                return 3600 * i4;
              case "m":
                return 60 * i4;
              case "ms":
                return 1e3 * i4;
              case "f":
                return i4 / t5.frameRate;
              case "t":
                return i4 / t5.tickRate;
            }
            return i4;
          }(e4, t4))), r4;
        }
      }
    ), "./src/utils/logger.ts": (
      /*!*****************************!*\
          !*** ./src/utils/logger.ts ***!
          \*****************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { enableLogs: () => o2, logger: () => l2 });
        var i3 = function() {
        }, n2 = { trace: i3, debug: i3, log: i3, warn: i3, info: i3, error: i3 }, a2 = n2;
        function s2(e4) {
          var t4 = self.console[e4];
          return t4 ? t4.bind(self.console, "[" + e4 + "] >") : i3;
        }
        function o2(e4, t4) {
          if (self.console && true === e4 || "object" == typeof e4) {
            !function(e5) {
              for (var t5 = arguments.length, r4 = new Array(t5 > 1 ? t5 - 1 : 0), i4 = 1; i4 < t5; i4++)
                r4[i4 - 1] = arguments[i4];
              r4.forEach(function(t6) {
                a2[t6] = e5[t6] ? e5[t6].bind(e5) : s2(t6);
              });
            }(e4, "debug", "log", "info", "warn", "error");
            try {
              a2.log('Debug logs enabled for "' + t4 + '"');
            } catch (e5) {
              a2 = n2;
            }
          } else
            a2 = n2;
        }
        var l2 = n2;
      }
    ), "./src/utils/mediakeys-helper.ts": (
      /*!***************************************!*\
          !*** ./src/utils/mediakeys-helper.ts ***!
          \***************************************/
      (e3, t3, r3) => {
        var i3;
        r3.r(t3), r3.d(t3, { KeySystems: () => i3, requestMediaKeySystemAccess: () => n2 }), function(e4) {
          e4.WIDEVINE = "com.widevine.alpha", e4.PLAYREADY = "com.microsoft.playready";
        }(i3 || (i3 = {}));
        var n2 = "undefined" != typeof self && self.navigator && self.navigator.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;
      }
    ), "./src/utils/mediasource-helper.ts": (
      /*!*****************************************!*\
          !*** ./src/utils/mediasource-helper.ts ***!
          \*****************************************/
      (e3, t3, r3) => {
        function i3() {
          return self.MediaSource || self.WebKitMediaSource;
        }
        r3.r(t3), r3.d(t3, { getMediaSource: () => i3 });
      }
    ), "./src/utils/mp4-tools.ts": (
      /*!********************************!*\
          !*** ./src/utils/mp4-tools.ts ***!
          \********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { RemuxerTrackIdConfig: () => l2, appendUint8Array: () => b2, bin2str: () => u2, computeRawDurationFromSamples: () => A2, discardEPB: () => C2, findBox: () => p2, getDuration: () => y2, getStartDTS: () => m2, offsetStartDTS: () => E2, parseEmsg: () => L2, parseInitSegment: () => v2, parseSEIMessageFromNALu: () => _2, parseSamples: () => k2, parseSegmentIndex: () => g2, readSint32: () => h2, readUint16: () => c2, readUint32: () => d2, segmentValidRange: () => T2, writeUint32: () => f2 });
        var i3 = r3(
          /*! ./typed-array */
          "./src/utils/typed-array.ts"
        ), n2 = r3(
          /*! ../loader/fragment */
          "./src/loader/fragment.ts"
        ), a2 = r3(
          /*! ../demux/id3 */
          "./src/demux/id3.ts"
        ), s2 = Math.pow(2, 32) - 1, o2 = [].push, l2 = { video: 1, audio: 2, id3: 3, text: 4 };
        function u2(e4) {
          return String.fromCharCode.apply(null, e4);
        }
        function c2(e4, t4) {
          var r4 = e4[t4] << 8 | e4[t4 + 1];
          return r4 < 0 ? 65536 + r4 : r4;
        }
        function d2(e4, t4) {
          var r4 = h2(e4, t4);
          return r4 < 0 ? 4294967296 + r4 : r4;
        }
        function h2(e4, t4) {
          return e4[t4] << 24 | e4[t4 + 1] << 16 | e4[t4 + 2] << 8 | e4[t4 + 3];
        }
        function f2(e4, t4, r4) {
          e4[t4] = r4 >> 24, e4[t4 + 1] = r4 >> 16 & 255, e4[t4 + 2] = r4 >> 8 & 255, e4[t4 + 3] = 255 & r4;
        }
        function p2(e4, t4) {
          var r4 = [];
          if (!t4.length)
            return r4;
          for (var i4 = e4.byteLength, n3 = 0; n3 < i4; ) {
            var a3 = d2(e4, n3), s3 = a3 > 1 ? n3 + a3 : i4;
            if (u2(e4.subarray(n3 + 4, n3 + 8)) === t4[0])
              if (1 === t4.length)
                r4.push(e4.subarray(n3 + 8, s3));
              else {
                var l3 = p2(e4.subarray(n3 + 8, s3), t4.slice(1));
                l3.length && o2.apply(r4, l3);
              }
            n3 = s3;
          }
          return r4;
        }
        function g2(e4) {
          var t4 = [], r4 = e4[0], i4 = 8, n3 = d2(e4, i4);
          i4 += 4, i4 += 0 === r4 ? 8 : 16, i4 += 2;
          var a3 = e4.length + 0, s3 = c2(e4, i4);
          i4 += 2;
          for (var o3 = 0; o3 < s3; o3++) {
            var l3 = i4, u3 = d2(e4, l3);
            l3 += 4;
            var h3 = 2147483647 & u3;
            if (1 == (2147483648 & u3) >>> 31)
              return console.warn("SIDX has hierarchical references (not supported)"), null;
            var f3 = d2(e4, l3);
            l3 += 4, t4.push({ referenceSize: h3, subsegmentDuration: f3, info: { duration: f3 / n3, start: a3, end: a3 + h3 - 1 } }), a3 += h3, i4 = l3 += 4;
          }
          return { earliestPresentationTime: 0, timescale: n3, version: r4, referencesCount: s3, references: t4 };
        }
        function v2(e4) {
          for (var t4 = [], r4 = p2(e4, ["moov", "trak"]), i4 = 0; i4 < r4.length; i4++) {
            var a3 = r4[i4], s3 = p2(a3, ["tkhd"])[0];
            if (s3) {
              var o3 = s3[0], l3 = 0 === o3 ? 12 : 20, c3 = d2(s3, l3), h3 = p2(a3, ["mdia", "mdhd"])[0];
              if (h3) {
                var f3 = d2(h3, l3 = 0 === (o3 = h3[0]) ? 12 : 20), g3 = p2(a3, ["mdia", "hdlr"])[0];
                if (g3) {
                  var v3 = u2(g3.subarray(8, 12)), m3 = { soun: n2.ElementaryStreamTypes.AUDIO, vide: n2.ElementaryStreamTypes.VIDEO }[v3];
                  if (m3) {
                    var y3 = p2(a3, ["mdia", "minf", "stbl", "stsd"])[0], A3 = void 0;
                    y3 && (A3 = u2(y3.subarray(12, 16))), t4[c3] = { timescale: f3, type: m3 }, t4[m3] = { timescale: f3, id: c3, codec: A3 };
                  }
                }
              }
            }
          }
          return p2(e4, ["moov", "mvex", "trex"]).forEach(function(e5) {
            var r5 = d2(e5, 4), i5 = t4[r5];
            i5 && (i5.default = { duration: d2(e5, 12), flags: d2(e5, 20) });
          }), t4;
        }
        function m2(e4, t4) {
          return p2(t4, ["moof", "traf"]).reduce(function(t5, r4) {
            var i4 = p2(r4, ["tfdt"])[0], n3 = i4[0], a3 = p2(r4, ["tfhd"]).reduce(function(t6, r5) {
              var a4 = d2(r5, 4), s3 = e4[a4];
              if (s3) {
                var o3 = d2(i4, 4);
                1 === n3 && (o3 *= Math.pow(2, 32), o3 += d2(i4, 8));
                var l3 = o3 / (s3.timescale || 9e4);
                if (isFinite(l3) && (null === t6 || l3 < t6))
                  return l3;
              }
              return t6;
            }, null);
            return null !== a3 && isFinite(a3) && (null === t5 || a3 < t5) ? a3 : t5;
          }, null) || 0;
        }
        function y2(e4, t4) {
          for (var r4 = 0, i4 = 0, a3 = 0, s3 = p2(e4, ["moof", "traf"]), o3 = 0; o3 < s3.length; o3++) {
            var l3 = s3[o3], u3 = p2(l3, ["tfhd"])[0], c3 = t4[d2(u3, 4)];
            if (c3) {
              var h3 = c3.default, f3 = d2(u3, 0) | (null == h3 ? void 0 : h3.flags), v3 = null == h3 ? void 0 : h3.duration;
              8 & f3 && (v3 = d2(u3, 2 & f3 ? 12 : 8));
              for (var m3 = c3.timescale || 9e4, y3 = p2(l3, ["trun"]), E3 = 0; E3 < y3.length; E3++)
                !(r4 = A2(y3[E3])) && v3 && (r4 = v3 * d2(y3[E3], 4)), c3.type === n2.ElementaryStreamTypes.VIDEO ? i4 += r4 / m3 : c3.type === n2.ElementaryStreamTypes.AUDIO && (a3 += r4 / m3);
            }
          }
          if (0 === i4 && 0 === a3) {
            for (var T3 = 0, b3 = p2(e4, ["sidx"]), k3 = 0; k3 < b3.length; k3++) {
              var S3 = g2(b3[k3]);
              null != S3 && S3.references && (T3 += S3.references.reduce(function(e5, t5) {
                return e5 + t5.info.duration || 0;
              }, 0));
            }
            return T3;
          }
          return i4 || a3;
        }
        function A2(e4) {
          var t4 = d2(e4, 0), r4 = 8;
          1 & t4 && (r4 += 4), 4 & t4 && (r4 += 4);
          for (var i4 = 0, n3 = d2(e4, 4), a3 = 0; a3 < n3; a3++)
            256 & t4 && (i4 += d2(e4, r4), r4 += 4), 512 & t4 && (r4 += 4), 1024 & t4 && (r4 += 4), 2048 & t4 && (r4 += 4);
          return i4;
        }
        function E2(e4, t4, r4) {
          p2(t4, ["moof", "traf"]).forEach(function(t5) {
            p2(t5, ["tfhd"]).forEach(function(i4) {
              var n3 = d2(i4, 4), a3 = e4[n3];
              if (a3) {
                var o3 = a3.timescale || 9e4;
                p2(t5, ["tfdt"]).forEach(function(e5) {
                  var t6 = e5[0], i5 = d2(e5, 4);
                  if (0 === t6)
                    i5 -= r4 * o3, f2(e5, 4, i5 = Math.max(i5, 0));
                  else {
                    i5 *= Math.pow(2, 32), i5 += d2(e5, 8), i5 -= r4 * o3, i5 = Math.max(i5, 0);
                    var n4 = Math.floor(i5 / (s2 + 1)), a4 = Math.floor(i5 % (s2 + 1));
                    f2(e5, 4, n4), f2(e5, 8, a4);
                  }
                });
              }
            });
          });
        }
        function T2(e4) {
          var t4 = { valid: null, remainder: null }, r4 = p2(e4, ["moof"]);
          if (!r4)
            return t4;
          if (r4.length < 2)
            return t4.remainder = e4, t4;
          var n3 = r4[r4.length - 1];
          return t4.valid = (0, i3.sliceUint8)(e4, 0, n3.byteOffset - 8), t4.remainder = (0, i3.sliceUint8)(e4, n3.byteOffset - 8), t4;
        }
        function b2(e4, t4) {
          var r4 = new Uint8Array(e4.length + t4.length);
          return r4.set(e4), r4.set(t4, e4.length), r4;
        }
        function k2(e4, t4) {
          var r4 = [], i4 = t4.samples, a3 = t4.timescale, s3 = t4.id, o3 = false;
          return p2(i4, ["moof"]).map(function(l3) {
            var u3 = l3.byteOffset - 8;
            p2(l3, ["traf"]).map(function(l4) {
              var c3 = p2(l4, ["tfdt"]).map(function(e5) {
                var t5 = e5[0], r5 = d2(e5, 4);
                return 1 === t5 && (r5 *= Math.pow(2, 32), r5 += d2(e5, 8)), r5 / a3;
              })[0];
              return void 0 !== c3 && (e4 = c3), p2(l4, ["tfhd"]).map(function(c4) {
                var f3 = d2(c4, 4), g3 = 16777215 & d2(c4, 0), v3 = 0, m3 = 0 != (16 & g3), y3 = 0, A3 = 0 != (32 & g3), E3 = 8;
                f3 === s3 && (0 != (1 & g3) && (E3 += 8), 0 != (2 & g3) && (E3 += 4), 0 != (8 & g3) && (v3 = d2(c4, E3), E3 += 4), m3 && (y3 = d2(c4, E3), E3 += 4), A3 && (E3 += 4), "video" === t4.type && (o3 = function(e5) {
                  if (!e5)
                    return false;
                  var t5 = e5.indexOf("."), r5 = t5 < 0 ? e5 : e5.substring(0, t5);
                  return "hvc1" === r5 || "hev1" === r5 || "dvh1" === r5 || "dvhe" === r5;
                }(t4.codec)), p2(l4, ["trun"]).map(function(s4) {
                  var l5 = s4[0], c5 = 16777215 & d2(s4, 0), f4 = 0 != (1 & c5), p3 = 0, g4 = 0 != (4 & c5), m4 = 0 != (256 & c5), A4 = 0, E4 = 0 != (512 & c5), T3 = 0, b3 = 0 != (1024 & c5), k3 = 0 != (2048 & c5), C3 = 0, L3 = d2(s4, 4), D2 = 8;
                  f4 && (p3 = d2(s4, D2), D2 += 4), g4 && (D2 += 4);
                  for (var R2 = p3 + u3, I2 = 0; I2 < L3; I2++) {
                    if (m4 ? (A4 = d2(s4, D2), D2 += 4) : A4 = v3, E4 ? (T3 = d2(s4, D2), D2 += 4) : T3 = y3, b3 && (D2 += 4), k3 && (C3 = 0 === l5 ? d2(s4, D2) : h2(s4, D2), D2 += 4), t4.type === n2.ElementaryStreamTypes.VIDEO)
                      for (var O2 = 0; O2 < T3; ) {
                        var w2 = d2(i4, R2);
                        S2(o3, i4[R2 += 4]) && _2(i4.subarray(R2, R2 + w2), o3 ? 2 : 1, e4 + C3 / a3, r4), R2 += w2, O2 += w2 + 4;
                      }
                    e4 += A4 / a3;
                  }
                }));
              });
            });
          }), r4;
        }
        function S2(e4, t4) {
          if (e4) {
            var r4 = t4 >> 1 & 63;
            return 39 === r4 || 40 === r4;
          }
          return 6 == (31 & t4);
        }
        function _2(e4, t4, r4, i4) {
          var n3 = C2(e4), s3 = 0;
          s3 += t4;
          for (var o3 = 0, l3 = 0, u3 = false, h3 = 0; s3 < n3.length; ) {
            o3 = 0;
            do {
              if (s3 >= n3.length)
                break;
              o3 += h3 = n3[s3++];
            } while (255 === h3);
            l3 = 0;
            do {
              if (s3 >= n3.length)
                break;
              l3 += h3 = n3[s3++];
            } while (255 === h3);
            var f3 = n3.length - s3;
            if (!u3 && 4 === o3 && s3 < n3.length) {
              if (u3 = true, 181 === n3[s3++]) {
                var p3 = c2(n3, s3);
                if (s3 += 2, 49 === p3) {
                  var g3 = d2(n3, s3);
                  if (s3 += 4, 1195456820 === g3) {
                    var v3 = n3[s3++];
                    if (3 === v3) {
                      var m3 = n3[s3++], y3 = 64 & m3, A3 = y3 ? 2 + 3 * (31 & m3) : 0, E3 = new Uint8Array(A3);
                      if (y3) {
                        E3[0] = m3;
                        for (var T3 = 1; T3 < A3; T3++)
                          E3[T3] = n3[s3++];
                      }
                      i4.push({ type: v3, payloadType: o3, pts: r4, bytes: E3 });
                    }
                  }
                }
              }
            } else if (5 === o3 && l3 < f3) {
              if (u3 = true, l3 > 16) {
                for (var b3 = [], k3 = 0; k3 < 16; k3++) {
                  var S3 = n3[s3++].toString(16);
                  b3.push(1 == S3.length ? "0" + S3 : S3), 3 !== k3 && 5 !== k3 && 7 !== k3 && 9 !== k3 || b3.push("-");
                }
                for (var _3 = l3 - 16, L3 = new Uint8Array(_3), D2 = 0; D2 < _3; D2++)
                  L3[D2] = n3[s3++];
                i4.push({ payloadType: o3, pts: r4, uuid: b3.join(""), userData: (0, a2.utf8ArrayToStr)(L3), userDataBytes: L3 });
              }
            } else if (l3 < f3)
              s3 += l3;
            else if (l3 > f3)
              break;
          }
        }
        function C2(e4) {
          for (var t4 = e4.byteLength, r4 = [], i4 = 1; i4 < t4 - 2; )
            0 === e4[i4] && 0 === e4[i4 + 1] && 3 === e4[i4 + 2] ? (r4.push(i4 + 2), i4 += 2) : i4++;
          if (0 === r4.length)
            return e4;
          var n3 = t4 - r4.length, a3 = new Uint8Array(n3), s3 = 0;
          for (i4 = 0; i4 < n3; s3++, i4++)
            s3 === r4[0] && (s3++, r4.shift()), a3[i4] = e4[s3];
          return a3;
        }
        function L2(e4) {
          var t4 = e4[0], r4 = "", i4 = "", n3 = 0, a3 = 0, s3 = 0, o3 = 0, l3 = 0, c3 = 0;
          if (0 === t4) {
            for (; "\0" !== u2(e4.subarray(c3, c3 + 1)); )
              r4 += u2(e4.subarray(c3, c3 + 1)), c3 += 1;
            for (r4 += u2(e4.subarray(c3, c3 + 1)), c3 += 1; "\0" !== u2(e4.subarray(c3, c3 + 1)); )
              i4 += u2(e4.subarray(c3, c3 + 1)), c3 += 1;
            i4 += u2(e4.subarray(c3, c3 + 1)), c3 += 1, n3 = d2(e4, 12), a3 = d2(e4, 16), o3 = d2(e4, 20), l3 = d2(e4, 24), c3 = 28;
          } else if (1 === t4) {
            n3 = d2(e4, c3 += 4);
            var h3 = d2(e4, c3 += 4), f3 = d2(e4, c3 += 4);
            for (c3 += 4, s3 = Math.pow(2, 32) * h3 + f3, Number.isSafeInteger(s3) || (s3 = Number.MAX_SAFE_INTEGER, console.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), o3 = d2(e4, c3), l3 = d2(e4, c3 += 4), c3 += 4; "\0" !== u2(e4.subarray(c3, c3 + 1)); )
              r4 += u2(e4.subarray(c3, c3 + 1)), c3 += 1;
            for (r4 += u2(e4.subarray(c3, c3 + 1)), c3 += 1; "\0" !== u2(e4.subarray(c3, c3 + 1)); )
              i4 += u2(e4.subarray(c3, c3 + 1)), c3 += 1;
            i4 += u2(e4.subarray(c3, c3 + 1)), c3 += 1;
          }
          return { schemeIdUri: r4, value: i4, timeScale: n3, presentationTime: s3, presentationTimeDelta: a3, eventDuration: o3, id: l3, payload: e4.subarray(c3, e4.byteLength) };
        }
      }
    ), "./src/utils/output-filter.ts": (
      /*!************************************!*\
          !*** ./src/utils/output-filter.ts ***!
          \************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => i3 });
        var i3 = function() {
          function e4(e5, t5) {
            this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e5, this.trackName = t5;
          }
          var t4 = e4.prototype;
          return t4.dispatchCue = function() {
            null !== this.startTime && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null);
          }, t4.newCue = function(e5, t5, r4) {
            (null === this.startTime || this.startTime > e5) && (this.startTime = e5), this.endTime = t5, this.screen = r4, this.timelineController.createCaptionsTrack(this.trackName);
          }, t4.reset = function() {
            this.cueRanges = [], this.startTime = null;
          }, e4;
        }();
      }
    ), "./src/utils/texttrack-utils.ts": (
      /*!**************************************!*\
          !*** ./src/utils/texttrack-utils.ts ***!
          \**************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { addCueToTrack: () => a2, clearCurrentCues: () => s2, getCuesInRange: () => l2, removeCuesInRange: () => o2, sendAddTrackEvent: () => n2 });
        var i3 = r3(
          /*! ./logger */
          "./src/utils/logger.ts"
        );
        function n2(e4, t4) {
          var r4;
          try {
            r4 = new Event("addtrack");
          } catch (e5) {
            (r4 = document.createEvent("Event")).initEvent("addtrack", false, false);
          }
          r4.track = e4, t4.dispatchEvent(r4);
        }
        function a2(e4, t4) {
          var r4 = e4.mode;
          if ("disabled" === r4 && (e4.mode = "hidden"), e4.cues && !e4.cues.getCueById(t4.id))
            try {
              if (e4.addCue(t4), !e4.cues.getCueById(t4.id))
                throw new Error("addCue is failed for: " + t4);
            } catch (r5) {
              i3.logger.debug("[texttrack-utils]: " + r5);
              var n3 = new self.TextTrackCue(t4.startTime, t4.endTime, t4.text);
              n3.id = t4.id, e4.addCue(n3);
            }
          "disabled" === r4 && (e4.mode = r4);
        }
        function s2(e4) {
          var t4 = e4.mode;
          if ("disabled" === t4 && (e4.mode = "hidden"), e4.cues)
            for (var r4 = e4.cues.length; r4--; )
              e4.removeCue(e4.cues[r4]);
          "disabled" === t4 && (e4.mode = t4);
        }
        function o2(e4, t4, r4, i4) {
          var n3 = e4.mode;
          if ("disabled" === n3 && (e4.mode = "hidden"), e4.cues && e4.cues.length > 0)
            for (var a3 = l2(e4.cues, t4, r4), s3 = 0; s3 < a3.length; s3++)
              i4 && !i4(a3[s3]) || e4.removeCue(a3[s3]);
          "disabled" === n3 && (e4.mode = n3);
        }
        function l2(e4, t4, r4) {
          var i4 = [], n3 = function(e5, t5) {
            if (t5 < e5[0].startTime)
              return 0;
            var r5 = e5.length - 1;
            if (t5 > e5[r5].endTime)
              return -1;
            for (var i5 = 0, n4 = r5; i5 <= n4; ) {
              var a4 = Math.floor((n4 + i5) / 2);
              if (t5 < e5[a4].startTime)
                n4 = a4 - 1;
              else {
                if (!(t5 > e5[a4].startTime && i5 < r5))
                  return a4;
                i5 = a4 + 1;
              }
            }
            return e5[i5].startTime - t5 < t5 - e5[n4].startTime ? i5 : n4;
          }(e4, t4);
          if (n3 > -1)
            for (var a3 = n3, s3 = e4.length; a3 < s3; a3++) {
              var o3 = e4[a3];
              if (o3.startTime >= t4 && o3.endTime <= r4)
                i4.push(o3);
              else if (o3.startTime > r4)
                return i4;
            }
          return i4;
        }
      }
    ), "./src/utils/time-ranges.ts": (
      /*!**********************************!*\
          !*** ./src/utils/time-ranges.ts ***!
          \**********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => i3 });
        const i3 = { toString: function(e4) {
          for (var t4 = "", r4 = e4.length, i4 = 0; i4 < r4; i4++)
            t4 += "[" + e4.start(i4).toFixed(3) + "," + e4.end(i4).toFixed(3) + "]";
          return t4;
        } };
      }
    ), "./src/utils/timescale-conversion.ts": (
      /*!*******************************************!*\
          !*** ./src/utils/timescale-conversion.ts ***!
          \*******************************************/
      (e3, t3, r3) => {
        function i3(e4, t4, r4, i4) {
          void 0 === r4 && (r4 = 1), void 0 === i4 && (i4 = false);
          var n3 = e4 * t4 * r4;
          return i4 ? Math.round(n3) : n3;
        }
        function n2(e4, t4, r4, n3) {
          return void 0 === r4 && (r4 = 1), void 0 === n3 && (n3 = false), i3(e4, t4, 1 / r4, n3);
        }
        function a2(e4, t4) {
          return void 0 === t4 && (t4 = false), i3(e4, 1e3, 1 / 9e4, t4);
        }
        function s2(e4, t4) {
          return void 0 === t4 && (t4 = 1), i3(e4, 9e4, 1 / t4);
        }
        r3.r(t3), r3.d(t3, { toMpegTsClockFromTimescale: () => s2, toMsFromMpegTsClock: () => a2, toTimescaleFromBase: () => i3, toTimescaleFromScale: () => n2 });
      }
    ), "./src/utils/typed-array.ts": (
      /*!**********************************!*\
          !*** ./src/utils/typed-array.ts ***!
          \**********************************/
      (e3, t3, r3) => {
        function i3(e4, t4, r4) {
          return Uint8Array.prototype.slice ? e4.slice(t4, r4) : new Uint8Array(Array.prototype.slice.call(e4, t4, r4));
        }
        r3.r(t3), r3.d(t3, { sliceUint8: () => i3 });
      }
    ), "./src/utils/vttcue.ts": (
      /*!*****************************!*\
          !*** ./src/utils/vttcue.ts ***!
          \*****************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => i3 });
        const i3 = function() {
          if ("undefined" != typeof self && self.VTTCue)
            return self.VTTCue;
          var e4 = ["", "lr", "rl"], t4 = ["start", "middle", "end", "left", "right"];
          function r4(e5, t5) {
            if ("string" != typeof t5)
              return false;
            if (!Array.isArray(e5))
              return false;
            var r5 = t5.toLowerCase();
            return !!~e5.indexOf(r5) && r5;
          }
          function i4(e5) {
            return r4(t4, e5);
          }
          function n2(e5) {
            for (var t5 = arguments.length, r5 = new Array(t5 > 1 ? t5 - 1 : 0), i5 = 1; i5 < t5; i5++)
              r5[i5 - 1] = arguments[i5];
            for (var n3 = 1; n3 < arguments.length; n3++) {
              var a3 = arguments[n3];
              for (var s2 in a3)
                e5[s2] = a3[s2];
            }
            return e5;
          }
          function a2(t5, a3, s2) {
            var o2 = this, l2 = { enumerable: true };
            o2.hasBeenReset = false;
            var u2 = "", c2 = false, d2 = t5, h2 = a3, f2 = s2, p2 = null, g2 = "", v2 = true, m2 = "auto", y2 = "start", A2 = 50, E2 = "middle", T2 = 50, b2 = "middle";
            Object.defineProperty(o2, "id", n2({}, l2, { get: function() {
              return u2;
            }, set: function(e5) {
              u2 = "" + e5;
            } })), Object.defineProperty(o2, "pauseOnExit", n2({}, l2, { get: function() {
              return c2;
            }, set: function(e5) {
              c2 = !!e5;
            } })), Object.defineProperty(o2, "startTime", n2({}, l2, { get: function() {
              return d2;
            }, set: function(e5) {
              if ("number" != typeof e5)
                throw new TypeError("Start time must be set to a number.");
              d2 = e5, this.hasBeenReset = true;
            } })), Object.defineProperty(o2, "endTime", n2({}, l2, { get: function() {
              return h2;
            }, set: function(e5) {
              if ("number" != typeof e5)
                throw new TypeError("End time must be set to a number.");
              h2 = e5, this.hasBeenReset = true;
            } })), Object.defineProperty(o2, "text", n2({}, l2, { get: function() {
              return f2;
            }, set: function(e5) {
              f2 = "" + e5, this.hasBeenReset = true;
            } })), Object.defineProperty(o2, "region", n2({}, l2, { get: function() {
              return p2;
            }, set: function(e5) {
              p2 = e5, this.hasBeenReset = true;
            } })), Object.defineProperty(o2, "vertical", n2({}, l2, { get: function() {
              return g2;
            }, set: function(t6) {
              var i5 = function(t7) {
                return r4(e4, t7);
              }(t6);
              if (false === i5)
                throw new SyntaxError("An invalid or illegal string was specified.");
              g2 = i5, this.hasBeenReset = true;
            } })), Object.defineProperty(o2, "snapToLines", n2({}, l2, { get: function() {
              return v2;
            }, set: function(e5) {
              v2 = !!e5, this.hasBeenReset = true;
            } })), Object.defineProperty(o2, "line", n2({}, l2, { get: function() {
              return m2;
            }, set: function(e5) {
              if ("number" != typeof e5 && "auto" !== e5)
                throw new SyntaxError("An invalid number or illegal string was specified.");
              m2 = e5, this.hasBeenReset = true;
            } })), Object.defineProperty(o2, "lineAlign", n2({}, l2, { get: function() {
              return y2;
            }, set: function(e5) {
              var t6 = i4(e5);
              if (!t6)
                throw new SyntaxError("An invalid or illegal string was specified.");
              y2 = t6, this.hasBeenReset = true;
            } })), Object.defineProperty(o2, "position", n2({}, l2, { get: function() {
              return A2;
            }, set: function(e5) {
              if (e5 < 0 || e5 > 100)
                throw new Error("Position must be between 0 and 100.");
              A2 = e5, this.hasBeenReset = true;
            } })), Object.defineProperty(o2, "positionAlign", n2({}, l2, { get: function() {
              return E2;
            }, set: function(e5) {
              var t6 = i4(e5);
              if (!t6)
                throw new SyntaxError("An invalid or illegal string was specified.");
              E2 = t6, this.hasBeenReset = true;
            } })), Object.defineProperty(o2, "size", n2({}, l2, { get: function() {
              return T2;
            }, set: function(e5) {
              if (e5 < 0 || e5 > 100)
                throw new Error("Size must be between 0 and 100.");
              T2 = e5, this.hasBeenReset = true;
            } })), Object.defineProperty(o2, "align", n2({}, l2, { get: function() {
              return b2;
            }, set: function(e5) {
              var t6 = i4(e5);
              if (!t6)
                throw new SyntaxError("An invalid or illegal string was specified.");
              b2 = t6, this.hasBeenReset = true;
            } })), o2.displayState = void 0;
          }
          return a2.prototype.getCueAsHTML = function() {
            return self.WebVTT.convertCueToDOMTree(self, this.text);
          }, a2;
        }();
      }
    ), "./src/utils/vttparser.ts": (
      /*!********************************!*\
          !*** ./src/utils/vttparser.ts ***!
          \********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { VTTParser: () => h2, fixLineBreaks: () => d2, parseTimeStamp: () => a2 });
        var i3 = r3(
          /*! ./vttcue */
          "./src/utils/vttcue.ts"
        ), n2 = function() {
          function e4() {
          }
          return e4.prototype.decode = function(e5, t4) {
            if (!e5)
              return "";
            if ("string" != typeof e5)
              throw new Error("Error - expected string data.");
            return decodeURIComponent(encodeURIComponent(e5));
          }, e4;
        }();
        function a2(e4) {
          function t4(e5, t5, r5, i4) {
            return 3600 * (0 | e5) + 60 * (0 | t5) + (0 | r5) + parseFloat(i4 || 0);
          }
          var r4 = e4.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
          return r4 ? parseFloat(r4[2]) > 59 ? t4(r4[2], r4[3], 0, r4[4]) : t4(r4[1], r4[2], r4[3], r4[4]) : null;
        }
        var s2 = function() {
          function e4() {
            this.values = /* @__PURE__ */ Object.create(null);
          }
          var t4 = e4.prototype;
          return t4.set = function(e5, t5) {
            this.get(e5) || "" === t5 || (this.values[e5] = t5);
          }, t4.get = function(e5, t5, r4) {
            return r4 ? this.has(e5) ? this.values[e5] : t5[r4] : this.has(e5) ? this.values[e5] : t5;
          }, t4.has = function(e5) {
            return e5 in this.values;
          }, t4.alt = function(e5, t5, r4) {
            for (var i4 = 0; i4 < r4.length; ++i4)
              if (t5 === r4[i4]) {
                this.set(e5, t5);
                break;
              }
          }, t4.integer = function(e5, t5) {
            /^-?\d+$/.test(t5) && this.set(e5, parseInt(t5, 10));
          }, t4.percent = function(e5, t5) {
            if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t5)) {
              var r4 = parseFloat(t5);
              if (r4 >= 0 && r4 <= 100)
                return this.set(e5, r4), true;
            }
            return false;
          }, e4;
        }();
        function o2(e4, t4, r4, i4) {
          var n3 = i4 ? e4.split(i4) : [e4];
          for (var a3 in n3)
            if ("string" == typeof n3[a3]) {
              var s3 = n3[a3].split(r4);
              2 === s3.length && t4(s3[0], s3[1]);
            }
        }
        var l2 = new i3.default(0, 0, ""), u2 = "middle" === l2.align ? "middle" : "center";
        function c2(e4, t4, r4) {
          var i4 = e4;
          function n3() {
            var t5 = a2(e4);
            if (null === t5)
              throw new Error("Malformed timestamp: " + i4);
            return e4 = e4.replace(/^[^\sa-zA-Z-]+/, ""), t5;
          }
          function c3() {
            e4 = e4.replace(/^\s+/, "");
          }
          if (c3(), t4.startTime = n3(), c3(), "-->" !== e4.slice(0, 3))
            throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + i4);
          e4 = e4.slice(3), c3(), t4.endTime = n3(), c3(), function(e5, t5) {
            var i5 = new s2();
            o2(e5, function(e6, t6) {
              var n5;
              switch (e6) {
                case "region":
                  for (var a4 = r4.length - 1; a4 >= 0; a4--)
                    if (r4[a4].id === t6) {
                      i5.set(e6, r4[a4].region);
                      break;
                    }
                  break;
                case "vertical":
                  i5.alt(e6, t6, ["rl", "lr"]);
                  break;
                case "line":
                  n5 = t6.split(","), i5.integer(e6, n5[0]), i5.percent(e6, n5[0]) && i5.set("snapToLines", false), i5.alt(e6, n5[0], ["auto"]), 2 === n5.length && i5.alt("lineAlign", n5[1], ["start", u2, "end"]);
                  break;
                case "position":
                  n5 = t6.split(","), i5.percent(e6, n5[0]), 2 === n5.length && i5.alt("positionAlign", n5[1], ["start", u2, "end", "line-left", "line-right", "auto"]);
                  break;
                case "size":
                  i5.percent(e6, t6);
                  break;
                case "align":
                  i5.alt(e6, t6, ["start", u2, "end", "left", "right"]);
              }
            }, /:/, /\s/), t5.region = i5.get("region", null), t5.vertical = i5.get("vertical", "");
            var n4 = i5.get("line", "auto");
            "auto" === n4 && -1 === l2.line && (n4 = -1), t5.line = n4, t5.lineAlign = i5.get("lineAlign", "start"), t5.snapToLines = i5.get("snapToLines", true), t5.size = i5.get("size", 100), t5.align = i5.get("align", u2);
            var a3 = i5.get("position", "auto");
            "auto" === a3 && 50 === l2.position && (a3 = "start" === t5.align || "left" === t5.align ? 0 : "end" === t5.align || "right" === t5.align ? 100 : 50), t5.position = a3;
          }(e4, t4);
        }
        function d2(e4) {
          return e4.replace(/<br(?: \/)?>/gi, "\n");
        }
        var h2 = function() {
          function e4() {
            this.state = "INITIAL", this.buffer = "", this.decoder = new n2(), this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0;
          }
          var t4 = e4.prototype;
          return t4.parse = function(e5) {
            var t5 = this;
            function r4() {
              var e6 = t5.buffer, r5 = 0;
              for (e6 = d2(e6); r5 < e6.length && "\r" !== e6[r5] && "\n" !== e6[r5]; )
                ++r5;
              var i4 = e6.slice(0, r5);
              return "\r" === e6[r5] && ++r5, "\n" === e6[r5] && ++r5, t5.buffer = e6.slice(r5), i4;
            }
            e5 && (t5.buffer += t5.decoder.decode(e5, { stream: true }));
            try {
              var n3 = "";
              if ("INITIAL" === t5.state) {
                if (!/\r\n|\n/.test(t5.buffer))
                  return this;
                var a3 = (n3 = r4()).match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
                if (!a3 || !a3[0])
                  throw new Error("Malformed WebVTT signature.");
                t5.state = "HEADER";
              }
              for (var s3 = false; t5.buffer; ) {
                if (!/\r\n|\n/.test(t5.buffer))
                  return this;
                switch (s3 ? s3 = false : n3 = r4(), t5.state) {
                  case "HEADER":
                    /:/.test(n3) ? o2(n3, function(e6, t6) {
                    }, /:/) : n3 || (t5.state = "ID");
                    continue;
                  case "NOTE":
                    n3 || (t5.state = "ID");
                    continue;
                  case "ID":
                    if (/^NOTE($|[ \t])/.test(n3)) {
                      t5.state = "NOTE";
                      break;
                    }
                    if (!n3)
                      continue;
                    if (t5.cue = new i3.default(0, 0, ""), t5.state = "CUE", -1 === n3.indexOf("-->")) {
                      t5.cue.id = n3;
                      continue;
                    }
                  case "CUE":
                    if (!t5.cue) {
                      t5.state = "BADCUE";
                      continue;
                    }
                    try {
                      c2(n3, t5.cue, t5.regionList);
                    } catch (e6) {
                      t5.cue = null, t5.state = "BADCUE";
                      continue;
                    }
                    t5.state = "CUETEXT";
                    continue;
                  case "CUETEXT":
                    var l3 = -1 !== n3.indexOf("-->");
                    if (!n3 || l3 && (s3 = true)) {
                      t5.oncue && t5.cue && t5.oncue(t5.cue), t5.cue = null, t5.state = "ID";
                      continue;
                    }
                    if (null === t5.cue)
                      continue;
                    t5.cue.text && (t5.cue.text += "\n"), t5.cue.text += n3;
                    continue;
                  case "BADCUE":
                    n3 || (t5.state = "ID");
                }
              }
            } catch (e6) {
              "CUETEXT" === t5.state && t5.cue && t5.oncue && t5.oncue(t5.cue), t5.cue = null, t5.state = "INITIAL" === t5.state ? "BADWEBVTT" : "BADCUE";
            }
            return this;
          }, t4.flush = function() {
            var e5 = this;
            try {
              if ((e5.cue || "HEADER" === e5.state) && (e5.buffer += "\n\n", e5.parse()), "INITIAL" === e5.state || "BADWEBVTT" === e5.state)
                throw new Error("Malformed WebVTT signature.");
            } catch (t5) {
              e5.onparsingerror && e5.onparsingerror(t5);
            }
            return e5.onflush && e5.onflush(), this;
          }, e4;
        }();
      }
    ), "./src/utils/webvtt-parser.ts": (
      /*!************************************!*\
          !*** ./src/utils/webvtt-parser.ts ***!
          \************************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { generateCueId: () => d2, parseWebVTT: () => h2 });
        var i3 = r3(
          /*! ./src/polyfills/number */
          "./src/polyfills/number.ts"
        ), n2 = r3(
          /*! ./vttparser */
          "./src/utils/vttparser.ts"
        ), a2 = r3(
          /*! ../demux/id3 */
          "./src/demux/id3.ts"
        ), s2 = r3(
          /*! ./timescale-conversion */
          "./src/utils/timescale-conversion.ts"
        ), o2 = r3(
          /*! ../remux/mp4-remuxer */
          "./src/remux/mp4-remuxer.ts"
        ), l2 = /\r\n|\n\r|\n|\r/g, u2 = function(e4, t4, r4) {
          return void 0 === r4 && (r4 = 0), e4.slice(r4, r4 + t4.length) === t4;
        }, c2 = function(e4) {
          for (var t4 = 5381, r4 = e4.length; r4; )
            t4 = 33 * t4 ^ e4.charCodeAt(--r4);
          return (t4 >>> 0).toString();
        };
        function d2(e4, t4, r4) {
          return c2(e4.toString()) + c2(t4.toString()) + c2(r4);
        }
        function h2(e4, t4, r4, c3, h3, f2, p2, g2) {
          var v2, m2 = new n2.VTTParser(), y2 = (0, a2.utf8ArrayToStr)(new Uint8Array(e4)).trim().replace(l2, "\n").split("\n"), A2 = [], E2 = (0, s2.toMpegTsClockFromTimescale)(t4, r4), T2 = "00:00.000", b2 = 0, k2 = 0, S2 = true;
          m2.oncue = function(e5) {
            var t5 = c3[h3], r5 = c3.ccOffset, i4 = (b2 - E2) / 9e4;
            null != t5 && t5.new && (void 0 !== k2 ? r5 = c3.ccOffset = t5.start : function(e6, t6, r6) {
              var i5 = e6[t6], n4 = e6[i5.prevCC];
              if (!n4 || !n4.new && i5.new)
                return e6.ccOffset = e6.presentationOffset = i5.start, void (i5.new = false);
              for (; null !== (a4 = n4) && void 0 !== a4 && a4.new; ) {
                var a4;
                e6.ccOffset += i5.start - n4.start, i5.new = false, n4 = e6[(i5 = n4).prevCC];
              }
              e6.presentationOffset = r6;
            }(c3, h3, i4)), i4 && (r5 = i4 - c3.presentationOffset);
            var n3 = e5.endTime - e5.startTime, a3 = (0, o2.normalizePts)(9e4 * (e5.startTime + r5 - k2), 9e4 * f2) / 9e4;
            e5.startTime = Math.max(a3, 0), e5.endTime = Math.max(a3 + n3, 0);
            var s3 = e5.text.trim();
            e5.text = decodeURIComponent(encodeURIComponent(s3)), e5.id || (e5.id = d2(e5.startTime, e5.endTime, s3)), e5.endTime > 0 && A2.push(e5);
          }, m2.onparsingerror = function(e5) {
            v2 = e5;
          }, m2.onflush = function() {
            v2 ? g2(v2) : p2(A2);
          }, y2.forEach(function(e5) {
            if (S2) {
              if (u2(e5, "X-TIMESTAMP-MAP=")) {
                S2 = false, e5.slice(16).split(",").forEach(function(e6) {
                  u2(e6, "LOCAL:") ? T2 = e6.slice(6) : u2(e6, "MPEGTS:") && (b2 = parseInt(e6.slice(7)));
                });
                try {
                  k2 = function(e6) {
                    var t5 = parseInt(e6.slice(-3)), r5 = parseInt(e6.slice(-6, -4)), n3 = parseInt(e6.slice(-9, -7)), a3 = e6.length > 9 ? parseInt(e6.substring(0, e6.indexOf(":"))) : 0;
                    if (!((0, i3.isFiniteNumber)(t5) && (0, i3.isFiniteNumber)(r5) && (0, i3.isFiniteNumber)(n3) && (0, i3.isFiniteNumber)(a3)))
                      throw Error("Malformed X-TIMESTAMP-MAP: Local:" + e6);
                    return t5 += 1e3 * r5, (t5 += 6e4 * n3) + 36e5 * a3;
                  }(T2) / 1e3;
                } catch (e6) {
                  v2 = e6;
                }
                return;
              }
              "" === e5 && (S2 = false);
            }
            m2.parse(e5 + "\n");
          }), m2.flush();
        }
      }
    ), "./src/utils/xhr-loader.ts": (
      /*!*********************************!*\
          !*** ./src/utils/xhr-loader.ts ***!
          \*********************************/
      (e3, t3, r3) => {
        r3.r(t3), r3.d(t3, { default: () => s2 });
        var i3 = r3(
          /*! ../utils/logger */
          "./src/utils/logger.ts"
        ), n2 = r3(
          /*! ../loader/load-stats */
          "./src/loader/load-stats.ts"
        ), a2 = /^age:\s*[\d.]+\s*$/m;
        const s2 = function() {
          function e4(e5) {
            this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = void 0, this.loader = null, this.stats = void 0, this.xhrSetup = e5 ? e5.xhrSetup : null, this.stats = new n2.LoadStats(), this.retryDelay = 0;
          }
          var t4 = e4.prototype;
          return t4.destroy = function() {
            this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null;
          }, t4.abortInternal = function() {
            var e5 = this.loader;
            self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e5 && (e5.onreadystatechange = null, e5.onprogress = null, 4 !== e5.readyState && (this.stats.aborted = true, e5.abort()));
          }, t4.abort = function() {
            var e5;
            this.abortInternal(), null !== (e5 = this.callbacks) && void 0 !== e5 && e5.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader);
          }, t4.load = function(e5, t5, r4) {
            if (this.stats.loading.start)
              throw new Error("Loader can only be used once.");
            this.stats.loading.start = self.performance.now(), this.context = e5, this.config = t5, this.callbacks = r4, this.retryDelay = t5.retryDelay, this.loadInternal();
          }, t4.loadInternal = function() {
            var e5 = this.config, t5 = this.context;
            if (e5) {
              var r4 = this.loader = new self.XMLHttpRequest(), i4 = this.stats;
              i4.loading.first = 0, i4.loaded = 0;
              var n3 = this.xhrSetup;
              try {
                if (n3)
                  try {
                    n3(r4, t5.url);
                  } catch (e6) {
                    r4.open("GET", t5.url, true), n3(r4, t5.url);
                  }
                r4.readyState || r4.open("GET", t5.url, true);
                var a3 = this.context.headers;
                if (a3)
                  for (var s3 in a3)
                    r4.setRequestHeader(s3, a3[s3]);
              } catch (e6) {
                return void this.callbacks.onError({ code: r4.status, text: e6.message }, t5, r4);
              }
              t5.rangeEnd && r4.setRequestHeader("Range", "bytes=" + t5.rangeStart + "-" + (t5.rangeEnd - 1)), r4.onreadystatechange = this.readystatechange.bind(this), r4.onprogress = this.loadprogress.bind(this), r4.responseType = t5.responseType, self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), e5.timeout), r4.send();
            }
          }, t4.readystatechange = function() {
            var e5 = this.context, t5 = this.loader, r4 = this.stats;
            if (e5 && t5) {
              var n3 = t5.readyState, a3 = this.config;
              if (!r4.aborted && n3 >= 2)
                if (self.clearTimeout(this.requestTimeout), 0 === r4.loading.first && (r4.loading.first = Math.max(self.performance.now(), r4.loading.start)), 4 === n3) {
                  t5.onreadystatechange = null, t5.onprogress = null;
                  var s3 = t5.status, o2 = "arraybuffer" === t5.responseType;
                  if (s3 >= 200 && s3 < 300 && (o2 && t5.response || null !== t5.responseText)) {
                    var l2, u2;
                    if (r4.loading.end = Math.max(self.performance.now(), r4.loading.first), u2 = o2 ? (l2 = t5.response).byteLength : (l2 = t5.responseText).length, r4.loaded = r4.total = u2, !this.callbacks)
                      return;
                    var c2 = this.callbacks.onProgress;
                    if (c2 && c2(r4, e5, l2, t5), !this.callbacks)
                      return;
                    var d2 = { url: t5.responseURL, data: l2 };
                    this.callbacks.onSuccess(d2, r4, e5, t5);
                  } else
                    r4.retry >= a3.maxRetry || s3 >= 400 && s3 < 499 ? (i3.logger.error(s3 + " while loading " + e5.url), this.callbacks.onError({ code: s3, text: t5.statusText }, e5, t5)) : (i3.logger.warn(s3 + " while loading " + e5.url + ", retrying in " + this.retryDelay + "..."), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, a3.maxRetryDelay), r4.retry++);
                } else
                  self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), a3.timeout);
            }
          }, t4.loadtimeout = function() {
            i3.logger.warn("timeout while loading " + this.context.url);
            var e5 = this.callbacks;
            e5 && (this.abortInternal(), e5.onTimeout(this.stats, this.context, this.loader));
          }, t4.loadprogress = function(e5) {
            var t5 = this.stats;
            t5.loaded = e5.loaded, e5.lengthComputable && (t5.total = e5.total);
          }, t4.getCacheAge = function() {
            var e5 = null;
            if (this.loader && a2.test(this.loader.getAllResponseHeaders())) {
              var t5 = this.loader.getResponseHeader("age");
              e5 = t5 ? parseFloat(t5) : null;
            }
            return e5;
          }, e4;
        }();
      }
    ), "./node_modules/eventemitter3/index.js": (
      /*!*********************************************!*\
          !*** ./node_modules/eventemitter3/index.js ***!
          \*********************************************/
      (e3) => {
        var t3 = Object.prototype.hasOwnProperty, r3 = "~";
        function i3() {
        }
        function n2(e4, t4, r4) {
          this.fn = e4, this.context = t4, this.once = r4 || false;
        }
        function a2(e4, t4, i4, a3, s3) {
          if ("function" != typeof i4)
            throw new TypeError("The listener must be a function");
          var o3 = new n2(i4, a3 || e4, s3), l2 = r3 ? r3 + t4 : t4;
          return e4._events[l2] ? e4._events[l2].fn ? e4._events[l2] = [e4._events[l2], o3] : e4._events[l2].push(o3) : (e4._events[l2] = o3, e4._eventsCount++), e4;
        }
        function s2(e4, t4) {
          0 == --e4._eventsCount ? e4._events = new i3() : delete e4._events[t4];
        }
        function o2() {
          this._events = new i3(), this._eventsCount = 0;
        }
        Object.create && (i3.prototype = /* @__PURE__ */ Object.create(null), new i3().__proto__ || (r3 = false)), o2.prototype.eventNames = function() {
          var e4, i4, n3 = [];
          if (0 === this._eventsCount)
            return n3;
          for (i4 in e4 = this._events)
            t3.call(e4, i4) && n3.push(r3 ? i4.slice(1) : i4);
          return Object.getOwnPropertySymbols ? n3.concat(Object.getOwnPropertySymbols(e4)) : n3;
        }, o2.prototype.listeners = function(e4) {
          var t4 = r3 ? r3 + e4 : e4, i4 = this._events[t4];
          if (!i4)
            return [];
          if (i4.fn)
            return [i4.fn];
          for (var n3 = 0, a3 = i4.length, s3 = new Array(a3); n3 < a3; n3++)
            s3[n3] = i4[n3].fn;
          return s3;
        }, o2.prototype.listenerCount = function(e4) {
          var t4 = r3 ? r3 + e4 : e4, i4 = this._events[t4];
          return i4 ? i4.fn ? 1 : i4.length : 0;
        }, o2.prototype.emit = function(e4, t4, i4, n3, a3, s3) {
          var o3 = r3 ? r3 + e4 : e4;
          if (!this._events[o3])
            return false;
          var l2, u2, c2 = this._events[o3], d2 = arguments.length;
          if (c2.fn) {
            switch (c2.once && this.removeListener(e4, c2.fn, void 0, true), d2) {
              case 1:
                return c2.fn.call(c2.context), true;
              case 2:
                return c2.fn.call(c2.context, t4), true;
              case 3:
                return c2.fn.call(c2.context, t4, i4), true;
              case 4:
                return c2.fn.call(c2.context, t4, i4, n3), true;
              case 5:
                return c2.fn.call(c2.context, t4, i4, n3, a3), true;
              case 6:
                return c2.fn.call(c2.context, t4, i4, n3, a3, s3), true;
            }
            for (u2 = 1, l2 = new Array(d2 - 1); u2 < d2; u2++)
              l2[u2 - 1] = arguments[u2];
            c2.fn.apply(c2.context, l2);
          } else {
            var h2, f2 = c2.length;
            for (u2 = 0; u2 < f2; u2++)
              switch (c2[u2].once && this.removeListener(e4, c2[u2].fn, void 0, true), d2) {
                case 1:
                  c2[u2].fn.call(c2[u2].context);
                  break;
                case 2:
                  c2[u2].fn.call(c2[u2].context, t4);
                  break;
                case 3:
                  c2[u2].fn.call(c2[u2].context, t4, i4);
                  break;
                case 4:
                  c2[u2].fn.call(c2[u2].context, t4, i4, n3);
                  break;
                default:
                  if (!l2)
                    for (h2 = 1, l2 = new Array(d2 - 1); h2 < d2; h2++)
                      l2[h2 - 1] = arguments[h2];
                  c2[u2].fn.apply(c2[u2].context, l2);
              }
          }
          return true;
        }, o2.prototype.on = function(e4, t4, r4) {
          return a2(this, e4, t4, r4, false);
        }, o2.prototype.once = function(e4, t4, r4) {
          return a2(this, e4, t4, r4, true);
        }, o2.prototype.removeListener = function(e4, t4, i4, n3) {
          var a3 = r3 ? r3 + e4 : e4;
          if (!this._events[a3])
            return this;
          if (!t4)
            return s2(this, a3), this;
          var o3 = this._events[a3];
          if (o3.fn)
            o3.fn !== t4 || n3 && !o3.once || i4 && o3.context !== i4 || s2(this, a3);
          else {
            for (var l2 = 0, u2 = [], c2 = o3.length; l2 < c2; l2++)
              (o3[l2].fn !== t4 || n3 && !o3[l2].once || i4 && o3[l2].context !== i4) && u2.push(o3[l2]);
            u2.length ? this._events[a3] = 1 === u2.length ? u2[0] : u2 : s2(this, a3);
          }
          return this;
        }, o2.prototype.removeAllListeners = function(e4) {
          var t4;
          return e4 ? (t4 = r3 ? r3 + e4 : e4, this._events[t4] && s2(this, t4)) : (this._events = new i3(), this._eventsCount = 0), this;
        }, o2.prototype.off = o2.prototype.removeListener, o2.prototype.addListener = o2.prototype.on, o2.prefixed = r3, o2.EventEmitter = o2, e3.exports = o2;
      }
    ), "./node_modules/url-toolkit/src/url-toolkit.js": (
      /*!*****************************************************!*\
          !*** ./node_modules/url-toolkit/src/url-toolkit.js ***!
          \*****************************************************/
      function(e3) {
        var t3, r3, i3, n2, a2;
        t3 = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, r3 = /^(?=([^\/?#]*))\1([^]*)$/, i3 = /(?:\/|^)\.(?=\/)/g, n2 = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, a2 = { buildAbsoluteURL: function(e4, t4, i4) {
          if (i4 = i4 || {}, e4 = e4.trim(), !(t4 = t4.trim())) {
            if (!i4.alwaysNormalize)
              return e4;
            var n3 = a2.parseURL(e4);
            if (!n3)
              throw new Error("Error trying to parse base URL.");
            return n3.path = a2.normalizePath(n3.path), a2.buildURLFromParts(n3);
          }
          var s2 = a2.parseURL(t4);
          if (!s2)
            throw new Error("Error trying to parse relative URL.");
          if (s2.scheme)
            return i4.alwaysNormalize ? (s2.path = a2.normalizePath(s2.path), a2.buildURLFromParts(s2)) : t4;
          var o2 = a2.parseURL(e4);
          if (!o2)
            throw new Error("Error trying to parse base URL.");
          if (!o2.netLoc && o2.path && "/" !== o2.path[0]) {
            var l2 = r3.exec(o2.path);
            o2.netLoc = l2[1], o2.path = l2[2];
          }
          o2.netLoc && !o2.path && (o2.path = "/");
          var u2 = { scheme: o2.scheme, netLoc: s2.netLoc, path: null, params: s2.params, query: s2.query, fragment: s2.fragment };
          if (!s2.netLoc && (u2.netLoc = o2.netLoc, "/" !== s2.path[0]))
            if (s2.path) {
              var c2 = o2.path, d2 = c2.substring(0, c2.lastIndexOf("/") + 1) + s2.path;
              u2.path = a2.normalizePath(d2);
            } else
              u2.path = o2.path, s2.params || (u2.params = o2.params, s2.query || (u2.query = o2.query));
          return null === u2.path && (u2.path = i4.alwaysNormalize ? a2.normalizePath(s2.path) : s2.path), a2.buildURLFromParts(u2);
        }, parseURL: function(e4) {
          var r4 = t3.exec(e4);
          return r4 ? { scheme: r4[1] || "", netLoc: r4[2] || "", path: r4[3] || "", params: r4[4] || "", query: r4[5] || "", fragment: r4[6] || "" } : null;
        }, normalizePath: function(e4) {
          for (e4 = e4.split("").reverse().join("").replace(i3, ""); e4.length !== (e4 = e4.replace(n2, "")).length; )
            ;
          return e4.split("").reverse().join("");
        }, buildURLFromParts: function(e4) {
          return e4.scheme + e4.netLoc + e4.path + e4.params + e4.query + e4.fragment;
        } }, e3.exports = a2;
      }
    ) }, t2 = {};
    function r2(i3) {
      var n2 = t2[i3];
      if (void 0 !== n2)
        return n2.exports;
      var a2 = t2[i3] = { exports: {} };
      return e2[i3].call(a2.exports, a2, a2.exports, r2), a2.exports;
    }
    r2.m = e2, r2.n = (e3) => {
      var t3 = e3 && e3.__esModule ? () => e3.default : () => e3;
      return r2.d(t3, { a: t3 }), t3;
    }, r2.d = (e3, t3) => {
      for (var i3 in t3)
        r2.o(t3, i3) && !r2.o(e3, i3) && Object.defineProperty(e3, i3, { enumerable: true, get: t3[i3] });
    }, r2.o = (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3), r2.r = (e3) => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
    };
    var i2 = r2("./src/hls.ts");
    return i2 = i2.default;
  })(), pr.exports = gr());
  var mr = fr(vr.exports), yr = J.now, Ar = J.assign, Er = J.listContainsIgnoreCase;
  ce.register("PLAYBACK_FRAGMENT_CHANGED"), ce.register("PLAYBACK_FRAGMENT_PARSING_METADATA");
  var Tr = function(e2) {
    !function(e3, t3) {
      if ("function" != typeof t3 && null !== t3)
        throw new TypeError("Super expression must either be null or a function");
      e3.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), Object.defineProperty(e3, "prototype", { writable: false }), t3 && ar(e3, t3);
    }(a2, e2);
    var t2, r2, i2, n2 = or(a2);
    function a2() {
      var e3;
      tr(this, a2);
      for (var t3 = arguments.length, r3 = new Array(t3), i3 = 0; i3 < t3; i3++)
        r3[i3] = arguments[i3];
      return (e3 = n2.call.apply(n2, [this].concat(r3))).options.playback = er(er({}, e3.options), e3.options.playback), e3.options.hlsPlayback = er(er({}, e3.defaultOptions), e3.options.hlsPlayback), e3._minDvrSize = void 0 === e3.options.hlsMinimumDvrSize ? 60 : e3.options.hlsMinimumDvrSize, e3._extrapolatedWindowNumSegments = e3.options.playback && void 0 !== e3.options.playback.extrapolatedWindowNumSegments ? e3.options.playback.extrapolatedWindowNumSegments : 2, e3._playbackType = Re.VOD, e3._lastTimeUpdate = { current: 0, total: 0 }, e3._lastDuration = null, e3._playableRegionStartTime = 0, e3._localStartTimeCorrelation = null, e3._localEndTimeCorrelation = null, e3._playableRegionDuration = 0, e3._programDateTime = 0, e3._durationExcludesAfterLiveSyncPoint = false, e3._segmentTargetDuration = null, e3._playlistType = null, e3._recoverAttemptsRemaining = e3.options.hlsRecoverAttempts || 16, e3;
    }
    return t2 = a2, r2 = [{ key: "name", get: function() {
      return "hls";
    } }, { key: "supportedVersion", get: function() {
      return { min: "0.4.27" };
    } }, { key: "levels", get: function() {
      return this._levels || [];
    } }, { key: "currentLevel", get: function() {
      return null === this._currentLevel || void 0 === this._currentLevel ? -1 : this._currentLevel;
    }, set: function(e3) {
      this._currentLevel = e3, this.trigger(ce.PLAYBACK_LEVEL_SWITCH_START), this.options.playback.hlsUseNextLevel ? this._hls.nextLevel = this._currentLevel : this._hls.currentLevel = this._currentLevel;
    } }, { key: "isReady", get: function() {
      return this._isReadyState;
    } }, { key: "_startTime", get: function() {
      return this._playbackType === Re.LIVE && "EVENT" !== this._playlistType ? this._extrapolatedStartTime : this._playableRegionStartTime;
    } }, { key: "_now", get: function() {
      return yr();
    } }, { key: "_extrapolatedStartTime", get: function() {
      if (!this._localStartTimeCorrelation)
        return this._playableRegionStartTime;
      var e3 = this._localStartTimeCorrelation, t3 = this._now - e3.local, r3 = (e3.remote + t3) / 1e3;
      return Math.min(r3, this._playableRegionStartTime + this._extrapolatedWindowDuration);
    } }, { key: "_extrapolatedEndTime", get: function() {
      var e3 = this._playableRegionStartTime + this._playableRegionDuration;
      if (!this._localEndTimeCorrelation)
        return e3;
      var t3 = this._localEndTimeCorrelation, r3 = this._now - t3.local, i3 = (t3.remote + r3) / 1e3;
      return Math.max(e3 - this._extrapolatedWindowDuration, Math.min(i3, e3));
    } }, { key: "_duration", get: function() {
      return this._extrapolatedEndTime - this._startTime;
    } }, { key: "_extrapolatedWindowDuration", get: function() {
      return null === this._segmentTargetDuration ? 0 : this._extrapolatedWindowNumSegments * this._segmentTargetDuration;
    } }, { key: "bandwidthEstimate", get: function() {
      return this._hls && this._hls.bandwidthEstimate;
    } }, { key: "defaultOptions", get: function() {
      return { preload: true };
    } }, { key: "customListeners", get: function() {
      return this.options.hlsPlayback && this.options.hlsPlayback.customListeners || [];
    } }, { key: "_setup", value: function() {
      var e3 = this;
      this._manifestParsed = false, this._ccIsSetup = false, this._ccTracksUpdated = false, this._hls && this._hls.destroy(), this._hls = new mr(Ar({}, this.options.playback.hlsjsConfig)), this._hls.once(mr.Events.MEDIA_ATTACHED, function() {
        e3.options.hlsPlayback.preload && e3._hls.loadSource(e3.options.src);
      }), this._hls.on(mr.Events.MANIFEST_PARSED, function() {
        return e3._manifestParsed = true;
      }), this._hls.on(mr.Events.LEVEL_LOADED, function(t3, r3) {
        return e3._updatePlaybackType(t3, r3);
      }), this._hls.on(mr.Events.LEVEL_UPDATED, function(t3, r3) {
        return e3._onLevelUpdated(t3, r3);
      }), this._hls.on(mr.Events.LEVEL_SWITCHING, function(t3, r3) {
        return e3._onLevelSwitch(t3, r3);
      }), this._hls.on(mr.Events.FRAG_CHANGED, function(t3, r3) {
        return e3._onFragmentChanged(t3, r3);
      }), this._hls.on(mr.Events.FRAG_LOADED, function(t3, r3) {
        return e3._onFragmentLoaded(t3, r3);
      }), this._hls.on(mr.Events.FRAG_PARSING_METADATA, function(t3, r3) {
        return e3._onFragmentParsingMetadata(t3, r3);
      }), this._hls.on(mr.Events.ERROR, function(t3, r3) {
        return e3._onHLSJSError(t3, r3);
      }), this._hls.on(mr.Events.SUBTITLE_TRACK_LOADED, function(t3, r3) {
        return e3._onSubtitleLoaded(t3, r3);
      }), this._hls.on(mr.Events.SUBTITLE_TRACKS_UPDATED, function() {
        return e3._ccTracksUpdated = true;
      }), this.bindCustomListeners(), this._hls.attachMedia(this.el);
    } }, { key: "bindCustomListeners", value: function() {
      var e3 = this;
      this.customListeners.forEach(function(t3) {
        var r3 = t3.eventName, i3 = t3.once ? "once" : "on";
        r3 && e3._hls["".concat(i3)](r3, t3.callback);
      });
    } }, { key: "unbindCustomListeners", value: function() {
      var e3 = this;
      this.customListeners.forEach(function(t3) {
        var r3 = t3.eventName;
        r3 && e3._hls.off(r3, t3.callback);
      });
    } }, { key: "_onFragmentParsingMetadata", value: function(e3, t3) {
      this.trigger(ce.Custom.PLAYBACK_FRAGMENT_PARSING_METADATA, { evt: e3, data: t3 });
    } }, { key: "render", value: function() {
      return this._ready(), ur(nr(a2.prototype), "render", this).call(this);
    } }, { key: "_ready", value: function() {
      this._isReadyState || (!this._hls && this._setup(), this._isReadyState = true, this.trigger(ce.PLAYBACK_READY, this.name));
    } }, { key: "_recover", value: function(e3, t3, r3) {
      if (this._recoveredDecodingError)
        if (this._recoveredAudioCodecError) {
          ae.error("hlsjs: failed to recover", { evt: e3, data: t3 }), r3.level = _e.Levels.FATAL;
          var i3 = this.createError(r3);
          this.trigger(ce.PLAYBACK_ERROR, i3), this.stop();
        } else
          this._recoveredAudioCodecError = true, this._hls.swapAudioCodec(), this._hls.recoverMediaError();
      else
        this._recoveredDecodingError = true, this._hls.recoverMediaError();
    } }, { key: "_setupSrc", value: function(e3) {
    } }, { key: "_startTimeUpdateTimer", value: function() {
      var e3 = this;
      this._timeUpdateTimer || (this._timeUpdateTimer = setInterval(function() {
        e3._onDurationChange(), e3._onTimeUpdate();
      }, 100));
    } }, { key: "_stopTimeUpdateTimer", value: function() {
      this._timeUpdateTimer && (clearInterval(this._timeUpdateTimer), this._timeUpdateTimer = null);
    } }, { key: "getProgramDateTime", value: function() {
      return this._programDateTime;
    } }, { key: "getDuration", value: function() {
      return this._duration;
    } }, { key: "getCurrentTime", value: function() {
      return Math.max(0, this.el.currentTime - this._startTime);
    } }, { key: "getStartTimeOffset", value: function() {
      return this._startTime;
    } }, { key: "seekPercentage", value: function(e3) {
      var t3 = this._duration;
      e3 > 0 && (t3 = this._duration * (e3 / 100)), this.seek(t3);
    } }, { key: "seek", value: function(e3) {
      e3 < 0 && (ae.warn("Attempt to seek to a negative time. Resetting to live point. Use seekToLivePoint() to seek to the live point."), e3 = this.getDuration()), this.dvrEnabled && this._updateDvr(e3 < this.getDuration() - 3), e3 += this._startTime, this.el.currentTime = e3;
    } }, { key: "seekToLivePoint", value: function() {
      this.seek(this.getDuration());
    } }, { key: "_updateDvr", value: function(e3) {
      this.trigger(ce.PLAYBACK_DVR, e3), this.trigger(ce.PLAYBACK_STATS_ADD, { dvr: e3 });
    } }, { key: "_updateSettings", value: function() {
      this._playbackType === Re.VOD ? this.settings.left = ["playpause", "position", "duration"] : this.dvrEnabled ? this.settings.left = ["playpause"] : this.settings.left = ["playstop"], this.settings.seekEnabled = this.isSeekEnabled(), this.trigger(ce.PLAYBACK_SETTINGSUPDATE);
    } }, { key: "_onHLSJSError", value: function(e3, t3) {
      var r3, i3 = { code: "".concat(t3.type, "_").concat(t3.details), description: "".concat(this.name, " error: type: ").concat(t3.type, ", details: ").concat(t3.details), raw: t3 };
      if (t3.response && (i3.description += ", response: ".concat(JSON.stringify(t3.response))), t3.fatal)
        if (this._recoverAttemptsRemaining > 0)
          switch (this._recoverAttemptsRemaining -= 1, t3.type) {
            case mr.ErrorTypes.NETWORK_ERROR:
              switch (t3.details) {
                case mr.ErrorDetails.MANIFEST_LOAD_ERROR:
                case mr.ErrorDetails.MANIFEST_LOAD_TIMEOUT:
                case mr.ErrorDetails.MANIFEST_PARSING_ERROR:
                case mr.ErrorDetails.LEVEL_LOAD_ERROR:
                case mr.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                  ae.error("hlsjs: unrecoverable network fatal error.", { evt: e3, data: t3 }), r3 = this.createError(i3), this.trigger(ce.PLAYBACK_ERROR, r3), this.stop();
                  break;
                default:
                  ae.warn("hlsjs: trying to recover from network error.", { evt: e3, data: t3 }), i3.level = _e.Levels.WARN, this._hls.startLoad();
              }
              break;
            case mr.ErrorTypes.MEDIA_ERROR:
              ae.warn("hlsjs: trying to recover from media error.", { evt: e3, data: t3 }), i3.level = _e.Levels.WARN, this._recover(e3, t3, i3);
              break;
            default:
              ae.error("hlsjs: could not recover from error.", { evt: e3, data: t3 }), r3 = this.createError(i3), this.trigger(ce.PLAYBACK_ERROR, r3), this.stop();
          }
        else
          ae.error("hlsjs: could not recover from error after maximum number of attempts.", { evt: e3, data: t3 }), r3 = this.createError(i3), this.trigger(ce.PLAYBACK_ERROR, r3), this.stop();
      else {
        if (this.options.playback.triggerFatalErrorOnResourceDenied && this._keyIsDenied(t3))
          return ae.error("hlsjs: could not load decrypt key.", { evt: e3, data: t3 }), r3 = this.createError(i3), this.trigger(ce.PLAYBACK_ERROR, r3), void this.stop();
        i3.level = _e.Levels.WARN, ae.warn("hlsjs: non-fatal error occurred", { evt: e3, data: t3 });
      }
    } }, { key: "_keyIsDenied", value: function(e3) {
      return e3.type === mr.ErrorTypes.NETWORK_ERROR && e3.details === mr.ErrorDetails.KEY_LOAD_ERROR && e3.response && e3.response.code >= 400;
    } }, { key: "_onTimeUpdate", value: function() {
      var e3 = { current: this.getCurrentTime(), total: this.getDuration(), firstFragDateTime: this.getProgramDateTime() };
      this._lastTimeUpdate && e3.current === this._lastTimeUpdate.current && e3.total === this._lastTimeUpdate.total || (this._lastTimeUpdate = e3, this.trigger(ce.PLAYBACK_TIMEUPDATE, e3, this.name));
    } }, { key: "_onDurationChange", value: function() {
      var e3 = this.getDuration();
      this._lastDuration !== e3 && (this._lastDuration = e3, ur(nr(a2.prototype), "_onDurationChange", this).call(this));
    } }, { key: "_onProgress", value: function() {
      if (this.el.buffered.length) {
        for (var e3 = [], t3 = 0, r3 = 0; r3 < this.el.buffered.length; r3++)
          e3 = [].concat(cr(e3), [{ start: Math.max(0, this.el.buffered.start(r3) - this._playableRegionStartTime), end: Math.max(0, this.el.buffered.end(r3) - this._playableRegionStartTime) }]), this.el.currentTime >= e3[r3].start && this.el.currentTime <= e3[r3].end && (t3 = r3);
        var i3 = { start: e3[t3].start, current: e3[t3].end, total: this.getDuration() };
        this.trigger(ce.PLAYBACK_PROGRESS, i3, e3);
      }
    } }, { key: "play", value: function() {
      !this._hls && this._setup(), !this._manifestParsed && !this.options.hlsPlayback.preload && this._hls.loadSource(this.options.src), ur(nr(a2.prototype), "play", this).call(this), this._startTimeUpdateTimer();
    } }, { key: "pause", value: function() {
      this._hls && (this.el.pause(), this.dvrEnabled && this._updateDvr(true));
    } }, { key: "stop", value: function() {
      this._stopTimeUpdateTimer(), this._hls && (ur(nr(a2.prototype), "stop", this).call(this), this._hls.destroy(), delete this._hls);
    } }, { key: "destroy", value: function() {
      this._stopTimeUpdateTimer(), this._hls && (this._hls.destroy(), delete this._hls), ur(nr(a2.prototype), "destroy", this).call(this);
    } }, { key: "_updatePlaybackType", value: function(e3, t3) {
      this._playbackType = t3.details.live ? Re.LIVE : Re.VOD, this._onLevelUpdated(e3, t3), this._ccTracksUpdated && this._playbackType === Re.LIVE && this.hasClosedCaptionsTracks && this._onSubtitleLoaded();
    } }, { key: "_fillLevels", value: function() {
      this._levels = this._hls.levels.map(function(e3, t3) {
        return { id: t3, level: e3, label: "".concat(e3.bitrate / 1e3, "Kbps") };
      }), this.trigger(ce.PLAYBACK_LEVELS_AVAILABLE, this._levels);
    } }, { key: "_onLevelUpdated", value: function(e3, t3) {
      this._segmentTargetDuration = t3.details.targetduration, this._playlistType = t3.details.type || null;
      var r3 = false, i3 = false, n3 = t3.details.fragments, a3 = this._playableRegionStartTime, s2 = this._playableRegionDuration;
      if (0 !== n3.length) {
        if (n3[0].rawProgramDateTime && (this._programDateTime = n3[0].rawProgramDateTime), this._playableRegionStartTime !== n3[0].start && (r3 = true, this._playableRegionStartTime = n3[0].start), r3)
          if (this._localStartTimeCorrelation) {
            var o2 = this._localStartTimeCorrelation, l2 = this._now - o2.local, u2 = (o2.remote + l2) / 1e3;
            u2 < n3[0].start ? this._localStartTimeCorrelation = { local: this._now, remote: 1e3 * n3[0].start } : u2 > a3 + this._extrapolatedWindowDuration && (this._localStartTimeCorrelation = { local: this._now, remote: 1e3 * Math.max(n3[0].start, a3 + this._extrapolatedWindowDuration) });
          } else
            this._localStartTimeCorrelation = { local: this._now, remote: 1e3 * (n3[0].start + this._extrapolatedWindowDuration / 2) };
        var c2 = t3.details.totalduration;
        if (this._playbackType === Re.LIVE) {
          var d2 = t3.details.targetduration * ((this.options.playback.hlsjsConfig || {}).liveSyncDurationCount || mr.DefaultConfig.liveSyncDurationCount);
          d2 <= c2 ? (c2 -= d2, this._durationExcludesAfterLiveSyncPoint = true) : this._durationExcludesAfterLiveSyncPoint = false;
        }
        c2 !== this._playableRegionDuration && (i3 = true, this._playableRegionDuration = c2);
        var h2 = n3[0].start + c2, f2 = a3 + s2;
        if (h2 !== f2)
          if (this._localEndTimeCorrelation) {
            var p2 = this._localEndTimeCorrelation, g2 = this._now - p2.local, v2 = (p2.remote + g2) / 1e3;
            v2 > h2 ? this._localEndTimeCorrelation = { local: this._now, remote: 1e3 * h2 } : v2 < h2 - this._extrapolatedWindowDuration ? this._localEndTimeCorrelation = { local: this._now, remote: 1e3 * (h2 - this._extrapolatedWindowDuration) } : v2 > f2 && (this._localEndTimeCorrelation = { local: this._now, remote: 1e3 * f2 });
          } else
            this._localEndTimeCorrelation = { local: this._now, remote: 1e3 * h2 };
        i3 && this._onDurationChange(), r3 && this._onProgress();
      }
    } }, { key: "_onFragmentChanged", value: function(e3, t3) {
      this.trigger(ce.Custom.PLAYBACK_FRAGMENT_CHANGED, t3);
    } }, { key: "_onFragmentLoaded", value: function(e3, t3) {
      this.trigger(ce.PLAYBACK_FRAGMENT_LOADED, t3);
    } }, { key: "_onSubtitleLoaded", value: function() {
      if (!this._ccIsSetup) {
        this.trigger(ce.PLAYBACK_SUBTITLE_AVAILABLE);
        var e3 = this._playbackType === Re.LIVE ? -1 : this.closedCaptionsTrackId;
        this.closedCaptionsTrackId = e3, this._ccIsSetup = true;
      }
    } }, { key: "_onLevelSwitch", value: function(e3, t3) {
      this.levels.length || this._fillLevels(), this.trigger(ce.PLAYBACK_LEVEL_SWITCH_END), this.trigger(ce.PLAYBACK_LEVEL_SWITCH, t3);
      var r3 = this._hls.levels[t3.level];
      r3 && (this.highDefinition = r3.height >= 720 || r3.bitrate / 1e3 >= 2e3, this.trigger(ce.PLAYBACK_HIGHDEFINITIONUPDATE, this.highDefinition), this.trigger(ce.PLAYBACK_BITRATE, { height: r3.height, width: r3.width, bandwidth: r3.bitrate, bitrate: r3.bitrate, level: t3.level }));
    } }, { key: "dvrEnabled", get: function() {
      return this._durationExcludesAfterLiveSyncPoint && this._duration >= this._minDvrSize && this.getPlaybackType() === Re.LIVE;
    } }, { key: "getPlaybackType", value: function() {
      return this._playbackType;
    } }, { key: "isSeekEnabled", value: function() {
      return this._playbackType === Re.VOD || this.dvrEnabled;
    } }], i2 = [{ key: "HLSJS", get: function() {
      return mr;
    } }], r2 && rr(t2.prototype, r2), i2 && rr(t2, i2), Object.defineProperty(t2, "prototype", { writable: false }), a2;
  }(ze);
  return Tr.canPlay = function(e2, t2) {
    var r2 = e2.split("?")[0].match(/.*\.(.*)$/) || [], i2 = r2.length > 1 && "m3u8" === r2[1].toLowerCase() || Er(t2, ["application/vnd.apple.mpegurl", "application/x-mpegURL"]);
    return !(!mr.isSupported() || !i2);
  }, Qt.Loader.registerPlayback(Tr), t(t({}, Qt), {}, { HLS: Tr });
}();
//# sourceMappingURL=scripts.js.map
